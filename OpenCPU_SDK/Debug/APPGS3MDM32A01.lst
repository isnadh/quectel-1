
APPGS3MDM32A01.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .initdata     0000002c  102c7040  102c7040  00007040  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 text          0001cef0  102c7070  102c7070  00007070  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text.Ql_EINT_Register 00000070  102e3f60  102e3f60  00023f60  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text.Ql_EINT_Init 00000080  102e3fd0  102e3fd0  00023fd0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .text.Ql_FS_Open 00000068  102e4050  102e4050  00024050  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .text.Ql_FS_Read 00000078  102e40b8  102e40b8  000240b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.Ql_FS_Write 00000078  102e4130  102e4130  00024130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.Ql_FS_Seek 00000070  102e41a8  102e41a8  000241a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.Ql_FS_Flush 00000054  102e4218  102e4218  00024218  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.Ql_FS_Close 00000054  102e426c  102e426c  0002426c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.Ql_FS_GetSize 00000060  102e42c0  102e42c0  000242c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.Ql_FS_Delete 00000060  102e4320  102e4320  00024320  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text.Ql_FS_Check 00000060  102e4380  102e4380  00024380  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text.Ql_FS_CreateDir 00000060  102e43e0  102e43e0  000243e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .text.Ql_FS_CheckDir 00000060  102e4440  102e4440  00024440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.Ql_FS_GetFreeSpace 00000074  102e44a0  102e44a0  000244a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.Ql_FS_GetTotalSpace 00000074  102e4514  102e4514  00024514  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.Ql_FS_Format 00000060  102e4588  102e4588  00024588  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.Ql_FOTA_Init 00000060  102e45e8  102e45e8  000245e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.Ql_FOTA_WriteData 00000068  102e4648  102e4648  00024648  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.Ql_FOTA_Finish 00000058  102e46b0  102e46b0  000246b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.Ql_FOTA_Update 00000058  102e4708  102e4708  00024708  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.Ql_GPIO_Init 00000078  102e4760  102e4760  00024760  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.Ql_GPIO_SetLevel 00000068  102e47d8  102e47d8  000247d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.Ql_MEM_Alloc 00000078  102e4840  102e4840  00024840  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.Ql_MEM_Free 00000074  102e48b8  102e48b8  000248b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.ql_InitVFunc 000000d8  102e492c  102e492c  0002492c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.ocpu_main 000000f0  102e4a04  102e4a04  00024a04  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.proc_reserved2 00000070  102e4af4  102e4af4  00024af4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.ril_StopATTimer 00000034  102e4b64  102e4b64  00024b64  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.Callback_OnATTimer 0000004c  102e4b98  102e4b98  00024b98  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.CallBack_SerialPort_Hdlr 00000384  102e4be4  102e4be4  00024be4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.proc_reserved1 00000200  102e4f68  102e4f68  00024f68  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.Ql_RIL_SendATCmd 00000260  102e5168  102e5168  00025168  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.Ql_RIL_WriteDataToCore 00000024  102e53c8  102e53c8  000253c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.Ql_SPI_Init 00000088  102e53ec  102e53ec  000253ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.Ql_SPI_Config 00000080  102e5474  102e5474  00025474  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.Ql_SPI_Write 00000070  102e54f4  102e54f4  000254f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.Ql_atof 00000098  102e5564  102e5564  00025564  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .text.Ql_strcpy 000000a0  102e55fc  102e55fc  000255fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.Ql_strncpy 00000088  102e569c  102e569c  0002569c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.Ql_strcat 00000080  102e5724  102e5724  00025724  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.Ql_strlen 00000078  102e57a4  102e57a4  000257a4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.Ql_strcmp 00000068  102e581c  102e581c  0002581c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.Ql_strncmp 00000070  102e5884  102e5884  00025884  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.Ql_memset 00000088  102e58f4  102e58f4  000258f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.Ql_memcpy 00000088  102e597c  102e597c  0002597c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.Ql_strstr 00000080  102e5a04  102e5a04  00025a04  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.Ql_toupper 00000008  102e5a84  102e5a84  00025a84  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.Ql_atoi 00000084  102e5a8c  102e5a8c  00025a8c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.Ql_Sleep 00000074  102e5b10  102e5b10  00025b10  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.Ql_GetCoreVer 0000006c  102e5b84  102e5b84  00025b84  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.Ql_GetSDKVer 00000064  102e5bf0  102e5bf0  00025bf0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.Ql_OS_GetMessage 00000060  102e5c54  102e5c54  00025c54  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .text.Ql_OS_SendMessage 00000078  102e5cb4  102e5cb4  00025cb4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .text.Ql_OS_CreateMutex 00000054  102e5d2c  102e5d2c  00025d2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .text.Ql_OS_TakeMutex 00000054  102e5d80  102e5d80  00025d80  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .text.Ql_OS_GiveMutex 00000054  102e5dd4  102e5dd4  00025dd4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .text.Ql_OS_CreateEvent 00000054  102e5e28  102e5e28  00025e28  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .text.Ql_OS_WaitEvent 00000068  102e5e7c  102e5e7c  00025e7c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .text.Ql_OS_SetEvent 00000068  102e5ee4  102e5ee4  00025ee4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .text.Ql_GetLocalTime 00000054  102e5f4c  102e5f4c  00025f4c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .text.Ql_Mktime 00000070  102e5fa0  102e5fa0  00025fa0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .text.Ql_Timer_Register 00000070  102e6010  102e6010  00026010  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .text.Ql_Timer_Start 00000070  102e6080  102e6080  00026080  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .text.Ql_Timer_Stop 00000060  102e60f0  102e60f0  000260f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .text.Ql_UART_Register 00000070  102e6150  102e6150  00026150  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text.Ql_UART_Open 00000070  102e61c0  102e61c0  000261c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text.Ql_UART_Write 00000070  102e6230  102e6230  00026230  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.Ql_UART_Read 00000070  102e62a0  102e62a0  000262a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .text.Ql_UART_ClrRxBuffer 00000054  102e6310  102e6310  00026310  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .text.Ql_UART_GetPinStatus 00000068  102e6364  102e6364  00026364  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .text.Ql_UART_SendEscap 00000060  102e63cc  102e63cc  000263cc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .text.Ql_WTD_Feed 0000005c  102e642c  102e642c  0002642c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .rodata       00007978  102e6488  102e6488  00026488  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 75 .rodata.str1.4 00002578  102ede00  102ede00  0002de00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 76 .rodata.str1.1 0000073e  102f0378  102f0378  00030378  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 77 .data         00003050  f03d2000  102f0ab8  00032000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 78 .bss          00009600  f03d5050  102f3b08  00035050  2**3
                  ALLOC
 79 .debug_info   00027b1d  00000000  00000000  00035050  2**0
                  CONTENTS, READONLY, DEBUGGING
 80 .debug_abbrev 0000465b  00000000  00000000  0005cb6d  2**0
                  CONTENTS, READONLY, DEBUGGING
 81 .debug_loc    00014164  00000000  00000000  000611c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 82 .debug_aranges 000003b8  00000000  00000000  0007532c  2**0
                  CONTENTS, READONLY, DEBUGGING
 83 .debug_macro  00004f14  00000000  00000000  000756e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 84 .debug_line   0000db8f  00000000  00000000  0007a5f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 85 .debug_str    000124e1  00000000  00000000  00088187  2**0
                  CONTENTS, READONLY, DEBUGGING
 86 .comment      00000030  00000000  00000000  0009a668  2**0
                  CONTENTS, READONLY
 87 .ARM.attributes 0000002b  00000000  00000000  0009a698  2**0
                  CONTENTS, READONLY
 88 .debug_frame  0000339c  00000000  00000000  0009a6c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 89 .debug_ranges 00000c58  00000000  00000000  0009da60  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section text:

102c7070 <Ql_RIL_AT_GetErrCode>:
static s32 m_iErrCode = 0; // Is used to record the specific error code
                            // 0 indicates success in executing AT
                            // -1 indicats failure in executing AT
                            // other value indicates the specific error code after executing AT failed.
                            //   you can usually find the meaning of error code in ATC document.
s32 Ql_RIL_AT_GetErrCode(void) {return m_iErrCode;}
102c7070:	e59f3004 	ldr	r3, [pc, #4]	; 102c707c <Ql_RIL_AT_GetErrCode+0xc>
102c7074:	e5930000 	ldr	r0, [r3]
102c7078:	e12fff1e 	bx	lr
102c707c:	f03d5050 	.word	0xf03d5050

102c7080 <Ql_RIL_AT_SetErrCode>:
//
// Developer can call this API to set the error code when resolving the response for AT.
s32 Ql_RIL_AT_SetErrCode(s32 errCode) {m_iErrCode = errCode;}
102c7080:	e59f2008 	ldr	r2, [pc, #8]	; 102c7090 <Ql_RIL_AT_SetErrCode+0x10>
102c7084:	e5820000 	str	r0, [r2]
102c7088:	e1a00003 	mov	r0, r3
102c708c:	e12fff1e 	bx	lr
102c7090:	f03d5050 	.word	0xf03d5050

102c7094 <Default_atRsp_callback>:
* Return:  
*               RIL_ATRSP_SUCCESS : AT command executed successfully.
*               RIL_ATRSP_FAILED : AT command executed failed.
******************************************************************************/
s32 Default_atRsp_callback(char* line, u32 len, void* userdata)
{
102c7094:	e92d4070 	push	{r4, r5, r6, lr}
    if (Ql_RIL_FindLine(line, len, "OK"))// find <CR><LF>OK<CR><LF>,OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c7098:	e59f20a8 	ldr	r2, [pc, #168]	; 102c7148 <Default_atRsp_callback+0xb4>
102c709c:	e59f40a8 	ldr	r4, [pc, #168]	; 102c714c <Default_atRsp_callback+0xb8>
* Return:  
*               RIL_ATRSP_SUCCESS : AT command executed successfully.
*               RIL_ATRSP_FAILED : AT command executed failed.
******************************************************************************/
s32 Default_atRsp_callback(char* line, u32 len, void* userdata)
{
102c70a0:	e1a05000 	mov	r5, r0
102c70a4:	e1a06001 	mov	r6, r1
    if (Ql_RIL_FindLine(line, len, "OK"))// find <CR><LF>OK<CR><LF>,OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c70a8:	e12fff34 	blx	r4
102c70ac:	e3500000 	cmp	r0, #0
102c70b0:	0a000003 	beq	102c70c4 <Default_atRsp_callback+0x30>
    {
        m_iErrCode = RIL_ATRSP_SUCCESS;
102c70b4:	e59f3094 	ldr	r3, [pc, #148]	; 102c7150 <Default_atRsp_callback+0xbc>
102c70b8:	e3a00000 	mov	r0, #0
102c70bc:	e5830000 	str	r0, [r3]
        return  RIL_ATRSP_SUCCESS;
102c70c0:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_RIL_FindLine(line, len, "ERROR")) // find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c70c4:	e1a00005 	mov	r0, r5
102c70c8:	e1a01006 	mov	r1, r6
102c70cc:	e59f2080 	ldr	r2, [pc, #128]	; 102c7154 <Default_atRsp_callback+0xc0>
102c70d0:	e12fff34 	blx	r4
102c70d4:	e3500000 	cmp	r0, #0
102c70d8:	1a000016 	bne	102c7138 <Default_atRsp_callback+0xa4>
    {
        m_iErrCode = RIL_ATRSP_FAILED;
        return  RIL_ATRSP_FAILED;
    }
    else if (Ql_RIL_FindString(line, len, "+CME ERROR:") || 
102c70dc:	e1a00005 	mov	r0, r5
102c70e0:	e1a01006 	mov	r1, r6
102c70e4:	e59f206c 	ldr	r2, [pc, #108]	; 102c7158 <Default_atRsp_callback+0xc4>
102c70e8:	e59f406c 	ldr	r4, [pc, #108]	; 102c715c <Default_atRsp_callback+0xc8>
102c70ec:	e12fff34 	blx	r4
102c70f0:	e3500000 	cmp	r0, #0
102c70f4:	1a000007 	bne	102c7118 <Default_atRsp_callback+0x84>
              Ql_RIL_FindString(line, len, "+CMS ERROR:"))
102c70f8:	e1a00005 	mov	r0, r5
102c70fc:	e1a01006 	mov	r1, r6
102c7100:	e59f2058 	ldr	r2, [pc, #88]	; 102c7160 <Default_atRsp_callback+0xcc>
102c7104:	e12fff34 	blx	r4
    else if (Ql_RIL_FindLine(line, len, "ERROR")) // find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    {
        m_iErrCode = RIL_ATRSP_FAILED;
        return  RIL_ATRSP_FAILED;
    }
    else if (Ql_RIL_FindString(line, len, "+CME ERROR:") || 
102c7108:	e3500000 	cmp	r0, #0
102c710c:	1a000001 	bne	102c7118 <Default_atRsp_callback+0x84>
              Ql_RIL_FindString(line, len, "+CMS ERROR:"))
    {
        Ql_sscanf(line, "%*[^:]: %d\r\n", &m_iErrCode);
        return  RIL_ATRSP_FAILED;
    }
    return RIL_ATRSP_CONTINUE; //continue wait
102c7110:	e3a00001 	mov	r0, #1
}
102c7114:	e8bd8070 	pop	{r4, r5, r6, pc}
        return  RIL_ATRSP_FAILED;
    }
    else if (Ql_RIL_FindString(line, len, "+CME ERROR:") || 
              Ql_RIL_FindString(line, len, "+CMS ERROR:"))
    {
        Ql_sscanf(line, "%*[^:]: %d\r\n", &m_iErrCode);
102c7118:	e59f3044 	ldr	r3, [pc, #68]	; 102c7164 <Default_atRsp_callback+0xd0>
102c711c:	e1a00005 	mov	r0, r5
102c7120:	e5933000 	ldr	r3, [r3]
102c7124:	e59f103c 	ldr	r1, [pc, #60]	; 102c7168 <Default_atRsp_callback+0xd4>
102c7128:	e59f2020 	ldr	r2, [pc, #32]	; 102c7150 <Default_atRsp_callback+0xbc>
102c712c:	e12fff33 	blx	r3
        return  RIL_ATRSP_FAILED;
102c7130:	e3e00000 	mvn	r0, #0
102c7134:	e8bd8070 	pop	{r4, r5, r6, pc}
        m_iErrCode = RIL_ATRSP_SUCCESS;
        return  RIL_ATRSP_SUCCESS;
    }
    else if (Ql_RIL_FindLine(line, len, "ERROR")) // find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    {
        m_iErrCode = RIL_ATRSP_FAILED;
102c7138:	e59f3010 	ldr	r3, [pc, #16]	; 102c7150 <Default_atRsp_callback+0xbc>
102c713c:	e3e00000 	mvn	r0, #0
102c7140:	e5830000 	str	r0, [r3]
        return  RIL_ATRSP_FAILED;
102c7144:	e8bd8070 	pop	{r4, r5, r6, pc}
102c7148:	102ee5e8 	.word	0x102ee5e8
102c714c:	102ccf24 	.word	0x102ccf24
102c7150:	f03d5050 	.word	0xf03d5050
102c7154:	102ede00 	.word	0x102ede00
102c7158:	102ede08 	.word	0x102ede08
102c715c:	102cce98 	.word	0x102cce98
102c7160:	102ede24 	.word	0x102ede24
102c7164:	f03de548 	.word	0xf03de548
102c7168:	102ede14 	.word	0x102ede14

102c716c <AtRsp_QBTCONND_Hdlr>:
    Ql_sprintf(strAT, "AT+QBTCONND=%s,%d,\"%s\"", btMacAddr, mode, pinCode);
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), AtRsp_QBTCONND_Hdlr, NULL, 0);
}

static s32 AtRsp_QBTCONND_Hdlr(char* line, u32 len, void* userData)
{
102c716c:	e92d4008 	push	{r3, lr}
    if (Ql_RIL_FindLine(line, len, "OK"))
102c7170:	e59f2010 	ldr	r2, [pc, #16]	; 102c7188 <AtRsp_QBTCONND_Hdlr+0x1c>
102c7174:	e59f3010 	ldr	r3, [pc, #16]	; 102c718c <AtRsp_QBTCONND_Hdlr+0x20>
102c7178:	e12fff33 	blx	r3
        return  RIL_ATRSP_SUCCESS;
    }else{
        //todo
        return RIL_ATRSP_CONTINUE;
    }
}
102c717c:	e2700001 	rsbs	r0, r0, #1
102c7180:	33a00000 	movcc	r0, #0
102c7184:	e8bd8008 	pop	{r3, pc}
102c7188:	102ee5e8 	.word	0x102ee5e8
102c718c:	102ccf24 	.word	0x102ccf24

102c7190 <BT_DevMngmt_Clean>:



// Clean the scanned bt devices
static void BT_DevMngmt_Clean(void)
{
102c7190:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102c7194:	e59f4028 	ldr	r4, [pc, #40]	; 102c71c4 <BT_DevMngmt_Clean+0x34>
    
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (m_arrBTDev[i] != NULL)
        {
            Ql_MEM_Free((void *)m_arrBTDev[i]);
102c7198:	e59f7028 	ldr	r7, [pc, #40]	; 102c71c8 <BT_DevMngmt_Clean+0x38>
extern u32 Ql_GenHash(char* strSrc, u32 len);



// Clean the scanned bt devices
static void BT_DevMngmt_Clean(void)
102c719c:	e2845078 	add	r5, r4, #120	; 0x78
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (m_arrBTDev[i] != NULL)
        {
            Ql_MEM_Free((void *)m_arrBTDev[i]);
            m_arrBTDev[i] = NULL;
102c71a0:	e3a06000 	mov	r6, #0
{
    u16 i;
    
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (m_arrBTDev[i] != NULL)
102c71a4:	e4940004 	ldr	r0, [r4], #4
102c71a8:	e3500000 	cmp	r0, #0
102c71ac:	0a000001 	beq	102c71b8 <BT_DevMngmt_Clean+0x28>
        {
            Ql_MEM_Free((void *)m_arrBTDev[i]);
102c71b0:	e12fff37 	blx	r7
            m_arrBTDev[i] = NULL;
102c71b4:	e5046004 	str	r6, [r4, #-4]
// Clean the scanned bt devices
static void BT_DevMngmt_Clean(void)
{
    u16 i;
    
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c71b8:	e1540005 	cmp	r4, r5
102c71bc:	1afffff8 	bne	102c71a4 <BT_DevMngmt_Clean+0x14>
        {
            Ql_MEM_Free((void *)m_arrBTDev[i]);
            m_arrBTDev[i] = NULL;
        }
    }
}
102c71c0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102c71c4:	f03d5058 	.word	0xf03d5058
102c71c8:	102e48b8 	.word	0x102e48b8

102c71cc <ATRsp_QBTSTATE_Hdlr>:

    return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATRsp_QBTSTATE_Hdlr(char* line, u32 len, void* param)
{
102c71cc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102c71d0:	e1a07002 	mov	r7, r2
102c71d4:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    char* pHead = Ql_RIL_FindString(line, len, "+QBTSTATE:"); //continue wait
102c71d8:	e59f5464 	ldr	r5, [pc, #1124]	; 102c7644 <ATRsp_QBTSTATE_Hdlr+0x478>
102c71dc:	e59f2464 	ldr	r2, [pc, #1124]	; 102c7648 <ATRsp_QBTSTATE_Hdlr+0x47c>

    return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATRsp_QBTSTATE_Hdlr(char* line, u32 len, void* param)
{
102c71e0:	e1a06000 	mov	r6, r0
102c71e4:	e1a08001 	mov	r8, r1
    char* pHead = Ql_RIL_FindString(line, len, "+QBTSTATE:"); //continue wait
102c71e8:	e12fff35 	blx	r5
    bool ret = FALSE ;
    char profile_name[40] = {0};
    static bool is_first_prompt = TRUE;
	s32 status = -1;
102c71ec:	e3e04000 	mvn	r4, #0

static s32 ATRsp_QBTSTATE_Hdlr(char* line, u32 len, void* param)
{
    char* pHead = Ql_RIL_FindString(line, len, "+QBTSTATE:"); //continue wait
    bool ret = FALSE ;
    char profile_name[40] = {0};
102c71f0:	e3a03000 	mov	r3, #0
102c71f4:	e58d3010 	str	r3, [sp, #16]
102c71f8:	e58d3014 	str	r3, [sp, #20]
102c71fc:	e58d3018 	str	r3, [sp, #24]
102c7200:	e58d301c 	str	r3, [sp, #28]
102c7204:	e58d3020 	str	r3, [sp, #32]
102c7208:	e58d3024 	str	r3, [sp, #36]	; 0x24
102c720c:	e58d3028 	str	r3, [sp, #40]	; 0x28
102c7210:	e58d302c 	str	r3, [sp, #44]	; 0x2c
102c7214:	e58d3030 	str	r3, [sp, #48]	; 0x30
102c7218:	e58d3034 	str	r3, [sp, #52]	; 0x34
    static bool is_first_prompt = TRUE;
	s32 status = -1;
102c721c:	e58d400c 	str	r4, [sp, #12]
    ST_BT_DevInfo* pstrNewBtDev = NULL;

    if (pHead)
102c7220:	e250a000 	subs	sl, r0, #0
102c7224:	0a0000d5 	beq	102c7580 <ATRsp_QBTSTATE_Hdlr+0x3b4>
    {
        // +QBTSTATE:0,1,"H60-L01",F4E3FBE47920
        // +QBTSTATE:1,2,"H60-L01",F4E3FBE47920,SPP

		if(is_first_prompt)
102c7228:	e59f541c 	ldr	r5, [pc, #1052]	; 102c764c <ATRsp_QBTSTATE_Hdlr+0x480>
102c722c:	e5d53000 	ldrb	r3, [r5]
102c7230:	e3530000 	cmp	r3, #0
102c7234:	0a000010 	beq	102c727c <ATRsp_QBTSTATE_Hdlr+0xb0>
		{
		    if(NULL != param)
102c7238:	e3570000 	cmp	r7, #0
102c723c:	0a000005 	beq	102c7258 <ATRsp_QBTSTATE_Hdlr+0x8c>
		    {
		       Ql_sscanf(pHead, "%*[^:]: %d\r\n", (s32 *)param);
102c7240:	e59f3408 	ldr	r3, [pc, #1032]	; 102c7650 <ATRsp_QBTSTATE_Hdlr+0x484>
102c7244:	e59f1408 	ldr	r1, [pc, #1032]	; 102c7654 <ATRsp_QBTSTATE_Hdlr+0x488>
102c7248:	e5933000 	ldr	r3, [r3]
102c724c:	e1a02007 	mov	r2, r7
102c7250:	e12fff33 	blx	r3
102c7254:	e59d400c 	ldr	r4, [sp, #12]
		    }
			is_first_prompt = FALSE;
102c7258:	e3a03000 	mov	r3, #0
		else
		{
             Ql_sscanf(pHead, "%*[^:]: %d%*[^\r\n]\r\n", &status);
		}
        
        if (0 == status)
102c725c:	e3540000 	cmp	r4, #0
		{
		    if(NULL != param)
		    {
		       Ql_sscanf(pHead, "%*[^:]: %d\r\n", (s32 *)param);
		    }
			is_first_prompt = FALSE;
102c7260:	e5c53000 	strb	r3, [r5]
		else
		{
             Ql_sscanf(pHead, "%*[^:]: %d%*[^\r\n]\r\n", &status);
		}
        
        if (0 == status)
102c7264:	0a00000c 	beq	102c729c <ATRsp_QBTSTATE_Hdlr+0xd0>
             {
                Ql_MEM_Free (pstrNewBtDev);
             }
            
        }
        else if (1 == status)
102c7268:	e3540001 	cmp	r4, #1
102c726c:	0a00004d 	beq	102c73a8 <ATRsp_QBTSTATE_Hdlr+0x1dc>
             {
                Ql_MEM_Free (pstrNewBtDev);
             }
        }
        
        return  RIL_ATRSP_CONTINUE;
102c7270:	e3a00001 	mov	r0, #1
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
102c7274:	e28dd03c 	add	sp, sp, #60	; 0x3c
102c7278:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    }
			is_first_prompt = FALSE;
		}
		else
		{
             Ql_sscanf(pHead, "%*[^:]: %d%*[^\r\n]\r\n", &status);
102c727c:	e59f33cc 	ldr	r3, [pc, #972]	; 102c7650 <ATRsp_QBTSTATE_Hdlr+0x484>
102c7280:	e59f13d0 	ldr	r1, [pc, #976]	; 102c7658 <ATRsp_QBTSTATE_Hdlr+0x48c>
102c7284:	e5933000 	ldr	r3, [r3]
102c7288:	e28d200c 	add	r2, sp, #12
102c728c:	e12fff33 	blx	r3
102c7290:	e59d400c 	ldr	r4, [sp, #12]
		}
        
        if (0 == status)
102c7294:	e3540000 	cmp	r4, #0
102c7298:	1afffff2 	bne	102c7268 <ATRsp_QBTSTATE_Hdlr+0x9c>
        {
            // paired device
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
102c729c:	e59f33b8 	ldr	r3, [pc, #952]	; 102c765c <ATRsp_QBTSTATE_Hdlr+0x490>
102c72a0:	e3a00060 	mov	r0, #96	; 0x60
102c72a4:	e12fff33 	blx	r3
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->pairId));
102c72a8:	e59f93a0 	ldr	r9, [pc, #928]	; 102c7650 <ATRsp_QBTSTATE_Hdlr+0x484>
        
        if (0 == status)
        {
            // paired device
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
102c72ac:	e1a01004 	mov	r1, r4
102c72b0:	e3a02060 	mov	r2, #96	; 0x60
102c72b4:	e59f83a4 	ldr	r8, [pc, #932]	; 102c7660 <ATRsp_QBTSTATE_Hdlr+0x494>
		}
        
        if (0 == status)
        {
            // paired device
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
102c72b8:	e1a05000 	mov	r5, r0
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
102c72bc:	e12fff38 	blx	r8
             pstrNewBtDev->pairId = -1;
102c72c0:	e3e03000 	mvn	r3, #0
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->pairId));
102c72c4:	e59f1398 	ldr	r1, [pc, #920]	; 102c7664 <ATRsp_QBTSTATE_Hdlr+0x498>
102c72c8:	e2852050 	add	r2, r5, #80	; 0x50
        if (0 == status)
        {
            // paired device
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
102c72cc:	e5853050 	str	r3, [r5, #80]	; 0x50
             pstrNewBtDev->connId = -1;
102c72d0:	e5853054 	str	r3, [r5, #84]	; 0x54
             pstrNewBtDev->profileId = -1;
102c72d4:	e5853058 	str	r3, [r5, #88]	; 0x58
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->pairId));
102c72d8:	e1a00006 	mov	r0, r6
102c72dc:	e5993000 	ldr	r3, [r9]
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
102c72e0:	e285a004 	add	sl, r5, #4
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->pairId));
102c72e4:	e12fff33 	blx	r3
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
102c72e8:	e285703c 	add	r7, r5, #60	; 0x3c
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->pairId));
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
102c72ec:	e5993000 	ldr	r3, [r9]
102c72f0:	e59f1370 	ldr	r1, [pc, #880]	; 102c7668 <ATRsp_QBTSTATE_Hdlr+0x49c>
102c72f4:	e1a0200a 	mov	r2, sl
102c72f8:	e1a00006 	mov	r0, r6
102c72fc:	e12fff33 	blx	r3
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
102c7300:	e1a02007 	mov	r2, r7
102c7304:	e59f1360 	ldr	r1, [pc, #864]	; 102c766c <ATRsp_QBTSTATE_Hdlr+0x4a0>
102c7308:	e5993000 	ldr	r3, [r9]
102c730c:	e1a00006 	mov	r0, r6
102c7310:	e12fff33 	blx	r3
             pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
102c7314:	e1a00007 	mov	r0, r7
102c7318:	e59f3350 	ldr	r3, [pc, #848]	; 102c7670 <ATRsp_QBTSTATE_Hdlr+0x4a4>
102c731c:	e12fff33 	blx	r3
102c7320:	e59f334c 	ldr	r3, [pc, #844]	; 102c7674 <ATRsp_QBTSTATE_Hdlr+0x4a8>
102c7324:	e1a01000 	mov	r1, r0
102c7328:	e1a00007 	mov	r0, r7
102c732c:	e12fff33 	blx	r3
102c7330:	e59f7340 	ldr	r7, [pc, #832]	; 102c7678 <ATRsp_QBTSTATE_Hdlr+0x4ac>
             ret = BT_PairUpdateConfirm(pstrNewBtDev->pairId,pstrNewBtDev->btDevice.devHdl,pstrNewBtDev->btDevice.name);
102c7334:	e5959050 	ldr	r9, [r5, #80]	; 0x50
102c7338:	e1a0c007 	mov	ip, r7
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->pairId));
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
             pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
102c733c:	e5850000 	str	r0, [r5]
102c7340:	ea000002 	b	102c7350 <ATRsp_QBTSTATE_Hdlr+0x184>
102c7344:	e2844001 	add	r4, r4, #1

static bool BT_PairUpdateConfirm(const s32 pairid,BT_DEV_HDL devHdl,const char *name)
{
    u16 i;

    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c7348:	e354001e 	cmp	r4, #30
102c734c:	0a00006f 	beq	102c7510 <ATRsp_QBTSTATE_Hdlr+0x344>
    {
        if (NULL != m_arrBTDev[i])
102c7350:	e5bc3004 	ldr	r3, [ip, #4]!
102c7354:	e3530000 	cmp	r3, #0
102c7358:	0afffff9 	beq	102c7344 <ATRsp_QBTSTATE_Hdlr+0x178>
        {
            if(devHdl == m_arrBTDev[i]->btDevice.devHdl)
102c735c:	e5936000 	ldr	r6, [r3]
102c7360:	e1500006 	cmp	r0, r6
102c7364:	1afffff6 	bne	102c7344 <ATRsp_QBTSTATE_Hdlr+0x178>
            {
                m_arrBTDev[i]->pairId = pairid;
				Ql_memset(m_arrBTDev[i]->btDevice.name,0,BT_NAME_LEN);
102c7368:	e3a01000 	mov	r1, #0
102c736c:	e3a02038 	mov	r2, #56	; 0x38
    {
        if (NULL != m_arrBTDev[i])
        {
            if(devHdl == m_arrBTDev[i]->btDevice.devHdl)
            {
                m_arrBTDev[i]->pairId = pairid;
102c7370:	e5839050 	str	r9, [r3, #80]	; 0x50
				Ql_memset(m_arrBTDev[i]->btDevice.name,0,BT_NAME_LEN);
102c7374:	e2830004 	add	r0, r3, #4
102c7378:	e12fff38 	blx	r8
                Ql_strcpy(m_arrBTDev[i]->btDevice.name,name);
102c737c:	e1a0100a 	mov	r1, sl
            if(devHdl == m_arrBTDev[i]->btDevice.devHdl)
            {
                m_arrBTDev[i]->connId = connid;
                m_arrBTDev[i]->profileId = profileId;
				Ql_memset(m_arrBTDev[i]->btDevice.name,0,BT_NAME_LEN);
                Ql_strcpy(m_arrBTDev[i]->btDevice.name,name);
102c7380:	e59f32f4 	ldr	r3, [pc, #756]	; 102c767c <ATRsp_QBTSTATE_Hdlr+0x4b0>
102c7384:	e7930104 	ldr	r0, [r3, r4, lsl #2]
102c7388:	e59f32f0 	ldr	r3, [pc, #752]	; 102c7680 <ATRsp_QBTSTATE_Hdlr+0x4b4>
102c738c:	e2800004 	add	r0, r0, #4
102c7390:	e12fff33 	blx	r3
                    Ql_MEM_Free (pstrNewBtDev);
                }
             }
             else
             {
                Ql_MEM_Free (pstrNewBtDev);
102c7394:	e1a00005 	mov	r0, r5
102c7398:	e59f32e4 	ldr	r3, [pc, #740]	; 102c7684 <ATRsp_QBTSTATE_Hdlr+0x4b8>
102c739c:	e12fff33 	blx	r3
             }
        }
        
        return  RIL_ATRSP_CONTINUE;
102c73a0:	e3a00001 	mov	r0, #1
102c73a4:	eaffffb2 	b	102c7274 <ATRsp_QBTSTATE_Hdlr+0xa8>
            
        }
        else if (1 == status)
        {
            // connected device  +QBTSTATE:1,2,"H60-L01",F4E3FBE47920,SPP
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
102c73a8:	e59f32ac 	ldr	r3, [pc, #684]	; 102c765c <ATRsp_QBTSTATE_Hdlr+0x490>
102c73ac:	e3a00060 	mov	r0, #96	; 0x60
102c73b0:	e12fff33 	blx	r3
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
102c73b4:	e59f4294 	ldr	r4, [pc, #660]	; 102c7650 <ATRsp_QBTSTATE_Hdlr+0x484>
        }
        else if (1 == status)
        {
            // connected device  +QBTSTATE:1,2,"H60-L01",F4E3FBE47920,SPP
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
102c73b8:	e3a01000 	mov	r1, #0
102c73bc:	e3a02060 	mov	r2, #96	; 0x60
102c73c0:	e59f8298 	ldr	r8, [pc, #664]	; 102c7660 <ATRsp_QBTSTATE_Hdlr+0x494>
    if(NULL == profile_name)
    {
        return -1;
    }
    
    while (pf_name[i] != NULL)
102c73c4:	e59fb2bc 	ldr	fp, [pc, #700]	; 102c7688 <ATRsp_QBTSTATE_Hdlr+0x4bc>
102c73c8:	e59f72bc 	ldr	r7, [pc, #700]	; 102c768c <ATRsp_QBTSTATE_Hdlr+0x4c0>
102c73cc:	e59f92bc 	ldr	r9, [pc, #700]	; 102c7690 <ATRsp_QBTSTATE_Hdlr+0x4c4>
            
        }
        else if (1 == status)
        {
            // connected device  +QBTSTATE:1,2,"H60-L01",F4E3FBE47920,SPP
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
102c73d0:	e1a05000 	mov	r5, r0
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
102c73d4:	e12fff38 	blx	r8
             pstrNewBtDev->pairId = -1;
102c73d8:	e3e03000 	mvn	r3, #0
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
102c73dc:	e285c004 	add	ip, r5, #4
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
102c73e0:	e59f127c 	ldr	r1, [pc, #636]	; 102c7664 <ATRsp_QBTSTATE_Hdlr+0x498>
102c73e4:	e2852054 	add	r2, r5, #84	; 0x54
        else if (1 == status)
        {
            // connected device  +QBTSTATE:1,2,"H60-L01",F4E3FBE47920,SPP
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
102c73e8:	e5853050 	str	r3, [r5, #80]	; 0x50
             pstrNewBtDev->connId = -1;
102c73ec:	e5853054 	str	r3, [r5, #84]	; 0x54
             pstrNewBtDev->profileId = -1;
102c73f0:	e5853058 	str	r3, [r5, #88]	; 0x58
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
102c73f4:	e1a00006 	mov	r0, r6
102c73f8:	e5943000 	ldr	r3, [r4]
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
102c73fc:	e58dc004 	str	ip, [sp, #4]
             pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
102c7400:	e12fff33 	blx	r3
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
102c7404:	e285303c 	add	r3, r5, #60	; 0x3c
102c7408:	e58d3000 	str	r3, [sp]
             Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
             pstrNewBtDev->pairId = -1;
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
102c740c:	e59f1254 	ldr	r1, [pc, #596]	; 102c7668 <ATRsp_QBTSTATE_Hdlr+0x49c>
102c7410:	e5943000 	ldr	r3, [r4]
102c7414:	e59d2004 	ldr	r2, [sp, #4]
102c7418:	e1a00006 	mov	r0, r6
102c741c:	e12fff33 	blx	r3
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
102c7420:	e5943000 	ldr	r3, [r4]
102c7424:	e59f1268 	ldr	r1, [pc, #616]	; 102c7694 <ATRsp_QBTSTATE_Hdlr+0x4c8>
102c7428:	e59d2000 	ldr	r2, [sp]
102c742c:	e1a00006 	mov	r0, r6
102c7430:	e12fff33 	blx	r3
             Ql_sscanf(line, "%*[^\"]\"%*[^\"]\"%*[^\"]\"%[^\"]%*[^\r\n]\r\n",profile_name);
102c7434:	e5943000 	ldr	r3, [r4]
102c7438:	e1a00006 	mov	r0, r6
102c743c:	e59f1254 	ldr	r1, [pc, #596]	; 102c7698 <ATRsp_QBTSTATE_Hdlr+0x4cc>
102c7440:	e28d2010 	add	r2, sp, #16
    if(NULL == profile_name)
    {
        return -1;
    }
    
    while (pf_name[i] != NULL)
102c7444:	e3a04000 	mov	r4, #0
             pstrNewBtDev->connId = -1;
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
             Ql_sscanf(line, "%*[^\"]\"%*[^\"]\"%*[^\"]\"%[^\"]%*[^\r\n]\r\n",profile_name);
102c7448:	e12fff33 	blx	r3
102c744c:	e59f621c 	ldr	r6, [pc, #540]	; 102c7670 <ATRsp_QBTSTATE_Hdlr+0x4a4>
102c7450:	e1a0a004 	mov	sl, r4
102c7454:	ea000004 	b	102c746c <ATRsp_QBTSTATE_Hdlr+0x2a0>
    {
       if(0 == Ql_strncmp(profile_name,pf_name[i],Ql_strlen(profile_name)))
       {
           return i ;
       }
       i++;
102c7458:	e1a04823 	lsr	r4, r3, #16
    if(NULL == profile_name)
    {
        return -1;
    }
    
    while (pf_name[i] != NULL)
102c745c:	e799b104 	ldr	fp, [r9, r4, lsl #2]
102c7460:	e1a0a004 	mov	sl, r4
102c7464:	e35b0000 	cmp	fp, #0
102c7468:	0a000050 	beq	102c75b0 <ATRsp_QBTSTATE_Hdlr+0x3e4>
    {
       if(0 == Ql_strncmp(profile_name,pf_name[i],Ql_strlen(profile_name)))
102c746c:	e28d0010 	add	r0, sp, #16
102c7470:	e12fff36 	blx	r6
102c7474:	e1a0100b 	mov	r1, fp
102c7478:	e1a02000 	mov	r2, r0
102c747c:	e28d0010 	add	r0, sp, #16
102c7480:	e12fff37 	blx	r7
       {
           return i ;
       }
       i++;
102c7484:	e28a3001 	add	r3, sl, #1
102c7488:	e1a03803 	lsl	r3, r3, #16
        return -1;
    }
    
    while (pf_name[i] != NULL)
    {
       if(0 == Ql_strncmp(profile_name,pf_name[i],Ql_strlen(profile_name)))
102c748c:	e3500000 	cmp	r0, #0
102c7490:	1afffff0 	bne	102c7458 <ATRsp_QBTSTATE_Hdlr+0x28c>
             pstrNewBtDev->profileId = -1;
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
             Ql_sscanf(line, "%*[^\"]\"%*[^\"]\"%*[^\"]\"%[^\"]%*[^\r\n]\r\n",profile_name);
			 pstrNewBtDev->profileId = BT_DevMngmt_ProfileNameToId(profile_name);  
102c7494:	e5854058 	str	r4, [r5, #88]	; 0x58
             pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
102c7498:	e59d0000 	ldr	r0, [sp]
102c749c:	e12fff36 	blx	r6
102c74a0:	e59f31cc 	ldr	r3, [pc, #460]	; 102c7674 <ATRsp_QBTSTATE_Hdlr+0x4a8>
102c74a4:	e59f61cc 	ldr	r6, [pc, #460]	; 102c7678 <ATRsp_QBTSTATE_Hdlr+0x4ac>
             ret = BT_ConnectUpdateConfirm(pstrNewBtDev->connId,pstrNewBtDev->profileId,pstrNewBtDev->btDevice.devHdl,pstrNewBtDev->btDevice.name);
102c74a8:	e3a04000 	mov	r4, #0
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
             Ql_sscanf(line, "%*[^\"]\"%*[^\"]\"%*[^\"]\"%[^\"]%*[^\r\n]\r\n",profile_name);
			 pstrNewBtDev->profileId = BT_DevMngmt_ProfileNameToId(profile_name);  
             pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
102c74ac:	e1a01000 	mov	r1, r0
102c74b0:	e59d0000 	ldr	r0, [sp]
102c74b4:	e12fff33 	blx	r3
             ret = BT_ConnectUpdateConfirm(pstrNewBtDev->connId,pstrNewBtDev->profileId,pstrNewBtDev->btDevice.devHdl,pstrNewBtDev->btDevice.name);
102c74b8:	e5957054 	ldr	r7, [r5, #84]	; 0x54
102c74bc:	e595c058 	ldr	ip, [r5, #88]	; 0x58
102c74c0:	e1a02006 	mov	r2, r6
             Ql_sscanf(line, "%*[^,],%d%*[^\r\n]\r\n",&(pstrNewBtDev->connId));
             Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
             Ql_sscanf(line, "%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
             Ql_sscanf(line, "%*[^\"]\"%*[^\"]\"%*[^\"]\"%[^\"]%*[^\r\n]\r\n",profile_name);
			 pstrNewBtDev->profileId = BT_DevMngmt_ProfileNameToId(profile_name);  
             pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
102c74c4:	e5850000 	str	r0, [r5]
102c74c8:	ea000002 	b	102c74d8 <ATRsp_QBTSTATE_Hdlr+0x30c>
102c74cc:	e2844001 	add	r4, r4, #1

static bool BT_ConnectUpdateConfirm(const s32 connid,const s32 profileId,BT_DEV_HDL devHdl,const char *name)
{
    u16 i;

    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c74d0:	e354001e 	cmp	r4, #30
102c74d4:	0a000037 	beq	102c75b8 <ATRsp_QBTSTATE_Hdlr+0x3ec>
    {
        if (NULL != m_arrBTDev[i])
102c74d8:	e5b23004 	ldr	r3, [r2, #4]!
102c74dc:	e3530000 	cmp	r3, #0
102c74e0:	0afffff9 	beq	102c74cc <ATRsp_QBTSTATE_Hdlr+0x300>
        {
            if(devHdl == m_arrBTDev[i]->btDevice.devHdl)
102c74e4:	e5931000 	ldr	r1, [r3]
102c74e8:	e1500001 	cmp	r0, r1
102c74ec:	1afffff6 	bne	102c74cc <ATRsp_QBTSTATE_Hdlr+0x300>
            {
                m_arrBTDev[i]->connId = connid;
                m_arrBTDev[i]->profileId = profileId;
				Ql_memset(m_arrBTDev[i]->btDevice.name,0,BT_NAME_LEN);
102c74f0:	e3a01000 	mov	r1, #0
102c74f4:	e3a02038 	mov	r2, #56	; 0x38
    {
        if (NULL != m_arrBTDev[i])
        {
            if(devHdl == m_arrBTDev[i]->btDevice.devHdl)
            {
                m_arrBTDev[i]->connId = connid;
102c74f8:	e5837054 	str	r7, [r3, #84]	; 0x54
                m_arrBTDev[i]->profileId = profileId;
102c74fc:	e583c058 	str	ip, [r3, #88]	; 0x58
				Ql_memset(m_arrBTDev[i]->btDevice.name,0,BT_NAME_LEN);
102c7500:	e2830004 	add	r0, r3, #4
102c7504:	e12fff38 	blx	r8
                Ql_strcpy(m_arrBTDev[i]->btDevice.name,name);
102c7508:	e59d1004 	ldr	r1, [sp, #4]
102c750c:	eaffff9b 	b	102c7380 <ATRsp_QBTSTATE_Hdlr+0x1b4>
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATRsp_QBTSTATE_Hdlr(char* line, u32 len, void* param)
102c7510:	e59f4184 	ldr	r4, [pc, #388]	; 102c769c <ATRsp_QBTSTATE_Hdlr+0x4d0>
102c7514:	e3a0c000 	mov	ip, #0
102c7518:	e2443078 	sub	r3, r4, #120	; 0x78
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c751c:	e5b32004 	ldr	r2, [r3, #4]!
        {
            count++;
102c7520:	e28c1001 	add	r1, ip, #1
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c7524:	e3520000 	cmp	r2, #0
        {
            count++;
102c7528:	e1a01801 	lsl	r1, r1, #16
102c752c:	11a0c821 	lsrne	ip, r1, #16

static bool BT_DevMngmt_isFull(void)
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c7530:	e1530004 	cmp	r3, r4
102c7534:	1afffff8 	bne	102c751c <ATRsp_QBTSTATE_Hdlr+0x350>
        {
            count++;
        }
    }

    if(count >= MAX_BT_DEV_CNT)
102c7538:	e35c001d 	cmp	ip, #29
102c753c:	8a00000b 	bhi	102c7570 <ATRsp_QBTSTATE_Hdlr+0x3a4>
102c7540:	e3a03000 	mov	r3, #0
102c7544:	ea000002 	b	102c7554 <ATRsp_QBTSTATE_Hdlr+0x388>
102c7548:	e2833001 	add	r3, r3, #1
//
// Append a bt device
static void BT_DevMngmt_Append(ST_BT_DevInfo* pstBtDev)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c754c:	e353001e 	cmp	r3, #30
102c7550:	0affff46 	beq	102c7270 <ATRsp_QBTSTATE_Hdlr+0xa4>
    {
        if (NULL == m_arrBTDev[i])
102c7554:	e5b72004 	ldr	r2, [r7, #4]!
102c7558:	e3520000 	cmp	r2, #0
102c755c:	1afffff9 	bne	102c7548 <ATRsp_QBTSTATE_Hdlr+0x37c>
        {
            m_arrBTDev[i] = pstBtDev;
102c7560:	e59f2114 	ldr	r2, [pc, #276]	; 102c767c <ATRsp_QBTSTATE_Hdlr+0x4b0>
             {
                Ql_MEM_Free (pstrNewBtDev);
             }
        }
        
        return  RIL_ATRSP_CONTINUE;
102c7564:	e3a00001 	mov	r0, #1
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL == m_arrBTDev[i])
        {
            m_arrBTDev[i] = pstBtDev;
102c7568:	e7825103 	str	r5, [r2, r3, lsl #2]
102c756c:	eaffff40 	b	102c7274 <ATRsp_QBTSTATE_Hdlr+0xa8>
                   BT_DevMngmt_Append(pstrNewBtDev);
            
                }
                else
                {
                    Ql_MEM_Free (pstrNewBtDev);
102c7570:	e1a00005 	mov	r0, r5
102c7574:	e59f3108 	ldr	r3, [pc, #264]	; 102c7684 <ATRsp_QBTSTATE_Hdlr+0x4b8>
102c7578:	e12fff33 	blx	r3
102c757c:	eaffff3b 	b	102c7270 <ATRsp_QBTSTATE_Hdlr+0xa4>
        }
        
        return  RIL_ATRSP_CONTINUE;
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c7580:	e1a00006 	mov	r0, r6
102c7584:	e1a01008 	mov	r1, r8
102c7588:	e59f2110 	ldr	r2, [pc, #272]	; 102c76a0 <ATRsp_QBTSTATE_Hdlr+0x4d4>
102c758c:	e59f4110 	ldr	r4, [pc, #272]	; 102c76a4 <ATRsp_QBTSTATE_Hdlr+0x4d8>
102c7590:	e12fff34 	blx	r4
    if (pHead)
102c7594:	e3500000 	cmp	r0, #0
102c7598:	0a00001b 	beq	102c760c <ATRsp_QBTSTATE_Hdlr+0x440>
    {  
        is_first_prompt = TRUE;
102c759c:	e59f30a8 	ldr	r3, [pc, #168]	; 102c764c <ATRsp_QBTSTATE_Hdlr+0x480>
102c75a0:	e3a02001 	mov	r2, #1
102c75a4:	e5c32000 	strb	r2, [r3]
        return  RIL_ATRSP_SUCCESS;
102c75a8:	e1a0000a 	mov	r0, sl
102c75ac:	eaffff30 	b	102c7274 <ATRsp_QBTSTATE_Hdlr+0xa8>
           return i ;
       }
       i++;
    }

    return -1;
102c75b0:	e3e04000 	mvn	r4, #0
102c75b4:	eaffffb6 	b	102c7494 <ATRsp_QBTSTATE_Hdlr+0x2c8>
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATRsp_QBTSTATE_Hdlr(char* line, u32 len, void* param)
102c75b8:	e59f00dc 	ldr	r0, [pc, #220]	; 102c769c <ATRsp_QBTSTATE_Hdlr+0x4d0>
102c75bc:	e3a0c000 	mov	ip, #0
102c75c0:	e2403078 	sub	r3, r0, #120	; 0x78
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c75c4:	e5b32004 	ldr	r2, [r3, #4]!
        {
            count++;
102c75c8:	e28c1001 	add	r1, ip, #1
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c75cc:	e3520000 	cmp	r2, #0
        {
            count++;
102c75d0:	e1a01801 	lsl	r1, r1, #16
102c75d4:	11a0c821 	lsrne	ip, r1, #16

static bool BT_DevMngmt_isFull(void)
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c75d8:	e1530000 	cmp	r3, r0
102c75dc:	1afffff8 	bne	102c75c4 <ATRsp_QBTSTATE_Hdlr+0x3f8>
        {
            count++;
        }
    }

    if(count >= MAX_BT_DEV_CNT)
102c75e0:	e35c001d 	cmp	ip, #29
102c75e4:	8affffe1 	bhi	102c7570 <ATRsp_QBTSTATE_Hdlr+0x3a4>
102c75e8:	e3a03000 	mov	r3, #0
102c75ec:	ea000002 	b	102c75fc <ATRsp_QBTSTATE_Hdlr+0x430>
102c75f0:	e2833001 	add	r3, r3, #1
//
// Append a bt device
static void BT_DevMngmt_Append(ST_BT_DevInfo* pstBtDev)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c75f4:	e353001e 	cmp	r3, #30
102c75f8:	0affff1c 	beq	102c7270 <ATRsp_QBTSTATE_Hdlr+0xa4>
    {
        if (NULL == m_arrBTDev[i])
102c75fc:	e5b62004 	ldr	r2, [r6, #4]!
102c7600:	e3520000 	cmp	r2, #0
102c7604:	1afffff9 	bne	102c75f0 <ATRsp_QBTSTATE_Hdlr+0x424>
102c7608:	eaffffd4 	b	102c7560 <ATRsp_QBTSTATE_Hdlr+0x394>
    {  
        is_first_prompt = TRUE;
        return  RIL_ATRSP_SUCCESS;
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c760c:	e1a00006 	mov	r0, r6
102c7610:	e1a01008 	mov	r1, r8
102c7614:	e59f208c 	ldr	r2, [pc, #140]	; 102c76a8 <ATRsp_QBTSTATE_Hdlr+0x4dc>
102c7618:	e12fff34 	blx	r4
    if (pHead)
102c761c:	e3500000 	cmp	r0, #0
102c7620:	1a000005 	bne	102c763c <ATRsp_QBTSTATE_Hdlr+0x470>
    {  
        return  RIL_ATRSP_FAILED;
    } 

    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102c7624:	e1a00006 	mov	r0, r6
102c7628:	e1a01008 	mov	r1, r8
102c762c:	e59f2078 	ldr	r2, [pc, #120]	; 102c76ac <ATRsp_QBTSTATE_Hdlr+0x4e0>
102c7630:	e12fff35 	blx	r5
    if (pHead)
102c7634:	e3500000 	cmp	r0, #0
102c7638:	0affff0c 	beq	102c7270 <ATRsp_QBTSTATE_Hdlr+0xa4>
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
102c763c:	e3e00000 	mvn	r0, #0
102c7640:	eaffff0b 	b	102c7274 <ATRsp_QBTSTATE_Hdlr+0xa8>
102c7644:	102cce98 	.word	0x102cce98
102c7648:	102ede34 	.word	0x102ede34
102c764c:	f03d2000 	.word	0xf03d2000
102c7650:	f03de548 	.word	0xf03de548
102c7654:	102ede14 	.word	0x102ede14
102c7658:	102ede40 	.word	0x102ede40
102c765c:	102e4840 	.word	0x102e4840
102c7660:	102e58f4 	.word	0x102e58f4
102c7664:	102ede54 	.word	0x102ede54
102c7668:	102ede68 	.word	0x102ede68
102c766c:	102ede80 	.word	0x102ede80
102c7670:	102e57a4 	.word	0x102e57a4
102c7674:	102cd1a4 	.word	0x102cd1a4
102c7678:	f03d5054 	.word	0xf03d5054
102c767c:	f03d5058 	.word	0xf03d5058
102c7680:	102e55fc 	.word	0x102e55fc
102c7684:	102e48b8 	.word	0x102e48b8
102c7688:	102ede30 	.word	0x102ede30
102c768c:	102e5884 	.word	0x102e5884
102c7690:	102e6488 	.word	0x102e6488
102c7694:	102ede98 	.word	0x102ede98
102c7698:	102edeb8 	.word	0x102edeb8
102c769c:	f03d50cc 	.word	0xf03d50cc
102c76a0:	102ee5e8 	.word	0x102ee5e8
102c76a4:	102ccf24 	.word	0x102ccf24
102c76a8:	102ede00 	.word	0x102ede00
102c76ac:	102ede08 	.word	0x102ede08

102c76b0 <ATRsp_QBTSPPREAD_Hdlr>:
    }

    return RIL_ATRSP_FAILED; //not supported
}
static s32 ATRsp_QBTSPPREAD_Hdlr(char* line, u32 len, void* param)
{
102c76b0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    static bool sppReadMode = FALSE;
    char* pHead = NULL;


    // The coming data is spp data
    if (sppReadMode)
102c76b4:	e59f40e4 	ldr	r4, [pc, #228]	; 102c77a0 <ATRsp_QBTSPPREAD_Hdlr+0xf0>
    }

    return RIL_ATRSP_FAILED; //not supported
}
static s32 ATRsp_QBTSPPREAD_Hdlr(char* line, u32 len, void* param)
{
102c76b8:	e1a05000 	mov	r5, r0
    static bool sppReadMode = FALSE;
    char* pHead = NULL;


    // The coming data is spp data
    if (sppReadMode)
102c76bc:	e5d43078 	ldrb	r3, [r4, #120]	; 0x78
    }

    return RIL_ATRSP_FAILED; //not supported
}
static s32 ATRsp_QBTSPPREAD_Hdlr(char* line, u32 len, void* param)
{
102c76c0:	e1a07001 	mov	r7, r1
    static bool sppReadMode = FALSE;
    char* pHead = NULL;


    // The coming data is spp data
    if (sppReadMode)
102c76c4:	e3530000 	cmp	r3, #0
    }

    return RIL_ATRSP_FAILED; //not supported
}
static s32 ATRsp_QBTSPPREAD_Hdlr(char* line, u32 len, void* param)
{
102c76c8:	e1a06002 	mov	r6, r2
    static bool sppReadMode = FALSE;
    char* pHead = NULL;


    // The coming data is spp data
    if (sppReadMode)
102c76cc:	0a00000b 	beq	102c7700 <ATRsp_QBTSPPREAD_Hdlr+0x50>
    {
        Ql_memcpy((void*)(m_ptrSppDataBuf), (const void*)line, m_nSppRealReadLen);
102c76d0:	e59f30cc 	ldr	r3, [pc, #204]	; 102c77a4 <ATRsp_QBTSPPREAD_Hdlr+0xf4>
102c76d4:	e594007c 	ldr	r0, [r4, #124]	; 0x7c
102c76d8:	e1a01005 	mov	r1, r5
102c76dc:	e5942080 	ldr	r2, [r4, #128]	; 0x80
102c76e0:	e12fff33 	blx	r3
	    if(NULL != param)
102c76e4:	e3560000 	cmp	r6, #0
       {
           *(u32 *)param = m_nSppRealReadLen ;
102c76e8:	15943080 	ldrne	r3, [r4, #128]	; 0x80
       }

		sppReadMode = FALSE;

        return  RIL_ATRSP_CONTINUE;
102c76ec:	e3a00001 	mov	r0, #1
    if (sppReadMode)
    {
        Ql_memcpy((void*)(m_ptrSppDataBuf), (const void*)line, m_nSppRealReadLen);
	    if(NULL != param)
       {
           *(u32 *)param = m_nSppRealReadLen ;
102c76f0:	15863000 	strne	r3, [r6]
       }

		sppReadMode = FALSE;
102c76f4:	e3a03000 	mov	r3, #0
102c76f8:	e5c43078 	strb	r3, [r4, #120]	; 0x78

        return  RIL_ATRSP_CONTINUE;
102c76fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
    
    pHead = Ql_RIL_FindString(line, len, "\r\n+QSPPREAD: ");
102c7700:	e59f20a0 	ldr	r2, [pc, #160]	; 102c77a8 <ATRsp_QBTSPPREAD_Hdlr+0xf8>
102c7704:	e59f60a0 	ldr	r6, [pc, #160]	; 102c77ac <ATRsp_QBTSPPREAD_Hdlr+0xfc>
102c7708:	e12fff36 	blx	r6
    if (pHead)
102c770c:	e2508000 	subs	r8, r0, #0
    {
        Ql_sscanf(line, "%*[^:]: %d", &m_nSppRealReadLen);
102c7710:	e1a00005 	mov	r0, r5

        return  RIL_ATRSP_CONTINUE;
    }
    
    pHead = Ql_RIL_FindString(line, len, "\r\n+QSPPREAD: ");
    if (pHead)
102c7714:	0a00000b 	beq	102c7748 <ATRsp_QBTSPPREAD_Hdlr+0x98>
    {
        Ql_sscanf(line, "%*[^:]: %d", &m_nSppRealReadLen);
102c7718:	e59f3090 	ldr	r3, [pc, #144]	; 102c77b0 <ATRsp_QBTSPPREAD_Hdlr+0x100>
102c771c:	e59f1090 	ldr	r1, [pc, #144]	; 102c77b4 <ATRsp_QBTSPPREAD_Hdlr+0x104>
102c7720:	e5933000 	ldr	r3, [r3]
102c7724:	e2842080 	add	r2, r4, #128	; 0x80
102c7728:	e12fff33 	blx	r3
        if (m_nSppRealReadLen > 0)
102c772c:	e5943080 	ldr	r3, [r4, #128]	; 0x80
102c7730:	e3530000 	cmp	r3, #0
        {
            sppReadMode = TRUE;
102c7734:	13a00001 	movne	r0, #1
        }else{  // no more data
            sppReadMode = FALSE;
102c7738:	05c43078 	strbeq	r3, [r4, #120]	; 0x78
            // do nothing, just wait for "OK"
        }
        return  RIL_ATRSP_CONTINUE;
102c773c:	03a00001 	moveq	r0, #1
    if (pHead)
    {
        Ql_sscanf(line, "%*[^:]: %d", &m_nSppRealReadLen);
        if (m_nSppRealReadLen > 0)
        {
            sppReadMode = TRUE;
102c7740:	15c40078 	strbne	r0, [r4, #120]	; 0x78
102c7744:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            // do nothing, just wait for "OK"
        }
        return  RIL_ATRSP_CONTINUE;
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c7748:	e1a01007 	mov	r1, r7
102c774c:	e59f2064 	ldr	r2, [pc, #100]	; 102c77b8 <ATRsp_QBTSPPREAD_Hdlr+0x108>
102c7750:	e59f4064 	ldr	r4, [pc, #100]	; 102c77bc <ATRsp_QBTSPPREAD_Hdlr+0x10c>
102c7754:	e12fff34 	blx	r4
    if (pHead)
102c7758:	e3500000 	cmp	r0, #0
102c775c:	0a000001 	beq	102c7768 <ATRsp_QBTSPPREAD_Hdlr+0xb8>
    {  
	   
       return  RIL_ATRSP_SUCCESS;
102c7760:	e1a00008 	mov	r0, r8
102c7764:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c7768:	e1a00005 	mov	r0, r5
102c776c:	e1a01007 	mov	r1, r7
102c7770:	e59f2048 	ldr	r2, [pc, #72]	; 102c77c0 <ATRsp_QBTSPPREAD_Hdlr+0x110>
102c7774:	e12fff34 	blx	r4
    if (pHead)
102c7778:	e3500000 	cmp	r0, #0
102c777c:	0a000001 	beq	102c7788 <ATRsp_QBTSPPREAD_Hdlr+0xd8>
    {  
        return  RIL_ATRSP_FAILED;
102c7780:	e3e00000 	mvn	r0, #0
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_FAILED; //not supported
}
102c7784:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
    } 
    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102c7788:	e1a00005 	mov	r0, r5
102c778c:	e1a01007 	mov	r1, r7
102c7790:	e59f202c 	ldr	r2, [pc, #44]	; 102c77c4 <ATRsp_QBTSPPREAD_Hdlr+0x114>
102c7794:	e12fff36 	blx	r6
    if (pHead)
    {
        return  RIL_ATRSP_FAILED;
102c7798:	e3e00000 	mvn	r0, #0
102c779c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102c77a0:	f03d5058 	.word	0xf03d5058
102c77a4:	102e597c 	.word	0x102e597c
102c77a8:	102ededc 	.word	0x102ededc
102c77ac:	102cce98 	.word	0x102cce98
102c77b0:	f03de548 	.word	0xf03de548
102c77b4:	102edeec 	.word	0x102edeec
102c77b8:	102ee5e8 	.word	0x102ee5e8
102c77bc:	102ccf24 	.word	0x102ccf24
102c77c0:	102ede00 	.word	0x102ede00
102c77c4:	102ede08 	.word	0x102ede08

102c77c8 <ATRsp_QBTGPROF_Hdlr>:
    return RIL_ATRSP_FAILED; //not supported
}


static s32 ATRsp_QBTGPROF_Hdlr(char* line, u32 len, void* param)
{
102c77c8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102c77cc:	e1a06002 	mov	r6, r2
    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTGPROF:");
102c77d0:	e59f50a8 	ldr	r5, [pc, #168]	; 102c7880 <ATRsp_QBTGPROF_Hdlr+0xb8>
102c77d4:	e59f20a8 	ldr	r2, [pc, #168]	; 102c7884 <ATRsp_QBTGPROF_Hdlr+0xbc>
    return RIL_ATRSP_FAILED; //not supported
}


static s32 ATRsp_QBTGPROF_Hdlr(char* line, u32 len, void* param)
{
102c77d8:	e1a04000 	mov	r4, r0
102c77dc:	e1a08001 	mov	r8, r1
    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTGPROF:");
102c77e0:	e12fff35 	blx	r5
	static u8 index = 0 ;

    if (pHead)
102c77e4:	e2507000 	subs	r7, r0, #0
102c77e8:	0a000009 	beq	102c7814 <ATRsp_QBTGPROF_Hdlr+0x4c>
    {
        Ql_sscanf(line, "%*[^:]: %d[^\r\n]\r\n", (s32 *)(param)+index);
102c77ec:	e59f3094 	ldr	r3, [pc, #148]	; 102c7888 <ATRsp_QBTGPROF_Hdlr+0xc0>
102c77f0:	e1a00004 	mov	r0, r4
102c77f4:	e5d32084 	ldrb	r2, [r3, #132]	; 0x84
102c77f8:	e59f308c 	ldr	r3, [pc, #140]	; 102c788c <ATRsp_QBTGPROF_Hdlr+0xc4>
102c77fc:	e59f108c 	ldr	r1, [pc, #140]	; 102c7890 <ATRsp_QBTGPROF_Hdlr+0xc8>
102c7800:	e5933000 	ldr	r3, [r3]
102c7804:	e0862102 	add	r2, r6, r2, lsl #2
102c7808:	e12fff33 	blx	r3

        return  RIL_ATRSP_CONTINUE;
102c780c:	e3a00001 	mov	r0, #1
102c7810:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c7814:	e1a00004 	mov	r0, r4
102c7818:	e1a01008 	mov	r1, r8
102c781c:	e59f2070 	ldr	r2, [pc, #112]	; 102c7894 <ATRsp_QBTGPROF_Hdlr+0xcc>
102c7820:	e59f6070 	ldr	r6, [pc, #112]	; 102c7898 <ATRsp_QBTGPROF_Hdlr+0xd0>
102c7824:	e12fff36 	blx	r6
    if (pHead)
102c7828:	e3500000 	cmp	r0, #0
102c782c:	0a000003 	beq	102c7840 <ATRsp_QBTGPROF_Hdlr+0x78>
    {  
       index = 0 ;
102c7830:	e59f3050 	ldr	r3, [pc, #80]	; 102c7888 <ATRsp_QBTGPROF_Hdlr+0xc0>
       return  RIL_ATRSP_SUCCESS;
102c7834:	e1a00007 	mov	r0, r7
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
    if (pHead)
    {  
       index = 0 ;
102c7838:	e5c37084 	strb	r7, [r3, #132]	; 0x84
       return  RIL_ATRSP_SUCCESS;
102c783c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c7840:	e1a00004 	mov	r0, r4
102c7844:	e1a01008 	mov	r1, r8
102c7848:	e59f204c 	ldr	r2, [pc, #76]	; 102c789c <ATRsp_QBTGPROF_Hdlr+0xd4>
102c784c:	e12fff36 	blx	r6
    if (pHead)
102c7850:	e3500000 	cmp	r0, #0
102c7854:	1a000007 	bne	102c7878 <ATRsp_QBTGPROF_Hdlr+0xb0>
    {  
        return  RIL_ATRSP_FAILED;
    } 
    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102c7858:	e1a00004 	mov	r0, r4
102c785c:	e1a01008 	mov	r1, r8
102c7860:	e59f2038 	ldr	r2, [pc, #56]	; 102c78a0 <ATRsp_QBTGPROF_Hdlr+0xd8>
102c7864:	e12fff35 	blx	r5
    if (pHead)
102c7868:	e3500000 	cmp	r0, #0
    {
        return  RIL_ATRSP_FAILED;
102c786c:	03a00001 	moveq	r0, #1
102c7870:	13e00000 	mvnne	r0, #0
102c7874:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
102c7878:	e3e00000 	mvn	r0, #0
    {
        return  RIL_ATRSP_FAILED;
    }
    
    return RIL_ATRSP_CONTINUE; //continue wait
}
102c787c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102c7880:	102cce98 	.word	0x102cce98
102c7884:	102edef8 	.word	0x102edef8
102c7888:	f03d5058 	.word	0xf03d5058
102c788c:	f03de548 	.word	0xf03de548
102c7890:	102edf08 	.word	0x102edf08
102c7894:	102ee5e8 	.word	0x102ee5e8
102c7898:	102ccf24 	.word	0x102ccf24
102c789c:	102ede00 	.word	0x102ede00
102c78a0:	102ede08 	.word	0x102ede08

102c78a4 <ATRsp_QBTVISB_Hdlr>:
    return RIL_ATRSP_FAILED; //not supported
}


static s32 ATRsp_QBTVISB_Hdlr(char* line, u32 len, void* param)
{
102c78a4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102c78a8:	e1a06002 	mov	r6, r2

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTVISB:");
102c78ac:	e59f508c 	ldr	r5, [pc, #140]	; 102c7940 <ATRsp_QBTVISB_Hdlr+0x9c>
102c78b0:	e59f208c 	ldr	r2, [pc, #140]	; 102c7944 <ATRsp_QBTVISB_Hdlr+0xa0>
    return RIL_ATRSP_FAILED; //not supported
}


static s32 ATRsp_QBTVISB_Hdlr(char* line, u32 len, void* param)
{
102c78b4:	e1a04000 	mov	r4, r0
102c78b8:	e1a07001 	mov	r7, r1

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTVISB:");
102c78bc:	e12fff35 	blx	r5

    if (pHead)
102c78c0:	e2508000 	subs	r8, r0, #0
    {
        Ql_sscanf(line, "%*[^:]: %d\r\n", (s32 *)param);
102c78c4:	e1a00004 	mov	r0, r4
static s32 ATRsp_QBTVISB_Hdlr(char* line, u32 len, void* param)
{

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTVISB:");

    if (pHead)
102c78c8:	0a000006 	beq	102c78e8 <ATRsp_QBTVISB_Hdlr+0x44>
    {
        Ql_sscanf(line, "%*[^:]: %d\r\n", (s32 *)param);
102c78cc:	e59f3074 	ldr	r3, [pc, #116]	; 102c7948 <ATRsp_QBTVISB_Hdlr+0xa4>
102c78d0:	e59f1074 	ldr	r1, [pc, #116]	; 102c794c <ATRsp_QBTVISB_Hdlr+0xa8>
102c78d4:	e5933000 	ldr	r3, [r3]
102c78d8:	e1a02006 	mov	r2, r6
102c78dc:	e12fff33 	blx	r3

        return  RIL_ATRSP_CONTINUE;
102c78e0:	e3a00001 	mov	r0, #1
102c78e4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c78e8:	e1a01007 	mov	r1, r7
102c78ec:	e59f205c 	ldr	r2, [pc, #92]	; 102c7950 <ATRsp_QBTVISB_Hdlr+0xac>
102c78f0:	e59f605c 	ldr	r6, [pc, #92]	; 102c7954 <ATRsp_QBTVISB_Hdlr+0xb0>
102c78f4:	e12fff36 	blx	r6
    if (pHead)
102c78f8:	e3500000 	cmp	r0, #0
102c78fc:	0a000001 	beq	102c7908 <ATRsp_QBTVISB_Hdlr+0x64>
    {  
       return  RIL_ATRSP_SUCCESS;
102c7900:	e1a00008 	mov	r0, r8
102c7904:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c7908:	e1a00004 	mov	r0, r4
102c790c:	e1a01007 	mov	r1, r7
102c7910:	e59f2040 	ldr	r2, [pc, #64]	; 102c7958 <ATRsp_QBTVISB_Hdlr+0xb4>
102c7914:	e12fff36 	blx	r6
    if (pHead)
102c7918:	e3500000 	cmp	r0, #0
102c791c:	0a000001 	beq	102c7928 <ATRsp_QBTVISB_Hdlr+0x84>
102c7920:	e3e00000 	mvn	r0, #0
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_FAILED; //not supported
}
102c7924:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
    } 
    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102c7928:	e1a00004 	mov	r0, r4
102c792c:	e1a01007 	mov	r1, r7
102c7930:	e59f2024 	ldr	r2, [pc, #36]	; 102c795c <ATRsp_QBTVISB_Hdlr+0xb8>
102c7934:	e12fff35 	blx	r5
102c7938:	e3e00000 	mvn	r0, #0
102c793c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102c7940:	102cce98 	.word	0x102cce98
102c7944:	102edf1c 	.word	0x102edf1c
102c7948:	f03de548 	.word	0xf03de548
102c794c:	102ede14 	.word	0x102ede14
102c7950:	102ee5e8 	.word	0x102ee5e8
102c7954:	102ccf24 	.word	0x102ccf24
102c7958:	102ede00 	.word	0x102ede00
102c795c:	102ede08 	.word	0x102ede08

102c7960 <ATRsp_QBTADDR_Hdlr>:
        // error
    }
}

static s32 ATRsp_QBTADDR_Hdlr(char* line, u32 len, void* param)
{
102c7960:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102c7964:	e1a06002 	mov	r6, r2
    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTADDR:");
102c7968:	e59f508c 	ldr	r5, [pc, #140]	; 102c79fc <ATRsp_QBTADDR_Hdlr+0x9c>
102c796c:	e59f208c 	ldr	r2, [pc, #140]	; 102c7a00 <ATRsp_QBTADDR_Hdlr+0xa0>
        // error
    }
}

static s32 ATRsp_QBTADDR_Hdlr(char* line, u32 len, void* param)
{
102c7970:	e1a04000 	mov	r4, r0
102c7974:	e1a07001 	mov	r7, r1
    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTADDR:");
102c7978:	e12fff35 	blx	r5

    if (pHead)
102c797c:	e2508000 	subs	r8, r0, #0
    {
        // +QBTADDR: 1488CD1F6261
        Ql_sscanf(line, "%*[^:]: %[^\r\n]\r\n", (char*)param);
102c7980:	e1a00004 	mov	r0, r4

static s32 ATRsp_QBTADDR_Hdlr(char* line, u32 len, void* param)
{
    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTADDR:");

    if (pHead)
102c7984:	0a000006 	beq	102c79a4 <ATRsp_QBTADDR_Hdlr+0x44>
    {
        // +QBTADDR: 1488CD1F6261
        Ql_sscanf(line, "%*[^:]: %[^\r\n]\r\n", (char*)param);
102c7988:	e59f3074 	ldr	r3, [pc, #116]	; 102c7a04 <ATRsp_QBTADDR_Hdlr+0xa4>
102c798c:	e59f1074 	ldr	r1, [pc, #116]	; 102c7a08 <ATRsp_QBTADDR_Hdlr+0xa8>
102c7990:	e5933000 	ldr	r3, [r3]
102c7994:	e1a02006 	mov	r2, r6
102c7998:	e12fff33 	blx	r3
        return  RIL_ATRSP_CONTINUE;
102c799c:	e3a00001 	mov	r0, #1
102c79a0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c79a4:	e1a01007 	mov	r1, r7
102c79a8:	e59f205c 	ldr	r2, [pc, #92]	; 102c7a0c <ATRsp_QBTADDR_Hdlr+0xac>
102c79ac:	e59f605c 	ldr	r6, [pc, #92]	; 102c7a10 <ATRsp_QBTADDR_Hdlr+0xb0>
102c79b0:	e12fff36 	blx	r6
    if (pHead)
102c79b4:	e3500000 	cmp	r0, #0
102c79b8:	0a000001 	beq	102c79c4 <ATRsp_QBTADDR_Hdlr+0x64>
    {  
       return  RIL_ATRSP_SUCCESS;
102c79bc:	e1a00008 	mov	r0, r8
102c79c0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c79c4:	e1a00004 	mov	r0, r4
102c79c8:	e1a01007 	mov	r1, r7
102c79cc:	e59f2040 	ldr	r2, [pc, #64]	; 102c7a14 <ATRsp_QBTADDR_Hdlr+0xb4>
102c79d0:	e12fff36 	blx	r6
    if (pHead)
102c79d4:	e3500000 	cmp	r0, #0
102c79d8:	0a000001 	beq	102c79e4 <ATRsp_QBTADDR_Hdlr+0x84>
102c79dc:	e3e00000 	mvn	r0, #0
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_FAILED; //not supported
}
102c79e0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
    } 
    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102c79e4:	e1a00004 	mov	r0, r4
102c79e8:	e1a01007 	mov	r1, r7
102c79ec:	e59f2024 	ldr	r2, [pc, #36]	; 102c7a18 <ATRsp_QBTADDR_Hdlr+0xb8>
102c79f0:	e12fff35 	blx	r5
102c79f4:	e3e00000 	mvn	r0, #0
102c79f8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102c79fc:	102cce98 	.word	0x102cce98
102c7a00:	102edf28 	.word	0x102edf28
102c7a04:	f03de548 	.word	0xf03de548
102c7a08:	102edf34 	.word	0x102edf34
102c7a0c:	102ee5e8 	.word	0x102ee5e8
102c7a10:	102ccf24 	.word	0x102ccf24
102c7a14:	102ede00 	.word	0x102ede00
102c7a18:	102ede08 	.word	0x102ede08

102c7a1c <ATRsp_QBTNAME_Hdlr>:
}



static s32 ATRsp_QBTNAME_Hdlr(char* line, u32 len, void* param)
{
102c7a1c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102c7a20:	e1a06002 	mov	r6, r2

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTNAME:");
102c7a24:	e59f508c 	ldr	r5, [pc, #140]	; 102c7ab8 <ATRsp_QBTNAME_Hdlr+0x9c>
102c7a28:	e59f208c 	ldr	r2, [pc, #140]	; 102c7abc <ATRsp_QBTNAME_Hdlr+0xa0>
}



static s32 ATRsp_QBTNAME_Hdlr(char* line, u32 len, void* param)
{
102c7a2c:	e1a04000 	mov	r4, r0
102c7a30:	e1a07001 	mov	r7, r1

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTNAME:");
102c7a34:	e12fff35 	blx	r5

    if (pHead)
102c7a38:	e2508000 	subs	r8, r0, #0
    {
        Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", (char*)param);
102c7a3c:	e1a00004 	mov	r0, r4
static s32 ATRsp_QBTNAME_Hdlr(char* line, u32 len, void* param)
{

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTNAME:");

    if (pHead)
102c7a40:	0a000006 	beq	102c7a60 <ATRsp_QBTNAME_Hdlr+0x44>
    {
        Ql_sscanf(line, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", (char*)param);
102c7a44:	e59f3074 	ldr	r3, [pc, #116]	; 102c7ac0 <ATRsp_QBTNAME_Hdlr+0xa4>
102c7a48:	e59f1074 	ldr	r1, [pc, #116]	; 102c7ac4 <ATRsp_QBTNAME_Hdlr+0xa8>
102c7a4c:	e5933000 	ldr	r3, [r3]
102c7a50:	e1a02006 	mov	r2, r6
102c7a54:	e12fff33 	blx	r3

        return  RIL_ATRSP_CONTINUE;
102c7a58:	e3a00001 	mov	r0, #1
102c7a5c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c7a60:	e1a01007 	mov	r1, r7
102c7a64:	e59f205c 	ldr	r2, [pc, #92]	; 102c7ac8 <ATRsp_QBTNAME_Hdlr+0xac>
102c7a68:	e59f605c 	ldr	r6, [pc, #92]	; 102c7acc <ATRsp_QBTNAME_Hdlr+0xb0>
102c7a6c:	e12fff36 	blx	r6
    if (pHead)
102c7a70:	e3500000 	cmp	r0, #0
102c7a74:	0a000001 	beq	102c7a80 <ATRsp_QBTNAME_Hdlr+0x64>
    {  
       return  RIL_ATRSP_SUCCESS;
102c7a78:	e1a00008 	mov	r0, r8
102c7a7c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c7a80:	e1a00004 	mov	r0, r4
102c7a84:	e1a01007 	mov	r1, r7
102c7a88:	e59f2040 	ldr	r2, [pc, #64]	; 102c7ad0 <ATRsp_QBTNAME_Hdlr+0xb4>
102c7a8c:	e12fff36 	blx	r6
    if (pHead)
102c7a90:	e3500000 	cmp	r0, #0
102c7a94:	0a000001 	beq	102c7aa0 <ATRsp_QBTNAME_Hdlr+0x84>
102c7a98:	e3e00000 	mvn	r0, #0
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_FAILED; //not supported
}
102c7a9c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
    } 
    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102c7aa0:	e1a00004 	mov	r0, r4
102c7aa4:	e1a01007 	mov	r1, r7
102c7aa8:	e59f2024 	ldr	r2, [pc, #36]	; 102c7ad4 <ATRsp_QBTNAME_Hdlr+0xb8>
102c7aac:	e12fff35 	blx	r5
102c7ab0:	e3e00000 	mvn	r0, #0
102c7ab4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102c7ab8:	102cce98 	.word	0x102cce98
102c7abc:	102edf48 	.word	0x102edf48
102c7ac0:	f03de548 	.word	0xf03de548
102c7ac4:	102ede68 	.word	0x102ede68
102c7ac8:	102ee5e8 	.word	0x102ee5e8
102c7acc:	102ccf24 	.word	0x102ccf24
102c7ad0:	102ede00 	.word	0x102ede00
102c7ad4:	102ede08 	.word	0x102ede08

102c7ad8 <ATRsp_QBTPWR_Hdlr>:
    return RIL_ATRSP_CONTINUE; //continue wait
}


static s32 ATRsp_QBTPWR_Hdlr(char* line, u32 len, void* param)
{
102c7ad8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102c7adc:	e1a06002 	mov	r6, r2

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTPWR:");
102c7ae0:	e59f508c 	ldr	r5, [pc, #140]	; 102c7b74 <ATRsp_QBTPWR_Hdlr+0x9c>
102c7ae4:	e59f208c 	ldr	r2, [pc, #140]	; 102c7b78 <ATRsp_QBTPWR_Hdlr+0xa0>
    return RIL_ATRSP_CONTINUE; //continue wait
}


static s32 ATRsp_QBTPWR_Hdlr(char* line, u32 len, void* param)
{
102c7ae8:	e1a04000 	mov	r4, r0
102c7aec:	e1a07001 	mov	r7, r1

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTPWR:");
102c7af0:	e12fff35 	blx	r5
  
    if (pHead)
102c7af4:	e2508000 	subs	r8, r0, #0
    {
        Ql_sscanf(line, "%*[^:]: %d\r\n", (s32*)param);
102c7af8:	e1a00004 	mov	r0, r4
static s32 ATRsp_QBTPWR_Hdlr(char* line, u32 len, void* param)
{

    char* pHead = Ql_RIL_FindString(line, len, "\r\n+QBTPWR:");
  
    if (pHead)
102c7afc:	0a000006 	beq	102c7b1c <ATRsp_QBTPWR_Hdlr+0x44>
    {
        Ql_sscanf(line, "%*[^:]: %d\r\n", (s32*)param);
102c7b00:	e59f3074 	ldr	r3, [pc, #116]	; 102c7b7c <ATRsp_QBTPWR_Hdlr+0xa4>
102c7b04:	e59f1074 	ldr	r1, [pc, #116]	; 102c7b80 <ATRsp_QBTPWR_Hdlr+0xa8>
102c7b08:	e5933000 	ldr	r3, [r3]
102c7b0c:	e1a02006 	mov	r2, r6
102c7b10:	e12fff33 	blx	r3

        return  RIL_ATRSP_CONTINUE;
102c7b14:	e3a00001 	mov	r0, #1
102c7b18:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c7b1c:	e1a01007 	mov	r1, r7
102c7b20:	e59f205c 	ldr	r2, [pc, #92]	; 102c7b84 <ATRsp_QBTPWR_Hdlr+0xac>
102c7b24:	e59f605c 	ldr	r6, [pc, #92]	; 102c7b88 <ATRsp_QBTPWR_Hdlr+0xb0>
102c7b28:	e12fff36 	blx	r6
    if (pHead)
102c7b2c:	e3500000 	cmp	r0, #0
102c7b30:	0a000001 	beq	102c7b3c <ATRsp_QBTPWR_Hdlr+0x64>
    {  
       return  RIL_ATRSP_SUCCESS;
102c7b34:	e1a00008 	mov	r0, r8
102c7b38:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c7b3c:	e1a00004 	mov	r0, r4
102c7b40:	e1a01007 	mov	r1, r7
102c7b44:	e59f2040 	ldr	r2, [pc, #64]	; 102c7b8c <ATRsp_QBTPWR_Hdlr+0xb4>
102c7b48:	e12fff36 	blx	r6
    if (pHead)
102c7b4c:	e3500000 	cmp	r0, #0
102c7b50:	0a000001 	beq	102c7b5c <ATRsp_QBTPWR_Hdlr+0x84>
102c7b54:	e3e00000 	mvn	r0, #0
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_FAILED; //not supported
}
102c7b58:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
    } 
    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102c7b5c:	e1a00004 	mov	r0, r4
102c7b60:	e1a01007 	mov	r1, r7
102c7b64:	e59f2024 	ldr	r2, [pc, #36]	; 102c7b90 <ATRsp_QBTPWR_Hdlr+0xb8>
102c7b68:	e12fff35 	blx	r5
102c7b6c:	e3e00000 	mvn	r0, #0
102c7b70:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102c7b74:	102cce98 	.word	0x102cce98
102c7b78:	102edf54 	.word	0x102edf54
102c7b7c:	f03de548 	.word	0xf03de548
102c7b80:	102ede14 	.word	0x102ede14
102c7b84:	102ee5e8 	.word	0x102ee5e8
102c7b88:	102ccf24 	.word	0x102ccf24
102c7b8c:	102ede00 	.word	0x102ede00
102c7b90:	102ede08 	.word	0x102ede08

102c7b94 <ATRsp_QBTSPPSEND_Hdlr>:
    }

    return RIL_ATRSP_FAILED; //not supported
}
static s32 ATRsp_QBTSPPSEND_Hdlr(char* line, u32 len, void* param)
{
102c7b94:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102c7b98:	e1a04002 	mov	r4, r2
    
    char* pHead = Ql_RIL_FindString(line, len, ">\r\n");
102c7b9c:	e59f50a8 	ldr	r5, [pc, #168]	; 102c7c4c <ATRsp_QBTSPPSEND_Hdlr+0xb8>
102c7ba0:	e59f20a8 	ldr	r2, [pc, #168]	; 102c7c50 <ATRsp_QBTSPPSEND_Hdlr+0xbc>
    }

    return RIL_ATRSP_FAILED; //not supported
}
static s32 ATRsp_QBTSPPSEND_Hdlr(char* line, u32 len, void* param)
{
102c7ba4:	e1a07000 	mov	r7, r0
102c7ba8:	e1a06001 	mov	r6, r1
    
    char* pHead = Ql_RIL_FindString(line, len, ">\r\n");
102c7bac:	e12fff35 	blx	r5
    u32 ret = 0;
    
    if (pHead)
102c7bb0:	e2508000 	subs	r8, r0, #0
102c7bb4:	0a000009 	beq	102c7be0 <ATRsp_QBTSPPSEND_Hdlr+0x4c>
    {
        
        ret = Ql_RIL_WriteDataToCore(m_ptrSppData, m_nSppDataLenToSnd);
102c7bb8:	e59f3094 	ldr	r3, [pc, #148]	; 102c7c54 <ATRsp_QBTSPPSEND_Hdlr+0xc0>
102c7bbc:	e5930088 	ldr	r0, [r3, #136]	; 0x88
102c7bc0:	e593108c 	ldr	r1, [r3, #140]	; 0x8c
102c7bc4:	e59f308c 	ldr	r3, [pc, #140]	; 102c7c58 <ATRsp_QBTSPPSEND_Hdlr+0xc4>
102c7bc8:	e12fff33 	blx	r3

        if(NULL != param && ret >= 0 )
102c7bcc:	e3540000 	cmp	r4, #0
102c7bd0:	0a00000b 	beq	102c7c04 <ATRsp_QBTSPPSEND_Hdlr+0x70>
        {
            *(u32 *)param = ret ;
102c7bd4:	e5840000 	str	r0, [r4]
        }
        return  RIL_ATRSP_CONTINUE;
102c7bd8:	e3a00001 	mov	r0, #1
102c7bdc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102c7be0:	e1a00007 	mov	r0, r7
102c7be4:	e1a01006 	mov	r1, r6
102c7be8:	e59f206c 	ldr	r2, [pc, #108]	; 102c7c5c <ATRsp_QBTSPPSEND_Hdlr+0xc8>
102c7bec:	e59f406c 	ldr	r4, [pc, #108]	; 102c7c60 <ATRsp_QBTSPPSEND_Hdlr+0xcc>
102c7bf0:	e12fff34 	blx	r4
    if (pHead)
102c7bf4:	e3500000 	cmp	r0, #0
102c7bf8:	0a000003 	beq	102c7c0c <ATRsp_QBTSPPSEND_Hdlr+0x78>
    {  
        return  RIL_ATRSP_SUCCESS;
102c7bfc:	e1a00008 	mov	r0, r8
102c7c00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

        if(NULL != param && ret >= 0 )
        {
            *(u32 *)param = ret ;
        }
        return  RIL_ATRSP_CONTINUE;
102c7c04:	e3a00001 	mov	r0, #1
102c7c08:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    if (pHead)
    {  
        return  RIL_ATRSP_SUCCESS;
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102c7c0c:	e1a00007 	mov	r0, r7
102c7c10:	e1a01006 	mov	r1, r6
102c7c14:	e59f2048 	ldr	r2, [pc, #72]	; 102c7c64 <ATRsp_QBTSPPSEND_Hdlr+0xd0>
102c7c18:	e12fff34 	blx	r4
    if (pHead)
102c7c1c:	e3500000 	cmp	r0, #0
102c7c20:	1a000007 	bne	102c7c44 <ATRsp_QBTSPPSEND_Hdlr+0xb0>
    {  
        return  RIL_ATRSP_FAILED;
    } 

    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102c7c24:	e1a00007 	mov	r0, r7
102c7c28:	e1a01006 	mov	r1, r6
102c7c2c:	e59f2034 	ldr	r2, [pc, #52]	; 102c7c68 <ATRsp_QBTSPPSEND_Hdlr+0xd4>
102c7c30:	e12fff35 	blx	r5
    if (pHead)
102c7c34:	e3500000 	cmp	r0, #0
    {
        return  RIL_ATRSP_FAILED;
102c7c38:	03a00001 	moveq	r0, #1
102c7c3c:	13e00000 	mvnne	r0, #0
102c7c40:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
102c7c44:	e3e00000 	mvn	r0, #0
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
102c7c48:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102c7c4c:	102cce98 	.word	0x102cce98
102c7c50:	102f006c 	.word	0x102f006c
102c7c54:	f03d5058 	.word	0xf03d5058
102c7c58:	102e53c8 	.word	0x102e53c8
102c7c5c:	102ee5e8 	.word	0x102ee5e8
102c7c60:	102ccf24 	.word	0x102ccf24
102c7c64:	102ede00 	.word	0x102ede00
102c7c68:	102ede08 	.word	0x102ede08

102c7c6c <BT_DevMngmt_GetDeviceId>:
    return 0;
}


s32 BT_DevMngmt_GetDeviceId(const u32 hdl)
{
102c7c6c:	e59f302c 	ldr	r3, [pc, #44]	; 102c7ca0 <BT_DevMngmt_GetDeviceId+0x34>
    }
    return 0;
}


s32 BT_DevMngmt_GetDeviceId(const u32 hdl)
102c7c70:	e283c078 	add	ip, r3, #120	; 0x78
102c7c74:	ea000001 	b	102c7c80 <BT_DevMngmt_GetDeviceId+0x14>
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c7c78:	e153000c 	cmp	r3, ip
102c7c7c:	0a000005 	beq	102c7c98 <BT_DevMngmt_GetDeviceId+0x2c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c7c80:	e5b32004 	ldr	r2, [r3, #4]!
102c7c84:	e5921000 	ldr	r1, [r2]
102c7c88:	e1510000 	cmp	r1, r0
102c7c8c:	1afffff9 	bne	102c7c78 <BT_DevMngmt_GetDeviceId+0xc>
        {
            return m_arrBTDev[i]->devId;
102c7c90:	e592004c 	ldr	r0, [r2, #76]	; 0x4c
102c7c94:	e12fff1e 	bx	lr
        }
    }
    return 0;
102c7c98:	e3a00000 	mov	r0, #0
}
102c7c9c:	e12fff1e 	bx	lr
102c7ca0:	f03d5054 	.word	0xf03d5054

102c7ca4 <BT_DevMngmt_GetPairedId>:


s32 BT_DevMngmt_GetPairedId(const u32 hdl)
{
102c7ca4:	e59f302c 	ldr	r3, [pc, #44]	; 102c7cd8 <BT_DevMngmt_GetPairedId+0x34>
    }
    return 0;
}


s32 BT_DevMngmt_GetPairedId(const u32 hdl)
102c7ca8:	e283c078 	add	ip, r3, #120	; 0x78
102c7cac:	ea000001 	b	102c7cb8 <BT_DevMngmt_GetPairedId+0x14>
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c7cb0:	e153000c 	cmp	r3, ip
102c7cb4:	0a000005 	beq	102c7cd0 <BT_DevMngmt_GetPairedId+0x2c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c7cb8:	e5b32004 	ldr	r2, [r3, #4]!
102c7cbc:	e5921000 	ldr	r1, [r2]
102c7cc0:	e1510000 	cmp	r1, r0
102c7cc4:	1afffff9 	bne	102c7cb0 <BT_DevMngmt_GetPairedId+0xc>
        {
            return m_arrBTDev[i]->pairId;
102c7cc8:	e5920050 	ldr	r0, [r2, #80]	; 0x50
102c7ccc:	e12fff1e 	bx	lr
        }
    }
    return 0;
102c7cd0:	e3a00000 	mov	r0, #0
}
102c7cd4:	e12fff1e 	bx	lr
102c7cd8:	f03d5054 	.word	0xf03d5054

102c7cdc <BT_DevMngmt_GetConnId>:
s32 BT_DevMngmt_GetConnId(const u32 hdl)
{
102c7cdc:	e59f302c 	ldr	r3, [pc, #44]	; 102c7d10 <BT_DevMngmt_GetConnId+0x34>
            return m_arrBTDev[i]->pairId;
        }
    }
    return 0;
}
s32 BT_DevMngmt_GetConnId(const u32 hdl)
102c7ce0:	e283c078 	add	ip, r3, #120	; 0x78
102c7ce4:	ea000001 	b	102c7cf0 <BT_DevMngmt_GetConnId+0x14>
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c7ce8:	e153000c 	cmp	r3, ip
102c7cec:	0a000005 	beq	102c7d08 <BT_DevMngmt_GetConnId+0x2c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c7cf0:	e5b32004 	ldr	r2, [r3, #4]!
102c7cf4:	e5921000 	ldr	r1, [r2]
102c7cf8:	e1510000 	cmp	r1, r0
102c7cfc:	1afffff9 	bne	102c7ce8 <BT_DevMngmt_GetConnId+0xc>
        {
            return m_arrBTDev[i]->connId;
102c7d00:	e5920054 	ldr	r0, [r2, #84]	; 0x54
102c7d04:	e12fff1e 	bx	lr
        }
    }
    return 0;
102c7d08:	e3a00000 	mov	r0, #0
}
102c7d0c:	e12fff1e 	bx	lr
102c7d10:	f03d5054 	.word	0xf03d5054

102c7d14 <BT_DevMngmt_GetProfileId>:

s32 BT_DevMngmt_GetProfileId(const u32 hdl)
{
102c7d14:	e59f302c 	ldr	r3, [pc, #44]	; 102c7d48 <BT_DevMngmt_GetProfileId+0x34>
        }
    }
    return 0;
}

s32 BT_DevMngmt_GetProfileId(const u32 hdl)
102c7d18:	e283c078 	add	ip, r3, #120	; 0x78
102c7d1c:	ea000001 	b	102c7d28 <BT_DevMngmt_GetProfileId+0x14>
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c7d20:	e153000c 	cmp	r3, ip
102c7d24:	0a000005 	beq	102c7d40 <BT_DevMngmt_GetProfileId+0x2c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c7d28:	e5b32004 	ldr	r2, [r3, #4]!
102c7d2c:	e5921000 	ldr	r1, [r2]
102c7d30:	e1510000 	cmp	r1, r0
102c7d34:	1afffff9 	bne	102c7d20 <BT_DevMngmt_GetProfileId+0xc>
        {
            return m_arrBTDev[i]->profileId;
102c7d38:	e5920058 	ldr	r0, [r2, #88]	; 0x58
102c7d3c:	e12fff1e 	bx	lr
        }
    }
    return 0;
102c7d40:	e3a00000 	mov	r0, #0
}
102c7d44:	e12fff1e 	bx	lr
102c7d48:	f03d5054 	.word	0xf03d5054

102c7d4c <BT_DevMngmt_GetDevName>:

char *BT_DevMngmt_GetDevName(const u32 hdl)
{
102c7d4c:	e59f302c 	ldr	r3, [pc, #44]	; 102c7d80 <BT_DevMngmt_GetDevName+0x34>
        }
    }
    return 0;
}

char *BT_DevMngmt_GetDevName(const u32 hdl)
102c7d50:	e283c078 	add	ip, r3, #120	; 0x78
102c7d54:	ea000001 	b	102c7d60 <BT_DevMngmt_GetDevName+0x14>
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c7d58:	e153000c 	cmp	r3, ip
102c7d5c:	0a000005 	beq	102c7d78 <BT_DevMngmt_GetDevName+0x2c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c7d60:	e5b32004 	ldr	r2, [r3, #4]!
102c7d64:	e5921000 	ldr	r1, [r2]
102c7d68:	e1510000 	cmp	r1, r0
102c7d6c:	1afffff9 	bne	102c7d58 <BT_DevMngmt_GetDevName+0xc>
        {
            return m_arrBTDev[i]->btDevice.name;
102c7d70:	e2820004 	add	r0, r2, #4
102c7d74:	e12fff1e 	bx	lr
        }
    }
    return NULL;
102c7d78:	e3a00000 	mov	r0, #0
}
102c7d7c:	e12fff1e 	bx	lr
102c7d80:	f03d5054 	.word	0xf03d5054

102c7d84 <BT_DevMngmt_GetDevAddr>:


char * BT_DevMngmt_GetDevAddr(const u32 hdl)
{
102c7d84:	e59f302c 	ldr	r3, [pc, #44]	; 102c7db8 <BT_DevMngmt_GetDevAddr+0x34>
    }
    return NULL;
}


char * BT_DevMngmt_GetDevAddr(const u32 hdl)
102c7d88:	e283c078 	add	ip, r3, #120	; 0x78
102c7d8c:	ea000001 	b	102c7d98 <BT_DevMngmt_GetDevAddr+0x14>
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c7d90:	e153000c 	cmp	r3, ip
102c7d94:	0a000005 	beq	102c7db0 <BT_DevMngmt_GetDevAddr+0x2c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c7d98:	e5b32004 	ldr	r2, [r3, #4]!
102c7d9c:	e5921000 	ldr	r1, [r2]
102c7da0:	e1510000 	cmp	r1, r0
102c7da4:	1afffff9 	bne	102c7d90 <BT_DevMngmt_GetDevAddr+0xc>
        {
            return m_arrBTDev[i]->btDevice.addr;
102c7da8:	e282003c 	add	r0, r2, #60	; 0x3c
102c7dac:	e12fff1e 	bx	lr
        }
    }
    return NULL;
102c7db0:	e3a00000 	mov	r0, #0
}
102c7db4:	e12fff1e 	bx	lr
102c7db8:	f03d5054 	.word	0xf03d5054

102c7dbc <RIL_BT_Switch>:
*****************************************************************/
s32 RIL_BT_Switch(u8 on_off)
{
    char strAT[20];

    if (on_off < BT_OFF || on_off > BT_ON)
102c7dbc:	e3500001 	cmp	r0, #1
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_Switch(u8 on_off)
{
102c7dc0:	e92d4010 	push	{r4, lr}
102c7dc4:	e1a04000 	mov	r4, r0
102c7dc8:	e24dd020 	sub	sp, sp, #32
    char strAT[20];

    if (on_off < BT_OFF || on_off > BT_ON)
    {
        return RIL_AT_INVALID_PARAM;
102c7dcc:	83e00003 	mvnhi	r0, #3
*****************************************************************/
s32 RIL_BT_Switch(u8 on_off)
{
    char strAT[20];

    if (on_off < BT_OFF || on_off > BT_ON)
102c7dd0:	8a000014 	bhi	102c7e28 <RIL_BT_Switch+0x6c>
    {
        return RIL_AT_INVALID_PARAM;
    }
    
    Ql_memset(strAT, 0x0, sizeof(strAT));
102c7dd4:	e3a01000 	mov	r1, #0
102c7dd8:	e3a02014 	mov	r2, #20
102c7ddc:	e59f304c 	ldr	r3, [pc, #76]	; 102c7e30 <RIL_BT_Switch+0x74>
102c7de0:	e28d000c 	add	r0, sp, #12
102c7de4:	e12fff33 	blx	r3
    Ql_sprintf(strAT, "AT+QBTPWR=%d", on_off);
102c7de8:	e59f3044 	ldr	r3, [pc, #68]	; 102c7e34 <RIL_BT_Switch+0x78>
102c7dec:	e59f1044 	ldr	r1, [pc, #68]	; 102c7e38 <RIL_BT_Switch+0x7c>
102c7df0:	e1a02004 	mov	r2, r4
102c7df4:	e5933000 	ldr	r3, [r3]
102c7df8:	e28d000c 	add	r0, sp, #12
102c7dfc:	e12fff33 	blx	r3
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c7e00:	e59f3034 	ldr	r3, [pc, #52]	; 102c7e3c <RIL_BT_Switch+0x80>
102c7e04:	e28d000c 	add	r0, sp, #12
102c7e08:	e12fff33 	blx	r3
102c7e0c:	e3a03000 	mov	r3, #0
102c7e10:	e1a02003 	mov	r2, r3
102c7e14:	e58d3000 	str	r3, [sp]
102c7e18:	e59fc020 	ldr	ip, [pc, #32]	; 102c7e40 <RIL_BT_Switch+0x84>
102c7e1c:	e1a01000 	mov	r1, r0
102c7e20:	e28d000c 	add	r0, sp, #12
102c7e24:	e12fff3c 	blx	ip
}
102c7e28:	e28dd020 	add	sp, sp, #32
102c7e2c:	e8bd8010 	pop	{r4, pc}
102c7e30:	102e58f4 	.word	0x102e58f4
102c7e34:	f03de540 	.word	0xf03de540
102c7e38:	102edf60 	.word	0x102edf60
102c7e3c:	102e57a4 	.word	0x102e57a4
102c7e40:	102e5168 	.word	0x102e5168

102c7e44 <RIL_BT_GetPwrState>:
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetPwrState(s32 *p_on_off)
{
    char strAT[] = "AT+QBTPWR?\0";
102c7e44:	e59f2058 	ldr	r2, [pc, #88]	; 102c7ea4 <RIL_BT_GetPwrState+0x60>
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetPwrState(s32 *p_on_off)
{
102c7e48:	e92d4030 	push	{r4, r5, lr}
102c7e4c:	e1a05000 	mov	r5, r0
    char strAT[] = "AT+QBTPWR?\0";
102c7e50:	e8920007 	ldm	r2, {r0, r1, r2}
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetPwrState(s32 *p_on_off)
{
102c7e54:	e24dd01c 	sub	sp, sp, #28
    char strAT[] = "AT+QBTPWR?\0";
102c7e58:	e28d400c 	add	r4, sp, #12
    
    if (NULL == p_on_off)
102c7e5c:	e3550000 	cmp	r5, #0
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetPwrState(s32 *p_on_off)
{
    char strAT[] = "AT+QBTPWR?\0";
102c7e60:	e8840007 	stm	r4, {r0, r1, r2}
    
    if (NULL == p_on_off)
102c7e64:	0a00000c 	beq	102c7e9c <RIL_BT_GetPwrState+0x58>
    {
        return RIL_AT_INVALID_PARAM;
    }
    
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTPWR_Hdlr, (void*)p_on_off, 0);
102c7e68:	e59f3038 	ldr	r3, [pc, #56]	; 102c7ea8 <RIL_BT_GetPwrState+0x64>
102c7e6c:	e1a00004 	mov	r0, r4
102c7e70:	e12fff33 	blx	r3
102c7e74:	e3a03000 	mov	r3, #0
102c7e78:	e58d3000 	str	r3, [sp]
102c7e7c:	e59f2028 	ldr	r2, [pc, #40]	; 102c7eac <RIL_BT_GetPwrState+0x68>
102c7e80:	e1a03005 	mov	r3, r5
102c7e84:	e59fc024 	ldr	ip, [pc, #36]	; 102c7eb0 <RIL_BT_GetPwrState+0x6c>
102c7e88:	e1a01000 	mov	r1, r0
102c7e8c:	e1a00004 	mov	r0, r4
102c7e90:	e12fff3c 	blx	ip
}
102c7e94:	e28dd01c 	add	sp, sp, #28
102c7e98:	e8bd8030 	pop	{r4, r5, pc}
{
    char strAT[] = "AT+QBTPWR?\0";
    
    if (NULL == p_on_off)
    {
        return RIL_AT_INVALID_PARAM;
102c7e9c:	e3e00003 	mvn	r0, #3
102c7ea0:	eafffffb 	b	102c7e94 <RIL_BT_GetPwrState+0x50>
102c7ea4:	102e64a8 	.word	0x102e64a8
102c7ea8:	102e57a4 	.word	0x102e57a4
102c7eac:	102c7ad8 	.word	0x102c7ad8
102c7eb0:	102e5168 	.word	0x102e5168

102c7eb4 <RIL_BT_SetName>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SetName(char *name,u8 len)
{
102c7eb4:	e92d4030 	push	{r4, r5, lr}
    char strAT[80];
    
    if(NULL == name || (len > BT_NAME_LEN - 2)) 
102c7eb8:	e2704001 	rsbs	r4, r0, #1
102c7ebc:	33a04000 	movcc	r4, #0
102c7ec0:	e3510036 	cmp	r1, #54	; 0x36
102c7ec4:	83844001 	orrhi	r4, r4, #1
102c7ec8:	e3540000 	cmp	r4, #0
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SetName(char *name,u8 len)
{
102c7ecc:	e24dd05c 	sub	sp, sp, #92	; 0x5c
    char strAT[80];
    
    if(NULL == name || (len > BT_NAME_LEN - 2)) 
102c7ed0:	e1a05000 	mov	r5, r0
102c7ed4:	1a000016 	bne	102c7f34 <RIL_BT_SetName+0x80>
    {
        return RIL_AT_INVALID_PARAM ;
    }

    Ql_memset(strAT, 0x0, sizeof(strAT));
102c7ed8:	e1a01004 	mov	r1, r4
102c7edc:	e3a02050 	mov	r2, #80	; 0x50
102c7ee0:	e59f3054 	ldr	r3, [pc, #84]	; 102c7f3c <RIL_BT_SetName+0x88>
102c7ee4:	e28d0008 	add	r0, sp, #8
102c7ee8:	e12fff33 	blx	r3
    Ql_sprintf(strAT, "AT+QBTNAME=\"%s\"", name);
102c7eec:	e59f304c 	ldr	r3, [pc, #76]	; 102c7f40 <RIL_BT_SetName+0x8c>
102c7ef0:	e59f104c 	ldr	r1, [pc, #76]	; 102c7f44 <RIL_BT_SetName+0x90>
102c7ef4:	e1a02005 	mov	r2, r5
102c7ef8:	e5933000 	ldr	r3, [r3]
102c7efc:	e28d0008 	add	r0, sp, #8
102c7f00:	e12fff33 	blx	r3
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c7f04:	e59f303c 	ldr	r3, [pc, #60]	; 102c7f48 <RIL_BT_SetName+0x94>
102c7f08:	e28d0008 	add	r0, sp, #8
102c7f0c:	e12fff33 	blx	r3
102c7f10:	e1a02004 	mov	r2, r4
102c7f14:	e58d4000 	str	r4, [sp]
102c7f18:	e1a03004 	mov	r3, r4
102c7f1c:	e59fc028 	ldr	ip, [pc, #40]	; 102c7f4c <RIL_BT_SetName+0x98>
102c7f20:	e1a01000 	mov	r1, r0
102c7f24:	e28d0008 	add	r0, sp, #8
102c7f28:	e12fff3c 	blx	ip
}
102c7f2c:	e28dd05c 	add	sp, sp, #92	; 0x5c
102c7f30:	e8bd8030 	pop	{r4, r5, pc}
{
    char strAT[80];
    
    if(NULL == name || (len > BT_NAME_LEN - 2)) 
    {
        return RIL_AT_INVALID_PARAM ;
102c7f34:	e3e00003 	mvn	r0, #3
102c7f38:	eafffffb 	b	102c7f2c <RIL_BT_SetName+0x78>
102c7f3c:	102e58f4 	.word	0x102e58f4
102c7f40:	f03de540 	.word	0xf03de540
102c7f44:	102edf70 	.word	0x102edf70
102c7f48:	102e57a4 	.word	0x102e57a4
102c7f4c:	102e5168 	.word	0x102e5168

102c7f50 <RIL_BT_GetName>:
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetName(char *name/*char addr[BT_NAME_LEN]*/,u8 len)

{
    char strAT[20]="AT+QBTNAME?\0";
102c7f50:	e59f311c 	ldr	r3, [pc, #284]	; 102c8074 <RIL_BT_GetName+0x124>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetName(char *name/*char addr[BT_NAME_LEN]*/,u8 len)

{
102c7f54:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102c7f58:	e1a05000 	mov	r5, r0
102c7f5c:	e1a06001 	mov	r6, r1
    char strAT[20]="AT+QBTNAME?\0";
102c7f60:	e893000f 	ldm	r3, {r0, r1, r2, r3}
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetName(char *name/*char addr[BT_NAME_LEN]*/,u8 len)

{
102c7f64:	e24dd05c 	sub	sp, sp, #92	; 0x5c
    char strAT[20]="AT+QBTNAME?\0";
102c7f68:	e3a04000 	mov	r4, #0
102c7f6c:	e28dc00c 	add	ip, sp, #12
    s32 ret = RIL_AT_SUCCESS;
    char in_name[BT_NAME_LEN] = {0};
    
    
    if(NULL == name )
102c7f70:	e1550004 	cmp	r5, r4
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetName(char *name/*char addr[BT_NAME_LEN]*/,u8 len)

{
    char strAT[20]="AT+QBTNAME?\0";
102c7f74:	e8ac0007 	stmia	ip!, {r0, r1, r2}
102c7f78:	e5cd4019 	strb	r4, [sp, #25]
102c7f7c:	e5cc3000 	strb	r3, [ip]
102c7f80:	e5cd401a 	strb	r4, [sp, #26]
102c7f84:	e5cd401b 	strb	r4, [sp, #27]
102c7f88:	e5cd401c 	strb	r4, [sp, #28]
102c7f8c:	e5cd401d 	strb	r4, [sp, #29]
102c7f90:	e5cd401e 	strb	r4, [sp, #30]
102c7f94:	e5cd401f 	strb	r4, [sp, #31]
    s32 ret = RIL_AT_SUCCESS;
    char in_name[BT_NAME_LEN] = {0};
102c7f98:	e58d4020 	str	r4, [sp, #32]
102c7f9c:	e58d4024 	str	r4, [sp, #36]	; 0x24
102c7fa0:	e58d4028 	str	r4, [sp, #40]	; 0x28
102c7fa4:	e58d402c 	str	r4, [sp, #44]	; 0x2c
102c7fa8:	e58d4030 	str	r4, [sp, #48]	; 0x30
102c7fac:	e58d4034 	str	r4, [sp, #52]	; 0x34
102c7fb0:	e58d4038 	str	r4, [sp, #56]	; 0x38
102c7fb4:	e58d403c 	str	r4, [sp, #60]	; 0x3c
102c7fb8:	e58d4040 	str	r4, [sp, #64]	; 0x40
102c7fbc:	e58d4044 	str	r4, [sp, #68]	; 0x44
102c7fc0:	e58d4048 	str	r4, [sp, #72]	; 0x48
102c7fc4:	e58d404c 	str	r4, [sp, #76]	; 0x4c
102c7fc8:	e58d4050 	str	r4, [sp, #80]	; 0x50
102c7fcc:	e58d4054 	str	r4, [sp, #84]	; 0x54
    
    
    if(NULL == name )
102c7fd0:	0a000025 	beq	102c806c <RIL_BT_GetName+0x11c>
    {
        return RIL_AT_INVALID_PARAM ;
    }

	Ql_memset(name,0,len);
102c7fd4:	e1a01004 	mov	r1, r4
102c7fd8:	e1a02006 	mov	r2, r6
102c7fdc:	e59f3094 	ldr	r3, [pc, #148]	; 102c8078 <RIL_BT_GetName+0x128>
102c7fe0:	e1a00005 	mov	r0, r5
102c7fe4:	e12fff33 	blx	r3

    ret = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTNAME_Hdlr,(void *)in_name, 0);
102c7fe8:	e59f708c 	ldr	r7, [pc, #140]	; 102c807c <RIL_BT_GetName+0x12c>
102c7fec:	e28d000c 	add	r0, sp, #12
102c7ff0:	e12fff37 	blx	r7
102c7ff4:	e58d4000 	str	r4, [sp]
102c7ff8:	e59f2080 	ldr	r2, [pc, #128]	; 102c8080 <RIL_BT_GetName+0x130>
102c7ffc:	e28d3020 	add	r3, sp, #32
102c8000:	e59fc07c 	ldr	ip, [pc, #124]	; 102c8084 <RIL_BT_GetName+0x134>
102c8004:	e1a01000 	mov	r1, r0
102c8008:	e28d000c 	add	r0, sp, #12
102c800c:	e12fff3c 	blx	ip

    if(ret == RIL_AT_SUCCESS)
102c8010:	e2504000 	subs	r4, r0, #0
102c8014:	0a000002 	beq	102c8024 <RIL_BT_GetName+0xd4>
            Ql_strncpy(name,in_name,Ql_strlen(in_name));
        }
    }

    return ret;
}
102c8018:	e1a00004 	mov	r0, r4
102c801c:	e28dd05c 	add	sp, sp, #92	; 0x5c
102c8020:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

    ret = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTNAME_Hdlr,(void *)in_name, 0);

    if(ret == RIL_AT_SUCCESS)
    {
        if(len < Ql_strlen(in_name))
102c8024:	e28d0020 	add	r0, sp, #32
102c8028:	e12fff37 	blx	r7
102c802c:	e1560000 	cmp	r6, r0
102c8030:	2a000005 	bcs	102c804c <RIL_BT_GetName+0xfc>
        {
            Ql_strncpy(name,in_name,len-1);
102c8034:	e1a00005 	mov	r0, r5
102c8038:	e28d1020 	add	r1, sp, #32
102c803c:	e2462001 	sub	r2, r6, #1
102c8040:	e59f3040 	ldr	r3, [pc, #64]	; 102c8088 <RIL_BT_GetName+0x138>
102c8044:	e12fff33 	blx	r3
102c8048:	eafffff2 	b	102c8018 <RIL_BT_GetName+0xc8>
        }
        else
        {
            Ql_strncpy(name,in_name,Ql_strlen(in_name));
102c804c:	e28d0020 	add	r0, sp, #32
102c8050:	e12fff37 	blx	r7
102c8054:	e28d1020 	add	r1, sp, #32
102c8058:	e59f3028 	ldr	r3, [pc, #40]	; 102c8088 <RIL_BT_GetName+0x138>
102c805c:	e1a02000 	mov	r2, r0
102c8060:	e1a00005 	mov	r0, r5
102c8064:	e12fff33 	blx	r3
102c8068:	eaffffea 	b	102c8018 <RIL_BT_GetName+0xc8>
    char in_name[BT_NAME_LEN] = {0};
    
    
    if(NULL == name )
    {
        return RIL_AT_INVALID_PARAM ;
102c806c:	e3e04003 	mvn	r4, #3
102c8070:	eaffffe8 	b	102c8018 <RIL_BT_GetName+0xc8>
102c8074:	102e64b4 	.word	0x102e64b4
102c8078:	102e58f4 	.word	0x102e58f4
102c807c:	102e57a4 	.word	0x102e57a4
102c8080:	102c7a1c 	.word	0x102c7a1c
102c8084:	102e5168 	.word	0x102e5168
102c8088:	102e569c 	.word	0x102e569c

102c808c <RIL_BT_GetLocalAddr>:
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetLocalAddr(char* ptrAddr/*char addr[BT_ADDR_LEN]*/,u8 len)
{
    char strAT[] = "AT+QBTADDR?\0";
102c808c:	e59f30d8 	ldr	r3, [pc, #216]	; 102c816c <RIL_BT_GetLocalAddr+0xe0>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetLocalAddr(char* ptrAddr/*char addr[BT_ADDR_LEN]*/,u8 len)
{
102c8090:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102c8094:	e1a05000 	mov	r5, r0
102c8098:	e1a06001 	mov	r6, r1
    char strAT[] = "AT+QBTADDR?\0";
102c809c:	e893000f 	ldm	r3, {r0, r1, r2, r3}
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetLocalAddr(char* ptrAddr/*char addr[BT_ADDR_LEN]*/,u8 len)
{
102c80a0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    char strAT[] = "AT+QBTADDR?\0";
    s32 ret = RIL_AT_SUCCESS;
    char in_addr[BT_ADDR_LEN] = {0};
102c80a4:	e3a04000 	mov	r4, #0
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetLocalAddr(char* ptrAddr/*char addr[BT_ADDR_LEN]*/,u8 len)
{
    char strAT[] = "AT+QBTADDR?\0";
102c80a8:	e28dc008 	add	ip, sp, #8
    s32 ret = RIL_AT_SUCCESS;
    char in_addr[BT_ADDR_LEN] = {0};
    
    if (NULL == ptrAddr)
102c80ac:	e1550004 	cmp	r5, r4
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetLocalAddr(char* ptrAddr/*char addr[BT_ADDR_LEN]*/,u8 len)
{
    char strAT[] = "AT+QBTADDR?\0";
102c80b0:	e8ac0007 	stmia	ip!, {r0, r1, r2}
    s32 ret = RIL_AT_SUCCESS;
    char in_addr[BT_ADDR_LEN] = {0};
102c80b4:	e58d4018 	str	r4, [sp, #24]
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetLocalAddr(char* ptrAddr/*char addr[BT_ADDR_LEN]*/,u8 len)
{
    char strAT[] = "AT+QBTADDR?\0";
102c80b8:	e5cc3000 	strb	r3, [ip]
    s32 ret = RIL_AT_SUCCESS;
    char in_addr[BT_ADDR_LEN] = {0};
102c80bc:	e58d401c 	str	r4, [sp, #28]
102c80c0:	e58d4020 	str	r4, [sp, #32]
102c80c4:	e5cd4024 	strb	r4, [sp, #36]	; 0x24
    
    if (NULL == ptrAddr)
102c80c8:	0a000025 	beq	102c8164 <RIL_BT_GetLocalAddr+0xd8>
    {
        return RIL_AT_INVALID_PARAM;
    }

	Ql_memset(ptrAddr,0,len);
102c80cc:	e1a01004 	mov	r1, r4
102c80d0:	e1a02006 	mov	r2, r6
102c80d4:	e59f3094 	ldr	r3, [pc, #148]	; 102c8170 <RIL_BT_GetLocalAddr+0xe4>
102c80d8:	e1a00005 	mov	r0, r5
102c80dc:	e12fff33 	blx	r3

    ret = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTADDR_Hdlr,(void *)in_addr, 0);
102c80e0:	e59f708c 	ldr	r7, [pc, #140]	; 102c8174 <RIL_BT_GetLocalAddr+0xe8>
102c80e4:	e28d0008 	add	r0, sp, #8
102c80e8:	e12fff37 	blx	r7
102c80ec:	e58d4000 	str	r4, [sp]
102c80f0:	e59f2080 	ldr	r2, [pc, #128]	; 102c8178 <RIL_BT_GetLocalAddr+0xec>
102c80f4:	e28d3018 	add	r3, sp, #24
102c80f8:	e59fc07c 	ldr	ip, [pc, #124]	; 102c817c <RIL_BT_GetLocalAddr+0xf0>
102c80fc:	e1a01000 	mov	r1, r0
102c8100:	e28d0008 	add	r0, sp, #8
102c8104:	e12fff3c 	blx	ip

    if(ret == RIL_AT_SUCCESS)
102c8108:	e2504000 	subs	r4, r0, #0
102c810c:	0a000002 	beq	102c811c <RIL_BT_GetLocalAddr+0x90>
            Ql_strncpy(ptrAddr,in_addr,Ql_strlen(in_addr));
        }
    }

    return ret;
}
102c8110:	e1a00004 	mov	r0, r4
102c8114:	e28dd02c 	add	sp, sp, #44	; 0x2c
102c8118:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

    ret = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTADDR_Hdlr,(void *)in_addr, 0);

    if(ret == RIL_AT_SUCCESS)
    {
        if(len < Ql_strlen(in_addr))
102c811c:	e28d0018 	add	r0, sp, #24
102c8120:	e12fff37 	blx	r7
102c8124:	e1560000 	cmp	r6, r0
102c8128:	2a000005 	bcs	102c8144 <RIL_BT_GetLocalAddr+0xb8>
        {
            Ql_strncpy(ptrAddr,in_addr,len-1);
102c812c:	e1a00005 	mov	r0, r5
102c8130:	e28d1018 	add	r1, sp, #24
102c8134:	e2462001 	sub	r2, r6, #1
102c8138:	e59f3040 	ldr	r3, [pc, #64]	; 102c8180 <RIL_BT_GetLocalAddr+0xf4>
102c813c:	e12fff33 	blx	r3
102c8140:	eafffff2 	b	102c8110 <RIL_BT_GetLocalAddr+0x84>
        }
        else
        {
            Ql_strncpy(ptrAddr,in_addr,Ql_strlen(in_addr));
102c8144:	e28d0018 	add	r0, sp, #24
102c8148:	e12fff37 	blx	r7
102c814c:	e28d1018 	add	r1, sp, #24
102c8150:	e59f3028 	ldr	r3, [pc, #40]	; 102c8180 <RIL_BT_GetLocalAddr+0xf4>
102c8154:	e1a02000 	mov	r2, r0
102c8158:	e1a00005 	mov	r0, r5
102c815c:	e12fff33 	blx	r3
102c8160:	eaffffea 	b	102c8110 <RIL_BT_GetLocalAddr+0x84>
    s32 ret = RIL_AT_SUCCESS;
    char in_addr[BT_ADDR_LEN] = {0};
    
    if (NULL == ptrAddr)
    {
        return RIL_AT_INVALID_PARAM;
102c8164:	e3e04003 	mvn	r4, #3
102c8168:	eaffffe8 	b	102c8110 <RIL_BT_GetLocalAddr+0x84>
102c816c:	102e64c8 	.word	0x102e64c8
102c8170:	102e58f4 	.word	0x102e58f4
102c8174:	102e57a4 	.word	0x102e57a4
102c8178:	102c7960 	.word	0x102c7960
102c817c:	102e5168 	.word	0x102e5168
102c8180:	102e569c 	.word	0x102e569c

102c8184 <RIL_BT_SetVisble>:

s32 RIL_BT_SetVisble(Enum_VisibleMode mode,u8 timeout)
{
    char strAT[30];
    
    if(mode < BT_INVISIBLE || mode >= BT_VISIBLE_END)
102c8184:	e3500002 	cmp	r0, #2
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_SetVisble(Enum_VisibleMode mode,u8 timeout)
{
102c8188:	e92d4030 	push	{r4, r5, lr}
102c818c:	e1a04000 	mov	r4, r0
102c8190:	e24dd02c 	sub	sp, sp, #44	; 0x2c
102c8194:	e1a05001 	mov	r5, r1
    char strAT[30];
    
    if(mode < BT_INVISIBLE || mode >= BT_VISIBLE_END)
102c8198:	8a00001e 	bhi	102c8218 <RIL_BT_SetVisble+0x94>
    {
        return RIL_AT_INVALID_PARAM;
    }

    Ql_memset(strAT, 0x0, sizeof(strAT));
102c819c:	e28d0008 	add	r0, sp, #8
102c81a0:	e3a01000 	mov	r1, #0
102c81a4:	e3a0201e 	mov	r2, #30
102c81a8:	e59fc070 	ldr	ip, [pc, #112]	; 102c8220 <RIL_BT_SetVisble+0x9c>
102c81ac:	e12fff3c 	blx	ip

    if(BT_INVISIBLE == mode || BT_VISIBLE_FOREVER == mode)
102c81b0:	e3540002 	cmp	r4, #2
    {
         Ql_sprintf(strAT, "AT+QBTVISB=%d", mode);
102c81b4:	e28d0008 	add	r0, sp, #8
102c81b8:	e59f3064 	ldr	r3, [pc, #100]	; 102c8224 <RIL_BT_SetVisble+0xa0>
        return RIL_AT_INVALID_PARAM;
    }

    Ql_memset(strAT, 0x0, sizeof(strAT));

    if(BT_INVISIBLE == mode || BT_VISIBLE_FOREVER == mode)
102c81bc:	1a000010 	bne	102c8204 <RIL_BT_SetVisble+0x80>
    {
         Ql_sprintf(strAT, "AT+QBTVISB=%d", mode);
    }
    else
    {
         Ql_sprintf(strAT, "AT+QBTVISB=%d,%d", mode,timeout);
102c81c0:	e593c000 	ldr	ip, [r3]
102c81c4:	e59f105c 	ldr	r1, [pc, #92]	; 102c8228 <RIL_BT_SetVisble+0xa4>
102c81c8:	e1a02004 	mov	r2, r4
102c81cc:	e1a03005 	mov	r3, r5
102c81d0:	e12fff3c 	blx	ip
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c81d4:	e59f3050 	ldr	r3, [pc, #80]	; 102c822c <RIL_BT_SetVisble+0xa8>
102c81d8:	e28d0008 	add	r0, sp, #8
102c81dc:	e12fff33 	blx	r3
102c81e0:	e3a03000 	mov	r3, #0
102c81e4:	e1a02003 	mov	r2, r3
102c81e8:	e58d3000 	str	r3, [sp]
102c81ec:	e59fc03c 	ldr	ip, [pc, #60]	; 102c8230 <RIL_BT_SetVisble+0xac>
102c81f0:	e1a01000 	mov	r1, r0
102c81f4:	e28d0008 	add	r0, sp, #8
102c81f8:	e12fff3c 	blx	ip
    
}
102c81fc:	e28dd02c 	add	sp, sp, #44	; 0x2c
102c8200:	e8bd8030 	pop	{r4, r5, pc}

    Ql_memset(strAT, 0x0, sizeof(strAT));

    if(BT_INVISIBLE == mode || BT_VISIBLE_FOREVER == mode)
    {
         Ql_sprintf(strAT, "AT+QBTVISB=%d", mode);
102c8204:	e5933000 	ldr	r3, [r3]
102c8208:	e59f1024 	ldr	r1, [pc, #36]	; 102c8234 <RIL_BT_SetVisble+0xb0>
102c820c:	e1a02004 	mov	r2, r4
102c8210:	e12fff33 	blx	r3
102c8214:	eaffffee 	b	102c81d4 <RIL_BT_SetVisble+0x50>
{
    char strAT[30];
    
    if(mode < BT_INVISIBLE || mode >= BT_VISIBLE_END)
    {
        return RIL_AT_INVALID_PARAM;
102c8218:	e3e00003 	mvn	r0, #3
102c821c:	eafffff6 	b	102c81fc <RIL_BT_SetVisble+0x78>
102c8220:	102e58f4 	.word	0x102e58f4
102c8224:	f03de540 	.word	0xf03de540
102c8228:	102edf90 	.word	0x102edf90
102c822c:	102e57a4 	.word	0x102e57a4
102c8230:	102e5168 	.word	0x102e5168
102c8234:	102edf80 	.word	0x102edf80

102c8238 <OnURCHandler_BTVisible>:
    
}


void OnURCHandler_BTVisible(const char* strURC, void* reserved)
{
102c8238:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    s32 err_code = 0;
    char urcHead[30];

	if(callback_bt == NULL)
102c823c:	e59f40d0 	ldr	r4, [pc, #208]	; 102c8314 <OnURCHandler_BTVisible+0xdc>
}


void OnURCHandler_BTVisible(const char* strURC, void* reserved)
{
    s32 err_code = 0;
102c8240:	e3a05000 	mov	r5, #0
    char urcHead[30];

	if(callback_bt == NULL)
102c8244:	e5943090 	ldr	r3, [r4, #144]	; 0x90
    
}


void OnURCHandler_BTVisible(const char* strURC, void* reserved)
{
102c8248:	e24dd028 	sub	sp, sp, #40	; 0x28
    s32 err_code = 0;
    char urcHead[30];

	if(callback_bt == NULL)
102c824c:	e1530005 	cmp	r3, r5
    
}


void OnURCHandler_BTVisible(const char* strURC, void* reserved)
{
102c8250:	e1a06000 	mov	r6, r0
    s32 err_code = 0;
102c8254:	e58d5004 	str	r5, [sp, #4]
    char urcHead[30];

	if(callback_bt == NULL)
102c8258:	0a000015 	beq	102c82b4 <OnURCHandler_BTVisible+0x7c>
	{
	   return;
	}

    if (Ql_StrPrefixMatch(strURC, urcHead))
102c825c:	e28d1008 	add	r1, sp, #8
102c8260:	e59f70b0 	ldr	r7, [pc, #176]	; 102c8318 <OnURCHandler_BTVisible+0xe0>
102c8264:	e12fff37 	blx	r7
102c8268:	e2508000 	subs	r8, r0, #0
102c826c:	0a000012 	beq	102c82bc <OnURCHandler_BTVisible+0x84>
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n",&err_code);
102c8270:	e59f30a4 	ldr	r3, [pc, #164]	; 102c831c <OnURCHandler_BTVisible+0xe4>
102c8274:	e28d2004 	add	r2, sp, #4
102c8278:	e5933000 	ldr	r3, [r3]
102c827c:	e59f109c 	ldr	r1, [pc, #156]	; 102c8320 <OnURCHandler_BTVisible+0xe8>
102c8280:	e1a00006 	mov	r0, r6
102c8284:	e12fff33 	blx	r3
        if(0 == err_code)
102c8288:	e59d1004 	ldr	r1, [sp, #4]
102c828c:	e1510005 	cmp	r1, r5
        {
           callback_bt(MSG_BT_VISIBLE_IND, URC_BT_INVISIBLE, NULL, NULL);
102c8290:	01a02001 	moveq	r2, r1
        }
		else
		{
		   callback_bt(MSG_BT_VISIBLE_IND, err_code, NULL, NULL);
102c8294:	11a02005 	movne	r2, r5
    if (Ql_StrPrefixMatch(strURC, urcHead))
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n",&err_code);
        if(0 == err_code)
        {
           callback_bt(MSG_BT_VISIBLE_IND, URC_BT_INVISIBLE, NULL, NULL);
102c8298:	0594c090 	ldreq	ip, [r4, #144]	; 0x90
102c829c:	03a00009 	moveq	r0, #9
102c82a0:	03a01001 	moveq	r1, #1
        }
		else
		{
		   callback_bt(MSG_BT_VISIBLE_IND, err_code, NULL, NULL);
102c82a4:	1594c090 	ldrne	ip, [r4, #144]	; 0x90
102c82a8:	13a00009 	movne	r0, #9
102c82ac:	e1a03002 	mov	r3, r2
102c82b0:	e12fff3c 	blx	ip
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", &err_code);
        callback_bt(MSG_BT_VISIBLE_IND, err_code, NULL, NULL);
        return;
    }
}
102c82b4:	e28dd028 	add	sp, sp, #40	; 0x28
102c82b8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		{
		   callback_bt(MSG_BT_VISIBLE_IND, err_code, NULL, NULL);
		}
        return;
    }
    Ql_strcpy(urcHead, "+CME ERROR:\0");
102c82bc:	e59f1060 	ldr	r1, [pc, #96]	; 102c8324 <OnURCHandler_BTVisible+0xec>
102c82c0:	e59f3060 	ldr	r3, [pc, #96]	; 102c8328 <OnURCHandler_BTVisible+0xf0>
102c82c4:	e28d0008 	add	r0, sp, #8
102c82c8:	e12fff33 	blx	r3
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c82cc:	e1a00006 	mov	r0, r6
102c82d0:	e28d1008 	add	r1, sp, #8
102c82d4:	e12fff37 	blx	r7
102c82d8:	e3500000 	cmp	r0, #0
102c82dc:	0afffff4 	beq	102c82b4 <OnURCHandler_BTVisible+0x7c>
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", &err_code);
102c82e0:	e59f3034 	ldr	r3, [pc, #52]	; 102c831c <OnURCHandler_BTVisible+0xe4>
102c82e4:	e28d2004 	add	r2, sp, #4
102c82e8:	e59f1030 	ldr	r1, [pc, #48]	; 102c8320 <OnURCHandler_BTVisible+0xe8>
102c82ec:	e5933000 	ldr	r3, [r3]
102c82f0:	e1a00006 	mov	r0, r6
102c82f4:	e12fff33 	blx	r3
        callback_bt(MSG_BT_VISIBLE_IND, err_code, NULL, NULL);
102c82f8:	e1a02008 	mov	r2, r8
102c82fc:	e594c090 	ldr	ip, [r4, #144]	; 0x90
102c8300:	e3a00009 	mov	r0, #9
102c8304:	e59d1004 	ldr	r1, [sp, #4]
102c8308:	e1a03008 	mov	r3, r8
102c830c:	e12fff3c 	blx	ip
102c8310:	eaffffe7 	b	102c82b4 <OnURCHandler_BTVisible+0x7c>
102c8314:	f03d5058 	.word	0xf03d5058
102c8318:	102ccd58 	.word	0x102ccd58
102c831c:	f03de548 	.word	0xf03de548
102c8320:	102ede14 	.word	0x102ede14
102c8324:	102e64d8 	.word	0x102e64d8
102c8328:	102e55fc 	.word	0x102e55fc

102c832c <RIL_BT_GetVisble>:
*****************************************************************/
s32 RIL_BT_GetVisble(s32 *mode)

{
        
    char strAT[] = "AT+QBTVISB?\0";
102c832c:	e59f205c 	ldr	r2, [pc, #92]	; 102c8390 <RIL_BT_GetVisble+0x64>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetVisble(s32 *mode)

{
102c8330:	e92d4010 	push	{r4, lr}
102c8334:	e1a04000 	mov	r4, r0
        
    char strAT[] = "AT+QBTVISB?\0";
102c8338:	e892000f 	ldm	r2, {r0, r1, r2, r3}
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetVisble(s32 *mode)

{
102c833c:	e24dd018 	sub	sp, sp, #24
        
    char strAT[] = "AT+QBTVISB?\0";
102c8340:	e28dc008 	add	ip, sp, #8
    
    if(NULL == mode)
102c8344:	e3540000 	cmp	r4, #0
*****************************************************************/
s32 RIL_BT_GetVisble(s32 *mode)

{
        
    char strAT[] = "AT+QBTVISB?\0";
102c8348:	e8ac0007 	stmia	ip!, {r0, r1, r2}
102c834c:	e5cc3000 	strb	r3, [ip]
    
    if(NULL == mode)
102c8350:	0a00000c 	beq	102c8388 <RIL_BT_GetVisble+0x5c>
    {
        return RIL_AT_INVALID_PARAM;
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTVISB_Hdlr, (void*)mode, 0);
102c8354:	e59f3038 	ldr	r3, [pc, #56]	; 102c8394 <RIL_BT_GetVisble+0x68>
102c8358:	e28d0008 	add	r0, sp, #8
102c835c:	e12fff33 	blx	r3
102c8360:	e3a03000 	mov	r3, #0
102c8364:	e58d3000 	str	r3, [sp]
102c8368:	e59f2028 	ldr	r2, [pc, #40]	; 102c8398 <RIL_BT_GetVisble+0x6c>
102c836c:	e1a03004 	mov	r3, r4
102c8370:	e59fc024 	ldr	ip, [pc, #36]	; 102c839c <RIL_BT_GetVisble+0x70>
102c8374:	e1a01000 	mov	r1, r0
102c8378:	e28d0008 	add	r0, sp, #8
102c837c:	e12fff3c 	blx	ip
}
102c8380:	e28dd018 	add	sp, sp, #24
102c8384:	e8bd8010 	pop	{r4, pc}
        
    char strAT[] = "AT+QBTVISB?\0";
    
    if(NULL == mode)
    {
        return RIL_AT_INVALID_PARAM;
102c8388:	e3e00003 	mvn	r0, #3
102c838c:	eafffffb 	b	102c8380 <RIL_BT_GetVisble+0x54>
102c8390:	102e64e8 	.word	0x102e64e8
102c8394:	102e57a4 	.word	0x102e57a4
102c8398:	102c78a4 	.word	0x102c78a4
102c839c:	102e5168 	.word	0x102e5168

102c83a0 <OnURCHandler_BTScan>:
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTScan(const char* strURC, void* reserved)
{
102c83a0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // +QBTSCAN:3,"M26-test",397D0D816261
    // +QBTSCAN:0
    char urcHead[] = "\r\n+QBTSCAN:\0";
102c83a4:	e59f626c 	ldr	r6, [pc, #620]	; 102c8618 <OnURCHandler_BTScan+0x278>
    s32 deviceId = 0;
    ST_BT_DevInfo* pstrNewBtDev = NULL;
    bool ret = FALSE;
    s32 err_code = 0;

	if(callback_bt == NULL)
102c83a8:	e59f526c 	ldr	r5, [pc, #620]	; 102c861c <OnURCHandler_BTScan+0x27c>
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTScan(const char* strURC, void* reserved)
{
102c83ac:	e1a09000 	mov	r9, r0
    s32 deviceId = 0;
    ST_BT_DevInfo* pstrNewBtDev = NULL;
    bool ret = FALSE;
    s32 err_code = 0;

	if(callback_bt == NULL)
102c83b0:	e5957090 	ldr	r7, [r5, #144]	; 0x90

void OnURCHandler_BTScan(const char* strURC, void* reserved)
{
    // +QBTSCAN:3,"M26-test",397D0D816261
    // +QBTSCAN:0
    char urcHead[] = "\r\n+QBTSCAN:\0";
102c83b4:	e896000f 	ldm	r6, {r0, r1, r2, r3}
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTScan(const char* strURC, void* reserved)
{
102c83b8:	e24dd01c 	sub	sp, sp, #28
    // +QBTSCAN:3,"M26-test",397D0D816261
    // +QBTSCAN:0
    char urcHead[] = "\r\n+QBTSCAN:\0";
    s32 deviceId = 0;
102c83bc:	e3a04000 	mov	r4, #0

void OnURCHandler_BTScan(const char* strURC, void* reserved)
{
    // +QBTSCAN:3,"M26-test",397D0D816261
    // +QBTSCAN:0
    char urcHead[] = "\r\n+QBTSCAN:\0";
102c83c0:	e28dc008 	add	ip, sp, #8
    s32 deviceId = 0;
    ST_BT_DevInfo* pstrNewBtDev = NULL;
    bool ret = FALSE;
    s32 err_code = 0;

	if(callback_bt == NULL)
102c83c4:	e1570004 	cmp	r7, r4

void OnURCHandler_BTScan(const char* strURC, void* reserved)
{
    // +QBTSCAN:3,"M26-test",397D0D816261
    // +QBTSCAN:0
    char urcHead[] = "\r\n+QBTSCAN:\0";
102c83c8:	e8ac0007 	stmia	ip!, {r0, r1, r2}
    s32 deviceId = 0;
102c83cc:	e58d4000 	str	r4, [sp]

void OnURCHandler_BTScan(const char* strURC, void* reserved)
{
    // +QBTSCAN:3,"M26-test",397D0D816261
    // +QBTSCAN:0
    char urcHead[] = "\r\n+QBTSCAN:\0";
102c83d0:	e5cc3000 	strb	r3, [ip]
    s32 deviceId = 0;
    ST_BT_DevInfo* pstrNewBtDev = NULL;
    bool ret = FALSE;
    s32 err_code = 0;
102c83d4:	e58d4004 	str	r4, [sp, #4]

	if(callback_bt == NULL)
102c83d8:	0a000050 	beq	102c8520 <OnURCHandler_BTScan+0x180>
    {
       return;
	}
		
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c83dc:	e1a00009 	mov	r0, r9
102c83e0:	e28d1008 	add	r1, sp, #8
102c83e4:	e59f7234 	ldr	r7, [pc, #564]	; 102c8620 <OnURCHandler_BTScan+0x280>
102c83e8:	e12fff37 	blx	r7
102c83ec:	e2508000 	subs	r8, r0, #0
102c83f0:	0a00004c 	beq	102c8528 <OnURCHandler_BTScan+0x188>
    {
        Ql_sscanf(strURC, "%*[^:]: %d%*[^\r\n]\r\n",&deviceId);
102c83f4:	e59f6228 	ldr	r6, [pc, #552]	; 102c8624 <OnURCHandler_BTScan+0x284>
102c83f8:	e1a0200d 	mov	r2, sp
102c83fc:	e1a00009 	mov	r0, r9
102c8400:	e5963000 	ldr	r3, [r6]
102c8404:	e59f121c 	ldr	r1, [pc, #540]	; 102c8628 <OnURCHandler_BTScan+0x288>
102c8408:	e12fff33 	blx	r3
        
        if (0 == deviceId)  // scan finished
102c840c:	e59d2000 	ldr	r2, [sp]
102c8410:	e1520004 	cmp	r2, r4
102c8414:	0a000059 	beq	102c8580 <OnURCHandler_BTScan+0x1e0>
        {
            callback_bt(MSG_BT_SCAN_IND,URC_BT_SCAN_FINISHED, NULL, NULL);
            
        }else{  // scan new bt device
            // Create a new bt device
            pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
102c8418:	e59f320c 	ldr	r3, [pc, #524]	; 102c862c <OnURCHandler_BTScan+0x28c>
102c841c:	e3a00060 	mov	r0, #96	; 0x60
102c8420:	e12fff33 	blx	r3
            Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
102c8424:	e59fa204 	ldr	sl, [pc, #516]	; 102c8630 <OnURCHandler_BTScan+0x290>
102c8428:	e1a01004 	mov	r1, r4
102c842c:	e3a02060 	mov	r2, #96	; 0x60
        {
            callback_bt(MSG_BT_SCAN_IND,URC_BT_SCAN_FINISHED, NULL, NULL);
            
        }else{  // scan new bt device
            // Create a new bt device
            pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
102c8430:	e1a07000 	mov	r7, r0
            pstrNewBtDev->devId = deviceId;
            pstrNewBtDev->pairId = -1;
            pstrNewBtDev->connId = -1;
            pstrNewBtDev->profileId = -1;

            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
102c8434:	e2878004 	add	r8, r7, #4
            callback_bt(MSG_BT_SCAN_IND,URC_BT_SCAN_FINISHED, NULL, NULL);
            
        }else{  // scan new bt device
            // Create a new bt device
            pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
            Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
102c8438:	e12fff3a 	blx	sl
            pstrNewBtDev->devId = deviceId;
            pstrNewBtDev->pairId = -1;
102c843c:	e3e03000 	mvn	r3, #0
            
        }else{  // scan new bt device
            // Create a new bt device
            pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
            Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
            pstrNewBtDev->devId = deviceId;
102c8440:	e59d0000 	ldr	r0, [sp]
            pstrNewBtDev->pairId = -1;
            pstrNewBtDev->connId = -1;
            pstrNewBtDev->profileId = -1;

            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
102c8444:	e287b03c 	add	fp, r7, #60	; 0x3c
            pstrNewBtDev->devId = deviceId;
            pstrNewBtDev->pairId = -1;
            pstrNewBtDev->connId = -1;
            pstrNewBtDev->profileId = -1;

            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
102c8448:	e59f11e4 	ldr	r1, [pc, #484]	; 102c8634 <OnURCHandler_BTScan+0x294>
102c844c:	e1a02008 	mov	r2, r8
            
        }else{  // scan new bt device
            // Create a new bt device
            pstrNewBtDev = (ST_BT_DevInfo*)Ql_MEM_Alloc(sizeof(ST_BT_DevInfo));
            Ql_memset(pstrNewBtDev, 0x0, sizeof(ST_BT_DevInfo));
            pstrNewBtDev->devId = deviceId;
102c8450:	e587004c 	str	r0, [r7, #76]	; 0x4c
            pstrNewBtDev->pairId = -1;
102c8454:	e5873050 	str	r3, [r7, #80]	; 0x50
            pstrNewBtDev->connId = -1;
102c8458:	e5873054 	str	r3, [r7, #84]	; 0x54
            pstrNewBtDev->profileId = -1;
102c845c:	e5873058 	str	r3, [r7, #88]	; 0x58

            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
102c8460:	e1a00009 	mov	r0, r9
102c8464:	e5963000 	ldr	r3, [r6]
102c8468:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
102c846c:	e1a0200b 	mov	r2, fp
102c8470:	e59f11c0 	ldr	r1, [pc, #448]	; 102c8638 <OnURCHandler_BTScan+0x298>
102c8474:	e5963000 	ldr	r3, [r6]
102c8478:	e1a00009 	mov	r0, r9
102c847c:	e12fff33 	blx	r3
            pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
102c8480:	e59f31b4 	ldr	r3, [pc, #436]	; 102c863c <OnURCHandler_BTScan+0x29c>
102c8484:	e1a0000b 	mov	r0, fp
102c8488:	e12fff33 	blx	r3
102c848c:	e59f31ac 	ldr	r3, [pc, #428]	; 102c8640 <OnURCHandler_BTScan+0x2a0>
102c8490:	e2456004 	sub	r6, r5, #4
102c8494:	e1a01000 	mov	r1, r0
102c8498:	e1a0000b 	mov	r0, fp
102c849c:	e12fff33 	blx	r3
            ret = BT_ScanUpdateConfirm(pstrNewBtDev->btDevice.devHdl,pstrNewBtDev->devId,pstrNewBtDev->btDevice.name);
102c84a0:	e597104c 	ldr	r1, [r7, #76]	; 0x4c
102c84a4:	e1a0c006 	mov	ip, r6
            pstrNewBtDev->connId = -1;
            pstrNewBtDev->profileId = -1;

            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
            pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
102c84a8:	e5870000 	str	r0, [r7]
102c84ac:	ea000002 	b	102c84bc <OnURCHandler_BTScan+0x11c>
102c84b0:	e2844001 	add	r4, r4, #1


static bool BT_ScanUpdateConfirm(BT_DEV_HDL devHdl,const s32 devid,const char *name)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c84b4:	e354001e 	cmp	r4, #30
102c84b8:	0a000036 	beq	102c8598 <OnURCHandler_BTScan+0x1f8>
    {
        if (NULL != m_arrBTDev[i])
102c84bc:	e5bc3004 	ldr	r3, [ip, #4]!
102c84c0:	e3530000 	cmp	r3, #0
102c84c4:	0afffff9 	beq	102c84b0 <OnURCHandler_BTScan+0x110>
        {
            if(devHdl == m_arrBTDev[i]->btDevice.devHdl)
102c84c8:	e593e000 	ldr	lr, [r3]
102c84cc:	e150000e 	cmp	r0, lr
102c84d0:	1afffff6 	bne	102c84b0 <OnURCHandler_BTScan+0x110>
            {
                m_arrBTDev[i]->devId = devid;
				Ql_memset(m_arrBTDev[i]->btDevice.name,0,BT_NAME_LEN);
102c84d4:	e3a02038 	mov	r2, #56	; 0x38
    {
        if (NULL != m_arrBTDev[i])
        {
            if(devHdl == m_arrBTDev[i]->btDevice.devHdl)
            {
                m_arrBTDev[i]->devId = devid;
102c84d8:	e583104c 	str	r1, [r3, #76]	; 0x4c
				Ql_memset(m_arrBTDev[i]->btDevice.name,0,BT_NAME_LEN);
102c84dc:	e2830004 	add	r0, r3, #4
102c84e0:	e3a01000 	mov	r1, #0
102c84e4:	e12fff3a 	blx	sl
                Ql_strcpy(m_arrBTDev[i]->btDevice.name,name);
102c84e8:	e7950104 	ldr	r0, [r5, r4, lsl #2]
102c84ec:	e1a01008 	mov	r1, r8
102c84f0:	e59f314c 	ldr	r3, [pc, #332]	; 102c8644 <OnURCHandler_BTScan+0x2a4>
102c84f4:	e2800004 	add	r0, r0, #4
102c84f8:	e12fff33 	blx	r3

            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
            pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
            ret = BT_ScanUpdateConfirm(pstrNewBtDev->btDevice.devHdl,pstrNewBtDev->devId,pstrNewBtDev->btDevice.name);
			callback_bt(MSG_BT_SCAN_IND,URC_BT_SCAN_FOUND,&(pstrNewBtDev->btDevice), NULL);//customer own management
102c84fc:	e3a03000 	mov	r3, #0
102c8500:	e3a00001 	mov	r0, #1
102c8504:	e595c090 	ldr	ip, [r5, #144]	; 0x90
102c8508:	e3a01003 	mov	r1, #3
102c850c:	e1a02007 	mov	r2, r7
102c8510:	e12fff3c 	blx	ip
	                Ql_MEM_Free(pstrNewBtDev);
	            }
            }
			else
			{
			    Ql_MEM_Free(pstrNewBtDev);
102c8514:	e1a00007 	mov	r0, r7
102c8518:	e59f3128 	ldr	r3, [pc, #296]	; 102c8648 <OnURCHandler_BTScan+0x2a8>
102c851c:	e12fff33 	blx	r3
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", &err_code);
        callback_bt(MSG_BT_SCAN_IND, err_code, NULL, NULL);
        return;
    }
}
102c8520:	e28dd01c 	add	sp, sp, #28
102c8524:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
       
        }
        return;
    }

    Ql_strcpy(urcHead, "+CME ERROR:\0");
102c8528:	e2461020 	sub	r1, r6, #32
102c852c:	e59f3110 	ldr	r3, [pc, #272]	; 102c8644 <OnURCHandler_BTScan+0x2a4>
102c8530:	e28d0008 	add	r0, sp, #8
102c8534:	e12fff33 	blx	r3
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c8538:	e1a00009 	mov	r0, r9
102c853c:	e28d1008 	add	r1, sp, #8
102c8540:	e12fff37 	blx	r7
102c8544:	e3500000 	cmp	r0, #0
102c8548:	0afffff4 	beq	102c8520 <OnURCHandler_BTScan+0x180>
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", &err_code);
102c854c:	e59f30d0 	ldr	r3, [pc, #208]	; 102c8624 <OnURCHandler_BTScan+0x284>
102c8550:	e28d2004 	add	r2, sp, #4
102c8554:	e5933000 	ldr	r3, [r3]
102c8558:	e1a00009 	mov	r0, r9
102c855c:	e59f10e8 	ldr	r1, [pc, #232]	; 102c864c <OnURCHandler_BTScan+0x2ac>
102c8560:	e12fff33 	blx	r3
        callback_bt(MSG_BT_SCAN_IND, err_code, NULL, NULL);
102c8564:	e1a02008 	mov	r2, r8
102c8568:	e595c090 	ldr	ip, [r5, #144]	; 0x90
102c856c:	e3a00001 	mov	r0, #1
102c8570:	e59d1004 	ldr	r1, [sp, #4]
102c8574:	e1a03008 	mov	r3, r8
102c8578:	e12fff3c 	blx	ip
102c857c:	eaffffe7 	b	102c8520 <OnURCHandler_BTScan+0x180>
    {
        Ql_sscanf(strURC, "%*[^:]: %d%*[^\r\n]\r\n",&deviceId);
        
        if (0 == deviceId)  // scan finished
        {
            callback_bt(MSG_BT_SCAN_IND,URC_BT_SCAN_FINISHED, NULL, NULL);
102c8580:	e595c090 	ldr	ip, [r5, #144]	; 0x90
102c8584:	e3a00001 	mov	r0, #1
102c8588:	e3a01002 	mov	r1, #2
102c858c:	e1a03002 	mov	r3, r2
102c8590:	e12fff3c 	blx	ip
102c8594:	eaffffe1 	b	102c8520 <OnURCHandler_BTScan+0x180>

            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",pstrNewBtDev->btDevice.name);
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n",pstrNewBtDev->btDevice.addr);
            pstrNewBtDev->btDevice.devHdl = Ql_GenHash(pstrNewBtDev->btDevice.addr, Ql_strlen(pstrNewBtDev->btDevice.addr));
            ret = BT_ScanUpdateConfirm(pstrNewBtDev->btDevice.devHdl,pstrNewBtDev->devId,pstrNewBtDev->btDevice.name);
			callback_bt(MSG_BT_SCAN_IND,URC_BT_SCAN_FOUND,&(pstrNewBtDev->btDevice), NULL);//customer own management
102c8598:	e1a02007 	mov	r2, r7
102c859c:	e3a03000 	mov	r3, #0
102c85a0:	e595c090 	ldr	ip, [r5, #144]	; 0x90
102c85a4:	e3a00001 	mov	r0, #1
102c85a8:	e3a01003 	mov	r1, #3
102c85ac:	e12fff3c 	blx	ip
    Ql_sprintf(strAT, "AT+QBTSCAN=%d,%d,%d", timeout, maxDevCount, CoD);
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTScan(const char* strURC, void* reserved)
102c85b0:	e59f2098 	ldr	r2, [pc, #152]	; 102c8650 <OnURCHandler_BTScan+0x2b0>
102c85b4:	e3a04000 	mov	r4, #0
102c85b8:	e2423078 	sub	r3, r2, #120	; 0x78
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c85bc:	e5b31004 	ldr	r1, [r3, #4]!
        {
            count++;
102c85c0:	e284c001 	add	ip, r4, #1
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c85c4:	e3510000 	cmp	r1, #0
        {
            count++;
102c85c8:	e1a0c80c 	lsl	ip, ip, #16
102c85cc:	11a0482c 	lsrne	r4, ip, #16

static bool BT_DevMngmt_isFull(void)
{
    u16 i;
    u16 count = 0 ;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c85d0:	e1530002 	cmp	r3, r2
102c85d4:	1afffff8 	bne	102c85bc <OnURCHandler_BTScan+0x21c>
        {
            count++;
        }
    }

    if(count >= MAX_BT_DEV_CNT)
102c85d8:	e354001d 	cmp	r4, #29
102c85dc:	8a000009 	bhi	102c8608 <OnURCHandler_BTScan+0x268>
102c85e0:	e3a03000 	mov	r3, #0
102c85e4:	ea000002 	b	102c85f4 <OnURCHandler_BTScan+0x254>
102c85e8:	e2833001 	add	r3, r3, #1
//
// Append a bt device
static void BT_DevMngmt_Append(ST_BT_DevInfo* pstBtDev)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c85ec:	e353001e 	cmp	r3, #30
102c85f0:	0affffca 	beq	102c8520 <OnURCHandler_BTScan+0x180>
    {
        if (NULL == m_arrBTDev[i])
102c85f4:	e5b62004 	ldr	r2, [r6, #4]!
102c85f8:	e3520000 	cmp	r2, #0
102c85fc:	1afffff9 	bne	102c85e8 <OnURCHandler_BTScan+0x248>
        {
            m_arrBTDev[i] = pstBtDev;
102c8600:	e7857103 	str	r7, [r5, r3, lsl #2]
102c8604:	eaffffc5 	b	102c8520 <OnURCHandler_BTScan+0x180>
	            {
	               BT_DevMngmt_Append(pstrNewBtDev);
	            }
	            else
	            {
	                Ql_MEM_Free(pstrNewBtDev);
102c8608:	e1a00007 	mov	r0, r7
102c860c:	e59f3034 	ldr	r3, [pc, #52]	; 102c8648 <OnURCHandler_BTScan+0x2a8>
102c8610:	e12fff33 	blx	r3
102c8614:	eaffffc1 	b	102c8520 <OnURCHandler_BTScan+0x180>
102c8618:	102e64f8 	.word	0x102e64f8
102c861c:	f03d5058 	.word	0xf03d5058
102c8620:	102ccd58 	.word	0x102ccd58
102c8624:	f03de548 	.word	0xf03de548
102c8628:	102ede40 	.word	0x102ede40
102c862c:	102e4840 	.word	0x102e4840
102c8630:	102e58f4 	.word	0x102e58f4
102c8634:	102ede68 	.word	0x102ede68
102c8638:	102edfa4 	.word	0x102edfa4
102c863c:	102e57a4 	.word	0x102e57a4
102c8640:	102cd1a4 	.word	0x102cd1a4
102c8644:	102e55fc 	.word	0x102e55fc
102c8648:	102e48b8 	.word	0x102e48b8
102c864c:	102ede14 	.word	0x102ede14
102c8650:	f03d50cc 	.word	0xf03d50cc

102c8654 <RIL_BT_GetDevListInfo>:
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetDevListInfo(void)
{
102c8654:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102c8658:	e59f4060 	ldr	r4, [pc, #96]	; 102c86c0 <RIL_BT_GetDevListInfo+0x6c>
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
        {
            Ql_Debug_Trace("%s %2d 0x%08x %2d %2d %2d %s\r\n",m_arrBTDev[i]->btDevice.addr,m_arrBTDev[i]->devId,\
102c865c:	e59f7060 	ldr	r7, [pc, #96]	; 102c86c4 <RIL_BT_GetDevListInfo+0x70>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetDevListInfo(void)
{
102c8660:	e24dd014 	sub	sp, sp, #20
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_GetDevListInfo(void)
102c8664:	e2846078 	add	r6, r4, #120	; 0x78
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c8668:	e5b4c004 	ldr	ip, [r4, #4]!
        {
            Ql_Debug_Trace("%s %2d 0x%08x %2d %2d %2d %s\r\n",m_arrBTDev[i]->btDevice.addr,m_arrBTDev[i]->devId,\
102c866c:	e59f0054 	ldr	r0, [pc, #84]	; 102c86c8 <RIL_BT_GetDevListInfo+0x74>
s32 RIL_BT_GetDevListInfo(void)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c8670:	e35c0000 	cmp	ip, #0
        {
            Ql_Debug_Trace("%s %2d 0x%08x %2d %2d %2d %s\r\n",m_arrBTDev[i]->btDevice.addr,m_arrBTDev[i]->devId,\
                m_arrBTDev[i]->btDevice.devHdl,m_arrBTDev[i]->pairId,m_arrBTDev[i]->connId,m_arrBTDev[i]->profileId,m_arrBTDev[i]->btDevice.name);
102c8674:	e28c5004 	add	r5, ip, #4
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
        {
            Ql_Debug_Trace("%s %2d 0x%08x %2d %2d %2d %s\r\n",m_arrBTDev[i]->btDevice.addr,m_arrBTDev[i]->devId,\
102c8678:	e28c103c 	add	r1, ip, #60	; 0x3c
s32 RIL_BT_GetDevListInfo(void)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (NULL != m_arrBTDev[i])
102c867c:	0a00000a 	beq	102c86ac <RIL_BT_GetDevListInfo+0x58>
        {
            Ql_Debug_Trace("%s %2d 0x%08x %2d %2d %2d %s\r\n",m_arrBTDev[i]->btDevice.addr,m_arrBTDev[i]->devId,\
102c8680:	e59ce050 	ldr	lr, [ip, #80]	; 0x50
102c8684:	e59c204c 	ldr	r2, [ip, #76]	; 0x4c
102c8688:	e59c3000 	ldr	r3, [ip]
102c868c:	e58de000 	str	lr, [sp]
102c8690:	e59ce054 	ldr	lr, [ip, #84]	; 0x54
102c8694:	e58de004 	str	lr, [sp, #4]
102c8698:	e59cc058 	ldr	ip, [ip, #88]	; 0x58
102c869c:	e58dc008 	str	ip, [sp, #8]
102c86a0:	e58d500c 	str	r5, [sp, #12]
102c86a4:	e597c000 	ldr	ip, [r7]
102c86a8:	e12fff3c 	blx	ip
*****************************************************************/

s32 RIL_BT_GetDevListInfo(void)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c86ac:	e1540006 	cmp	r4, r6
102c86b0:	1affffec 	bne	102c8668 <RIL_BT_GetDevListInfo+0x14>
            Ql_Debug_Trace("%s %2d 0x%08x %2d %2d %2d %s\r\n",m_arrBTDev[i]->btDevice.addr,m_arrBTDev[i]->devId,\
                m_arrBTDev[i]->btDevice.devHdl,m_arrBTDev[i]->pairId,m_arrBTDev[i]->connId,m_arrBTDev[i]->profileId,m_arrBTDev[i]->btDevice.name);
        }
    }
    return RIL_AT_SUCCESS;
}
102c86b4:	e3a00000 	mov	r0, #0
102c86b8:	e28dd014 	add	sp, sp, #20
102c86bc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
102c86c0:	f03d5054 	.word	0xf03d5054
102c86c4:	f03de544 	.word	0xf03de544
102c86c8:	102edfbc 	.word	0x102edfbc

102c86cc <RIL_BT_GetDevListPointer>:
*****************************************************************/

ST_BT_DevInfo ** RIL_BT_GetDevListPointer(void)
{
    return m_arrBTDev;
}
102c86cc:	e59f0000 	ldr	r0, [pc]	; 102c86d4 <RIL_BT_GetDevListPointer+0x8>
102c86d0:	e12fff1e 	bx	lr
102c86d4:	f03d5058 	.word	0xf03d5058

102c86d8 <RIL_BT_StopScan>:
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_StopScan(void)
{
    char strAT[] = "AT+QBTSCANC\0";
102c86d8:	e59f3044 	ldr	r3, [pc, #68]	; 102c8724 <RIL_BT_StopScan+0x4c>
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_StopScan(void)
{
102c86dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    char strAT[] = "AT+QBTSCANC\0";
102c86e0:	e893000f 	ldm	r3, {r0, r1, r2, r3}
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_StopScan(void)
{
102c86e4:	e24dd01c 	sub	sp, sp, #28
    char strAT[] = "AT+QBTSCANC\0";
102c86e8:	e28dc008 	add	ip, sp, #8
102c86ec:	e8ac0007 	stmia	ip!, {r0, r1, r2}
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c86f0:	e28d0008 	add	r0, sp, #8
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_StopScan(void)
{
    char strAT[] = "AT+QBTSCANC\0";
102c86f4:	e5cc3000 	strb	r3, [ip]
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c86f8:	e59f3028 	ldr	r3, [pc, #40]	; 102c8728 <RIL_BT_StopScan+0x50>
102c86fc:	e12fff33 	blx	r3
102c8700:	e3a03000 	mov	r3, #0
102c8704:	e1a02003 	mov	r2, r3
102c8708:	e58d3000 	str	r3, [sp]
102c870c:	e59fc018 	ldr	ip, [pc, #24]	; 102c872c <RIL_BT_StopScan+0x54>
102c8710:	e1a01000 	mov	r1, r0
102c8714:	e28d0008 	add	r0, sp, #8
102c8718:	e12fff3c 	blx	ip
}
102c871c:	e28dd01c 	add	sp, sp, #28
102c8720:	e8bd8000 	ldmfd	sp!, {pc}
102c8724:	102e6508 	.word	0x102e6508
102c8728:	102e57a4 	.word	0x102e57a4
102c872c:	102e5168 	.word	0x102e5168

102c8730 <RIL_BT_QueryState>:
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_QueryState(s32 *status)
{
    char strAT[] = "AT+QBTSTATE\0";
102c8730:	e59f204c 	ldr	r2, [pc, #76]	; 102c8784 <RIL_BT_QueryState+0x54>
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_QueryState(s32 *status)
{
102c8734:	e92d4010 	push	{r4, lr}
102c8738:	e1a04000 	mov	r4, r0
    char strAT[] = "AT+QBTSTATE\0";
102c873c:	e892000f 	ldm	r2, {r0, r1, r2, r3}
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_QueryState(s32 *status)
{
102c8740:	e24dd018 	sub	sp, sp, #24
    char strAT[] = "AT+QBTSTATE\0";
102c8744:	e28dc008 	add	ip, sp, #8
102c8748:	e8ac0007 	stmia	ip!, {r0, r1, r2}
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTSTATE_Hdlr, (void *)status, 0);
102c874c:	e28d0008 	add	r0, sp, #8
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_QueryState(s32 *status)
{
    char strAT[] = "AT+QBTSTATE\0";
102c8750:	e5cc3000 	strb	r3, [ip]
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTSTATE_Hdlr, (void *)status, 0);
102c8754:	e59f302c 	ldr	r3, [pc, #44]	; 102c8788 <RIL_BT_QueryState+0x58>
102c8758:	e12fff33 	blx	r3
102c875c:	e3a03000 	mov	r3, #0
102c8760:	e58d3000 	str	r3, [sp]
102c8764:	e59f2020 	ldr	r2, [pc, #32]	; 102c878c <RIL_BT_QueryState+0x5c>
102c8768:	e1a03004 	mov	r3, r4
102c876c:	e59fc01c 	ldr	ip, [pc, #28]	; 102c8790 <RIL_BT_QueryState+0x60>
102c8770:	e1a01000 	mov	r1, r0
102c8774:	e28d0008 	add	r0, sp, #8
102c8778:	e12fff3c 	blx	ip
}
102c877c:	e28dd018 	add	sp, sp, #24
102c8780:	e8bd8010 	pop	{r4, pc}
102c8784:	102e6518 	.word	0x102e6518
102c8788:	102e57a4 	.word	0x102e57a4
102c878c:	102c71cc 	.word	0x102c71cc
102c8790:	102e5168 	.word	0x102e5168

102c8794 <RIL_BT_StartScan>:

s32 RIL_BT_StartScan(u16 maxDevCount, u16 CoD, u16 timeout)
{
    char strAT[20];

    if(maxDevCount < 0 || maxDevCount > MAX_BT_SCAN_CNT)
102c8794:	e3500014 	cmp	r0, #20
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/

s32 RIL_BT_StartScan(u16 maxDevCount, u16 CoD, u16 timeout)
{
102c8798:	e92d4070 	push	{r4, r5, r6, lr}
102c879c:	e1a04000 	mov	r4, r0
102c87a0:	e24dd020 	sub	sp, sp, #32
102c87a4:	e1a05001 	mov	r5, r1
102c87a8:	e1a06002 	mov	r6, r2
    char strAT[20];

    if(maxDevCount < 0 || maxDevCount > MAX_BT_SCAN_CNT)
102c87ac:	8a000021 	bhi	102c8838 <RIL_BT_StartScan+0xa4>
    {
        return  RIL_AT_INVALID_PARAM ;
    }

    if(CoD < 0 || CoD > MAX_BT_SCAN_COD)
102c87b0:	e35100ff 	cmp	r1, #255	; 0xff
102c87b4:	8a00001f 	bhi	102c8838 <RIL_BT_StartScan+0xa4>
    {
        return  RIL_AT_INVALID_PARAM ;
    }

    if(timeout < 1 || timeout > MAX_BT_SCAN_TIMEOUT)
102c87b8:	e2423001 	sub	r3, r2, #1
102c87bc:	e1a03803 	lsl	r3, r3, #16
102c87c0:	e35308fe 	cmp	r3, #16646144	; 0xfe0000
102c87c4:	8a00001b 	bhi	102c8838 <RIL_BT_StartScan+0xa4>
    {
        return  RIL_AT_INVALID_PARAM ;
    }

    BT_DevMngmt_Clean();
102c87c8:	ebfffa70 	bl	102c7190 <BT_DevMngmt_Clean>

    RIL_BT_QueryState(NULL);
102c87cc:	e3a00000 	mov	r0, #0
102c87d0:	ebffffd6 	bl	102c8730 <RIL_BT_QueryState>

    // Start to scan bt devices
    Ql_memset(strAT, 0x0, sizeof(strAT));
102c87d4:	e3a01000 	mov	r1, #0
102c87d8:	e3a02014 	mov	r2, #20
102c87dc:	e59f305c 	ldr	r3, [pc, #92]	; 102c8840 <RIL_BT_StartScan+0xac>
102c87e0:	e28d000c 	add	r0, sp, #12
102c87e4:	e12fff33 	blx	r3
    Ql_sprintf(strAT, "AT+QBTSCAN=%d,%d,%d", timeout, maxDevCount, CoD);
102c87e8:	e59f0054 	ldr	r0, [pc, #84]	; 102c8844 <RIL_BT_StartScan+0xb0>
102c87ec:	e59f1054 	ldr	r1, [pc, #84]	; 102c8848 <RIL_BT_StartScan+0xb4>
102c87f0:	e1a02006 	mov	r2, r6
102c87f4:	e1a03004 	mov	r3, r4
102c87f8:	e58d5000 	str	r5, [sp]
102c87fc:	e590c000 	ldr	ip, [r0]
102c8800:	e28d000c 	add	r0, sp, #12
102c8804:	e12fff3c 	blx	ip
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c8808:	e59f303c 	ldr	r3, [pc, #60]	; 102c884c <RIL_BT_StartScan+0xb8>
102c880c:	e28d000c 	add	r0, sp, #12
102c8810:	e12fff33 	blx	r3
102c8814:	e3a03000 	mov	r3, #0
102c8818:	e1a02003 	mov	r2, r3
102c881c:	e58d3000 	str	r3, [sp]
102c8820:	e59fc028 	ldr	ip, [pc, #40]	; 102c8850 <RIL_BT_StartScan+0xbc>
102c8824:	e1a01000 	mov	r1, r0
102c8828:	e28d000c 	add	r0, sp, #12
102c882c:	e12fff3c 	blx	ip
}
102c8830:	e28dd020 	add	sp, sp, #32
102c8834:	e8bd8070 	pop	{r4, r5, r6, pc}
{
    char strAT[20];

    if(maxDevCount < 0 || maxDevCount > MAX_BT_SCAN_CNT)
    {
        return  RIL_AT_INVALID_PARAM ;
102c8838:	e3e00003 	mvn	r0, #3
102c883c:	eafffffb 	b	102c8830 <RIL_BT_StartScan+0x9c>
102c8840:	102e58f4 	.word	0x102e58f4
102c8844:	f03de540 	.word	0xf03de540
102c8848:	102edfdc 	.word	0x102edfdc
102c884c:	102e57a4 	.word	0x102e57a4
102c8850:	102e5168 	.word	0x102e5168

102c8854 <RIL_BT_Initialize>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_Initialize(CALLBACK_BT_IND cb)
{
102c8854:	e92d4010 	push	{r4, lr}
    
    if (!cb)
102c8858:	e2504000 	subs	r4, r0, #0
102c885c:	0a000006 	beq	102c887c <RIL_BT_Initialize+0x28>
    {
        return RIL_AT_INVALID_PARAM;
    }
    
    BT_DevMngmt_Clean();
102c8860:	ebfffa4a 	bl	102c7190 <BT_DevMngmt_Clean>
    
    callback_bt = cb;
102c8864:	e59f3018 	ldr	r3, [pc, #24]	; 102c8884 <RIL_BT_Initialize+0x30>

    RIL_BT_QueryState(NULL); //update paired items
102c8868:	e3a00000 	mov	r0, #0
        return RIL_AT_INVALID_PARAM;
    }
    
    BT_DevMngmt_Clean();
    
    callback_bt = cb;
102c886c:	e5834090 	str	r4, [r3, #144]	; 0x90

    RIL_BT_QueryState(NULL); //update paired items
102c8870:	ebffffae 	bl	102c8730 <RIL_BT_QueryState>
    
    return RIL_AT_SUCCESS;
102c8874:	e3a00000 	mov	r0, #0
102c8878:	e8bd8010 	pop	{r4, pc}
s32 RIL_BT_Initialize(CALLBACK_BT_IND cb)
{
    
    if (!cb)
    {
        return RIL_AT_INVALID_PARAM;
102c887c:	e3e00003 	mvn	r0, #3
    callback_bt = cb;

    RIL_BT_QueryState(NULL); //update paired items
    
    return RIL_AT_SUCCESS;
}
102c8880:	e8bd8010 	pop	{r4, pc}
102c8884:	f03d5058 	.word	0xf03d5058

102c8888 <RIL_BT_PairReq>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_PairReq(BT_DEV_HDL hdlDevice)
{
102c8888:	e59f307c 	ldr	r3, [pc, #124]	; 102c890c <RIL_BT_PairReq+0x84>
102c888c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
*                RIL_AT_TIMEOUT,send AT timeout.
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_PairReq(BT_DEV_HDL hdlDevice)
102c8890:	e283c078 	add	ip, r3, #120	; 0x78
{
102c8894:	e24dd024 	sub	sp, sp, #36	; 0x24
102c8898:	ea000001 	b	102c88a4 <RIL_BT_PairReq+0x1c>


s32 BT_DevMngmt_GetDeviceId(const u32 hdl)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c889c:	e153000c 	cmp	r3, ip
102c88a0:	0a000017 	beq	102c8904 <RIL_BT_PairReq+0x7c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c88a4:	e5b32004 	ldr	r2, [r3, #4]!
102c88a8:	e5921000 	ldr	r1, [r2]
102c88ac:	e1500001 	cmp	r0, r1
102c88b0:	1afffff9 	bne	102c889c <RIL_BT_PairReq+0x14>
        {
            return m_arrBTDev[i]->devId;
102c88b4:	e592204c 	ldr	r2, [r2, #76]	; 0x4c
{
    char strAT[20];
    s32  devId ;
    
    devId = BT_DevMngmt_GetDeviceId(hdlDevice);
    if(devId == 0)
102c88b8:	e3520000 	cmp	r2, #0
102c88bc:	0a000010 	beq	102c8904 <RIL_BT_PairReq+0x7c>
    {
        return RIL_AT_INVALID_PARAM;
    }    
    Ql_sprintf(strAT, "AT+QBTPAIR=%d", devId);
102c88c0:	e59f3048 	ldr	r3, [pc, #72]	; 102c8910 <RIL_BT_PairReq+0x88>
102c88c4:	e59f1048 	ldr	r1, [pc, #72]	; 102c8914 <RIL_BT_PairReq+0x8c>
102c88c8:	e5933000 	ldr	r3, [r3]
102c88cc:	e28d000c 	add	r0, sp, #12
102c88d0:	e12fff33 	blx	r3
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c88d4:	e59f303c 	ldr	r3, [pc, #60]	; 102c8918 <RIL_BT_PairReq+0x90>
102c88d8:	e28d000c 	add	r0, sp, #12
102c88dc:	e12fff33 	blx	r3
102c88e0:	e3a03000 	mov	r3, #0
102c88e4:	e1a02003 	mov	r2, r3
102c88e8:	e58d3000 	str	r3, [sp]
102c88ec:	e59fc028 	ldr	ip, [pc, #40]	; 102c891c <RIL_BT_PairReq+0x94>
102c88f0:	e1a01000 	mov	r1, r0
102c88f4:	e28d000c 	add	r0, sp, #12
102c88f8:	e12fff3c 	blx	ip
}
102c88fc:	e28dd024 	add	sp, sp, #36	; 0x24
102c8900:	e8bd8000 	ldmfd	sp!, {pc}
    s32  devId ;
    
    devId = BT_DevMngmt_GetDeviceId(hdlDevice);
    if(devId == 0)
    {
        return RIL_AT_INVALID_PARAM;
102c8904:	e3e00003 	mvn	r0, #3
102c8908:	eafffffb 	b	102c88fc <RIL_BT_PairReq+0x74>
102c890c:	f03d5054 	.word	0xf03d5054
102c8910:	f03de540 	.word	0xf03de540
102c8914:	102edff0 	.word	0x102edff0
102c8918:	102e57a4 	.word	0x102e57a4
102c891c:	102e5168 	.word	0x102e5168

102c8920 <OnURCHandler_BTPair>:




void OnURCHandler_BTPair(const char* strURC, void* reserved)
{
102c8920:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    char urcHead[30];
    char pinCode[BT_PIN_LEN] = {0};
    ST_BT_BasicInfo bt_dev;
    char temp[30]={0};

    Ql_memset(&bt_dev, 0x0, sizeof(ST_BT_BasicInfo));
102c8924:	e3a0204c 	mov	r2, #76	; 0x4c




void OnURCHandler_BTPair(const char* strURC, void* reserved)
{
102c8928:	e24dd09c 	sub	sp, sp, #156	; 0x9c
    s32 err_code = 0;
102c892c:	e3a04000 	mov	r4, #0
    char urcHead[30];
    char pinCode[BT_PIN_LEN] = {0};
    ST_BT_BasicInfo bt_dev;
    char temp[30]={0};

    Ql_memset(&bt_dev, 0x0, sizeof(ST_BT_BasicInfo));
102c8930:	e1a01004 	mov	r1, r4
102c8934:	e59f61b8 	ldr	r6, [pc, #440]	; 102c8af4 <OnURCHandler_BTPair+0x1d4>




void OnURCHandler_BTPair(const char* strURC, void* reserved)
{
102c8938:	e1a05000 	mov	r5, r0
    char temp[30]={0};

    Ql_memset(&bt_dev, 0x0, sizeof(ST_BT_BasicInfo));
    Ql_memset(pinCode, 0x0, sizeof(pinCode));

	if(callback_bt == NULL)
102c893c:	e59f71b4 	ldr	r7, [pc, #436]	; 102c8af8 <OnURCHandler_BTPair+0x1d8>
    char urcHead[30];
    char pinCode[BT_PIN_LEN] = {0};
    ST_BT_BasicInfo bt_dev;
    char temp[30]={0};

    Ql_memset(&bt_dev, 0x0, sizeof(ST_BT_BasicInfo));
102c8940:	e08d0002 	add	r0, sp, r2



void OnURCHandler_BTPair(const char* strURC, void* reserved)
{
    s32 err_code = 0;
102c8944:	e58d4000 	str	r4, [sp]
    char urcHead[30];
    char pinCode[BT_PIN_LEN] = {0};
102c8948:	e58d4004 	str	r4, [sp, #4]
102c894c:	e1cd40b8 	strh	r4, [sp, #8]
102c8950:	e5cd400a 	strb	r4, [sp, #10]
    ST_BT_BasicInfo bt_dev;
    char temp[30]={0};
102c8954:	e58d402c 	str	r4, [sp, #44]	; 0x2c
102c8958:	e58d4030 	str	r4, [sp, #48]	; 0x30
102c895c:	e58d4034 	str	r4, [sp, #52]	; 0x34
102c8960:	e58d4038 	str	r4, [sp, #56]	; 0x38
102c8964:	e58d403c 	str	r4, [sp, #60]	; 0x3c
102c8968:	e58d4040 	str	r4, [sp, #64]	; 0x40
102c896c:	e58d4044 	str	r4, [sp, #68]	; 0x44
102c8970:	e1cd44b8 	strh	r4, [sp, #72]	; 0x48

    Ql_memset(&bt_dev, 0x0, sizeof(ST_BT_BasicInfo));
102c8974:	e12fff36 	blx	r6
    Ql_memset(pinCode, 0x0, sizeof(pinCode));
102c8978:	e28d0004 	add	r0, sp, #4
102c897c:	e1a01004 	mov	r1, r4
102c8980:	e3a02007 	mov	r2, #7
102c8984:	e12fff36 	blx	r6

	if(callback_bt == NULL)
102c8988:	e5973090 	ldr	r3, [r7, #144]	; 0x90
102c898c:	e1530004 	cmp	r3, r4
102c8990:	0a000030 	beq	102c8a58 <OnURCHandler_BTPair+0x138>
	}

    // +QBTPAIR: "H60-L01",F4E3FBE47920,724242

    
    Ql_strcpy(urcHead, "\r\n+QBTPAIR:\0");
102c8994:	e59f1160 	ldr	r1, [pc, #352]	; 102c8afc <OnURCHandler_BTPair+0x1dc>
102c8998:	e28d000c 	add	r0, sp, #12
102c899c:	e59f815c 	ldr	r8, [pc, #348]	; 102c8b00 <OnURCHandler_BTPair+0x1e0>
102c89a0:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c89a4:	e59f6158 	ldr	r6, [pc, #344]	; 102c8b04 <OnURCHandler_BTPair+0x1e4>
102c89a8:	e1a00005 	mov	r0, r5
102c89ac:	e28d100c 	add	r1, sp, #12
102c89b0:	e12fff36 	blx	r6
102c89b4:	e250a000 	subs	sl, r0, #0
102c89b8:	0a000028 	beq	102c8a60 <OnURCHandler_BTPair+0x140>
    {
        Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", bt_dev.name);
102c89bc:	e59f6144 	ldr	r6, [pc, #324]	; 102c8b08 <OnURCHandler_BTPair+0x1e8>
102c89c0:	e59f1144 	ldr	r1, [pc, #324]	; 102c8b0c <OnURCHandler_BTPair+0x1ec>
102c89c4:	e28d2050 	add	r2, sp, #80	; 0x50
102c89c8:	e5963000 	ldr	r3, [r6]
102c89cc:	e1a00005 	mov	r0, r5
102c89d0:	e12fff33 	blx	r3
        Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", temp);
102c89d4:	e28d202c 	add	r2, sp, #44	; 0x2c
102c89d8:	e5963000 	ldr	r3, [r6]
102c89dc:	e59f112c 	ldr	r1, [pc, #300]	; 102c8b10 <OnURCHandler_BTPair+0x1f0>
102c89e0:	e1a00005 	mov	r0, r5
102c89e4:	e12fff33 	blx	r3
       
        if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
102c89e8:	e59f8124 	ldr	r8, [pc, #292]	; 102c8b14 <OnURCHandler_BTPair+0x1f4>
102c89ec:	e28d002c 	add	r0, sp, #44	; 0x2c
102c89f0:	e12fff38 	blx	r8
        {
             Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", bt_dev.addr);
102c89f4:	e28d2088 	add	r2, sp, #136	; 0x88
102c89f8:	e5963000 	ldr	r3, [r6]
    if (Ql_StrPrefixMatch(strURC, urcHead))
    {
        Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", bt_dev.name);
        Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", temp);
       
        if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
102c89fc:	e350000c 	cmp	r0, #12
        {
             Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", bt_dev.addr);
102c8a00:	e1a00005 	mov	r0, r5
    if (Ql_StrPrefixMatch(strURC, urcHead))
    {
        Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", bt_dev.name);
        Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", temp);
       
        if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
102c8a04:	0a00002a 	beq	102c8ab4 <OnURCHandler_BTPair+0x194>
             bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
             callback_bt(MSG_BT_PAIR_IND, URC_BT_NEED_PASSKEY, &bt_dev, NULL); // need paaskey
        }
        else
        {
            Ql_sscanf(strURC, "%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c8a08:	e59f1108 	ldr	r1, [pc, #264]	; 102c8b18 <OnURCHandler_BTPair+0x1f8>
102c8a0c:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n",pinCode);
102c8a10:	e28d2004 	add	r2, sp, #4
102c8a14:	e5963000 	ldr	r3, [r6]
102c8a18:	e59f10fc 	ldr	r1, [pc, #252]	; 102c8b1c <OnURCHandler_BTPair+0x1fc>
102c8a1c:	e1a00005 	mov	r0, r5
102c8a20:	e12fff33 	blx	r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c8a24:	e28d0088 	add	r0, sp, #136	; 0x88
102c8a28:	e12fff38 	blx	r8
102c8a2c:	e59f30ec 	ldr	r3, [pc, #236]	; 102c8b20 <OnURCHandler_BTPair+0x200>
102c8a30:	e1a01000 	mov	r1, r0
102c8a34:	e28d0088 	add	r0, sp, #136	; 0x88
102c8a38:	e12fff33 	blx	r3
            callback_bt(MSG_BT_PAIR_IND, URC_BT_NO_NEED_PASSKEY, &bt_dev, pinCode); //direct confirm
102c8a3c:	e597c090 	ldr	ip, [r7, #144]	; 0x90
102c8a40:	e3a01005 	mov	r1, #5
102c8a44:	e28d204c 	add	r2, sp, #76	; 0x4c
102c8a48:	e28d3004 	add	r3, sp, #4
        }
        else
        {
            Ql_sscanf(strURC, "%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n",pinCode);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c8a4c:	e58d004c 	str	r0, [sp, #76]	; 0x4c
            callback_bt(MSG_BT_PAIR_IND, URC_BT_NO_NEED_PASSKEY, &bt_dev, pinCode); //direct confirm
102c8a50:	e3a00002 	mov	r0, #2
102c8a54:	e12fff3c 	blx	ip
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", &err_code);
        callback_bt(MSG_BT_PAIR_IND, err_code, NULL, NULL);
        return;
    }

}
102c8a58:	e28dd09c 	add	sp, sp, #156	; 0x9c
102c8a5c:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
            callback_bt(MSG_BT_PAIR_IND, URC_BT_NO_NEED_PASSKEY, &bt_dev, pinCode); //direct confirm
        }   
        return;
    }

    Ql_strcpy(urcHead, "+CME ERROR:\0");
102c8a60:	e59f10bc 	ldr	r1, [pc, #188]	; 102c8b24 <OnURCHandler_BTPair+0x204>
102c8a64:	e28d000c 	add	r0, sp, #12
102c8a68:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c8a6c:	e1a00005 	mov	r0, r5
102c8a70:	e28d100c 	add	r1, sp, #12
102c8a74:	e12fff36 	blx	r6
102c8a78:	e3500000 	cmp	r0, #0
102c8a7c:	0afffff5 	beq	102c8a58 <OnURCHandler_BTPair+0x138>
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", &err_code);
102c8a80:	e59f3080 	ldr	r3, [pc, #128]	; 102c8b08 <OnURCHandler_BTPair+0x1e8>
102c8a84:	e1a0200d 	mov	r2, sp
102c8a88:	e59f1098 	ldr	r1, [pc, #152]	; 102c8b28 <OnURCHandler_BTPair+0x208>
102c8a8c:	e5933000 	ldr	r3, [r3]
102c8a90:	e1a00005 	mov	r0, r5
102c8a94:	e12fff33 	blx	r3
        callback_bt(MSG_BT_PAIR_IND, err_code, NULL, NULL);
102c8a98:	e1a0200a 	mov	r2, sl
102c8a9c:	e597c090 	ldr	ip, [r7, #144]	; 0x90
102c8aa0:	e3a00002 	mov	r0, #2
102c8aa4:	e59d1000 	ldr	r1, [sp]
102c8aa8:	e1a0300a 	mov	r3, sl
102c8aac:	e12fff3c 	blx	ip
102c8ab0:	eaffffe8 	b	102c8a58 <OnURCHandler_BTPair+0x138>
        Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", bt_dev.name);
        Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", temp);
       
        if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
        {
             Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", bt_dev.addr);
102c8ab4:	e59f1054 	ldr	r1, [pc, #84]	; 102c8b10 <OnURCHandler_BTPair+0x1f0>
102c8ab8:	e12fff33 	blx	r3
             bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c8abc:	e28d0088 	add	r0, sp, #136	; 0x88
102c8ac0:	e12fff38 	blx	r8
102c8ac4:	e59f3054 	ldr	r3, [pc, #84]	; 102c8b20 <OnURCHandler_BTPair+0x200>
102c8ac8:	e1a01000 	mov	r1, r0
102c8acc:	e28d0088 	add	r0, sp, #136	; 0x88
102c8ad0:	e12fff33 	blx	r3
             callback_bt(MSG_BT_PAIR_IND, URC_BT_NEED_PASSKEY, &bt_dev, NULL); // need paaskey
102c8ad4:	e597c090 	ldr	ip, [r7, #144]	; 0x90
102c8ad8:	e3a01004 	mov	r1, #4
102c8adc:	e28d204c 	add	r2, sp, #76	; 0x4c
102c8ae0:	e1a03004 	mov	r3, r4
        Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", temp);
       
        if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
        {
             Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n", bt_dev.addr);
             bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c8ae4:	e58d004c 	str	r0, [sp, #76]	; 0x4c
             callback_bt(MSG_BT_PAIR_IND, URC_BT_NEED_PASSKEY, &bt_dev, NULL); // need paaskey
102c8ae8:	e3a00002 	mov	r0, #2
102c8aec:	e12fff3c 	blx	ip
102c8af0:	eaffffd8 	b	102c8a58 <OnURCHandler_BTPair+0x138>
102c8af4:	102e58f4 	.word	0x102e58f4
102c8af8:	f03d5058 	.word	0xf03d5058
102c8afc:	102e6528 	.word	0x102e6528
102c8b00:	102e55fc 	.word	0x102e55fc
102c8b04:	102ccd58 	.word	0x102ccd58
102c8b08:	f03de548 	.word	0xf03de548
102c8b0c:	102ede68 	.word	0x102ede68
102c8b10:	102ee000 	.word	0x102ee000
102c8b14:	102e57a4 	.word	0x102e57a4
102c8b18:	102ee010 	.word	0x102ee010
102c8b1c:	102edfa4 	.word	0x102edfa4
102c8b20:	102cd1a4 	.word	0x102cd1a4
102c8b24:	102e64d8 	.word	0x102e64d8
102c8b28:	102ede14 	.word	0x102ede14

102c8b2c <RIL_BT_PairConfirm>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_PairConfirm(bool accept, char* pinCode)
{
102c8b2c:	e92d4010 	push	{r4, lr}
    char strAT[20] = {0};
102c8b30:	e3a0c000 	mov	ip, #0
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_PairConfirm(bool accept, char* pinCode)
{
102c8b34:	e24dd020 	sub	sp, sp, #32
    char strAT[20] = {0};

    if(accept != 0 && accept != 1)
102c8b38:	e3500001 	cmp	r0, #1
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_PairConfirm(bool accept, char* pinCode)
{
102c8b3c:	e1a02000 	mov	r2, r0
102c8b40:	e1a03001 	mov	r3, r1
    char strAT[20] = {0};
102c8b44:	e58dc00c 	str	ip, [sp, #12]
102c8b48:	e58dc010 	str	ip, [sp, #16]
102c8b4c:	e58dc014 	str	ip, [sp, #20]
102c8b50:	e58dc018 	str	ip, [sp, #24]
102c8b54:	e58dc01c 	str	ip, [sp, #28]

    if(accept != 0 && accept != 1)
102c8b58:	8a000019 	bhi	102c8bc4 <RIL_BT_PairConfirm+0x98>
    {
        return RIL_AT_INVALID_PARAM;
    }

    if (NULL != pinCode)//not numeric code ,is passkey(4bit digits)
102c8b5c:	e151000c 	cmp	r1, ip
    {
        Ql_sprintf(strAT, "AT+QBTPAIRCNF=%d,\"%s\"", (u8)accept, pinCode);
102c8b60:	e28d400c 	add	r4, sp, #12
    if(accept != 0 && accept != 1)
    {
        return RIL_AT_INVALID_PARAM;
    }

    if (NULL != pinCode)//not numeric code ,is passkey(4bit digits)
102c8b64:	0a000010 	beq	102c8bac <RIL_BT_PairConfirm+0x80>
    {
        Ql_sprintf(strAT, "AT+QBTPAIRCNF=%d,\"%s\"", (u8)accept, pinCode);
102c8b68:	e59f105c 	ldr	r1, [pc, #92]	; 102c8bcc <RIL_BT_PairConfirm+0xa0>
102c8b6c:	e1a00004 	mov	r0, r4
102c8b70:	e591c000 	ldr	ip, [r1]
102c8b74:	e59f1054 	ldr	r1, [pc, #84]	; 102c8bd0 <RIL_BT_PairConfirm+0xa4>
102c8b78:	e12fff3c 	blx	ip
    }else{
        Ql_sprintf(strAT, "AT+QBTPAIRCNF=%d", (u8)accept);
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c8b7c:	e59f3050 	ldr	r3, [pc, #80]	; 102c8bd4 <RIL_BT_PairConfirm+0xa8>
102c8b80:	e1a00004 	mov	r0, r4
102c8b84:	e12fff33 	blx	r3
102c8b88:	e3a03000 	mov	r3, #0
102c8b8c:	e1a02003 	mov	r2, r3
102c8b90:	e58d3000 	str	r3, [sp]
102c8b94:	e59fc03c 	ldr	ip, [pc, #60]	; 102c8bd8 <RIL_BT_PairConfirm+0xac>
102c8b98:	e1a01000 	mov	r1, r0
102c8b9c:	e1a00004 	mov	r0, r4
102c8ba0:	e12fff3c 	blx	ip
}
102c8ba4:	e28dd020 	add	sp, sp, #32
102c8ba8:	e8bd8010 	pop	{r4, pc}

    if (NULL != pinCode)//not numeric code ,is passkey(4bit digits)
    {
        Ql_sprintf(strAT, "AT+QBTPAIRCNF=%d,\"%s\"", (u8)accept, pinCode);
    }else{
        Ql_sprintf(strAT, "AT+QBTPAIRCNF=%d", (u8)accept);
102c8bac:	e59f3018 	ldr	r3, [pc, #24]	; 102c8bcc <RIL_BT_PairConfirm+0xa0>
102c8bb0:	e1a00004 	mov	r0, r4
102c8bb4:	e5933000 	ldr	r3, [r3]
102c8bb8:	e59f101c 	ldr	r1, [pc, #28]	; 102c8bdc <RIL_BT_PairConfirm+0xb0>
102c8bbc:	e12fff33 	blx	r3
102c8bc0:	eaffffed 	b	102c8b7c <RIL_BT_PairConfirm+0x50>
{
    char strAT[20] = {0};

    if(accept != 0 && accept != 1)
    {
        return RIL_AT_INVALID_PARAM;
102c8bc4:	e3e00003 	mvn	r0, #3
102c8bc8:	eafffff5 	b	102c8ba4 <RIL_BT_PairConfirm+0x78>
102c8bcc:	f03de540 	.word	0xf03de540
102c8bd0:	102ee028 	.word	0x102ee028
102c8bd4:	102e57a4 	.word	0x102e57a4
102c8bd8:	102e5168 	.word	0x102e5168
102c8bdc:	102ee040 	.word	0x102ee040

102c8be0 <OnURCHandler_BTPairCnf>:
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTPairCnf(const char* strURC, void* reserved)
{
102c8be0:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    s32 err_code = 0;
102c8be4:	e3a05000 	mov	r5, #0
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTPairCnf(const char* strURC, void* reserved)
{
102c8be8:	e24dd07c 	sub	sp, sp, #124	; 0x7c
    char urcHead[30];
    ST_BT_BasicInfo bt_dev;

    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));

    if(callback_bt == NULL)
102c8bec:	e59f61d8 	ldr	r6, [pc, #472]	; 102c8dcc <OnURCHandler_BTPairCnf+0x1ec>
    s32  pairedId;
    s32  is1stPaired;
    char urcHead[30];
    ST_BT_BasicInfo bt_dev;

    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c8bf0:	e59f31d8 	ldr	r3, [pc, #472]	; 102c8dd0 <OnURCHandler_BTPairCnf+0x1f0>
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTPairCnf(const char* strURC, void* reserved)
{
102c8bf4:	e1a04000 	mov	r4, r0
    s32  pairedId;
    s32  is1stPaired;
    char urcHead[30];
    ST_BT_BasicInfo bt_dev;

    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c8bf8:	e1a01005 	mov	r1, r5
102c8bfc:	e28d002c 	add	r0, sp, #44	; 0x2c
102c8c00:	e3a0204c 	mov	r2, #76	; 0x4c
}


void OnURCHandler_BTPairCnf(const char* strURC, void* reserved)
{
    s32 err_code = 0;
102c8c04:	e58d5000 	str	r5, [sp]
    s32  pairedId;
    s32  is1stPaired;
    char urcHead[30];
    ST_BT_BasicInfo bt_dev;

    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c8c08:	e12fff33 	blx	r3

    if(callback_bt == NULL)
102c8c0c:	e5963090 	ldr	r3, [r6, #144]	; 0x90
102c8c10:	e1530005 	cmp	r3, r5
102c8c14:	0a000036 	beq	102c8cf4 <OnURCHandler_BTPairCnf+0x114>
       return;
	}

    
    // +QBTPAIRCNF:1,1,1,"H60-L01",F4E3FBE47920
    Ql_strcpy(urcHead, "\r\n+QBTPAIRCNF:\0");
102c8c18:	e59f11b4 	ldr	r1, [pc, #436]	; 102c8dd4 <OnURCHandler_BTPairCnf+0x1f4>
102c8c1c:	e28d000c 	add	r0, sp, #12
102c8c20:	e59f81b0 	ldr	r8, [pc, #432]	; 102c8dd8 <OnURCHandler_BTPairCnf+0x1f8>
102c8c24:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c8c28:	e59f71ac 	ldr	r7, [pc, #428]	; 102c8ddc <OnURCHandler_BTPairCnf+0x1fc>
102c8c2c:	e1a00004 	mov	r0, r4
102c8c30:	e28d100c 	add	r1, sp, #12
102c8c34:	e12fff37 	blx	r7
102c8c38:	e250a000 	subs	sl, r0, #0
102c8c3c:	0a00002e 	beq	102c8cfc <OnURCHandler_BTPairCnf+0x11c>
    {
        Ql_sscanf(strURC, "%*[^:]: %d%*[^\r\n]\r\n", &err_code);
102c8c40:	e59f7198 	ldr	r7, [pc, #408]	; 102c8de0 <OnURCHandler_BTPairCnf+0x200>
102c8c44:	e1a00004 	mov	r0, r4
102c8c48:	e5973000 	ldr	r3, [r7]
102c8c4c:	e59f1190 	ldr	r1, [pc, #400]	; 102c8de4 <OnURCHandler_BTPairCnf+0x204>
102c8c50:	e1a0200d 	mov	r2, sp
102c8c54:	e12fff33 	blx	r3
        if (err_code > 0)
102c8c58:	e59d3000 	ldr	r3, [sp]
102c8c5c:	e1530005 	cmp	r3, r5
102c8c60:	da00003a 	ble	102c8d50 <OnURCHandler_BTPairCnf+0x170>
        {
			Ql_sscanf(strURC, "%*[^,],%d%*[^\r\n]\r\n",&pairedId);
102c8c64:	e28d2004 	add	r2, sp, #4
102c8c68:	e5973000 	ldr	r3, [r7]
102c8c6c:	e59f1174 	ldr	r1, [pc, #372]	; 102c8de8 <OnURCHandler_BTPairCnf+0x208>
102c8c70:	e1a00004 	mov	r0, r4
102c8c74:	e12fff33 	blx	r3
			Ql_sscanf(strURC, "%*[^,]%*[^,],%d%*[^\r\n]\r\n",&is1stPaired);
102c8c78:	e28d2008 	add	r2, sp, #8
102c8c7c:	e5973000 	ldr	r3, [r7]
102c8c80:	e59f1164 	ldr	r1, [pc, #356]	; 102c8dec <OnURCHandler_BTPairCnf+0x20c>
102c8c84:	e1a00004 	mov	r0, r4
102c8c88:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
102c8c8c:	e28d2030 	add	r2, sp, #48	; 0x30
102c8c90:	e5973000 	ldr	r3, [r7]
102c8c94:	e59f1154 	ldr	r1, [pc, #340]	; 102c8df0 <OnURCHandler_BTPairCnf+0x210>
102c8c98:	e1a00004 	mov	r0, r4
102c8c9c:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^\"]\"%*[^\"]\",%[^\r\n]\r\n",bt_dev.addr);
102c8ca0:	e28d2068 	add	r2, sp, #104	; 0x68
102c8ca4:	e59f1148 	ldr	r1, [pc, #328]	; 102c8df4 <OnURCHandler_BTPairCnf+0x214>
102c8ca8:	e5973000 	ldr	r3, [r7]
102c8cac:	e1a00004 	mov	r0, r4
102c8cb0:	e12fff33 	blx	r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c8cb4:	e59f313c 	ldr	r3, [pc, #316]	; 102c8df8 <OnURCHandler_BTPairCnf+0x218>
102c8cb8:	e28d0068 	add	r0, sp, #104	; 0x68
102c8cbc:	e12fff33 	blx	r3
102c8cc0:	e59f3134 	ldr	r3, [pc, #308]	; 102c8dfc <OnURCHandler_BTPairCnf+0x21c>
102c8cc4:	e1a01000 	mov	r1, r0
102c8cc8:	e28d0068 	add	r0, sp, #104	; 0x68
102c8ccc:	e12fff33 	blx	r3
102c8cd0:	e58d002c 	str	r0, [sp, #44]	; 0x2c
            RIL_BT_QueryState(NULL);
102c8cd4:	e1a00005 	mov	r0, r5
102c8cd8:	ebfffe94 	bl	102c8730 <RIL_BT_QueryState>
            callback_bt(MSG_BT_PAIR_CNF_IND, URC_BT_PAIR_CNF_SUCCESS, &bt_dev, NULL);
102c8cdc:	e596c090 	ldr	ip, [r6, #144]	; 0x90
102c8ce0:	e3a00003 	mov	r0, #3
102c8ce4:	e3a01006 	mov	r1, #6
102c8ce8:	e28d202c 	add	r2, sp, #44	; 0x2c
102c8cec:	e1a03005 	mov	r3, r5
102c8cf0:	e12fff3c 	blx	ip
    {
        Ql_sscanf(strURC, "%*[^:]: %d[^\r\n]", &err_code);
        callback_bt(MSG_BT_PAIR_CNF_IND, err_code, NULL, NULL);
        return;
    }
}
102c8cf4:	e28dd07c 	add	sp, sp, #124	; 0x7c
102c8cf8:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
        }
        
        return;
    }

    Ql_strcpy(urcHead, "+CME ERROR:\0");
102c8cfc:	e59f10fc 	ldr	r1, [pc, #252]	; 102c8e00 <OnURCHandler_BTPairCnf+0x220>
102c8d00:	e28d000c 	add	r0, sp, #12
102c8d04:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c8d08:	e1a00004 	mov	r0, r4
102c8d0c:	e28d100c 	add	r1, sp, #12
102c8d10:	e12fff37 	blx	r7
102c8d14:	e3500000 	cmp	r0, #0
102c8d18:	0afffff5 	beq	102c8cf4 <OnURCHandler_BTPairCnf+0x114>
    {
        Ql_sscanf(strURC, "%*[^:]: %d[^\r\n]", &err_code);
102c8d1c:	e59f30bc 	ldr	r3, [pc, #188]	; 102c8de0 <OnURCHandler_BTPairCnf+0x200>
102c8d20:	e1a0200d 	mov	r2, sp
102c8d24:	e59f10d8 	ldr	r1, [pc, #216]	; 102c8e04 <OnURCHandler_BTPairCnf+0x224>
102c8d28:	e5933000 	ldr	r3, [r3]
102c8d2c:	e1a00004 	mov	r0, r4
102c8d30:	e12fff33 	blx	r3
        callback_bt(MSG_BT_PAIR_CNF_IND, err_code, NULL, NULL);
102c8d34:	e1a0200a 	mov	r2, sl
102c8d38:	e596c090 	ldr	ip, [r6, #144]	; 0x90
102c8d3c:	e3a00003 	mov	r0, #3
102c8d40:	e59d1000 	ldr	r1, [sp]
102c8d44:	e1a0300a 	mov	r3, sl
102c8d48:	e12fff3c 	blx	ip
102c8d4c:	eaffffe8 	b	102c8cf4 <OnURCHandler_BTPairCnf+0x114>
            Ql_sscanf(strURC, "%*[^\"]\"%*[^\"]\",%[^\r\n]\r\n",bt_dev.addr);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            RIL_BT_QueryState(NULL);
            callback_bt(MSG_BT_PAIR_CNF_IND, URC_BT_PAIR_CNF_SUCCESS, &bt_dev, NULL);
        }else{
            Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n",bt_dev.addr);
102c8d50:	e28d2068 	add	r2, sp, #104	; 0x68
102c8d54:	e59f10ac 	ldr	r1, [pc, #172]	; 102c8e08 <OnURCHandler_BTPairCnf+0x228>
102c8d58:	e5973000 	ldr	r3, [r7]
102c8d5c:	e1a00004 	mov	r0, r4
102c8d60:	e12fff33 	blx	r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c8d64:	e59f308c 	ldr	r3, [pc, #140]	; 102c8df8 <OnURCHandler_BTPairCnf+0x218>
102c8d68:	e28d0068 	add	r0, sp, #104	; 0x68
102c8d6c:	e12fff33 	blx	r3
102c8d70:	e59f3084 	ldr	r3, [pc, #132]	; 102c8dfc <OnURCHandler_BTPairCnf+0x21c>
102c8d74:	e1a01000 	mov	r1, r0
102c8d78:	e28d0068 	add	r0, sp, #104	; 0x68
102c8d7c:	e12fff33 	blx	r3
102c8d80:	e2463004 	sub	r3, r6, #4
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTPairCnf(const char* strURC, void* reserved)
102c8d84:	e286c074 	add	ip, r6, #116	; 0x74
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            RIL_BT_QueryState(NULL);
            callback_bt(MSG_BT_PAIR_CNF_IND, URC_BT_PAIR_CNF_SUCCESS, &bt_dev, NULL);
        }else{
            Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n",bt_dev.addr);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c8d88:	e58d002c 	str	r0, [sp, #44]	; 0x2c
102c8d8c:	ea000001 	b	102c8d98 <OnURCHandler_BTPairCnf+0x1b8>
//
// Update pair id
static void BT_DevMngmt_UpdatePairId(const u32 hdl, const s32 pairId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c8d90:	e153000c 	cmp	r3, ip
102c8d94:	0a000005 	beq	102c8db0 <OnURCHandler_BTPairCnf+0x1d0>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c8d98:	e5b32004 	ldr	r2, [r3, #4]!
102c8d9c:	e5921000 	ldr	r1, [r2]
102c8da0:	e1500001 	cmp	r0, r1
102c8da4:	1afffff9 	bne	102c8d90 <OnURCHandler_BTPairCnf+0x1b0>
        {
            m_arrBTDev[i]->pairId= pairId;
102c8da8:	e3e03000 	mvn	r3, #0
102c8dac:	e5823050 	str	r3, [r2, #80]	; 0x50
            callback_bt(MSG_BT_PAIR_CNF_IND, URC_BT_PAIR_CNF_SUCCESS, &bt_dev, NULL);
        }else{
            Ql_sscanf(strURC, "%*[^,],%[^\r\n]\r\n",bt_dev.addr);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            BT_DevMngmt_UpdatePairId(bt_dev.devHdl,-1);
            callback_bt(MSG_BT_PAIR_CNF_IND, URC_BT_PAIR_CNF_FAIL, NULL, NULL);
102c8db0:	e3a02000 	mov	r2, #0
102c8db4:	e596c090 	ldr	ip, [r6, #144]	; 0x90
102c8db8:	e3a00003 	mov	r0, #3
102c8dbc:	e3a01007 	mov	r1, #7
102c8dc0:	e1a03002 	mov	r3, r2
102c8dc4:	e12fff3c 	blx	ip
102c8dc8:	eaffffc9 	b	102c8cf4 <OnURCHandler_BTPairCnf+0x114>
102c8dcc:	f03d5058 	.word	0xf03d5058
102c8dd0:	102e58f4 	.word	0x102e58f4
102c8dd4:	102e6538 	.word	0x102e6538
102c8dd8:	102e55fc 	.word	0x102e55fc
102c8ddc:	102ccd58 	.word	0x102ccd58
102c8de0:	f03de548 	.word	0xf03de548
102c8de4:	102ede40 	.word	0x102ede40
102c8de8:	102ede54 	.word	0x102ede54
102c8dec:	102ee054 	.word	0x102ee054
102c8df0:	102ede68 	.word	0x102ede68
102c8df4:	102ee070 	.word	0x102ee070
102c8df8:	102e57a4 	.word	0x102e57a4
102c8dfc:	102cd1a4 	.word	0x102cd1a4
102c8e00:	102e64d8 	.word	0x102e64d8
102c8e04:	102ee088 	.word	0x102ee088
102c8e08:	102ee000 	.word	0x102ee000

102c8e0c <RIL_BT_Unpair>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_Unpair(BT_DEV_HDL hdlDevice)
{
102c8e0c:	e92d4070 	push	{r4, r5, r6, lr}
102c8e10:	e59f610c 	ldr	r6, [pc, #268]	; 102c8f24 <RIL_BT_Unpair+0x118>
102c8e14:	e24dd020 	sub	sp, sp, #32
102c8e18:	e1a04000 	mov	r4, r0
*                RIL_AT_TIMEOUT,send AT timeout.
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_Unpair(BT_DEV_HDL hdlDevice)
102c8e1c:	e2865078 	add	r5, r6, #120	; 0x78
102c8e20:	e1a03006 	mov	r3, r6
102c8e24:	ea000001 	b	102c8e30 <RIL_BT_Unpair+0x24>


s32 BT_DevMngmt_GetPairedId(const u32 hdl)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c8e28:	e1530005 	cmp	r3, r5
102c8e2c:	0a00003a 	beq	102c8f1c <RIL_BT_Unpair+0x110>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c8e30:	e5b32004 	ldr	r2, [r3, #4]!
102c8e34:	e5921000 	ldr	r1, [r2]
102c8e38:	e1540001 	cmp	r4, r1
102c8e3c:	1afffff9 	bne	102c8e28 <RIL_BT_Unpair+0x1c>
        {
            return m_arrBTDev[i]->pairId;
102c8e40:	e5922050 	ldr	r2, [r2, #80]	; 0x50
    s32  pairedId = -1 ;
    s32 ret = RIL_AT_SUCCESS ;
    
    pairedId = BT_DevMngmt_GetPairedId(hdlDevice);

    if(pairedId <=0 || pairedId >MAX_BT_PAIRED_CNT)
102c8e44:	e2423001 	sub	r3, r2, #1
102c8e48:	e3530009 	cmp	r3, #9
102c8e4c:	8a000032 	bhi	102c8f1c <RIL_BT_Unpair+0x110>
    {
        return RIL_AT_INVALID_PARAM;
    }
    
    Ql_sprintf(strAT, "AT+QBTUNPAIR=%d", pairedId);
102c8e50:	e59f30d0 	ldr	r3, [pc, #208]	; 102c8f28 <RIL_BT_Unpair+0x11c>
102c8e54:	e59f10d0 	ldr	r1, [pc, #208]	; 102c8f2c <RIL_BT_Unpair+0x120>
102c8e58:	e5933000 	ldr	r3, [r3]
102c8e5c:	e28d000c 	add	r0, sp, #12
102c8e60:	e12fff33 	blx	r3
    ret = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c8e64:	e59f30c4 	ldr	r3, [pc, #196]	; 102c8f30 <RIL_BT_Unpair+0x124>
102c8e68:	e28d000c 	add	r0, sp, #12
102c8e6c:	e12fff33 	blx	r3
102c8e70:	e3a03000 	mov	r3, #0
102c8e74:	e1a02003 	mov	r2, r3
102c8e78:	e58d3000 	str	r3, [sp]
102c8e7c:	e59fc0b0 	ldr	ip, [pc, #176]	; 102c8f34 <RIL_BT_Unpair+0x128>
102c8e80:	e1a01000 	mov	r1, r0
102c8e84:	e28d000c 	add	r0, sp, #12
102c8e88:	e12fff3c 	blx	ip


    if(RIL_AT_SUCCESS == ret)
102c8e8c:	e3500000 	cmp	r0, #0
102c8e90:	1a00001f 	bne	102c8f14 <RIL_BT_Unpair+0x108>
102c8e94:	e59f3088 	ldr	r3, [pc, #136]	; 102c8f24 <RIL_BT_Unpair+0x118>
102c8e98:	ea000001 	b	102c8ea4 <RIL_BT_Unpair+0x98>
//
// Update pair id
static void BT_DevMngmt_UpdatePairId(const u32 hdl, const s32 pairId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c8e9c:	e1530005 	cmp	r3, r5
102c8ea0:	0a000005 	beq	102c8ebc <RIL_BT_Unpair+0xb0>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c8ea4:	e5b32004 	ldr	r2, [r3, #4]!
102c8ea8:	e5921000 	ldr	r1, [r2]
102c8eac:	e1540001 	cmp	r4, r1
102c8eb0:	1afffff9 	bne	102c8e9c <RIL_BT_Unpair+0x90>
        {
            m_arrBTDev[i]->pairId= pairId;
102c8eb4:	e3e03000 	mvn	r3, #0
102c8eb8:	e5823050 	str	r3, [r2, #80]	; 0x50
    
    Ql_sprintf(strAT, "AT+QBTUNPAIR=%d", pairedId);
    ret = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);


    if(RIL_AT_SUCCESS == ret)
102c8ebc:	e59f3060 	ldr	r3, [pc, #96]	; 102c8f24 <RIL_BT_Unpair+0x118>
102c8ec0:	ea000001 	b	102c8ecc <RIL_BT_Unpair+0xc0>
//
// Update connect id
static void BT_DevMngmt_UpdateConnId(const u32 hdl, const s32 connId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c8ec4:	e1530005 	cmp	r3, r5
102c8ec8:	0a00000b 	beq	102c8efc <RIL_BT_Unpair+0xf0>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c8ecc:	e5b32004 	ldr	r2, [r3, #4]!
102c8ed0:	e5921000 	ldr	r1, [r2]
102c8ed4:	e1540001 	cmp	r4, r1
102c8ed8:	1afffff9 	bne	102c8ec4 <RIL_BT_Unpair+0xb8>
        {
            m_arrBTDev[i]->connId= connId;
102c8edc:	e3e03000 	mvn	r3, #0
102c8ee0:	e5823054 	str	r3, [r2, #84]	; 0x54
static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c8ee4:	e5b63004 	ldr	r3, [r6, #4]!
102c8ee8:	e5932000 	ldr	r2, [r3]
102c8eec:	e1540002 	cmp	r4, r2
102c8ef0:	0a000005 	beq	102c8f0c <RIL_BT_Unpair+0x100>
}

static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c8ef4:	e1560005 	cmp	r6, r5
102c8ef8:	0a000005 	beq	102c8f14 <RIL_BT_Unpair+0x108>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c8efc:	e5b63004 	ldr	r3, [r6, #4]!
102c8f00:	e5932000 	ldr	r2, [r3]
102c8f04:	e1540002 	cmp	r4, r2
102c8f08:	1afffff9 	bne	102c8ef4 <RIL_BT_Unpair+0xe8>
        {
            m_arrBTDev[i]->profileId= profileId;
102c8f0c:	e3e02000 	mvn	r2, #0
102c8f10:	e5832058 	str	r2, [r3, #88]	; 0x58
         BT_DevMngmt_UpdateConnId(hdlDevice,-1);
         BT_DevMngmt_UpdateProfileId(hdlDevice,-1);
    }

    return ret ;
}
102c8f14:	e28dd020 	add	sp, sp, #32
102c8f18:	e8bd8070 	pop	{r4, r5, r6, pc}
    
    pairedId = BT_DevMngmt_GetPairedId(hdlDevice);

    if(pairedId <=0 || pairedId >MAX_BT_PAIRED_CNT)
    {
        return RIL_AT_INVALID_PARAM;
102c8f1c:	e3e00003 	mvn	r0, #3
102c8f20:	eafffffb 	b	102c8f14 <RIL_BT_Unpair+0x108>
102c8f24:	f03d5054 	.word	0xf03d5054
102c8f28:	f03de540 	.word	0xf03de540
102c8f2c:	102ee098 	.word	0x102ee098
102c8f30:	102e57a4 	.word	0x102e57a4
102c8f34:	102e5168 	.word	0x102e5168

102c8f38 <RIL_BT_GetSupportedProfile>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetSupportedProfile(BT_DEV_HDL hdlDevice,s32 *profile_support,u8 len)
{
102c8f38:	e59f3104 	ldr	r3, [pc, #260]	; 102c9044 <RIL_BT_GetSupportedProfile+0x10c>
102c8f3c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    char strAT[20];
    s32  pairedId = -1 ;
	s32 ret;
	s32 in_profile_get[BT_PROFILE_END] = {-1};
102c8f40:	e3a0c000 	mov	ip, #0
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetSupportedProfile(BT_DEV_HDL hdlDevice,s32 *profile_support,u8 len)
{
102c8f44:	e24dd038 	sub	sp, sp, #56	; 0x38
102c8f48:	e1a06002 	mov	r6, r2
    char strAT[20];
    s32  pairedId = -1 ;
	s32 ret;
	s32 in_profile_get[BT_PROFILE_END] = {-1};
102c8f4c:	e3e02000 	mvn	r2, #0
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetSupportedProfile(BT_DEV_HDL hdlDevice,s32 *profile_support,u8 len)
{
102c8f50:	e1a07001 	mov	r7, r1
*                RIL_AT_TIMEOUT,send AT timeout.
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_GetSupportedProfile(BT_DEV_HDL hdlDevice,s32 *profile_support,u8 len)
102c8f54:	e2835078 	add	r5, r3, #120	; 0x78
{
    char strAT[20];
    s32  pairedId = -1 ;
	s32 ret;
	s32 in_profile_get[BT_PROFILE_END] = {-1};
102c8f58:	e58dc020 	str	ip, [sp, #32]
102c8f5c:	e58dc024 	str	ip, [sp, #36]	; 0x24
102c8f60:	e58dc028 	str	ip, [sp, #40]	; 0x28
102c8f64:	e58dc02c 	str	ip, [sp, #44]	; 0x2c
102c8f68:	e58dc030 	str	ip, [sp, #48]	; 0x30
102c8f6c:	e58dc034 	str	ip, [sp, #52]	; 0x34
102c8f70:	e58d201c 	str	r2, [sp, #28]
102c8f74:	ea000001 	b	102c8f80 <RIL_BT_GetSupportedProfile+0x48>


s32 BT_DevMngmt_GetPairedId(const u32 hdl)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c8f78:	e1530005 	cmp	r3, r5
102c8f7c:	0a00002e 	beq	102c903c <RIL_BT_GetSupportedProfile+0x104>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c8f80:	e5b3c004 	ldr	ip, [r3, #4]!
102c8f84:	e59c4000 	ldr	r4, [ip]
102c8f88:	e1500004 	cmp	r0, r4
102c8f8c:	1afffff9 	bne	102c8f78 <RIL_BT_GetSupportedProfile+0x40>
        {
            return m_arrBTDev[i]->pairId;
102c8f90:	e59c5050 	ldr	r5, [ip, #80]	; 0x50
	s32 ret;
	s32 in_profile_get[BT_PROFILE_END] = {-1};
    
    pairedId = BT_DevMngmt_GetPairedId(hdlDevice);

    if(pairedId <= 0 || pairedId > MAX_BT_PAIRED_CNT || NULL == profile_support || len <= 0 )
102c8f94:	e2453001 	sub	r3, r5, #1
102c8f98:	e3530009 	cmp	r3, #9
102c8f9c:	8a000026 	bhi	102c903c <RIL_BT_GetSupportedProfile+0x104>
102c8fa0:	e3570000 	cmp	r7, #0
102c8fa4:	13560000 	cmpne	r6, #0
102c8fa8:	13a04000 	movne	r4, #0
102c8fac:	03a04001 	moveq	r4, #1
102c8fb0:	0a000021 	beq	102c903c <RIL_BT_GetSupportedProfile+0x104>
    {
        return RIL_AT_INVALID_PARAM;
    }

	Ql_memset(profile_support,0,len*sizeof(profile_support[0]));
102c8fb4:	e1a08106 	lsl	r8, r6, #2
102c8fb8:	e1a01004 	mov	r1, r4
102c8fbc:	e1a02008 	mov	r2, r8
102c8fc0:	e59f3080 	ldr	r3, [pc, #128]	; 102c9048 <RIL_BT_GetSupportedProfile+0x110>
102c8fc4:	e1a00007 	mov	r0, r7
102c8fc8:	e12fff33 	blx	r3
    
    Ql_sprintf(strAT, "AT+QBTGPROF=%d", pairedId);
102c8fcc:	e59f3078 	ldr	r3, [pc, #120]	; 102c904c <RIL_BT_GetSupportedProfile+0x114>
102c8fd0:	e59f1078 	ldr	r1, [pc, #120]	; 102c9050 <RIL_BT_GetSupportedProfile+0x118>
102c8fd4:	e1a02005 	mov	r2, r5
102c8fd8:	e5933000 	ldr	r3, [r3]
102c8fdc:	e28d0008 	add	r0, sp, #8
102c8fe0:	e12fff33 	blx	r3
    ret =  Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTGPROF_Hdlr, (void *)in_profile_get, 0);
102c8fe4:	e59f3068 	ldr	r3, [pc, #104]	; 102c9054 <RIL_BT_GetSupportedProfile+0x11c>
102c8fe8:	e28d0008 	add	r0, sp, #8
102c8fec:	e12fff33 	blx	r3
102c8ff0:	e58d4000 	str	r4, [sp]
102c8ff4:	e59f205c 	ldr	r2, [pc, #92]	; 102c9058 <RIL_BT_GetSupportedProfile+0x120>
102c8ff8:	e28d301c 	add	r3, sp, #28
102c8ffc:	e59fc058 	ldr	ip, [pc, #88]	; 102c905c <RIL_BT_GetSupportedProfile+0x124>
102c9000:	e1a01000 	mov	r1, r0
102c9004:	e28d0008 	add	r0, sp, #8
102c9008:	e12fff3c 	blx	ip

	if(RIL_AT_SUCCESS == ret)
102c900c:	e2504000 	subs	r4, r0, #0
102c9010:	1a000006 	bne	102c9030 <RIL_BT_GetSupportedProfile+0xf8>
	{
	   if(len < BT_PROFILE_END)
102c9014:	e3560006 	cmp	r6, #6
	   {
	      Ql_memcpy(profile_support,in_profile_get,len*sizeof(in_profile_get[0]));
102c9018:	e1a00007 	mov	r0, r7
102c901c:	e28d101c 	add	r1, sp, #28
102c9020:	91a02008 	movls	r2, r8
	   }
	   else
	   {
	      Ql_memcpy(profile_support,in_profile_get,BT_PROFILE_END*sizeof(in_profile_get[0]));
102c9024:	83a0201c 	movhi	r2, #28
102c9028:	e59f3030 	ldr	r3, [pc, #48]	; 102c9060 <RIL_BT_GetSupportedProfile+0x128>
102c902c:	e12fff33 	blx	r3
	   }
	}
	return ret;
}
102c9030:	e1a00004 	mov	r0, r4
102c9034:	e28dd038 	add	sp, sp, #56	; 0x38
102c9038:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    
    pairedId = BT_DevMngmt_GetPairedId(hdlDevice);

    if(pairedId <= 0 || pairedId > MAX_BT_PAIRED_CNT || NULL == profile_support || len <= 0 )
    {
        return RIL_AT_INVALID_PARAM;
102c903c:	e3e04003 	mvn	r4, #3
102c9040:	eafffffa 	b	102c9030 <RIL_BT_GetSupportedProfile+0xf8>
102c9044:	f03d5054 	.word	0xf03d5054
102c9048:	102e58f4 	.word	0x102e58f4
102c904c:	f03de540 	.word	0xf03de540
102c9050:	102ee0a8 	.word	0x102ee0a8
102c9054:	102e57a4 	.word	0x102e57a4
102c9058:	102c77c8 	.word	0x102c77c8
102c905c:	102e5168 	.word	0x102e5168
102c9060:	102e597c 	.word	0x102e597c

102c9064 <RIL_BT_ConnReq>:
s32 RIL_BT_ConnReq(BT_DEV_HDL hdlDevice, u8 profileId, u8 mode)
{
    char strAT[20];
    s32 pairedId;
    
    if (profileId < BT_PROFILE_SPP || profileId >= BT_PROFILE_END)
102c9064:	e3510006 	cmp	r1, #6
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_ConnReq(BT_DEV_HDL hdlDevice, u8 profileId, u8 mode)
{
102c9068:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102c906c:	e1a03001 	mov	r3, r1
102c9070:	e24dd024 	sub	sp, sp, #36	; 0x24
102c9074:	e1a07002 	mov	r7, r2
    char strAT[20];
    s32 pairedId;
    
    if (profileId < BT_PROFILE_SPP || profileId >= BT_PROFILE_END)
102c9078:	8a000020 	bhi	102c9100 <RIL_BT_ConnReq+0x9c>
    {
        return RIL_AT_INVALID_PARAM;
    }

    if(mode < BT_SPP_CONN_MODE_AT || mode > BT_SPP_CONN_MODE_TRANS)
102c907c:	e3520002 	cmp	r2, #2
102c9080:	8a00001e 	bhi	102c9100 <RIL_BT_ConnReq+0x9c>
102c9084:	e59fc07c 	ldr	ip, [pc, #124]	; 102c9108 <RIL_BT_ConnReq+0xa4>
*                RIL_AT_TIMEOUT,send AT timeout.
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_ConnReq(BT_DEV_HDL hdlDevice, u8 profileId, u8 mode)
102c9088:	e28c6078 	add	r6, ip, #120	; 0x78
102c908c:	ea000001 	b	102c9098 <RIL_BT_ConnReq+0x34>


s32 BT_DevMngmt_GetPairedId(const u32 hdl)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9090:	e15c0006 	cmp	ip, r6
102c9094:	0a000019 	beq	102c9100 <RIL_BT_ConnReq+0x9c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9098:	e5bc4004 	ldr	r4, [ip, #4]!
102c909c:	e5945000 	ldr	r5, [r4]
102c90a0:	e1500005 	cmp	r0, r5
102c90a4:	1afffff9 	bne	102c9090 <RIL_BT_ConnReq+0x2c>
        {
            return m_arrBTDev[i]->pairId;
102c90a8:	e5942050 	ldr	r2, [r4, #80]	; 0x50
        return RIL_AT_INVALID_PARAM;
    }
    
    pairedId = BT_DevMngmt_GetPairedId(hdlDevice);

    if(pairedId <= 0 || pairedId > MAX_BT_PAIRED_CNT)
102c90ac:	e2421001 	sub	r1, r2, #1
102c90b0:	e3510009 	cmp	r1, #9
102c90b4:	8a000011 	bhi	102c9100 <RIL_BT_ConnReq+0x9c>
    {
        return RIL_AT_INVALID_PARAM;
    }

    Ql_sprintf(strAT, "AT+QBTCONN=%d,%d,%d", pairedId, profileId, mode);
102c90b8:	e59f004c 	ldr	r0, [pc, #76]	; 102c910c <RIL_BT_ConnReq+0xa8>
102c90bc:	e59f104c 	ldr	r1, [pc, #76]	; 102c9110 <RIL_BT_ConnReq+0xac>
102c90c0:	e58d7000 	str	r7, [sp]
102c90c4:	e590c000 	ldr	ip, [r0]
102c90c8:	e28d000c 	add	r0, sp, #12
102c90cc:	e12fff3c 	blx	ip
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c90d0:	e59f303c 	ldr	r3, [pc, #60]	; 102c9114 <RIL_BT_ConnReq+0xb0>
102c90d4:	e28d000c 	add	r0, sp, #12
102c90d8:	e12fff33 	blx	r3
102c90dc:	e3a03000 	mov	r3, #0
102c90e0:	e1a02003 	mov	r2, r3
102c90e4:	e58d3000 	str	r3, [sp]
102c90e8:	e59fc028 	ldr	ip, [pc, #40]	; 102c9118 <RIL_BT_ConnReq+0xb4>
102c90ec:	e1a01000 	mov	r1, r0
102c90f0:	e28d000c 	add	r0, sp, #12
102c90f4:	e12fff3c 	blx	ip
    
}
102c90f8:	e28dd024 	add	sp, sp, #36	; 0x24
102c90fc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    char strAT[20];
    s32 pairedId;
    
    if (profileId < BT_PROFILE_SPP || profileId >= BT_PROFILE_END)
    {
        return RIL_AT_INVALID_PARAM;
102c9100:	e3e00003 	mvn	r0, #3
102c9104:	eafffffb 	b	102c90f8 <RIL_BT_ConnReq+0x94>
102c9108:	f03d5054 	.word	0xf03d5054
102c910c:	f03de540 	.word	0xf03de540
102c9110:	102ee0b8 	.word	0x102ee0b8
102c9114:	102e57a4 	.word	0x102e57a4
102c9118:	102e5168 	.word	0x102e5168

102c911c <OnURCHandler_BTConn>:
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
    
}

void OnURCHandler_BTConn(const char* strURC, void* reserved)
{
102c911c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    s32 err_code = 0;
102c9120:	e3a04000 	mov	r4, #0
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
    
}

void OnURCHandler_BTConn(const char* strURC, void* reserved)
{
102c9124:	e24dd0a4 	sub	sp, sp, #164	; 0xa4
    char urcHead[30];
    ST_BT_BasicInfo bt_dev;
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));

	if(callback_bt == NULL)
102c9128:	e59f6228 	ldr	r6, [pc, #552]	; 102c9358 <OnURCHandler_BTConn+0x23c>
    s32  connId;
    char profile_name[40] = {0};
    char urcHead[30];
    ST_BT_BasicInfo bt_dev;
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c912c:	e59f3228 	ldr	r3, [pc, #552]	; 102c935c <OnURCHandler_BTConn+0x240>
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
    
}

void OnURCHandler_BTConn(const char* strURC, void* reserved)
{
102c9130:	e1a05000 	mov	r5, r0
    s32  connId;
    char profile_name[40] = {0};
    char urcHead[30];
    ST_BT_BasicInfo bt_dev;
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c9134:	e1a01004 	mov	r1, r4
102c9138:	e28d0054 	add	r0, sp, #84	; 0x54
102c913c:	e3a0204c 	mov	r2, #76	; 0x4c
    
}

void OnURCHandler_BTConn(const char* strURC, void* reserved)
{
    s32 err_code = 0;
102c9140:	e58d4004 	str	r4, [sp, #4]
    s32  connId;
    char profile_name[40] = {0};
102c9144:	e58d402c 	str	r4, [sp, #44]	; 0x2c
102c9148:	e58d4030 	str	r4, [sp, #48]	; 0x30
102c914c:	e58d4034 	str	r4, [sp, #52]	; 0x34
102c9150:	e58d4038 	str	r4, [sp, #56]	; 0x38
102c9154:	e58d403c 	str	r4, [sp, #60]	; 0x3c
102c9158:	e58d4040 	str	r4, [sp, #64]	; 0x40
102c915c:	e58d4044 	str	r4, [sp, #68]	; 0x44
102c9160:	e58d4048 	str	r4, [sp, #72]	; 0x48
102c9164:	e58d404c 	str	r4, [sp, #76]	; 0x4c
102c9168:	e58d4050 	str	r4, [sp, #80]	; 0x50
    char urcHead[30];
    ST_BT_BasicInfo bt_dev;
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c916c:	e12fff33 	blx	r3

	if(callback_bt == NULL)
102c9170:	e5963090 	ldr	r3, [r6, #144]	; 0x90
102c9174:	e1530004 	cmp	r3, r4
102c9178:	0a000036 	beq	102c9258 <OnURCHandler_BTConn+0x13c>

    
    //+QBTCONN:1,1,H60-L01,F4E3FBE47920,SPP
    //+QBTDISC:F4E3FBE47920,SPP
    //+QBTCONN:0
    Ql_strcpy(urcHead, "\r\n+QBTCONN:\0");
102c917c:	e59f11dc 	ldr	r1, [pc, #476]	; 102c9360 <OnURCHandler_BTConn+0x244>
102c9180:	e28d000c 	add	r0, sp, #12
102c9184:	e59f81d8 	ldr	r8, [pc, #472]	; 102c9364 <OnURCHandler_BTConn+0x248>
102c9188:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c918c:	e59f71d4 	ldr	r7, [pc, #468]	; 102c9368 <OnURCHandler_BTConn+0x24c>
102c9190:	e1a00005 	mov	r0, r5
102c9194:	e28d100c 	add	r1, sp, #12
102c9198:	e12fff37 	blx	r7
102c919c:	e250a000 	subs	sl, r0, #0
102c91a0:	0a00002e 	beq	102c9260 <OnURCHandler_BTConn+0x144>
    {
        Ql_sscanf(strURC, "%*[^:]: %d%*[^\r\n]\r\n", &err_code);
102c91a4:	e59f71c0 	ldr	r7, [pc, #448]	; 102c936c <OnURCHandler_BTConn+0x250>
102c91a8:	e1a00005 	mov	r0, r5
102c91ac:	e5973000 	ldr	r3, [r7]
102c91b0:	e59f11b8 	ldr	r1, [pc, #440]	; 102c9370 <OnURCHandler_BTConn+0x254>
102c91b4:	e28d2004 	add	r2, sp, #4
102c91b8:	e12fff33 	blx	r3
        if (err_code > 0)
102c91bc:	e59d3004 	ldr	r3, [sp, #4]
102c91c0:	e1530004 	cmp	r3, r4
102c91c4:	da00003a 	ble	102c92b4 <OnURCHandler_BTConn+0x198>
        {  
            //+QBTCONN:1,1,H30-T00,786A89ECCEC7,HF_PROFILE
            Ql_sscanf(strURC, "%*[^,],%d%*[^\r\n]\r\n",&connId);
102c91c8:	e28d2008 	add	r2, sp, #8
102c91cc:	e5973000 	ldr	r3, [r7]
102c91d0:	e59f119c 	ldr	r1, [pc, #412]	; 102c9374 <OnURCHandler_BTConn+0x258>
102c91d4:	e1a00005 	mov	r0, r5
102c91d8:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
102c91dc:	e28d2058 	add	r2, sp, #88	; 0x58
102c91e0:	e5973000 	ldr	r3, [r7]
102c91e4:	e59f118c 	ldr	r1, [pc, #396]	; 102c9378 <OnURCHandler_BTConn+0x25c>
102c91e8:	e1a00005 	mov	r0, r5
102c91ec:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c91f0:	e28d2090 	add	r2, sp, #144	; 0x90
102c91f4:	e5973000 	ldr	r3, [r7]
102c91f8:	e59f117c 	ldr	r1, [pc, #380]	; 102c937c <OnURCHandler_BTConn+0x260>
102c91fc:	e1a00005 	mov	r0, r5
102c9200:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%*[^,],\"%[^\"]%*[^\r\n]\r\n",profile_name);
102c9204:	e28d202c 	add	r2, sp, #44	; 0x2c
102c9208:	e59f1170 	ldr	r1, [pc, #368]	; 102c9380 <OnURCHandler_BTConn+0x264>
102c920c:	e5973000 	ldr	r3, [r7]
102c9210:	e1a00005 	mov	r0, r5
102c9214:	e12fff33 	blx	r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9218:	e59f3164 	ldr	r3, [pc, #356]	; 102c9384 <OnURCHandler_BTConn+0x268>
102c921c:	e28d0090 	add	r0, sp, #144	; 0x90
102c9220:	e12fff33 	blx	r3
102c9224:	e59f315c 	ldr	r3, [pc, #348]	; 102c9388 <OnURCHandler_BTConn+0x26c>
102c9228:	e1a01000 	mov	r1, r0
102c922c:	e28d0090 	add	r0, sp, #144	; 0x90
102c9230:	e12fff33 	blx	r3
102c9234:	e58d0054 	str	r0, [sp, #84]	; 0x54
            RIL_BT_QueryState(NULL);
102c9238:	e1a00004 	mov	r0, r4
102c923c:	ebfffd3b 	bl	102c8730 <RIL_BT_QueryState>
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_SUCCESS, &bt_dev, NULL);
102c9240:	e3a00008 	mov	r0, #8
102c9244:	e596c090 	ldr	ip, [r6, #144]	; 0x90
102c9248:	e1a01000 	mov	r1, r0
102c924c:	e28d2054 	add	r2, sp, #84	; 0x54
102c9250:	e1a03004 	mov	r3, r4
102c9254:	e12fff3c 	blx	ip
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", err_code);
        callback_bt(MSG_BT_SPP_CONN_IND, err_code, NULL, NULL);
        return;
    }
}
102c9258:	e28dd0a4 	add	sp, sp, #164	; 0xa4
102c925c:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_FAIL, NULL, NULL);
        }
        return;
    }

    Ql_strcpy(urcHead, "+CME ERROR:\0");
102c9260:	e59f1124 	ldr	r1, [pc, #292]	; 102c938c <OnURCHandler_BTConn+0x270>
102c9264:	e28d000c 	add	r0, sp, #12
102c9268:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c926c:	e1a00005 	mov	r0, r5
102c9270:	e28d100c 	add	r1, sp, #12
102c9274:	e12fff37 	blx	r7
102c9278:	e3500000 	cmp	r0, #0
102c927c:	0afffff5 	beq	102c9258 <OnURCHandler_BTConn+0x13c>
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", err_code);
102c9280:	e59f30e4 	ldr	r3, [pc, #228]	; 102c936c <OnURCHandler_BTConn+0x250>
102c9284:	e59d2004 	ldr	r2, [sp, #4]
102c9288:	e59f1100 	ldr	r1, [pc, #256]	; 102c9390 <OnURCHandler_BTConn+0x274>
102c928c:	e5933000 	ldr	r3, [r3]
102c9290:	e1a00005 	mov	r0, r5
102c9294:	e12fff33 	blx	r3
        callback_bt(MSG_BT_SPP_CONN_IND, err_code, NULL, NULL);
102c9298:	e1a0200a 	mov	r2, sl
102c929c:	e596c090 	ldr	ip, [r6, #144]	; 0x90
102c92a0:	e3a00008 	mov	r0, #8
102c92a4:	e59d1004 	ldr	r1, [sp, #4]
102c92a8:	e1a0300a 	mov	r3, sl
102c92ac:	e12fff3c 	blx	ip
102c92b0:	eaffffe8 	b	102c9258 <OnURCHandler_BTConn+0x13c>
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%*[^,],\"%[^\"]%*[^\r\n]\r\n",profile_name);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            RIL_BT_QueryState(NULL);
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_SUCCESS, &bt_dev, NULL);
        }else{
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c92b4:	e28d2090 	add	r2, sp, #144	; 0x90
102c92b8:	e59f10bc 	ldr	r1, [pc, #188]	; 102c937c <OnURCHandler_BTConn+0x260>
102c92bc:	e5973000 	ldr	r3, [r7]
102c92c0:	e1a00005 	mov	r0, r5
102c92c4:	e12fff33 	blx	r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c92c8:	e59f30b4 	ldr	r3, [pc, #180]	; 102c9384 <OnURCHandler_BTConn+0x268>
102c92cc:	e28d0090 	add	r0, sp, #144	; 0x90
102c92d0:	e12fff33 	blx	r3
102c92d4:	e59f30ac 	ldr	r3, [pc, #172]	; 102c9388 <OnURCHandler_BTConn+0x26c>
102c92d8:	e1a01000 	mov	r1, r0
102c92dc:	e28d0090 	add	r0, sp, #144	; 0x90
102c92e0:	e12fff33 	blx	r3
102c92e4:	e2463004 	sub	r3, r6, #4
    Ql_sprintf(strAT, "AT+QBTCONN=%d,%d,%d", pairedId, profileId, mode);
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
    
}

void OnURCHandler_BTConn(const char* strURC, void* reserved)
102c92e8:	e286e074 	add	lr, r6, #116	; 0x74
102c92ec:	e1a02003 	mov	r2, r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            RIL_BT_QueryState(NULL);
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_SUCCESS, &bt_dev, NULL);
        }else{
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c92f0:	e58d0054 	str	r0, [sp, #84]	; 0x54
102c92f4:	ea000001 	b	102c9300 <OnURCHandler_BTConn+0x1e4>
//
// Update connect id
static void BT_DevMngmt_UpdateConnId(const u32 hdl, const s32 connId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c92f8:	e152000e 	cmp	r2, lr
102c92fc:	0a000008 	beq	102c9324 <OnURCHandler_BTConn+0x208>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9300:	e5b21004 	ldr	r1, [r2, #4]!
102c9304:	e591c000 	ldr	ip, [r1]
102c9308:	e150000c 	cmp	r0, ip
102c930c:	1afffff9 	bne	102c92f8 <OnURCHandler_BTConn+0x1dc>
        {
            m_arrBTDev[i]->connId= connId;
102c9310:	e3e02000 	mvn	r2, #0
102c9314:	e5812054 	str	r2, [r1, #84]	; 0x54
102c9318:	ea000001 	b	102c9324 <OnURCHandler_BTConn+0x208>
}

static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c931c:	e153000e 	cmp	r3, lr
102c9320:	0a000005 	beq	102c933c <OnURCHandler_BTConn+0x220>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9324:	e5b32004 	ldr	r2, [r3, #4]!
102c9328:	e5921000 	ldr	r1, [r2]
102c932c:	e1500001 	cmp	r0, r1
102c9330:	1afffff9 	bne	102c931c <OnURCHandler_BTConn+0x200>
        {
            m_arrBTDev[i]->profileId= profileId;
102c9334:	e3e03000 	mvn	r3, #0
102c9338:	e5823058 	str	r3, [r2, #88]	; 0x58
        }else{
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            BT_DevMngmt_UpdateConnId(bt_dev.devHdl, -1);
            BT_DevMngmt_UpdateProfileId(bt_dev.devHdl,-1);
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_FAIL, NULL, NULL);
102c933c:	e3a02000 	mov	r2, #0
102c9340:	e596c090 	ldr	ip, [r6, #144]	; 0x90
102c9344:	e3a00008 	mov	r0, #8
102c9348:	e3a01009 	mov	r1, #9
102c934c:	e1a03002 	mov	r3, r2
102c9350:	e12fff3c 	blx	ip
102c9354:	eaffffbf 	b	102c9258 <OnURCHandler_BTConn+0x13c>
102c9358:	f03d5058 	.word	0xf03d5058
102c935c:	102e58f4 	.word	0x102e58f4
102c9360:	102e6548 	.word	0x102e6548
102c9364:	102e55fc 	.word	0x102e55fc
102c9368:	102ccd58 	.word	0x102ccd58
102c936c:	f03de548 	.word	0xf03de548
102c9370:	102ede40 	.word	0x102ede40
102c9374:	102ede54 	.word	0x102ede54
102c9378:	102ede68 	.word	0x102ede68
102c937c:	102ee0cc 	.word	0x102ee0cc
102c9380:	102ee0f0 	.word	0x102ee0f0
102c9384:	102e57a4 	.word	0x102e57a4
102c9388:	102cd1a4 	.word	0x102cd1a4
102c938c:	102e64d8 	.word	0x102e64d8
102c9390:	102ede14 	.word	0x102ede14

102c9394 <RIL_BT_SPP_DirectConn>:
s32 RIL_BT_SPP_DirectConn(char* btMacAddr, u8 mode, char* pinCode)
{

    char strAT[20];

    if(NULL == btMacAddr)
102c9394:	e3500000 	cmp	r0, #0
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SPP_DirectConn(char* btMacAddr, u8 mode, char* pinCode)
{
102c9398:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102c939c:	e1a03001 	mov	r3, r1
102c93a0:	e24dd024 	sub	sp, sp, #36	; 0x24
102c93a4:	e1a0c002 	mov	ip, r2

    char strAT[20];

    if(NULL == btMacAddr)
102c93a8:	0a000014 	beq	102c9400 <RIL_BT_SPP_DirectConn+0x6c>
    {
        return RIL_AT_INVALID_PARAM;
    }
    
    if(mode < BT_SPP_CONN_MODE_AT || mode > BT_SPP_CONN_MODE_TRANS)
102c93ac:	e3510002 	cmp	r1, #2
102c93b0:	8a000012 	bhi	102c9400 <RIL_BT_SPP_DirectConn+0x6c>
    {
        return RIL_AT_INVALID_PARAM;
    }
    
    Ql_sprintf(strAT, "AT+QBTCONND=%s,%d,\"%s\"", btMacAddr, mode, pinCode);
102c93b4:	e1a02000 	mov	r2, r0
102c93b8:	e59f0048 	ldr	r0, [pc, #72]	; 102c9408 <RIL_BT_SPP_DirectConn+0x74>
102c93bc:	e59f1048 	ldr	r1, [pc, #72]	; 102c940c <RIL_BT_SPP_DirectConn+0x78>
102c93c0:	e58dc000 	str	ip, [sp]
102c93c4:	e590c000 	ldr	ip, [r0]
102c93c8:	e28d000c 	add	r0, sp, #12
102c93cc:	e12fff3c 	blx	ip
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), AtRsp_QBTCONND_Hdlr, NULL, 0);
102c93d0:	e59f3038 	ldr	r3, [pc, #56]	; 102c9410 <RIL_BT_SPP_DirectConn+0x7c>
102c93d4:	e28d000c 	add	r0, sp, #12
102c93d8:	e12fff33 	blx	r3
102c93dc:	e3a03000 	mov	r3, #0
102c93e0:	e58d3000 	str	r3, [sp]
102c93e4:	e59f2028 	ldr	r2, [pc, #40]	; 102c9414 <RIL_BT_SPP_DirectConn+0x80>
102c93e8:	e59fc028 	ldr	ip, [pc, #40]	; 102c9418 <RIL_BT_SPP_DirectConn+0x84>
102c93ec:	e1a01000 	mov	r1, r0
102c93f0:	e28d000c 	add	r0, sp, #12
102c93f4:	e12fff3c 	blx	ip
}
102c93f8:	e28dd024 	add	sp, sp, #36	; 0x24
102c93fc:	e8bd8000 	ldmfd	sp!, {pc}

    char strAT[20];

    if(NULL == btMacAddr)
    {
        return RIL_AT_INVALID_PARAM;
102c9400:	e3e00003 	mvn	r0, #3
102c9404:	eafffffb 	b	102c93f8 <RIL_BT_SPP_DirectConn+0x64>
102c9408:	f03de540 	.word	0xf03de540
102c940c:	102ee11c 	.word	0x102ee11c
102c9410:	102e57a4 	.word	0x102e57a4
102c9414:	102c716c 	.word	0x102c716c
102c9418:	102e5168 	.word	0x102e5168

102c941c <RIL_BT_ConnAccept>:
*****************************************************************/
s32 RIL_BT_ConnAccept(bool accept , u8 mode)
{
    char strAT[20];

    if(accept != 0 && accept != 1)
102c941c:	e3500001 	cmp	r0, #1
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_ConnAccept(bool accept , u8 mode)
{
102c9420:	e92d4010 	push	{r4, lr}
102c9424:	e1a02001 	mov	r2, r1
102c9428:	e24dd020 	sub	sp, sp, #32
    char strAT[20];

    if(accept != 0 && accept != 1)
102c942c:	8a000015 	bhi	102c9488 <RIL_BT_ConnAccept+0x6c>
    {
        return RIL_AT_INVALID_PARAM;
    }

    if(mode < BT_SPP_CONN_MODE_AT || mode > BT_SPP_CONN_MODE_TRANS)
102c9430:	e3510002 	cmp	r1, #2
102c9434:	8a000013 	bhi	102c9488 <RIL_BT_ConnAccept+0x6c>
        return RIL_AT_INVALID_PARAM;
    }
    
    if(1 == accept)
    {
        Ql_sprintf(strAT, "AT+QBTACPT=1,%d", mode);
102c9438:	e59f3050 	ldr	r3, [pc, #80]	; 102c9490 <RIL_BT_ConnAccept+0x74>
    if(mode < BT_SPP_CONN_MODE_AT || mode > BT_SPP_CONN_MODE_TRANS)
    {
        return RIL_AT_INVALID_PARAM;
    }
    
    if(1 == accept)
102c943c:	e3500001 	cmp	r0, #1
    {
        Ql_sprintf(strAT, "AT+QBTACPT=1,%d", mode);
102c9440:	e28d400c 	add	r4, sp, #12
102c9444:	059f1048 	ldreq	r1, [pc, #72]	; 102c9494 <RIL_BT_ConnAccept+0x78>
    }
    else
    {
        Ql_sprintf(strAT, "AT+QBTACPT=0", mode);
102c9448:	159f1048 	ldrne	r1, [pc, #72]	; 102c9498 <RIL_BT_ConnAccept+0x7c>
        return RIL_AT_INVALID_PARAM;
    }
    
    if(1 == accept)
    {
        Ql_sprintf(strAT, "AT+QBTACPT=1,%d", mode);
102c944c:	e5933000 	ldr	r3, [r3]
102c9450:	e1a00004 	mov	r0, r4
    }
    else
    {
        Ql_sprintf(strAT, "AT+QBTACPT=0", mode);
102c9454:	e12fff33 	blx	r3
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c9458:	e59f303c 	ldr	r3, [pc, #60]	; 102c949c <RIL_BT_ConnAccept+0x80>
102c945c:	e1a00004 	mov	r0, r4
102c9460:	e12fff33 	blx	r3
102c9464:	e3a03000 	mov	r3, #0
102c9468:	e1a02003 	mov	r2, r3
102c946c:	e58d3000 	str	r3, [sp]
102c9470:	e59fc028 	ldr	ip, [pc, #40]	; 102c94a0 <RIL_BT_ConnAccept+0x84>
102c9474:	e1a01000 	mov	r1, r0
102c9478:	e1a00004 	mov	r0, r4
102c947c:	e12fff3c 	blx	ip
}
102c9480:	e28dd020 	add	sp, sp, #32
102c9484:	e8bd8010 	pop	{r4, pc}
{
    char strAT[20];

    if(accept != 0 && accept != 1)
    {
        return RIL_AT_INVALID_PARAM;
102c9488:	e3e00003 	mvn	r0, #3
102c948c:	eafffffb 	b	102c9480 <RIL_BT_ConnAccept+0x64>
102c9490:	f03de540 	.word	0xf03de540
102c9494:	102ee134 	.word	0x102ee134
102c9498:	102ee144 	.word	0x102ee144
102c949c:	102e57a4 	.word	0x102e57a4
102c94a0:	102e5168 	.word	0x102e5168

102c94a4 <OnURCHandler_BTConnCnf>:
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTConnCnf(const char* strURC, void* reserved)
{
102c94a4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    s32 err_code = 0;
102c94a8:	e3a04000 	mov	r4, #0
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTConnCnf(const char* strURC, void* reserved)
{
102c94ac:	e24dd0a0 	sub	sp, sp, #160	; 0xa0
    //s32 profileId;
    ST_BT_BasicInfo bt_dev;
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));

	if(callback_bt == NULL)
102c94b0:	e59f52dc 	ldr	r5, [pc, #732]	; 102c9794 <OnURCHandler_BTConnCnf+0x2f0>
    char urcHead[30];
    char profile_name[40] = {0};
    //s32 profileId;
    ST_BT_BasicInfo bt_dev;
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c94b4:	e59f32dc 	ldr	r3, [pc, #732]	; 102c9798 <OnURCHandler_BTConnCnf+0x2f4>
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTConnCnf(const char* strURC, void* reserved)
{
102c94b8:	e1a06000 	mov	r6, r0
    char urcHead[30];
    char profile_name[40] = {0};
    //s32 profileId;
    ST_BT_BasicInfo bt_dev;
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c94bc:	e1a01004 	mov	r1, r4
102c94c0:	e28d0054 	add	r0, sp, #84	; 0x54
102c94c4:	e3a0204c 	mov	r2, #76	; 0x4c
}


void OnURCHandler_BTConnCnf(const char* strURC, void* reserved)
{
    s32 err_code = 0;
102c94c8:	e58d4004 	str	r4, [sp, #4]
    s32  connId;
    char urcHead[30];
    char profile_name[40] = {0};
102c94cc:	e58d402c 	str	r4, [sp, #44]	; 0x2c
102c94d0:	e58d4030 	str	r4, [sp, #48]	; 0x30
102c94d4:	e58d4034 	str	r4, [sp, #52]	; 0x34
102c94d8:	e58d4038 	str	r4, [sp, #56]	; 0x38
102c94dc:	e58d403c 	str	r4, [sp, #60]	; 0x3c
102c94e0:	e58d4040 	str	r4, [sp, #64]	; 0x40
102c94e4:	e58d4044 	str	r4, [sp, #68]	; 0x44
102c94e8:	e58d4048 	str	r4, [sp, #72]	; 0x48
102c94ec:	e58d404c 	str	r4, [sp, #76]	; 0x4c
102c94f0:	e58d4050 	str	r4, [sp, #80]	; 0x50
    //s32 profileId;
    ST_BT_BasicInfo bt_dev;
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c94f4:	e12fff33 	blx	r3

	if(callback_bt == NULL)
102c94f8:	e5953090 	ldr	r3, [r5, #144]	; 0x90
102c94fc:	e1530004 	cmp	r3, r4
102c9500:	0a000036 	beq	102c95e0 <OnURCHandler_BTConnCnf+0x13c>
    // AT+QBTACPT=1
    //+QBTACPT:1,2,H60-L01,F4E3FBE47920,SPP
    //
    // AT+QBTACPT=0
    //+QBTDISC:F4E3FBE47920,SPP
    Ql_strcpy(urcHead, "\r\n+QBTACPT:\0");
102c9504:	e59f1290 	ldr	r1, [pc, #656]	; 102c979c <OnURCHandler_BTConnCnf+0x2f8>
102c9508:	e28d000c 	add	r0, sp, #12
102c950c:	e59f828c 	ldr	r8, [pc, #652]	; 102c97a0 <OnURCHandler_BTConnCnf+0x2fc>
102c9510:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c9514:	e59f7288 	ldr	r7, [pc, #648]	; 102c97a4 <OnURCHandler_BTConnCnf+0x300>
102c9518:	e1a00006 	mov	r0, r6
102c951c:	e28d100c 	add	r1, sp, #12
102c9520:	e12fff37 	blx	r7
102c9524:	e1500004 	cmp	r0, r4
102c9528:	0a00002e 	beq	102c95e8 <OnURCHandler_BTConnCnf+0x144>
    {// Response for succeeding in connecting
        Ql_sscanf(strURC, "%*[^:]: %d[^\r\n]\r\n", &err_code);
102c952c:	e59f7274 	ldr	r7, [pc, #628]	; 102c97a8 <OnURCHandler_BTConnCnf+0x304>
102c9530:	e1a00006 	mov	r0, r6
102c9534:	e5973000 	ldr	r3, [r7]
102c9538:	e59f126c 	ldr	r1, [pc, #620]	; 102c97ac <OnURCHandler_BTConnCnf+0x308>
102c953c:	e28d2004 	add	r2, sp, #4
102c9540:	e12fff33 	blx	r3
        if (err_code > 0)
102c9544:	e59d3004 	ldr	r3, [sp, #4]
102c9548:	e1530004 	cmp	r3, r4
102c954c:	da00006f 	ble	102c9710 <OnURCHandler_BTConnCnf+0x26c>
        {
            Ql_sscanf(strURC, "%*[^,],%d%*[^\r\n]\r\n",&connId);
102c9550:	e28d2008 	add	r2, sp, #8
102c9554:	e5973000 	ldr	r3, [r7]
102c9558:	e59f1250 	ldr	r1, [pc, #592]	; 102c97b0 <OnURCHandler_BTConnCnf+0x30c>
102c955c:	e1a00006 	mov	r0, r6
102c9560:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^\"]%[^\"]%*[^\r\n]\r\n",bt_dev.name);
102c9564:	e28d2058 	add	r2, sp, #88	; 0x58
102c9568:	e5973000 	ldr	r3, [r7]
102c956c:	e59f1240 	ldr	r1, [pc, #576]	; 102c97b4 <OnURCHandler_BTConnCnf+0x310>
102c9570:	e1a00006 	mov	r0, r6
102c9574:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c9578:	e28d2090 	add	r2, sp, #144	; 0x90
102c957c:	e5973000 	ldr	r3, [r7]
102c9580:	e59f1230 	ldr	r1, [pc, #560]	; 102c97b8 <OnURCHandler_BTConnCnf+0x314>
102c9584:	e1a00006 	mov	r0, r6
102c9588:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%*[^,],\"%[^\"]%*[^\r\n]\r\n",profile_name);
102c958c:	e28d202c 	add	r2, sp, #44	; 0x2c
102c9590:	e59f1224 	ldr	r1, [pc, #548]	; 102c97bc <OnURCHandler_BTConnCnf+0x318>
102c9594:	e5973000 	ldr	r3, [r7]
102c9598:	e1a00006 	mov	r0, r6
102c959c:	e12fff33 	blx	r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c95a0:	e59f3218 	ldr	r3, [pc, #536]	; 102c97c0 <OnURCHandler_BTConnCnf+0x31c>
102c95a4:	e28d0090 	add	r0, sp, #144	; 0x90
102c95a8:	e12fff33 	blx	r3
102c95ac:	e59f3210 	ldr	r3, [pc, #528]	; 102c97c4 <OnURCHandler_BTConnCnf+0x320>
102c95b0:	e1a01000 	mov	r1, r0
102c95b4:	e28d0090 	add	r0, sp, #144	; 0x90
102c95b8:	e12fff33 	blx	r3
102c95bc:	e58d0054 	str	r0, [sp, #84]	; 0x54
            RIL_BT_QueryState(NULL);
102c95c0:	e1a00004 	mov	r0, r4
102c95c4:	ebfffc59 	bl	102c8730 <RIL_BT_QueryState>
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_SUCCESS, &bt_dev, NULL);
102c95c8:	e3a00008 	mov	r0, #8
102c95cc:	e595c090 	ldr	ip, [r5, #144]	; 0x90
102c95d0:	e1a01000 	mov	r1, r0
102c95d4:	e28d2054 	add	r2, sp, #84	; 0x54
102c95d8:	e1a03004 	mov	r3, r4
102c95dc:	e12fff3c 	blx	ip
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", err_code);
        callback_bt(MSG_BT_SPP_CONN_IND, err_code, NULL, NULL);
        return;
    }
}
102c95e0:	e28dd0a0 	add	sp, sp, #160	; 0xa0
102c95e4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            BT_DevMngmt_UpdateProfileId(bt_dev.devHdl,-1);
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_FAIL, NULL, NULL);
        }
        return;
    }
    Ql_strcpy(urcHead, "\r\n+QBTDISC:\0");
102c95e8:	e59f11d8 	ldr	r1, [pc, #472]	; 102c97c8 <OnURCHandler_BTConnCnf+0x324>
102c95ec:	e28d000c 	add	r0, sp, #12
102c95f0:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c95f4:	e1a00006 	mov	r0, r6
102c95f8:	e28d100c 	add	r1, sp, #12
102c95fc:	e12fff37 	blx	r7
102c9600:	e2504000 	subs	r4, r0, #0
102c9604:	0a00002c 	beq	102c96bc <OnURCHandler_BTConnCnf+0x218>
    {// Fail to connect or reject connection req
        Ql_sscanf(strURC, "%*[^:]: %[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c9608:	e59f3198 	ldr	r3, [pc, #408]	; 102c97a8 <OnURCHandler_BTConnCnf+0x304>
102c960c:	e28d2090 	add	r2, sp, #144	; 0x90
102c9610:	e59f11b4 	ldr	r1, [pc, #436]	; 102c97cc <OnURCHandler_BTConnCnf+0x328>
102c9614:	e5933000 	ldr	r3, [r3]
102c9618:	e1a00006 	mov	r0, r6
102c961c:	e12fff33 	blx	r3
        bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9620:	e59f3198 	ldr	r3, [pc, #408]	; 102c97c0 <OnURCHandler_BTConnCnf+0x31c>
102c9624:	e28d0090 	add	r0, sp, #144	; 0x90
102c9628:	e12fff33 	blx	r3
102c962c:	e59f3190 	ldr	r3, [pc, #400]	; 102c97c4 <OnURCHandler_BTConnCnf+0x320>
102c9630:	e1a01000 	mov	r1, r0
102c9634:	e28d0090 	add	r0, sp, #144	; 0x90
102c9638:	e12fff33 	blx	r3
102c963c:	e2453004 	sub	r3, r5, #4
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTConnCnf(const char* strURC, void* reserved)
102c9640:	e285e074 	add	lr, r5, #116	; 0x74
102c9644:	e1a02003 	mov	r2, r3
    }
    Ql_strcpy(urcHead, "\r\n+QBTDISC:\0");
    if (Ql_StrPrefixMatch(strURC, urcHead))
    {// Fail to connect or reject connection req
        Ql_sscanf(strURC, "%*[^:]: %[^,]%*[^\r\n]\r\n",bt_dev.addr);
        bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9648:	e58d0054 	str	r0, [sp, #84]	; 0x54
102c964c:	ea000001 	b	102c9658 <OnURCHandler_BTConnCnf+0x1b4>
//
// Update connect id
static void BT_DevMngmt_UpdateConnId(const u32 hdl, const s32 connId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9650:	e152000e 	cmp	r2, lr
102c9654:	0a00000b 	beq	102c9688 <OnURCHandler_BTConnCnf+0x1e4>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9658:	e5b21004 	ldr	r1, [r2, #4]!
102c965c:	e591c000 	ldr	ip, [r1]
102c9660:	e150000c 	cmp	r0, ip
102c9664:	1afffff9 	bne	102c9650 <OnURCHandler_BTConnCnf+0x1ac>
        {
            m_arrBTDev[i]->connId= connId;
102c9668:	e3e02000 	mvn	r2, #0
102c966c:	e5812054 	str	r2, [r1, #84]	; 0x54
static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9670:	e5b32004 	ldr	r2, [r3, #4]!
102c9674:	e5921000 	ldr	r1, [r2]
102c9678:	e1500001 	cmp	r0, r1
102c967c:	0a000005 	beq	102c9698 <OnURCHandler_BTConnCnf+0x1f4>
}

static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9680:	e153000e 	cmp	r3, lr
102c9684:	0a000005 	beq	102c96a0 <OnURCHandler_BTConnCnf+0x1fc>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9688:	e5b32004 	ldr	r2, [r3, #4]!
102c968c:	e5921000 	ldr	r1, [r2]
102c9690:	e1500001 	cmp	r0, r1
102c9694:	1afffff9 	bne	102c9680 <OnURCHandler_BTConnCnf+0x1dc>
        {
            m_arrBTDev[i]->profileId= profileId;
102c9698:	e3e03000 	mvn	r3, #0
102c969c:	e5823058 	str	r3, [r2, #88]	; 0x58
    {// Fail to connect or reject connection req
        Ql_sscanf(strURC, "%*[^:]: %[^,]%*[^\r\n]\r\n",bt_dev.addr);
        bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
        BT_DevMngmt_UpdateConnId(bt_dev.devHdl, -1);
        BT_DevMngmt_UpdateProfileId(bt_dev.devHdl,-1);
        callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_FAIL, NULL, NULL);
102c96a0:	e3a02000 	mov	r2, #0
102c96a4:	e595c090 	ldr	ip, [r5, #144]	; 0x90
102c96a8:	e3a00008 	mov	r0, #8
102c96ac:	e3a01009 	mov	r1, #9
102c96b0:	e1a03002 	mov	r3, r2
102c96b4:	e12fff3c 	blx	ip
102c96b8:	eaffffc8 	b	102c95e0 <OnURCHandler_BTConnCnf+0x13c>
        return;
    }

    Ql_strcpy(urcHead, "+CME ERROR:\0");
102c96bc:	e59f110c 	ldr	r1, [pc, #268]	; 102c97d0 <OnURCHandler_BTConnCnf+0x32c>
102c96c0:	e28d000c 	add	r0, sp, #12
102c96c4:	e12fff38 	blx	r8
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c96c8:	e1a00006 	mov	r0, r6
102c96cc:	e28d100c 	add	r1, sp, #12
102c96d0:	e12fff37 	blx	r7
102c96d4:	e3500000 	cmp	r0, #0
102c96d8:	0affffc0 	beq	102c95e0 <OnURCHandler_BTConnCnf+0x13c>
    {
        Ql_sscanf(strURC, "%*[^:]: %d\r\n", err_code);
102c96dc:	e59f30c4 	ldr	r3, [pc, #196]	; 102c97a8 <OnURCHandler_BTConnCnf+0x304>
102c96e0:	e59d2004 	ldr	r2, [sp, #4]
102c96e4:	e59f10e8 	ldr	r1, [pc, #232]	; 102c97d4 <OnURCHandler_BTConnCnf+0x330>
102c96e8:	e5933000 	ldr	r3, [r3]
102c96ec:	e1a00006 	mov	r0, r6
102c96f0:	e12fff33 	blx	r3
        callback_bt(MSG_BT_SPP_CONN_IND, err_code, NULL, NULL);
102c96f4:	e1a02004 	mov	r2, r4
102c96f8:	e595c090 	ldr	ip, [r5, #144]	; 0x90
102c96fc:	e3a00008 	mov	r0, #8
102c9700:	e59d1004 	ldr	r1, [sp, #4]
102c9704:	e1a03004 	mov	r3, r4
102c9708:	e12fff3c 	blx	ip
102c970c:	eaffffb3 	b	102c95e0 <OnURCHandler_BTConnCnf+0x13c>
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%*[^,],\"%[^\"]%*[^\r\n]\r\n",profile_name);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            RIL_BT_QueryState(NULL);
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_SUCCESS, &bt_dev, NULL);
        }else{
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c9710:	e28d2090 	add	r2, sp, #144	; 0x90
102c9714:	e59f109c 	ldr	r1, [pc, #156]	; 102c97b8 <OnURCHandler_BTConnCnf+0x314>
102c9718:	e5973000 	ldr	r3, [r7]
102c971c:	e1a00006 	mov	r0, r6
102c9720:	e12fff33 	blx	r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9724:	e59f3094 	ldr	r3, [pc, #148]	; 102c97c0 <OnURCHandler_BTConnCnf+0x31c>
102c9728:	e28d0090 	add	r0, sp, #144	; 0x90
102c972c:	e12fff33 	blx	r3
102c9730:	e59f308c 	ldr	r3, [pc, #140]	; 102c97c4 <OnURCHandler_BTConnCnf+0x320>
102c9734:	e1a01000 	mov	r1, r0
102c9738:	e28d0090 	add	r0, sp, #144	; 0x90
102c973c:	e12fff33 	blx	r3
102c9740:	e2453004 	sub	r3, r5, #4
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}


void OnURCHandler_BTConnCnf(const char* strURC, void* reserved)
102c9744:	e285e074 	add	lr, r5, #116	; 0x74
102c9748:	e1a02003 	mov	r2, r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            RIL_BT_QueryState(NULL);
            callback_bt(MSG_BT_SPP_CONN_IND, URC_BT_CONN_SUCCESS, &bt_dev, NULL);
        }else{
            Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c974c:	e58d0054 	str	r0, [sp, #84]	; 0x54
102c9750:	ea000001 	b	102c975c <OnURCHandler_BTConnCnf+0x2b8>
//
// Update connect id
static void BT_DevMngmt_UpdateConnId(const u32 hdl, const s32 connId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9754:	e152000e 	cmp	r2, lr
102c9758:	0a000008 	beq	102c9780 <OnURCHandler_BTConnCnf+0x2dc>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c975c:	e5b21004 	ldr	r1, [r2, #4]!
102c9760:	e591c000 	ldr	ip, [r1]
102c9764:	e150000c 	cmp	r0, ip
102c9768:	1afffff9 	bne	102c9754 <OnURCHandler_BTConnCnf+0x2b0>
        {
            m_arrBTDev[i]->connId= connId;
102c976c:	e3e02000 	mvn	r2, #0
102c9770:	e5812054 	str	r2, [r1, #84]	; 0x54
102c9774:	ea000001 	b	102c9780 <OnURCHandler_BTConnCnf+0x2dc>
}

static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9778:	e153000e 	cmp	r3, lr
102c977c:	0affffc7 	beq	102c96a0 <OnURCHandler_BTConnCnf+0x1fc>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9780:	e5b32004 	ldr	r2, [r3, #4]!
102c9784:	e5921000 	ldr	r1, [r2]
102c9788:	e1500001 	cmp	r0, r1
102c978c:	1afffff9 	bne	102c9778 <OnURCHandler_BTConnCnf+0x2d4>
102c9790:	eaffffc0 	b	102c9698 <OnURCHandler_BTConnCnf+0x1f4>
102c9794:	f03d5058 	.word	0xf03d5058
102c9798:	102e58f4 	.word	0x102e58f4
102c979c:	102e6558 	.word	0x102e6558
102c97a0:	102e55fc 	.word	0x102e55fc
102c97a4:	102ccd58 	.word	0x102ccd58
102c97a8:	f03de548 	.word	0xf03de548
102c97ac:	102edf08 	.word	0x102edf08
102c97b0:	102ede54 	.word	0x102ede54
102c97b4:	102ee154 	.word	0x102ee154
102c97b8:	102ee0cc 	.word	0x102ee0cc
102c97bc:	102ee0f0 	.word	0x102ee0f0
102c97c0:	102e57a4 	.word	0x102e57a4
102c97c4:	102cd1a4 	.word	0x102cd1a4
102c97c8:	102e6568 	.word	0x102e6568
102c97cc:	102ee16c 	.word	0x102ee16c
102c97d0:	102e64d8 	.word	0x102e64d8
102c97d4:	102ede14 	.word	0x102ede14

102c97d8 <RIL_BT_Disconnect>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_Disconnect(BT_DEV_HDL hdlDevice)
{
102c97d8:	e59f3084 	ldr	r3, [pc, #132]	; 102c9864 <RIL_BT_Disconnect+0x8c>
102c97dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
*                RIL_AT_TIMEOUT,send AT timeout.
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_Disconnect(BT_DEV_HDL hdlDevice)
102c97e0:	e283c078 	add	ip, r3, #120	; 0x78
{
102c97e4:	e24dd024 	sub	sp, sp, #36	; 0x24
102c97e8:	ea000001 	b	102c97f4 <RIL_BT_Disconnect+0x1c>
    return 0;
}
s32 BT_DevMngmt_GetConnId(const u32 hdl)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c97ec:	e153000c 	cmp	r3, ip
102c97f0:	0a000017 	beq	102c9854 <RIL_BT_Disconnect+0x7c>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c97f4:	e5b32004 	ldr	r2, [r3, #4]!
102c97f8:	e5921000 	ldr	r1, [r2]
102c97fc:	e1500001 	cmp	r0, r1
102c9800:	1afffff9 	bne	102c97ec <RIL_BT_Disconnect+0x14>
        {
            return m_arrBTDev[i]->connId;
102c9804:	e5922054 	ldr	r2, [r2, #84]	; 0x54
    char strAT[20];
    s32  connId ;
    
    connId = BT_DevMngmt_GetConnId(hdlDevice);

    if(-1 == connId)
102c9808:	e3720001 	cmn	r2, #1
102c980c:	0a000012 	beq	102c985c <RIL_BT_Disconnect+0x84>
    {
        return RIL_AT_INVALID_PARAM ;
    }
    
    Ql_sprintf(strAT, "AT+QBTDISCONN=%d", connId);
102c9810:	e59f3050 	ldr	r3, [pc, #80]	; 102c9868 <RIL_BT_Disconnect+0x90>
102c9814:	e59f1050 	ldr	r1, [pc, #80]	; 102c986c <RIL_BT_Disconnect+0x94>
102c9818:	e5933000 	ldr	r3, [r3]
102c981c:	e28d000c 	add	r0, sp, #12
102c9820:	e12fff33 	blx	r3
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102c9824:	e59f3044 	ldr	r3, [pc, #68]	; 102c9870 <RIL_BT_Disconnect+0x98>
102c9828:	e28d000c 	add	r0, sp, #12
102c982c:	e12fff33 	blx	r3
102c9830:	e3a03000 	mov	r3, #0
102c9834:	e1a02003 	mov	r2, r3
102c9838:	e58d3000 	str	r3, [sp]
102c983c:	e59fc030 	ldr	ip, [pc, #48]	; 102c9874 <RIL_BT_Disconnect+0x9c>
102c9840:	e1a01000 	mov	r1, r0
102c9844:	e28d000c 	add	r0, sp, #12
102c9848:	e12fff3c 	blx	ip
}
102c984c:	e28dd024 	add	sp, sp, #36	; 0x24
102c9850:	e8bd8000 	ldmfd	sp!, {pc}
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
        {
            return m_arrBTDev[i]->connId;
        }
    }
    return 0;
102c9854:	e3a02000 	mov	r2, #0
102c9858:	eaffffec 	b	102c9810 <RIL_BT_Disconnect+0x38>
    
    connId = BT_DevMngmt_GetConnId(hdlDevice);

    if(-1 == connId)
    {
        return RIL_AT_INVALID_PARAM ;
102c985c:	e3e00003 	mvn	r0, #3
102c9860:	eafffff9 	b	102c984c <RIL_BT_Disconnect+0x74>
102c9864:	f03d5054 	.word	0xf03d5054
102c9868:	f03de540 	.word	0xf03de540
102c986c:	102ee184 	.word	0x102ee184
102c9870:	102e57a4 	.word	0x102e57a4
102c9874:	102e5168 	.word	0x102e5168

102c9878 <OnURCHandler_BTDisconn>:
    Ql_sprintf(strAT, "AT+QBTDISCONN=%d", connId);
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}

void OnURCHandler_BTDisconn(const char* strURC, void* reserved)
{
102c9878:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    ST_BT_BasicInfo bt_dev;
    char urcHead[30];
    s32  connId;
    s32  pairedId;
    s32  profileId;
    s32 err_code = 0;
102c987c:	e3a03000 	mov	r3, #0
    Ql_sprintf(strAT, "AT+QBTDISCONN=%d", connId);
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}

void OnURCHandler_BTDisconn(const char* strURC, void* reserved)
{
102c9880:	e24dd0a0 	sub	sp, sp, #160	; 0xa0
    s32  profileId;
    s32 err_code = 0;
    char profile_name[40] = {0};    
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
	if(callback_bt == NULL)
102c9884:	e59f41c0 	ldr	r4, [pc, #448]	; 102c9a4c <OnURCHandler_BTDisconn+0x1d4>
    s32  pairedId;
    s32  profileId;
    s32 err_code = 0;
    char profile_name[40] = {0};    
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c9888:	e1a01003 	mov	r1, r3
    ST_BT_BasicInfo bt_dev;
    char urcHead[30];
    s32  connId;
    s32  pairedId;
    s32  profileId;
    s32 err_code = 0;
102c988c:	e58d3008 	str	r3, [sp, #8]
    char profile_name[40] = {0};    
102c9890:	e58d302c 	str	r3, [sp, #44]	; 0x2c
102c9894:	e58d3030 	str	r3, [sp, #48]	; 0x30
102c9898:	e58d3034 	str	r3, [sp, #52]	; 0x34
102c989c:	e58d3038 	str	r3, [sp, #56]	; 0x38
102c98a0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
102c98a4:	e58d3040 	str	r3, [sp, #64]	; 0x40
102c98a8:	e58d3044 	str	r3, [sp, #68]	; 0x44
102c98ac:	e58d3048 	str	r3, [sp, #72]	; 0x48
102c98b0:	e58d304c 	str	r3, [sp, #76]	; 0x4c
102c98b4:	e58d3050 	str	r3, [sp, #80]	; 0x50
    Ql_sprintf(strAT, "AT+QBTDISCONN=%d", connId);
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}

void OnURCHandler_BTDisconn(const char* strURC, void* reserved)
{
102c98b8:	e1a05000 	mov	r5, r0
    s32  pairedId;
    s32  profileId;
    s32 err_code = 0;
    char profile_name[40] = {0};    
    
    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c98bc:	e59f318c 	ldr	r3, [pc, #396]	; 102c9a50 <OnURCHandler_BTDisconn+0x1d8>
102c98c0:	e28d0054 	add	r0, sp, #84	; 0x54
102c98c4:	e3a0204c 	mov	r2, #76	; 0x4c
102c98c8:	e12fff33 	blx	r3
	if(callback_bt == NULL)
102c98cc:	e5943090 	ldr	r3, [r4, #144]	; 0x90
102c98d0:	e3530000 	cmp	r3, #0
102c98d4:	0a000045 	beq	102c99f0 <OnURCHandler_BTDisconn+0x178>
	{
	   return ;
	}

    Ql_strcpy(urcHead, "\r\n+QBTDISCONN:\0");
102c98d8:	e59f1174 	ldr	r1, [pc, #372]	; 102c9a54 <OnURCHandler_BTDisconn+0x1dc>
102c98dc:	e28d000c 	add	r0, sp, #12
102c98e0:	e59f7170 	ldr	r7, [pc, #368]	; 102c9a58 <OnURCHandler_BTDisconn+0x1e0>
102c98e4:	e12fff37 	blx	r7
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c98e8:	e59f616c 	ldr	r6, [pc, #364]	; 102c9a5c <OnURCHandler_BTDisconn+0x1e4>
102c98ec:	e1a00005 	mov	r0, r5
102c98f0:	e28d100c 	add	r1, sp, #12
102c98f4:	e12fff36 	blx	r6
102c98f8:	e2508000 	subs	r8, r0, #0
102c98fc:	0a00003d 	beq	102c99f8 <OnURCHandler_BTDisconn+0x180>
    {
        Ql_sscanf(strURC, "%*[^:]: %d,%d%*[^\r\n]\r\n", &connId,&pairedId);
102c9900:	e59f6158 	ldr	r6, [pc, #344]	; 102c9a60 <OnURCHandler_BTDisconn+0x1e8>
102c9904:	e28d3004 	add	r3, sp, #4
102c9908:	e596c000 	ldr	ip, [r6]
102c990c:	e59f1150 	ldr	r1, [pc, #336]	; 102c9a64 <OnURCHandler_BTDisconn+0x1ec>
102c9910:	e1a0200d 	mov	r2, sp
102c9914:	e1a00005 	mov	r0, r5
102c9918:	e12fff3c 	blx	ip
        Ql_sscanf(strURC, "%*[^,],%*[^,],\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
102c991c:	e59f1144 	ldr	r1, [pc, #324]	; 102c9a68 <OnURCHandler_BTDisconn+0x1f0>
102c9920:	e28d2058 	add	r2, sp, #88	; 0x58
102c9924:	e5963000 	ldr	r3, [r6]
102c9928:	e1a00005 	mov	r0, r5
102c992c:	e12fff33 	blx	r3
        Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c9930:	e59f1134 	ldr	r1, [pc, #308]	; 102c9a6c <OnURCHandler_BTDisconn+0x1f4>
102c9934:	e28d2090 	add	r2, sp, #144	; 0x90
102c9938:	e5963000 	ldr	r3, [r6]
102c993c:	e1a00005 	mov	r0, r5
102c9940:	e12fff33 	blx	r3
        Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%*[^,],\"%[^\"]%*[^\r\n]\r\n",profile_name);
102c9944:	e28d202c 	add	r2, sp, #44	; 0x2c
102c9948:	e59f1120 	ldr	r1, [pc, #288]	; 102c9a70 <OnURCHandler_BTDisconn+0x1f8>
102c994c:	e5963000 	ldr	r3, [r6]
102c9950:	e1a00005 	mov	r0, r5
102c9954:	e12fff33 	blx	r3
        bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr)); 
102c9958:	e59f3114 	ldr	r3, [pc, #276]	; 102c9a74 <OnURCHandler_BTDisconn+0x1fc>
102c995c:	e28d0090 	add	r0, sp, #144	; 0x90
102c9960:	e12fff33 	blx	r3
102c9964:	e59f310c 	ldr	r3, [pc, #268]	; 102c9a78 <OnURCHandler_BTDisconn+0x200>
102c9968:	e1a01000 	mov	r1, r0
102c996c:	e28d0090 	add	r0, sp, #144	; 0x90
102c9970:	e12fff33 	blx	r3
102c9974:	e2443004 	sub	r3, r4, #4
    
    Ql_sprintf(strAT, "AT+QBTDISCONN=%d", connId);
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
}

void OnURCHandler_BTDisconn(const char* strURC, void* reserved)
102c9978:	e284e074 	add	lr, r4, #116	; 0x74
102c997c:	e1a02003 	mov	r2, r3
    {
        Ql_sscanf(strURC, "%*[^:]: %d,%d%*[^\r\n]\r\n", &connId,&pairedId);
        Ql_sscanf(strURC, "%*[^,],%*[^,],\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
        Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
        Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%*[^,],\"%[^\"]%*[^\r\n]\r\n",profile_name);
        bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr)); 
102c9980:	e58d0054 	str	r0, [sp, #84]	; 0x54
102c9984:	ea000001 	b	102c9990 <OnURCHandler_BTDisconn+0x118>
//
// Update connect id
static void BT_DevMngmt_UpdateConnId(const u32 hdl, const s32 connId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9988:	e152000e 	cmp	r2, lr
102c998c:	0a00000b 	beq	102c99c0 <OnURCHandler_BTDisconn+0x148>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9990:	e5b21004 	ldr	r1, [r2, #4]!
102c9994:	e591c000 	ldr	ip, [r1]
102c9998:	e150000c 	cmp	r0, ip
102c999c:	1afffff9 	bne	102c9988 <OnURCHandler_BTDisconn+0x110>
        {
            m_arrBTDev[i]->connId= connId;
102c99a0:	e3e02000 	mvn	r2, #0
102c99a4:	e5812054 	str	r2, [r1, #84]	; 0x54
static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c99a8:	e5b32004 	ldr	r2, [r3, #4]!
102c99ac:	e5921000 	ldr	r1, [r2]
102c99b0:	e1500001 	cmp	r0, r1
102c99b4:	0a000005 	beq	102c99d0 <OnURCHandler_BTDisconn+0x158>
}

static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c99b8:	e153000e 	cmp	r3, lr
102c99bc:	0a000005 	beq	102c99d8 <OnURCHandler_BTDisconn+0x160>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c99c0:	e5b32004 	ldr	r2, [r3, #4]!
102c99c4:	e5921000 	ldr	r1, [r2]
102c99c8:	e1500001 	cmp	r0, r1
102c99cc:	1afffff9 	bne	102c99b8 <OnURCHandler_BTDisconn+0x140>
        {
            m_arrBTDev[i]->profileId= profileId;
102c99d0:	e3e03000 	mvn	r3, #0
102c99d4:	e5823058 	str	r3, [r2, #88]	; 0x58
        bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr)); 
        //Ql_Debug_Trace("connid = %d pairid = %d name = %s addr = %s ,handle = 0x%08x\r\n",connId,pairedId,bt_dev.name,bt_dev.addr,bt_dev.devHdl);
        BT_DevMngmt_UpdateConnId(bt_dev.devHdl, -1);
        BT_DevMngmt_UpdateProfileId(bt_dev.devHdl,-1);
 
        callback_bt(MSG_BT_DISCONN_IND, URC_BT_DISCONNECT_POSITIVE, &bt_dev, NULL);
102c99d8:	e594c090 	ldr	ip, [r4, #144]	; 0x90
102c99dc:	e3a00007 	mov	r0, #7
102c99e0:	e3a0100c 	mov	r1, #12
102c99e4:	e28d2054 	add	r2, sp, #84	; 0x54
102c99e8:	e3a03000 	mov	r3, #0
102c99ec:	e12fff3c 	blx	ip
    {
        Ql_sscanf(strURC, "%*[^: ]: %d\r\n", &err_code);
        callback_bt(MSG_BT_DISCONN_IND, err_code, &bt_dev, NULL);
        return;
    }
}
102c99f0:	e28dd0a0 	add	sp, sp, #160	; 0xa0
102c99f4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 
        callback_bt(MSG_BT_DISCONN_IND, URC_BT_DISCONNECT_POSITIVE, &bt_dev, NULL);
        return;
    }
    
    Ql_strcpy(urcHead, "\r\n+CME ERROR: \0");
102c99f8:	e59f107c 	ldr	r1, [pc, #124]	; 102c9a7c <OnURCHandler_BTDisconn+0x204>
102c99fc:	e28d000c 	add	r0, sp, #12
102c9a00:	e12fff37 	blx	r7
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c9a04:	e1a00005 	mov	r0, r5
102c9a08:	e28d100c 	add	r1, sp, #12
102c9a0c:	e12fff36 	blx	r6
102c9a10:	e3500000 	cmp	r0, #0
102c9a14:	0afffff5 	beq	102c99f0 <OnURCHandler_BTDisconn+0x178>
    {
        Ql_sscanf(strURC, "%*[^: ]: %d\r\n", &err_code);
102c9a18:	e59f3040 	ldr	r3, [pc, #64]	; 102c9a60 <OnURCHandler_BTDisconn+0x1e8>
102c9a1c:	e28d2008 	add	r2, sp, #8
102c9a20:	e59f1058 	ldr	r1, [pc, #88]	; 102c9a80 <OnURCHandler_BTDisconn+0x208>
102c9a24:	e5933000 	ldr	r3, [r3]
102c9a28:	e1a00005 	mov	r0, r5
102c9a2c:	e12fff33 	blx	r3
        callback_bt(MSG_BT_DISCONN_IND, err_code, &bt_dev, NULL);
102c9a30:	e594c090 	ldr	ip, [r4, #144]	; 0x90
102c9a34:	e3a00007 	mov	r0, #7
102c9a38:	e59d1008 	ldr	r1, [sp, #8]
102c9a3c:	e28d2054 	add	r2, sp, #84	; 0x54
102c9a40:	e1a03008 	mov	r3, r8
102c9a44:	e12fff3c 	blx	ip
102c9a48:	eaffffe8 	b	102c99f0 <OnURCHandler_BTDisconn+0x178>
102c9a4c:	f03d5058 	.word	0xf03d5058
102c9a50:	102e58f4 	.word	0x102e58f4
102c9a54:	102e6578 	.word	0x102e6578
102c9a58:	102e55fc 	.word	0x102e55fc
102c9a5c:	102ccd58 	.word	0x102ccd58
102c9a60:	f03de548 	.word	0xf03de548
102c9a64:	102ee198 	.word	0x102ee198
102c9a68:	102ee1b0 	.word	0x102ee1b0
102c9a6c:	102ee0cc 	.word	0x102ee0cc
102c9a70:	102ee0f0 	.word	0x102ee0f0
102c9a74:	102e57a4 	.word	0x102e57a4
102c9a78:	102cd1a4 	.word	0x102cd1a4
102c9a7c:	102e6588 	.word	0x102e6588
102c9a80:	102ee1d0 	.word	0x102ee1d0

102c9a84 <RIL_BT_SPP_Send>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SPP_Send(BT_DEV_HDL hdlDevice, u8* ptrData, u32 lenToSend,u32* actualSend)
{
102c9a84:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    char strAT[20];
    s32  connId ;

    if(NULL == ptrData || lenToSend < 0)
102c9a88:	e251a000 	subs	sl, r1, #0
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SPP_Send(BT_DEV_HDL hdlDevice, u8* ptrData, u32 lenToSend,u32* actualSend)
{
102c9a8c:	e24dd024 	sub	sp, sp, #36	; 0x24
102c9a90:	e1a07002 	mov	r7, r2
102c9a94:	e1a08003 	mov	r8, r3
    char strAT[20];
    s32  connId ;

    if(NULL == ptrData || lenToSend < 0)
102c9a98:	0a000023 	beq	102c9b2c <RIL_BT_SPP_Send+0xa8>
102c9a9c:	e59fc090 	ldr	ip, [pc, #144]	; 102c9b34 <RIL_BT_SPP_Send+0xb0>
*                RIL_AT_TIMEOUT,send AT timeout.
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SPP_Send(BT_DEV_HDL hdlDevice, u8* ptrData, u32 lenToSend,u32* actualSend)
102c9aa0:	e28c6078 	add	r6, ip, #120	; 0x78
102c9aa4:	ea000001 	b	102c9ab0 <RIL_BT_SPP_Send+0x2c>
    return 0;
}
s32 BT_DevMngmt_GetConnId(const u32 hdl)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9aa8:	e15c0006 	cmp	ip, r6
102c9aac:	0a00001c 	beq	102c9b24 <RIL_BT_SPP_Send+0xa0>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9ab0:	e5bc4004 	ldr	r4, [ip, #4]!
102c9ab4:	e5945000 	ldr	r5, [r4]
102c9ab8:	e1500005 	cmp	r0, r5
102c9abc:	1afffff9 	bne	102c9aa8 <RIL_BT_SPP_Send+0x24>
        {
            return m_arrBTDev[i]->connId;
102c9ac0:	e5942054 	ldr	r2, [r4, #84]	; 0x54
        return RIL_AT_INVALID_PARAM;
    }
    
    connId = BT_DevMngmt_GetConnId(hdlDevice);

    if(-1 == connId)
102c9ac4:	e3720001 	cmn	r2, #1
102c9ac8:	0a000017 	beq	102c9b2c <RIL_BT_SPP_Send+0xa8>
        return RIL_AT_INVALID_PARAM;
    }

    m_ptrSppData = ptrData;
    m_nSppDataLenToSnd   = lenToSend;
    Ql_sprintf(strAT, "AT+QSPPSEND=%d,%d", connId, lenToSend);
102c9acc:	e59f0064 	ldr	r0, [pc, #100]	; 102c9b38 <RIL_BT_SPP_Send+0xb4>
    if(-1 == connId)
    {
        return RIL_AT_INVALID_PARAM;
    }

    m_ptrSppData = ptrData;
102c9ad0:	e59fc064 	ldr	ip, [pc, #100]	; 102c9b3c <RIL_BT_SPP_Send+0xb8>
    m_nSppDataLenToSnd   = lenToSend;
    Ql_sprintf(strAT, "AT+QSPPSEND=%d,%d", connId, lenToSend);
102c9ad4:	e59f1064 	ldr	r1, [pc, #100]	; 102c9b40 <RIL_BT_SPP_Send+0xbc>
102c9ad8:	e1a03007 	mov	r3, r7
102c9adc:	e5904000 	ldr	r4, [r0]
102c9ae0:	e28d000c 	add	r0, sp, #12
    if(-1 == connId)
    {
        return RIL_AT_INVALID_PARAM;
    }

    m_ptrSppData = ptrData;
102c9ae4:	e58ca088 	str	sl, [ip, #136]	; 0x88
    m_nSppDataLenToSnd   = lenToSend;
102c9ae8:	e58c708c 	str	r7, [ip, #140]	; 0x8c
    Ql_sprintf(strAT, "AT+QSPPSEND=%d,%d", connId, lenToSend);
102c9aec:	e12fff34 	blx	r4
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTSPPSEND_Hdlr,(void *)actualSend, 0);
102c9af0:	e59f304c 	ldr	r3, [pc, #76]	; 102c9b44 <RIL_BT_SPP_Send+0xc0>
102c9af4:	e28d000c 	add	r0, sp, #12
102c9af8:	e12fff33 	blx	r3
102c9afc:	e3a03000 	mov	r3, #0
102c9b00:	e58d3000 	str	r3, [sp]
102c9b04:	e59f203c 	ldr	r2, [pc, #60]	; 102c9b48 <RIL_BT_SPP_Send+0xc4>
102c9b08:	e1a03008 	mov	r3, r8
102c9b0c:	e59fc038 	ldr	ip, [pc, #56]	; 102c9b4c <RIL_BT_SPP_Send+0xc8>
102c9b10:	e1a01000 	mov	r1, r0
102c9b14:	e28d000c 	add	r0, sp, #12
102c9b18:	e12fff3c 	blx	ip
}
102c9b1c:	e28dd024 	add	sp, sp, #36	; 0x24
102c9b20:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
        {
            return m_arrBTDev[i]->connId;
        }
    }
    return 0;
102c9b24:	e3a02000 	mov	r2, #0
102c9b28:	eaffffe7 	b	102c9acc <RIL_BT_SPP_Send+0x48>
    char strAT[20];
    s32  connId ;

    if(NULL == ptrData || lenToSend < 0)
    {
        return RIL_AT_INVALID_PARAM;
102c9b2c:	e3e00003 	mvn	r0, #3
102c9b30:	eafffff9 	b	102c9b1c <RIL_BT_SPP_Send+0x98>
102c9b34:	f03d5054 	.word	0xf03d5054
102c9b38:	f03de540 	.word	0xf03de540
102c9b3c:	f03d5058 	.word	0xf03d5058
102c9b40:	102ee1e0 	.word	0x102ee1e0
102c9b44:	102e57a4 	.word	0x102e57a4
102c9b48:	102c7b94 	.word	0x102c7b94
102c9b4c:	102e5168 	.word	0x102e5168

102c9b50 <RIL_BT_SPP_Read>:
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SPP_Read(BT_DEV_HDL hdlDevice, u8* ptrBuffer, u32 lenToRead ,u32 *actualReadlen)
{
102c9b50:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    char strAT[20];
    s32  connId;

    if(NULL == ptrBuffer || lenToRead < 0)
102c9b54:	e251a000 	subs	sl, r1, #0
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SPP_Read(BT_DEV_HDL hdlDevice, u8* ptrBuffer, u32 lenToRead ,u32 *actualReadlen)
{
102c9b58:	e24dd024 	sub	sp, sp, #36	; 0x24
102c9b5c:	e1a07002 	mov	r7, r2
102c9b60:	e1a08003 	mov	r8, r3
    char strAT[20];
    s32  connId;

    if(NULL == ptrBuffer || lenToRead < 0)
102c9b64:	0a000024 	beq	102c9bfc <RIL_BT_SPP_Read+0xac>
102c9b68:	e59fc094 	ldr	ip, [pc, #148]	; 102c9c04 <RIL_BT_SPP_Read+0xb4>
*                RIL_AT_TIMEOUT,send AT timeout.
*                RIL_AT_BUSY,   sending AT.
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*****************************************************************/
s32 RIL_BT_SPP_Read(BT_DEV_HDL hdlDevice, u8* ptrBuffer, u32 lenToRead ,u32 *actualReadlen)
102c9b6c:	e28c6078 	add	r6, ip, #120	; 0x78
102c9b70:	ea000001 	b	102c9b7c <RIL_BT_SPP_Read+0x2c>
    return 0;
}
s32 BT_DevMngmt_GetConnId(const u32 hdl)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9b74:	e15c0006 	cmp	ip, r6
102c9b78:	0a00001d 	beq	102c9bf4 <RIL_BT_SPP_Read+0xa4>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9b7c:	e5bc4004 	ldr	r4, [ip, #4]!
102c9b80:	e5945000 	ldr	r5, [r4]
102c9b84:	e1500005 	cmp	r0, r5
102c9b88:	1afffff9 	bne	102c9b74 <RIL_BT_SPP_Read+0x24>
        {
            return m_arrBTDev[i]->connId;
102c9b8c:	e5942054 	ldr	r2, [r4, #84]	; 0x54
    }
    
    connId = BT_DevMngmt_GetConnId(hdlDevice);

    
    if(-1 == connId)
102c9b90:	e3720001 	cmn	r2, #1
102c9b94:	0a000018 	beq	102c9bfc <RIL_BT_SPP_Read+0xac>
    {
       return RIL_AT_INVALID_PARAM;
    }
    
    m_ptrSppDataBuf = ptrBuffer;
102c9b98:	e59fc068 	ldr	ip, [pc, #104]	; 102c9c08 <RIL_BT_SPP_Read+0xb8>
    m_nSppDataLenToRd = lenToRead;
    m_nSppRealReadLen = 0;
    Ql_sprintf(strAT, "AT+QSPPREAD=%d,%d", connId, lenToRead);
102c9b9c:	e59f0068 	ldr	r0, [pc, #104]	; 102c9c0c <RIL_BT_SPP_Read+0xbc>
       return RIL_AT_INVALID_PARAM;
    }
    
    m_ptrSppDataBuf = ptrBuffer;
    m_nSppDataLenToRd = lenToRead;
    m_nSppRealReadLen = 0;
102c9ba0:	e3a04000 	mov	r4, #0
    Ql_sprintf(strAT, "AT+QSPPREAD=%d,%d", connId, lenToRead);
102c9ba4:	e59f1064 	ldr	r1, [pc, #100]	; 102c9c10 <RIL_BT_SPP_Read+0xc0>
       return RIL_AT_INVALID_PARAM;
    }
    
    m_ptrSppDataBuf = ptrBuffer;
    m_nSppDataLenToRd = lenToRead;
    m_nSppRealReadLen = 0;
102c9ba8:	e58c4080 	str	r4, [ip, #128]	; 0x80
    Ql_sprintf(strAT, "AT+QSPPREAD=%d,%d", connId, lenToRead);
102c9bac:	e1a03007 	mov	r3, r7
102c9bb0:	e5905000 	ldr	r5, [r0]
102c9bb4:	e28d000c 	add	r0, sp, #12
    if(-1 == connId)
    {
       return RIL_AT_INVALID_PARAM;
    }
    
    m_ptrSppDataBuf = ptrBuffer;
102c9bb8:	e58ca07c 	str	sl, [ip, #124]	; 0x7c
    m_nSppDataLenToRd = lenToRead;
102c9bbc:	e58c7094 	str	r7, [ip, #148]	; 0x94
    m_nSppRealReadLen = 0;
    Ql_sprintf(strAT, "AT+QSPPREAD=%d,%d", connId, lenToRead);
102c9bc0:	e12fff35 	blx	r5
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QBTSPPREAD_Hdlr, (void *)actualReadlen, 0);
102c9bc4:	e59f3048 	ldr	r3, [pc, #72]	; 102c9c14 <RIL_BT_SPP_Read+0xc4>
102c9bc8:	e28d000c 	add	r0, sp, #12
102c9bcc:	e12fff33 	blx	r3
102c9bd0:	e58d4000 	str	r4, [sp]
102c9bd4:	e59f203c 	ldr	r2, [pc, #60]	; 102c9c18 <RIL_BT_SPP_Read+0xc8>
102c9bd8:	e1a03008 	mov	r3, r8
102c9bdc:	e59fc038 	ldr	ip, [pc, #56]	; 102c9c1c <RIL_BT_SPP_Read+0xcc>
102c9be0:	e1a01000 	mov	r1, r0
102c9be4:	e28d000c 	add	r0, sp, #12
102c9be8:	e12fff3c 	blx	ip
}
102c9bec:	e28dd024 	add	sp, sp, #36	; 0x24
102c9bf0:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
        {
            return m_arrBTDev[i]->connId;
        }
    }
    return 0;
102c9bf4:	e3a02000 	mov	r2, #0
102c9bf8:	eaffffe6 	b	102c9b98 <RIL_BT_SPP_Read+0x48>
    char strAT[20];
    s32  connId;

    if(NULL == ptrBuffer || lenToRead < 0)
    {
        return RIL_AT_INVALID_PARAM;
102c9bfc:	e3e00003 	mvn	r0, #3
102c9c00:	eafffff9 	b	102c9bec <RIL_BT_SPP_Read+0x9c>
102c9c04:	f03d5054 	.word	0xf03d5054
102c9c08:	f03d5058 	.word	0xf03d5058
102c9c0c:	f03de540 	.word	0xf03de540
102c9c10:	102ee1f4 	.word	0x102ee1f4
102c9c14:	102e57a4 	.word	0x102e57a4
102c9c18:	102c76b0 	.word	0x102c76b0
102c9c1c:	102e5168 	.word	0x102e5168

102c9c20 <OnURCHandler_BTIndication>:




void OnURCHandler_BTIndication(const char* strURC, void* reserved)
{
102c9c20:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    // +QBTIND: "pair",H60-L01,F4E3FBE47920,760429
    // +QBTIND: "conn","H60-L01",F4E3FBE47920,"SPP"
    // +QBTIND: "disc",2,"H60-L01",F4E3FBE47920,"SPP"
    char urcHead[30];
    char urcType[10];
    char pinCode[BT_PIN_LEN]={0};
102c9c24:	e3a04000 	mov	r4, #0




void OnURCHandler_BTIndication(const char* strURC, void* reserved)
{
102c9c28:	e24dd0a8 	sub	sp, sp, #168	; 0xa8
    ST_BT_BasicInfo bt_dev;
    s32 connId;
    char temp[30]={0};
	

    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c9c2c:	e1a01004 	mov	r1, r4
102c9c30:	e3a0204c 	mov	r2, #76	; 0x4c
102c9c34:	e59f533c 	ldr	r5, [pc, #828]	; 102c9f78 <OnURCHandler_BTIndication+0x358>




void OnURCHandler_BTIndication(const char* strURC, void* reserved)
{
102c9c38:	e1a06000 	mov	r6, r0
	

    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
    Ql_memset(urcType,  0x0, sizeof(urcType));

	if(callback_bt == NULL)
102c9c3c:	e59f7338 	ldr	r7, [pc, #824]	; 102c9f7c <OnURCHandler_BTIndication+0x35c>
    ST_BT_BasicInfo bt_dev;
    s32 connId;
    char temp[30]={0};
	

    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c9c40:	e28d005c 	add	r0, sp, #92	; 0x5c
    // +QBTIND: "pair",H60-L01,F4E3FBE47920,760429
    // +QBTIND: "conn","H60-L01",F4E3FBE47920,"SPP"
    // +QBTIND: "disc",2,"H60-L01",F4E3FBE47920,"SPP"
    char urcHead[30];
    char urcType[10];
    char pinCode[BT_PIN_LEN]={0};
102c9c44:	e58d4008 	str	r4, [sp, #8]
102c9c48:	e1cd40bc 	strh	r4, [sp, #12]
102c9c4c:	e5cd400e 	strb	r4, [sp, #14]
    ST_BT_BasicInfo bt_dev;
    s32 connId;
    char temp[30]={0};
102c9c50:	e58d403c 	str	r4, [sp, #60]	; 0x3c
102c9c54:	e58d4040 	str	r4, [sp, #64]	; 0x40
102c9c58:	e58d4044 	str	r4, [sp, #68]	; 0x44
102c9c5c:	e58d4048 	str	r4, [sp, #72]	; 0x48
102c9c60:	e58d404c 	str	r4, [sp, #76]	; 0x4c
102c9c64:	e58d4050 	str	r4, [sp, #80]	; 0x50
102c9c68:	e58d4054 	str	r4, [sp, #84]	; 0x54
102c9c6c:	e1cd45b8 	strh	r4, [sp, #88]	; 0x58
	

    Ql_memset(&bt_dev,  0x0, sizeof(ST_BT_BasicInfo));
102c9c70:	e12fff35 	blx	r5
    Ql_memset(urcType,  0x0, sizeof(urcType));
102c9c74:	e28d0010 	add	r0, sp, #16
102c9c78:	e1a01004 	mov	r1, r4
102c9c7c:	e3a0200a 	mov	r2, #10
102c9c80:	e12fff35 	blx	r5

	if(callback_bt == NULL)
102c9c84:	e5973090 	ldr	r3, [r7, #144]	; 0x90
102c9c88:	e1530004 	cmp	r3, r4
102c9c8c:	0a000009 	beq	102c9cb8 <OnURCHandler_BTIndication+0x98>
    {
       return;
	}


    Ql_strcpy(urcHead, "\r\n+QBTIND:\0");
102c9c90:	e59f12e8 	ldr	r1, [pc, #744]	; 102c9f80 <OnURCHandler_BTIndication+0x360>
102c9c94:	e59f32e8 	ldr	r3, [pc, #744]	; 102c9f84 <OnURCHandler_BTIndication+0x364>
102c9c98:	e28d001c 	add	r0, sp, #28
102c9c9c:	e12fff33 	blx	r3
    if (Ql_StrPrefixMatch(strURC, urcHead))
102c9ca0:	e1a00006 	mov	r0, r6
102c9ca4:	e28d101c 	add	r1, sp, #28
102c9ca8:	e59f32d8 	ldr	r3, [pc, #728]	; 102c9f88 <OnURCHandler_BTIndication+0x368>
102c9cac:	e12fff33 	blx	r3
102c9cb0:	e1500004 	cmp	r0, r4
102c9cb4:	1a000001 	bne	102c9cc0 <OnURCHandler_BTIndication+0xa0>
            callback_bt(MSG_BT_RECV_IND, URC_BT_DATA_RECIEVE, &connId, &bt_dev);
        }
    }else{
        // error
    }
}
102c9cb8:	e28dd0a8 	add	sp, sp, #168	; 0xa8
102c9cbc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    Ql_strcpy(urcHead, "\r\n+QBTIND:\0");
    if (Ql_StrPrefixMatch(strURC, urcHead))
    {
        // +QBTIND: "pair",H60-L01,F4E3FBE47920,760429
        Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", urcType);
102c9cc0:	e59f42c4 	ldr	r4, [pc, #708]	; 102c9f8c <OnURCHandler_BTIndication+0x36c>
102c9cc4:	e59f12c4 	ldr	r1, [pc, #708]	; 102c9f90 <OnURCHandler_BTIndication+0x370>
102c9cc8:	e28d2010 	add	r2, sp, #16
102c9ccc:	e5943000 	ldr	r3, [r4]
102c9cd0:	e1a00006 	mov	r0, r6
102c9cd4:	e12fff33 	blx	r3
        if (Ql_strcmp(urcType, "pair") == 0)
102c9cd8:	e59f52b4 	ldr	r5, [pc, #692]	; 102c9f94 <OnURCHandler_BTIndication+0x374>
102c9cdc:	e28d0010 	add	r0, sp, #16
102c9ce0:	e59f12b0 	ldr	r1, [pc, #688]	; 102c9f98 <OnURCHandler_BTIndication+0x378>
102c9ce4:	e12fff35 	blx	r5
102c9ce8:	e2508000 	subs	r8, r0, #0
102c9cec:	1a000021 	bne	102c9d78 <OnURCHandler_BTIndication+0x158>
        {
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", temp);
102c9cf0:	e28d203c 	add	r2, sp, #60	; 0x3c
102c9cf4:	e5943000 	ldr	r3, [r4]
102c9cf8:	e59f129c 	ldr	r1, [pc, #668]	; 102c9f9c <OnURCHandler_BTIndication+0x37c>
102c9cfc:	e1a00006 	mov	r0, r6
102c9d00:	e12fff33 	blx	r3
            if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
102c9d04:	e59f5294 	ldr	r5, [pc, #660]	; 102c9fa0 <OnURCHandler_BTIndication+0x380>
102c9d08:	e28d003c 	add	r0, sp, #60	; 0x3c
102c9d0c:	e12fff35 	blx	r5
            {
                 Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", bt_dev.addr);
102c9d10:	e28d2098 	add	r2, sp, #152	; 0x98
102c9d14:	e5943000 	ldr	r3, [r4]
        // +QBTIND: "pair",H60-L01,F4E3FBE47920,760429
        Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", urcType);
        if (Ql_strcmp(urcType, "pair") == 0)
        {
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", temp);
            if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
102c9d18:	e350000c 	cmp	r0, #12
            {
                 Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", bt_dev.addr);
102c9d1c:	e1a00006 	mov	r0, r6
        // +QBTIND: "pair",H60-L01,F4E3FBE47920,760429
        Ql_sscanf(strURC, "%*[^\"]\"%[^\"]%*[^\r\n]\r\n", urcType);
        if (Ql_strcmp(urcType, "pair") == 0)
        {
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", temp);
            if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
102c9d20:	0a000082 	beq	102c9f30 <OnURCHandler_BTIndication+0x310>
                 bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
                 callback_bt(MSG_BT_PAIR_REQ, URC_BT_NEED_PASSKEY, &bt_dev, NULL); // need paaskey
            }
            else
            {
                Ql_sscanf(strURC, "%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c9d24:	e59f1278 	ldr	r1, [pc, #632]	; 102c9fa4 <OnURCHandler_BTIndication+0x384>
102c9d28:	e12fff33 	blx	r3
                Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^\r\n]\r\n",pinCode);
102c9d2c:	e28d2008 	add	r2, sp, #8
102c9d30:	e5943000 	ldr	r3, [r4]
102c9d34:	e59f126c 	ldr	r1, [pc, #620]	; 102c9fa8 <OnURCHandler_BTIndication+0x388>
102c9d38:	e1a00006 	mov	r0, r6
102c9d3c:	e12fff33 	blx	r3
                bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9d40:	e28d0098 	add	r0, sp, #152	; 0x98
102c9d44:	e12fff35 	blx	r5
102c9d48:	e59f325c 	ldr	r3, [pc, #604]	; 102c9fac <OnURCHandler_BTIndication+0x38c>
102c9d4c:	e1a01000 	mov	r1, r0
102c9d50:	e28d0098 	add	r0, sp, #152	; 0x98
102c9d54:	e12fff33 	blx	r3
                callback_bt(MSG_BT_PAIR_REQ, URC_BT_NO_NEED_PASSKEY, &bt_dev, pinCode); //direct confirm
102c9d58:	e597c090 	ldr	ip, [r7, #144]	; 0x90
102c9d5c:	e28d205c 	add	r2, sp, #92	; 0x5c
102c9d60:	e28d3008 	add	r3, sp, #8
            }
            else
            {
                Ql_sscanf(strURC, "%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
                Ql_sscanf(strURC, "%*[^,],%*[^,],%*[^,],%[^\r\n]\r\n",pinCode);
                bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9d64:	e58d005c 	str	r0, [sp, #92]	; 0x5c
                callback_bt(MSG_BT_PAIR_REQ, URC_BT_NO_NEED_PASSKEY, &bt_dev, pinCode); //direct confirm
102c9d68:	e3a00005 	mov	r0, #5
102c9d6c:	e1a01000 	mov	r1, r0
102c9d70:	e12fff3c 	blx	ip
102c9d74:	eaffffcf 	b	102c9cb8 <OnURCHandler_BTIndication+0x98>
            }   
        }
        else if (Ql_strcmp(urcType, "conn") == 0)
102c9d78:	e28d0010 	add	r0, sp, #16
102c9d7c:	e59f122c 	ldr	r1, [pc, #556]	; 102c9fb0 <OnURCHandler_BTIndication+0x390>
102c9d80:	e12fff35 	blx	r5
102c9d84:	e2508000 	subs	r8, r0, #0
102c9d88:	1a000018 	bne	102c9df0 <OnURCHandler_BTIndication+0x1d0>
        {
            // +QBTIND: "conn","H60-L01",F4E3FBE47920,"SPP"
           Ql_sscanf(strURC, "%*[^,],\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
102c9d8c:	e28d2060 	add	r2, sp, #96	; 0x60
102c9d90:	e5943000 	ldr	r3, [r4]
102c9d94:	e1a00006 	mov	r0, r6
102c9d98:	e59f1214 	ldr	r1, [pc, #532]	; 102c9fb4 <OnURCHandler_BTIndication+0x394>
102c9d9c:	e12fff33 	blx	r3
           Ql_sscanf(strURC, "%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c9da0:	e28d2098 	add	r2, sp, #152	; 0x98
102c9da4:	e5943000 	ldr	r3, [r4]
102c9da8:	e59f11f4 	ldr	r1, [pc, #500]	; 102c9fa4 <OnURCHandler_BTIndication+0x384>
102c9dac:	e1a00006 	mov	r0, r6
102c9db0:	e12fff33 	blx	r3
           bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9db4:	e28d0098 	add	r0, sp, #152	; 0x98
102c9db8:	e59f31e0 	ldr	r3, [pc, #480]	; 102c9fa0 <OnURCHandler_BTIndication+0x380>
102c9dbc:	e12fff33 	blx	r3
102c9dc0:	e59f31e4 	ldr	r3, [pc, #484]	; 102c9fac <OnURCHandler_BTIndication+0x38c>
102c9dc4:	e1a01000 	mov	r1, r0
102c9dc8:	e28d0098 	add	r0, sp, #152	; 0x98
102c9dcc:	e12fff33 	blx	r3
           callback_bt(MSG_BT_CONN_REQ,URC_BT_CONN_REQ ,&bt_dev, NULL);
102c9dd0:	e597c090 	ldr	ip, [r7, #144]	; 0x90
102c9dd4:	e3a0100a 	mov	r1, #10
102c9dd8:	e28d205c 	add	r2, sp, #92	; 0x5c
102c9ddc:	e1a03008 	mov	r3, r8
        else if (Ql_strcmp(urcType, "conn") == 0)
        {
            // +QBTIND: "conn","H60-L01",F4E3FBE47920,"SPP"
           Ql_sscanf(strURC, "%*[^,],\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
           Ql_sscanf(strURC, "%*[^,],%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
           bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9de0:	e58d005c 	str	r0, [sp, #92]	; 0x5c
           callback_bt(MSG_BT_CONN_REQ,URC_BT_CONN_REQ ,&bt_dev, NULL);
102c9de4:	e3a00006 	mov	r0, #6
102c9de8:	e12fff3c 	blx	ip
102c9dec:	eaffffb1 	b	102c9cb8 <OnURCHandler_BTIndication+0x98>
        }
        else if (Ql_strcmp(urcType, "disc") == 0)
102c9df0:	e28d0010 	add	r0, sp, #16
102c9df4:	e59f11bc 	ldr	r1, [pc, #444]	; 102c9fb8 <OnURCHandler_BTIndication+0x398>
102c9df8:	e12fff35 	blx	r5
102c9dfc:	e3500000 	cmp	r0, #0
102c9e00:	0a00001c 	beq	102c9e78 <OnURCHandler_BTIndication+0x258>
            Ql_sscanf(strURC, "%*[^,],%*[^\"]\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            BT_DevMngmt_UpdateConnId(bt_dev.devHdl, -1);
            BT_DevMngmt_UpdateProfileId(bt_dev.devHdl, -1);
            callback_bt(MSG_BT_DISCONN_IND, URC_BT_DISCONNECT_PASSIVE, &bt_dev, NULL);
        }else if (Ql_strcmp(urcType, "recv") == 0)
102c9e04:	e28d0010 	add	r0, sp, #16
102c9e08:	e59f11ac 	ldr	r1, [pc, #428]	; 102c9fbc <OnURCHandler_BTIndication+0x39c>
102c9e0c:	e12fff35 	blx	r5
102c9e10:	e3500000 	cmp	r0, #0
102c9e14:	1affffa7 	bne	102c9cb8 <OnURCHandler_BTIndication+0x98>
        {

            Ql_sscanf(strURC, "%*[^,],%d\r\n",&connId);
102c9e18:	e5943000 	ldr	r3, [r4]
102c9e1c:	e1a00006 	mov	r0, r6
102c9e20:	e59f1198 	ldr	r1, [pc, #408]	; 102c9fc0 <OnURCHandler_BTIndication+0x3a0>
102c9e24:	e28d2004 	add	r2, sp, #4
102c9e28:	e12fff33 	blx	r3
            bt_dev.devHdl = BT_DevMngmt_GetDevHdl(connId);
102c9e2c:	e59d0004 	ldr	r0, [sp, #4]
102c9e30:	e2473004 	sub	r3, r7, #4
}




void OnURCHandler_BTIndication(const char* strURC, void* reserved)
102c9e34:	e287c074 	add	ip, r7, #116	; 0x74
102c9e38:	ea000001 	b	102c9e44 <OnURCHandler_BTIndication+0x224>


static BT_DEV_HDL BT_DevMngmt_GetDevHdl(const s32 connId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9e3c:	e153000c 	cmp	r3, ip
102c9e40:	0a00004a 	beq	102c9f70 <OnURCHandler_BTIndication+0x350>
    {
        if (connId == m_arrBTDev[i]->connId)
102c9e44:	e5b32004 	ldr	r2, [r3, #4]!
102c9e48:	e5921054 	ldr	r1, [r2, #84]	; 0x54
102c9e4c:	e1500001 	cmp	r0, r1
102c9e50:	1afffff9 	bne	102c9e3c <OnURCHandler_BTIndication+0x21c>
        {
            return m_arrBTDev[i]->btDevice.devHdl;
102c9e54:	e5923000 	ldr	r3, [r2]
        }else if (Ql_strcmp(urcType, "recv") == 0)
        {

            Ql_sscanf(strURC, "%*[^,],%d\r\n",&connId);
            bt_dev.devHdl = BT_DevMngmt_GetDevHdl(connId);
            callback_bt(MSG_BT_RECV_IND, URC_BT_DATA_RECIEVE, &connId, &bt_dev);
102c9e58:	e3a00004 	mov	r0, #4
            callback_bt(MSG_BT_DISCONN_IND, URC_BT_DISCONNECT_PASSIVE, &bt_dev, NULL);
        }else if (Ql_strcmp(urcType, "recv") == 0)
        {

            Ql_sscanf(strURC, "%*[^,],%d\r\n",&connId);
            bt_dev.devHdl = BT_DevMngmt_GetDevHdl(connId);
102c9e5c:	e58d305c 	str	r3, [sp, #92]	; 0x5c
            callback_bt(MSG_BT_RECV_IND, URC_BT_DATA_RECIEVE, &connId, &bt_dev);
102c9e60:	e597c090 	ldr	ip, [r7, #144]	; 0x90
102c9e64:	e3a0100d 	mov	r1, #13
102c9e68:	e08d2000 	add	r2, sp, r0
102c9e6c:	e28d305c 	add	r3, sp, #92	; 0x5c
102c9e70:	e12fff3c 	blx	ip
102c9e74:	eaffff8f 	b	102c9cb8 <OnURCHandler_BTIndication+0x98>
           callback_bt(MSG_BT_CONN_REQ,URC_BT_CONN_REQ ,&bt_dev, NULL);
        }
        else if (Ql_strcmp(urcType, "disc") == 0)
        {
            // +QBTIND: "disc",2,2,"H60-L01",F4E3FBE47920,"SPP"
            Ql_sscanf(strURC, "%*[^,],%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
102c9e78:	e59f1144 	ldr	r1, [pc, #324]	; 102c9fc4 <OnURCHandler_BTIndication+0x3a4>
102c9e7c:	e28d2098 	add	r2, sp, #152	; 0x98
102c9e80:	e5943000 	ldr	r3, [r4]
102c9e84:	e1a00006 	mov	r0, r6
102c9e88:	e12fff33 	blx	r3
            Ql_sscanf(strURC, "%*[^,],%*[^\"]\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
102c9e8c:	e28d2060 	add	r2, sp, #96	; 0x60
102c9e90:	e59f1130 	ldr	r1, [pc, #304]	; 102c9fc8 <OnURCHandler_BTIndication+0x3a8>
102c9e94:	e5943000 	ldr	r3, [r4]
102c9e98:	e1a00006 	mov	r0, r6
102c9e9c:	e12fff33 	blx	r3
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9ea0:	e59f30f8 	ldr	r3, [pc, #248]	; 102c9fa0 <OnURCHandler_BTIndication+0x380>
102c9ea4:	e28d0098 	add	r0, sp, #152	; 0x98
102c9ea8:	e12fff33 	blx	r3
102c9eac:	e59f30f8 	ldr	r3, [pc, #248]	; 102c9fac <OnURCHandler_BTIndication+0x38c>
102c9eb0:	e1a01000 	mov	r1, r0
102c9eb4:	e28d0098 	add	r0, sp, #152	; 0x98
102c9eb8:	e12fff33 	blx	r3
102c9ebc:	e2473004 	sub	r3, r7, #4
}




void OnURCHandler_BTIndication(const char* strURC, void* reserved)
102c9ec0:	e287e074 	add	lr, r7, #116	; 0x74
102c9ec4:	e1a02003 	mov	r2, r3
        else if (Ql_strcmp(urcType, "disc") == 0)
        {
            // +QBTIND: "disc",2,2,"H60-L01",F4E3FBE47920,"SPP"
            Ql_sscanf(strURC, "%*[^,],%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
            Ql_sscanf(strURC, "%*[^,],%*[^\"]\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9ec8:	e58d005c 	str	r0, [sp, #92]	; 0x5c
102c9ecc:	ea000001 	b	102c9ed8 <OnURCHandler_BTIndication+0x2b8>
//
// Update connect id
static void BT_DevMngmt_UpdateConnId(const u32 hdl, const s32 connId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9ed0:	e152000e 	cmp	r2, lr
102c9ed4:	0a000008 	beq	102c9efc <OnURCHandler_BTIndication+0x2dc>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9ed8:	e5b21004 	ldr	r1, [r2, #4]!
102c9edc:	e591c000 	ldr	ip, [r1]
102c9ee0:	e150000c 	cmp	r0, ip
102c9ee4:	1afffff9 	bne	102c9ed0 <OnURCHandler_BTIndication+0x2b0>
        {
            m_arrBTDev[i]->connId= connId;
102c9ee8:	e3e02000 	mvn	r2, #0
102c9eec:	e5812054 	str	r2, [r1, #84]	; 0x54
102c9ef0:	ea000001 	b	102c9efc <OnURCHandler_BTIndication+0x2dc>
}

static void BT_DevMngmt_UpdateProfileId(const u32 hdl, const s32 profileId)
{
    u16 i;
    for (i = 0; i < MAX_BT_DEV_CNT; i++)
102c9ef4:	e153000e 	cmp	r3, lr
102c9ef8:	0a000005 	beq	102c9f14 <OnURCHandler_BTIndication+0x2f4>
    {
        if (hdl == m_arrBTDev[i]->btDevice.devHdl)
102c9efc:	e5b32004 	ldr	r2, [r3, #4]!
102c9f00:	e5921000 	ldr	r1, [r2]
102c9f04:	e1500001 	cmp	r0, r1
102c9f08:	1afffff9 	bne	102c9ef4 <OnURCHandler_BTIndication+0x2d4>
        {
            m_arrBTDev[i]->profileId= profileId;
102c9f0c:	e3e03000 	mvn	r3, #0
102c9f10:	e5823058 	str	r3, [r2, #88]	; 0x58
            Ql_sscanf(strURC, "%*[^,],%*[^\"]\"%*[^,],%[^,]%*[^\r\n]\r\n",bt_dev.addr);
            Ql_sscanf(strURC, "%*[^,],%*[^\"]\"%[^\"]%*[^\r\n]\r\n",bt_dev.name);
            bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
            BT_DevMngmt_UpdateConnId(bt_dev.devHdl, -1);
            BT_DevMngmt_UpdateProfileId(bt_dev.devHdl, -1);
            callback_bt(MSG_BT_DISCONN_IND, URC_BT_DISCONNECT_PASSIVE, &bt_dev, NULL);
102c9f14:	e597c090 	ldr	ip, [r7, #144]	; 0x90
102c9f18:	e3a00007 	mov	r0, #7
102c9f1c:	e3a0100b 	mov	r1, #11
102c9f20:	e28d205c 	add	r2, sp, #92	; 0x5c
102c9f24:	e3a03000 	mov	r3, #0
102c9f28:	e12fff3c 	blx	ip
102c9f2c:	eaffff61 	b	102c9cb8 <OnURCHandler_BTIndication+0x98>
        if (Ql_strcmp(urcType, "pair") == 0)
        {
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", temp);
            if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
            {
                 Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", bt_dev.addr);
102c9f30:	e59f1064 	ldr	r1, [pc, #100]	; 102c9f9c <OnURCHandler_BTIndication+0x37c>
102c9f34:	e12fff33 	blx	r3
                 bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9f38:	e28d0098 	add	r0, sp, #152	; 0x98
102c9f3c:	e12fff35 	blx	r5
102c9f40:	e59f3064 	ldr	r3, [pc, #100]	; 102c9fac <OnURCHandler_BTIndication+0x38c>
102c9f44:	e1a01000 	mov	r1, r0
102c9f48:	e28d0098 	add	r0, sp, #152	; 0x98
102c9f4c:	e12fff33 	blx	r3
                 callback_bt(MSG_BT_PAIR_REQ, URC_BT_NEED_PASSKEY, &bt_dev, NULL); // need paaskey
102c9f50:	e597c090 	ldr	ip, [r7, #144]	; 0x90
102c9f54:	e3a01004 	mov	r1, #4
102c9f58:	e28d205c 	add	r2, sp, #92	; 0x5c
102c9f5c:	e1a03008 	mov	r3, r8
        {
            Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", temp);
            if(Ql_strlen(temp) == (BT_ADDR_LEN - 1))
            {
                 Ql_sscanf(strURC, "%*[^,],%*[^,],%[^\r\n]\r\n", bt_dev.addr);
                 bt_dev.devHdl = Ql_GenHash(bt_dev.addr, Ql_strlen(bt_dev.addr));
102c9f60:	e58d005c 	str	r0, [sp, #92]	; 0x5c
                 callback_bt(MSG_BT_PAIR_REQ, URC_BT_NEED_PASSKEY, &bt_dev, NULL); // need paaskey
102c9f64:	e3a00005 	mov	r0, #5
102c9f68:	e12fff3c 	blx	ip
102c9f6c:	eaffff51 	b	102c9cb8 <OnURCHandler_BTIndication+0x98>
        if (connId == m_arrBTDev[i]->connId)
        {
            return m_arrBTDev[i]->btDevice.devHdl;
        }
    }
    return 0;
102c9f70:	e3a03000 	mov	r3, #0
102c9f74:	eaffffb7 	b	102c9e58 <OnURCHandler_BTIndication+0x238>
102c9f78:	102e58f4 	.word	0x102e58f4
102c9f7c:	f03d5058 	.word	0xf03d5058
102c9f80:	102e6598 	.word	0x102e6598
102c9f84:	102e55fc 	.word	0x102e55fc
102c9f88:	102ccd58 	.word	0x102ccd58
102c9f8c:	f03de548 	.word	0xf03de548
102c9f90:	102ede68 	.word	0x102ede68
102c9f94:	102e581c 	.word	0x102e581c
102c9f98:	102ee208 	.word	0x102ee208
102c9f9c:	102edfa4 	.word	0x102edfa4
102c9fa0:	102e57a4 	.word	0x102e57a4
102c9fa4:	102ee210 	.word	0x102ee210
102c9fa8:	102ee230 	.word	0x102ee230
102c9fac:	102cd1a4 	.word	0x102cd1a4
102c9fb0:	102ee250 	.word	0x102ee250
102c9fb4:	102ee258 	.word	0x102ee258
102c9fb8:	102ee270 	.word	0x102ee270
102c9fbc:	102ee2bc 	.word	0x102ee2bc
102c9fc0:	102ee2c4 	.word	0x102ee2c4
102c9fc4:	102ee278 	.word	0x102ee278
102c9fc8:	102ee29c 	.word	0x102ee29c

102c9fcc <Ql_RIL_RcvDataFrmCore>:
*               None.     
*
*****************************************************************/
CB_RIL_RcvDataFrmCore cb_rcvCoreData = NULL;
void Ql_RIL_RcvDataFrmCore(u8* ptrData, u32 dataLen, void* reserved)
{
102c9fcc:	e92d4008 	push	{r3, lr}
    if (cb_rcvCoreData != NULL)
102c9fd0:	e59f3010 	ldr	r3, [pc, #16]	; 102c9fe8 <Ql_RIL_RcvDataFrmCore+0x1c>
102c9fd4:	e5933000 	ldr	r3, [r3]
102c9fd8:	e3530000 	cmp	r3, #0
102c9fdc:	08bd8008 	popeq	{r3, pc}
    {
        cb_rcvCoreData(ptrData, dataLen, reserved);
102c9fe0:	e12fff33 	blx	r3
102c9fe4:	e8bd8008 	pop	{r3, pc}
102c9fe8:	f03d50f0 	.word	0xf03d50f0

102c9fec <ATResponse_Handler>:
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.               
*****************************************************************/
static s32 ATResponse_Handler(char* line, u32 len, void* userData)
{
102c9fec:	e92d4070 	push	{r4, r5, r6, lr}
    // get TONEDET threshold
    if ( Ql_strstr(line, "+QTONEDET:") )
102c9ff0:	e59f30c4 	ldr	r3, [pc, #196]	; 102ca0bc <ATResponse_Handler+0xd0>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.               
*****************************************************************/
static s32 ATResponse_Handler(char* line, u32 len, void* userData)
{
102c9ff4:	e1a05001 	mov	r5, r1
    // get TONEDET threshold
    if ( Ql_strstr(line, "+QTONEDET:") )
102c9ff8:	e59f10c0 	ldr	r1, [pc, #192]	; 102ca0c0 <ATResponse_Handler+0xd4>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.               
*****************************************************************/
static s32 ATResponse_Handler(char* line, u32 len, void* userData)
{
102c9ffc:	e1a04000 	mov	r4, r0
    // get TONEDET threshold
    if ( Ql_strstr(line, "+QTONEDET:") )
102ca000:	e12fff33 	blx	r3
102ca004:	e3500000 	cmp	r0, #0
102ca008:	0a00000b 	beq	102ca03c <ATResponse_Handler+0x50>
    {
        if ( NULL != g_low_thresholdPtr && NULL != g_high_thresholdPtr )
102ca00c:	e59f30b0 	ldr	r3, [pc, #176]	; 102ca0c4 <ATResponse_Handler+0xd8>
102ca010:	e5932000 	ldr	r2, [r3]
102ca014:	e3520000 	cmp	r2, #0
102ca018:	0a000007 	beq	102ca03c <ATResponse_Handler+0x50>
102ca01c:	e5933004 	ldr	r3, [r3, #4]
102ca020:	e3530000 	cmp	r3, #0
102ca024:	0a000004 	beq	102ca03c <ATResponse_Handler+0x50>
        {
            Ql_sscanf( line, "%*[^,],%*[^,],%d,%d", g_low_thresholdPtr, g_high_thresholdPtr );
102ca028:	e59f1098 	ldr	r1, [pc, #152]	; 102ca0c8 <ATResponse_Handler+0xdc>
102ca02c:	e1a00004 	mov	r0, r4
102ca030:	e591c000 	ldr	ip, [r1]
102ca034:	e59f1090 	ldr	r1, [pc, #144]	; 102ca0cc <ATResponse_Handler+0xe0>
102ca038:	e12fff3c 	blx	ip
            RIL_DTMF_DEBUG( DBG_Buffer, "<-- ATResponse_Handler: low=%d, high=%d -->\r\n", *g_low_thresholdPtr, *g_high_thresholdPtr );
        }
    }
    
    
    if (Ql_RIL_FindLine(line, len, "OK"))
102ca03c:	e1a00004 	mov	r0, r4
102ca040:	e1a01005 	mov	r1, r5
102ca044:	e59f2084 	ldr	r2, [pc, #132]	; 102ca0d0 <ATResponse_Handler+0xe4>
102ca048:	e59f6084 	ldr	r6, [pc, #132]	; 102ca0d4 <ATResponse_Handler+0xe8>
102ca04c:	e12fff36 	blx	r6
102ca050:	e3500000 	cmp	r0, #0
102ca054:	0a000001 	beq	102ca060 <ATResponse_Handler+0x74>
    {  
        return  RIL_ATRSP_SUCCESS;
102ca058:	e3a00000 	mov	r0, #0
102ca05c:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_RIL_FindLine(line, len, "ERROR"))
102ca060:	e1a00004 	mov	r0, r4
102ca064:	e1a01005 	mov	r1, r5
102ca068:	e59f2068 	ldr	r2, [pc, #104]	; 102ca0d8 <ATResponse_Handler+0xec>
102ca06c:	e12fff36 	blx	r6
102ca070:	e3500000 	cmp	r0, #0
102ca074:	1a00000e 	bne	102ca0b4 <ATResponse_Handler+0xc8>
    {  
        return  RIL_ATRSP_FAILED;
    }
    else if (Ql_RIL_FindString(line, len, "+CME ERROR"))
102ca078:	e1a00004 	mov	r0, r4
102ca07c:	e1a01005 	mov	r1, r5
102ca080:	e59f2054 	ldr	r2, [pc, #84]	; 102ca0dc <ATResponse_Handler+0xf0>
102ca084:	e59f6054 	ldr	r6, [pc, #84]	; 102ca0e0 <ATResponse_Handler+0xf4>
102ca088:	e12fff36 	blx	r6
102ca08c:	e3500000 	cmp	r0, #0
102ca090:	1a000007 	bne	102ca0b4 <ATResponse_Handler+0xc8>
    {
        return  RIL_ATRSP_FAILED;
    }
    else if (Ql_RIL_FindString(line, len, "+CMS ERROR:"))
102ca094:	e1a00004 	mov	r0, r4
102ca098:	e1a01005 	mov	r1, r5
102ca09c:	e59f2040 	ldr	r2, [pc, #64]	; 102ca0e4 <ATResponse_Handler+0xf8>
102ca0a0:	e12fff36 	blx	r6
102ca0a4:	e3500000 	cmp	r0, #0
102ca0a8:	1a000001 	bne	102ca0b4 <ATResponse_Handler+0xc8>
    {
        return  RIL_ATRSP_FAILED;
    }
    return RIL_ATRSP_CONTINUE; //continue wait
102ca0ac:	e3a00001 	mov	r0, #1
102ca0b0:	e8bd8070 	pop	{r4, r5, r6, pc}
    {  
        return  RIL_ATRSP_SUCCESS;
    }
    else if (Ql_RIL_FindLine(line, len, "ERROR"))
    {  
        return  RIL_ATRSP_FAILED;
102ca0b4:	e3e00000 	mvn	r0, #0
    else if (Ql_RIL_FindString(line, len, "+CMS ERROR:"))
    {
        return  RIL_ATRSP_FAILED;
    }
    return RIL_ATRSP_CONTINUE; //continue wait
}
102ca0b8:	e8bd8070 	pop	{r4, r5, r6, pc}
102ca0bc:	102e5a04 	.word	0x102e5a04
102ca0c0:	102ee348 	.word	0x102ee348
102ca0c4:	f03d50f4 	.word	0xf03d50f4
102ca0c8:	f03de548 	.word	0xf03de548
102ca0cc:	102ee354 	.word	0x102ee354
102ca0d0:	102ee5e8 	.word	0x102ee5e8
102ca0d4:	102ccf24 	.word	0x102ccf24
102ca0d8:	102ede00 	.word	0x102ede00
102ca0dc:	102ee368 	.word	0x102ee368
102ca0e0:	102cce98 	.word	0x102cce98
102ca0e4:	102ede24 	.word	0x102ede24

102ca0e8 <RIL_ToneDet_Open>:
s32 RIL_ToneDet_Open( CB_ToneDet cb_ToneDet_hdl )
{
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 
    
    callback_ToneDet = cb_ToneDet_hdl;
102ca0e8:	e59f3064 	ldr	r3, [pc, #100]	; 102ca154 <RIL_ToneDet_Open+0x6c>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.                
*****************************************************************/
s32 RIL_ToneDet_Open( CB_ToneDet cb_ToneDet_hdl )
{
102ca0ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102ca0f0:	e24dd0d4 	sub	sp, sp, #212	; 0xd4
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 
    
    callback_ToneDet = cb_ToneDet_hdl;

	Ql_memset(strAT, 0, sizeof(strAT));
102ca0f4:	e3a020c8 	mov	r2, #200	; 0xc8
s32 RIL_ToneDet_Open( CB_ToneDet cb_ToneDet_hdl )
{
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 
    
    callback_ToneDet = cb_ToneDet_hdl;
102ca0f8:	e5830008 	str	r0, [r3, #8]

	Ql_memset(strAT, 0, sizeof(strAT));
102ca0fc:	e3a01000 	mov	r1, #0
102ca100:	e28d0008 	add	r0, sp, #8
102ca104:	e59f304c 	ldr	r3, [pc, #76]	; 102ca158 <RIL_ToneDet_Open+0x70>
102ca108:	e12fff33 	blx	r3
	Ql_sprintf(strAT, "AT+QTONEDET=1\r\n");
102ca10c:	e59f3048 	ldr	r3, [pc, #72]	; 102ca15c <RIL_ToneDet_Open+0x74>
102ca110:	e59f1048 	ldr	r1, [pc, #72]	; 102ca160 <RIL_ToneDet_Open+0x78>
102ca114:	e5933000 	ldr	r3, [r3]
102ca118:	e28d0008 	add	r0, sp, #8
102ca11c:	e12fff33 	blx	r3
	ret = Ql_RIL_SendATCmd( strAT, Ql_strlen(strAT), NULL, NULL, 300 ) ;
102ca120:	e28d0008 	add	r0, sp, #8
102ca124:	e59f3038 	ldr	r3, [pc, #56]	; 102ca164 <RIL_ToneDet_Open+0x7c>
102ca128:	e12fff33 	blx	r3
102ca12c:	e3a02000 	mov	r2, #0
102ca130:	e3a03f4b 	mov	r3, #300	; 0x12c
102ca134:	e58d3000 	str	r3, [sp]
102ca138:	e59fc028 	ldr	ip, [pc, #40]	; 102ca168 <RIL_ToneDet_Open+0x80>
102ca13c:	e1a03002 	mov	r3, r2
102ca140:	e1a01000 	mov	r1, r0
102ca144:	e28d0008 	add	r0, sp, #8
102ca148:	e12fff3c 	blx	ip
                  
    RIL_DTMF_DEBUG( DBG_Buffer, "<-- Send AT:%s, ret = %d -->\r\n", strAT, ret );
    
    return ret;
}
102ca14c:	e28dd0d4 	add	sp, sp, #212	; 0xd4
102ca150:	e8bd8000 	ldmfd	sp!, {pc}
102ca154:	f03d50f4 	.word	0xf03d50f4
102ca158:	102e58f4 	.word	0x102e58f4
102ca15c:	f03de540 	.word	0xf03de540
102ca160:	102ee374 	.word	0x102ee374
102ca164:	102e57a4 	.word	0x102e57a4
102ca168:	102e5168 	.word	0x102e5168

102ca16c <RIL_ToneDet_Close>:
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.                
*****************************************************************/
s32 RIL_ToneDet_Close( void )
{
102ca16c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102ca170:	e24dd0d4 	sub	sp, sp, #212	; 0xd4
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 
    
	Ql_memset( strAT, 0, sizeof(strAT) );
102ca174:	e3a020c8 	mov	r2, #200	; 0xc8
102ca178:	e3a01000 	mov	r1, #0
102ca17c:	e28d0008 	add	r0, sp, #8
102ca180:	e59f3048 	ldr	r3, [pc, #72]	; 102ca1d0 <RIL_ToneDet_Close+0x64>
102ca184:	e12fff33 	blx	r3
	Ql_sprintf( strAT, "AT+QTONEDET=0\r\n" );
102ca188:	e59f3044 	ldr	r3, [pc, #68]	; 102ca1d4 <RIL_ToneDet_Close+0x68>
102ca18c:	e59f1044 	ldr	r1, [pc, #68]	; 102ca1d8 <RIL_ToneDet_Close+0x6c>
102ca190:	e5933000 	ldr	r3, [r3]
102ca194:	e28d0008 	add	r0, sp, #8
102ca198:	e12fff33 	blx	r3
	ret = Ql_RIL_SendATCmd( strAT, Ql_strlen(strAT), NULL, NULL, 300 ) ;
102ca19c:	e28d0008 	add	r0, sp, #8
102ca1a0:	e59f3034 	ldr	r3, [pc, #52]	; 102ca1dc <RIL_ToneDet_Close+0x70>
102ca1a4:	e12fff33 	blx	r3
102ca1a8:	e3a02000 	mov	r2, #0
102ca1ac:	e3a03f4b 	mov	r3, #300	; 0x12c
102ca1b0:	e58d3000 	str	r3, [sp]
102ca1b4:	e59fc024 	ldr	ip, [pc, #36]	; 102ca1e0 <RIL_ToneDet_Close+0x74>
102ca1b8:	e1a03002 	mov	r3, r2
102ca1bc:	e1a01000 	mov	r1, r0
102ca1c0:	e28d0008 	add	r0, sp, #8
102ca1c4:	e12fff3c 	blx	ip
                  
    RIL_DTMF_DEBUG( DBG_Buffer, "<-- Send AT:%s, ret = %d -->\r\n", strAT, ret );
    
    return ret;
}
102ca1c8:	e28dd0d4 	add	sp, sp, #212	; 0xd4
102ca1cc:	e8bd8000 	ldmfd	sp!, {pc}
102ca1d0:	102e58f4 	.word	0x102e58f4
102ca1d4:	f03de540 	.word	0xf03de540
102ca1d8:	102ee384 	.word	0x102ee384
102ca1dc:	102e57a4 	.word	0x102e57a4
102ca1e0:	102e5168 	.word	0x102e5168

102ca1e4 <RIL_ToneDet_Set>:
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.                            
*****************************************************************/
s32 RIL_ToneDet_Set( Enum_ToneDet_Mode mode, u32 pause, u32 low, u32 high )
{
102ca1e4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102ca1e8:	e1a04000 	mov	r4, r0
    s32 ret = RIL_AT_FAILED;
	char strAT[200]; 

    if ( mode <= RIL_DETThreshold_Min || mode >= RIL_DETThreshold_Max )
102ca1ec:	e2400002 	sub	r0, r0, #2
102ca1f0:	e3500002 	cmp	r0, #2
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.                            
*****************************************************************/
s32 RIL_ToneDet_Set( Enum_ToneDet_Mode mode, u32 pause, u32 low, u32 high )
{
102ca1f4:	e24dd0d4 	sub	sp, sp, #212	; 0xd4
102ca1f8:	e1a07001 	mov	r7, r1
102ca1fc:	e1a06002 	mov	r6, r2
102ca200:	e1a05003 	mov	r5, r3
    s32 ret = RIL_AT_FAILED;
	char strAT[200]; 

    if ( mode <= RIL_DETThreshold_Min || mode >= RIL_DETThreshold_Max )
102ca204:	8a00001a 	bhi	102ca274 <RIL_ToneDet_Set+0x90>
    {
        RIL_DTMF_DEBUG( DBG_Buffer, "<-- ToneDet Set Fail, INVALID PARAM: mode=%d -->\r\n", mode );
        return RIL_AT_INVALID_PARAM;
    }
    
	Ql_memset( strAT, 0, sizeof(strAT) );
102ca208:	e3a01000 	mov	r1, #0
102ca20c:	e3a020c8 	mov	r2, #200	; 0xc8
102ca210:	e59f3064 	ldr	r3, [pc, #100]	; 102ca27c <RIL_ToneDet_Set+0x98>
102ca214:	e28d0008 	add	r0, sp, #8
102ca218:	e12fff33 	blx	r3
	Ql_sprintf( strAT, "AT+QTONEDET=%d,1,%d,%d,%d", mode, pause, low, high );
102ca21c:	e59f005c 	ldr	r0, [pc, #92]	; 102ca280 <RIL_ToneDet_Set+0x9c>
102ca220:	e59f105c 	ldr	r1, [pc, #92]	; 102ca284 <RIL_ToneDet_Set+0xa0>
102ca224:	e1a02004 	mov	r2, r4
102ca228:	e1a03007 	mov	r3, r7
102ca22c:	e58d6000 	str	r6, [sp]
102ca230:	e58d5004 	str	r5, [sp, #4]
102ca234:	e590c000 	ldr	ip, [r0]
102ca238:	e28d0008 	add	r0, sp, #8
102ca23c:	e12fff3c 	blx	ip
	ret = Ql_RIL_SendATCmd( strAT, Ql_strlen(strAT), NULL, NULL, 300 ) ;
102ca240:	e59f3040 	ldr	r3, [pc, #64]	; 102ca288 <RIL_ToneDet_Set+0xa4>
102ca244:	e28d0008 	add	r0, sp, #8
102ca248:	e12fff33 	blx	r3
102ca24c:	e3a03f4b 	mov	r3, #300	; 0x12c
102ca250:	e3a02000 	mov	r2, #0
102ca254:	e58d3000 	str	r3, [sp]
102ca258:	e59fc02c 	ldr	ip, [pc, #44]	; 102ca28c <RIL_ToneDet_Set+0xa8>
102ca25c:	e1a03002 	mov	r3, r2
102ca260:	e1a01000 	mov	r1, r0
102ca264:	e28d0008 	add	r0, sp, #8
102ca268:	e12fff3c 	blx	ip
                  
    RIL_DTMF_DEBUG( DBG_Buffer, "<-- Send AT:%s, ret = %d -->\r\n", strAT, ret );

    return ret;
}
102ca26c:	e28dd0d4 	add	sp, sp, #212	; 0xd4
102ca270:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	char strAT[200]; 

    if ( mode <= RIL_DETThreshold_Min || mode >= RIL_DETThreshold_Max )
    {
        RIL_DTMF_DEBUG( DBG_Buffer, "<-- ToneDet Set Fail, INVALID PARAM: mode=%d -->\r\n", mode );
        return RIL_AT_INVALID_PARAM;
102ca274:	e3e00003 	mvn	r0, #3
102ca278:	eafffffb 	b	102ca26c <RIL_ToneDet_Set+0x88>
102ca27c:	102e58f4 	.word	0x102e58f4
102ca280:	f03de540 	.word	0xf03de540
102ca284:	102ee394 	.word	0x102ee394
102ca288:	102e57a4 	.word	0x102e57a4
102ca28c:	102e5168 	.word	0x102e5168

102ca290 <RIL_ToneDet_Get>:
s32 RIL_ToneDet_Get( Enum_ToneDet_Mode mode, u32 *low, u32 *high )
{
    s32 ret = RIL_AT_FAILED;
	char strAT[200]; 

    if ( mode < RIL_DETThreshold_Min || mode > RIL_DETThreshold_Max 
102ca290:	e2403001 	sub	r3, r0, #1
102ca294:	e3530004 	cmp	r3, #4
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.                              
*****************************************************************/
s32 RIL_ToneDet_Get( Enum_ToneDet_Mode mode, u32 *low, u32 *high )
{
102ca298:	e92d4070 	push	{r4, r5, r6, lr}
102ca29c:	e1a0c002 	mov	ip, r2
102ca2a0:	e24dd0d0 	sub	sp, sp, #208	; 0xd0
102ca2a4:	e1a05000 	mov	r5, r0
102ca2a8:	e1a04001 	mov	r4, r1
    s32 ret = RIL_AT_FAILED;
	char strAT[200]; 

    if ( mode < RIL_DETThreshold_Min || mode > RIL_DETThreshold_Max 
102ca2ac:	8a00001e 	bhi	102ca32c <RIL_ToneDet_Get+0x9c>
        || NULL == low
        || NULL == high )
102ca2b0:	e3510000 	cmp	r1, #0
102ca2b4:	13520000 	cmpne	r2, #0
102ca2b8:	13a06000 	movne	r6, #0
102ca2bc:	03a06001 	moveq	r6, #1
102ca2c0:	0a000019 	beq	102ca32c <RIL_ToneDet_Get+0x9c>
    {
        RIL_DTMF_DEBUG( DBG_Buffer, "<-- ToneDet Set Fail, INVALID PARAM: mode=%d. -->\r\n", mode );
        return RIL_AT_INVALID_PARAM;
    }

    g_low_thresholdPtr = low;
102ca2c4:	e59f3068 	ldr	r3, [pc, #104]	; 102ca334 <RIL_ToneDet_Get+0xa4>
    g_high_thresholdPtr = high;
    
	Ql_memset( strAT, 0, sizeof(strAT) );
102ca2c8:	e1a01006 	mov	r1, r6
        RIL_DTMF_DEBUG( DBG_Buffer, "<-- ToneDet Set Fail, INVALID PARAM: mode=%d. -->\r\n", mode );
        return RIL_AT_INVALID_PARAM;
    }

    g_low_thresholdPtr = low;
    g_high_thresholdPtr = high;
102ca2cc:	e8831010 	stm	r3, {r4, ip}
    
	Ql_memset( strAT, 0, sizeof(strAT) );
102ca2d0:	e3a020c8 	mov	r2, #200	; 0xc8
102ca2d4:	e59f305c 	ldr	r3, [pc, #92]	; 102ca338 <RIL_ToneDet_Get+0xa8>
102ca2d8:	e28d0008 	add	r0, sp, #8
102ca2dc:	e12fff33 	blx	r3
	Ql_sprintf( strAT, "AT+QTONEDET=%d,0", mode );
102ca2e0:	e59f3054 	ldr	r3, [pc, #84]	; 102ca33c <RIL_ToneDet_Get+0xac>
102ca2e4:	e59f1054 	ldr	r1, [pc, #84]	; 102ca340 <RIL_ToneDet_Get+0xb0>
102ca2e8:	e1a02005 	mov	r2, r5
102ca2ec:	e5933000 	ldr	r3, [r3]
102ca2f0:	e28d0008 	add	r0, sp, #8
102ca2f4:	e12fff33 	blx	r3
	ret = Ql_RIL_SendATCmd( strAT, Ql_strlen(strAT), ATResponse_Handler, NULL, 300 ) ;
102ca2f8:	e59f3044 	ldr	r3, [pc, #68]	; 102ca344 <RIL_ToneDet_Get+0xb4>
102ca2fc:	e28d0008 	add	r0, sp, #8
102ca300:	e12fff33 	blx	r3
102ca304:	e3a03f4b 	mov	r3, #300	; 0x12c
102ca308:	e58d3000 	str	r3, [sp]
102ca30c:	e59f2034 	ldr	r2, [pc, #52]	; 102ca348 <RIL_ToneDet_Get+0xb8>
102ca310:	e1a03006 	mov	r3, r6
102ca314:	e59fc030 	ldr	ip, [pc, #48]	; 102ca34c <RIL_ToneDet_Get+0xbc>
102ca318:	e1a01000 	mov	r1, r0
102ca31c:	e28d0008 	add	r0, sp, #8
102ca320:	e12fff3c 	blx	ip
                  
    RIL_DTMF_DEBUG( DBG_Buffer, "<-- Send AT:%s, ret = %d -->\r\n", strAT, ret );

    return ret;
}
102ca324:	e28dd0d0 	add	sp, sp, #208	; 0xd0
102ca328:	e8bd8070 	pop	{r4, r5, r6, pc}
    if ( mode < RIL_DETThreshold_Min || mode > RIL_DETThreshold_Max 
        || NULL == low
        || NULL == high )
    {
        RIL_DTMF_DEBUG( DBG_Buffer, "<-- ToneDet Set Fail, INVALID PARAM: mode=%d. -->\r\n", mode );
        return RIL_AT_INVALID_PARAM;
102ca32c:	e3e00003 	mvn	r0, #3
102ca330:	eafffffb 	b	102ca324 <RIL_ToneDet_Get+0x94>
102ca334:	f03d50f4 	.word	0xf03d50f4
102ca338:	102e58f4 	.word	0x102e58f4
102ca33c:	f03de540 	.word	0xf03de540
102ca340:	102ee3b0 	.word	0x102ee3b0
102ca344:	102e57a4 	.word	0x102e57a4
102ca348:	102c9fec 	.word	0x102c9fec
102ca34c:	102e5168 	.word	0x102e5168

102ca350 <OnURCHandler_QToneDet>:
*                   reserved, can be NULL.
* Return:        
*               
*****************************************************************/
void OnURCHandler_QToneDet( const char* strURC, void* reserved )
{
102ca350:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
	char buff[30];
    s32 dtmfCode = -1;
    s32 timems = -1;
        
 	if ( NULL != callback_ToneDet )
102ca354:	e59f40c4 	ldr	r4, [pc, #196]	; 102ca420 <OnURCHandler_QToneDet+0xd0>
*                   reserved, can be NULL.
* Return:        
*               
*****************************************************************/
void OnURCHandler_QToneDet( const char* strURC, void* reserved )
{
102ca358:	e24dd024 	sub	sp, sp, #36	; 0x24
	char buff[30];
    s32 dtmfCode = -1;
    s32 timems = -1;
        
 	if ( NULL != callback_ToneDet )
102ca35c:	e5943008 	ldr	r3, [r4, #8]
*                   reserved, can be NULL.
* Return:        
*               
*****************************************************************/
void OnURCHandler_QToneDet( const char* strURC, void* reserved )
{
102ca360:	e1a05000 	mov	r5, r0
	char buff[30];
    s32 dtmfCode = -1;
    s32 timems = -1;
        
 	if ( NULL != callback_ToneDet )
102ca364:	e3530000 	cmp	r3, #0
102ca368:	0a000009 	beq	102ca394 <OnURCHandler_QToneDet+0x44>
 	{
		Ql_strcpy( buff, "\r\n+QTONEDET:\0" );
102ca36c:	e59f10b0 	ldr	r1, [pc, #176]	; 102ca424 <OnURCHandler_QToneDet+0xd4>
102ca370:	e59f30b0 	ldr	r3, [pc, #176]	; 102ca428 <OnURCHandler_QToneDet+0xd8>
102ca374:	e1a0000d 	mov	r0, sp
102ca378:	e12fff33 	blx	r3
		if( Ql_StrPrefixMatch(strURC, buff) )
102ca37c:	e1a00005 	mov	r0, r5
102ca380:	e1a0100d 	mov	r1, sp
102ca384:	e59f30a0 	ldr	r3, [pc, #160]	; 102ca42c <OnURCHandler_QToneDet+0xdc>
102ca388:	e12fff33 	blx	r3
102ca38c:	e3500000 	cmp	r0, #0
102ca390:	1a000001 	bne	102ca39c <OnURCHandler_QToneDet+0x4c>
            }
			
			callback_ToneDet( dtmfCode, timems );
		}
	}
}
102ca394:	e28dd024 	add	sp, sp, #36	; 0x24
102ca398:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
 	if ( NULL != callback_ToneDet )
 	{
		Ql_strcpy( buff, "\r\n+QTONEDET:\0" );
		if( Ql_StrPrefixMatch(strURC, buff) )
		{
			Ql_sscanf(strURC,"%*[^:]: %[^,]",buff);
102ca39c:	e59fa08c 	ldr	sl, [pc, #140]	; 102ca430 <OnURCHandler_QToneDet+0xe0>
102ca3a0:	e1a0200d 	mov	r2, sp
102ca3a4:	e59a3000 	ldr	r3, [sl]
102ca3a8:	e59f1084 	ldr	r1, [pc, #132]	; 102ca434 <OnURCHandler_QToneDet+0xe4>
102ca3ac:	e1a00005 	mov	r0, r5
102ca3b0:	e12fff33 	blx	r3
			dtmfCode = Ql_atof(buff);
102ca3b4:	e59f807c 	ldr	r8, [pc, #124]	; 102ca438 <OnURCHandler_QToneDet+0xe8>
102ca3b8:	e1a0000d 	mov	r0, sp
102ca3bc:	e12fff38 	blx	r8
102ca3c0:	e59f7074 	ldr	r7, [pc, #116]	; 102ca43c <OnURCHandler_QToneDet+0xec>
102ca3c4:	e12fff37 	blx	r7
            if ( dtmfCode < 48 || dtmfCode > 70 )   
102ca3c8:	e2403030 	sub	r3, r0, #48	; 0x30
102ca3cc:	e3530016 	cmp	r3, #22
 	{
		Ql_strcpy( buff, "\r\n+QTONEDET:\0" );
		if( Ql_StrPrefixMatch(strURC, buff) )
		{
			Ql_sscanf(strURC,"%*[^:]: %[^,]",buff);
			dtmfCode = Ql_atof(buff);
102ca3d0:	e1a06000 	mov	r6, r0
            if ( dtmfCode < 48 || dtmfCode > 70 )   
102ca3d4:	8affffee 	bhi	102ca394 <OnURCHandler_QToneDet+0x44>
            {
                return;     // not dtmfCode return.
            }
            else if ( 69 == dtmfCode || 70 == dtmfCode )
102ca3d8:	e2403045 	sub	r3, r0, #69	; 0x45
102ca3dc:	e3530001 	cmp	r3, #1
*****************************************************************/
void OnURCHandler_QToneDet( const char* strURC, void* reserved )
{
	char buff[30];
    s32 dtmfCode = -1;
    s32 timems = -1;
102ca3e0:	83e01000 	mvnhi	r1, #0
			dtmfCode = Ql_atof(buff);
            if ( dtmfCode < 48 || dtmfCode > 70 )   
            {
                return;     // not dtmfCode return.
            }
            else if ( 69 == dtmfCode || 70 == dtmfCode )
102ca3e4:	9a000003 	bls	102ca3f8 <OnURCHandler_QToneDet+0xa8>
            {
                Ql_sscanf( strURC, "%*[^,],%[^\r\n]", buff );
    			timems = Ql_atof( buff );
            }
			
			callback_ToneDet( dtmfCode, timems );
102ca3e8:	e5943008 	ldr	r3, [r4, #8]
102ca3ec:	e1a00006 	mov	r0, r6
102ca3f0:	e12fff33 	blx	r3
102ca3f4:	eaffffe6 	b	102ca394 <OnURCHandler_QToneDet+0x44>
            {
                return;     // not dtmfCode return.
            }
            else if ( 69 == dtmfCode || 70 == dtmfCode )
            {
                Ql_sscanf( strURC, "%*[^,],%[^\r\n]", buff );
102ca3f8:	e1a0200d 	mov	r2, sp
102ca3fc:	e59a3000 	ldr	r3, [sl]
102ca400:	e59f1038 	ldr	r1, [pc, #56]	; 102ca440 <OnURCHandler_QToneDet+0xf0>
102ca404:	e1a00005 	mov	r0, r5
102ca408:	e12fff33 	blx	r3
    			timems = Ql_atof( buff );
102ca40c:	e1a0000d 	mov	r0, sp
102ca410:	e12fff38 	blx	r8
102ca414:	e12fff37 	blx	r7
102ca418:	e1a01000 	mov	r1, r0
102ca41c:	eafffff1 	b	102ca3e8 <OnURCHandler_QToneDet+0x98>
102ca420:	f03d50f4 	.word	0xf03d50f4
102ca424:	102e65a4 	.word	0x102e65a4
102ca428:	102e55fc 	.word	0x102e55fc
102ca42c:	102ccd58 	.word	0x102ccd58
102ca430:	f03de548 	.word	0xf03de548
102ca434:	102ee3c4 	.word	0x102ee3c4
102ca438:	102e5564 	.word	0x102e5564
102ca43c:	102e3900 	.word	0x102e3900
102ca440:	102ee3d4 	.word	0x102ee3d4

102ca444 <RIL_WDTMF_Send>:
s32 RIL_WDTMF_Send( Enum_WDTMF_Vomume ul_volume, Enum_WDTMF_Vomume dl_volume, u8 *dtmfStr, CB_WDTMF cb_WDTMF_hdl )
{
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 

    if ( ( ul_volume < RIL_WDTMF_VOLUME0 || ul_volume > RIL_WDTMF_VOLUME7 )
102ca444:	e3500007 	cmp	r0, #7
102ca448:	93510007 	cmpls	r1, #7
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.               
*****************************************************************/
s32 RIL_WDTMF_Send( Enum_WDTMF_Vomume ul_volume, Enum_WDTMF_Vomume dl_volume, u8 *dtmfStr, CB_WDTMF cb_WDTMF_hdl )
{
102ca44c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102ca450:	e1a05000 	mov	r5, r0
102ca454:	e24dd0d4 	sub	sp, sp, #212	; 0xd4
102ca458:	e1a04001 	mov	r4, r1
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 

    if ( ( ul_volume < RIL_WDTMF_VOLUME0 || ul_volume > RIL_WDTMF_VOLUME7 )
102ca45c:	93a06000 	movls	r6, #0
102ca460:	83a06001 	movhi	r6, #1
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.               
*****************************************************************/
s32 RIL_WDTMF_Send( Enum_WDTMF_Vomume ul_volume, Enum_WDTMF_Vomume dl_volume, u8 *dtmfStr, CB_WDTMF cb_WDTMF_hdl )
{
102ca464:	e1a07002 	mov	r7, r2
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 

    if ( ( ul_volume < RIL_WDTMF_VOLUME0 || ul_volume > RIL_WDTMF_VOLUME7 )
102ca468:	8a00001c 	bhi	102ca4e0 <RIL_WDTMF_Send+0x9c>
        || ( dl_volume < RIL_WDTMF_VOLUME0 || dl_volume > RIL_WDTMF_VOLUME7 )
        || ( NULL == dtmfStr ) )
102ca46c:	e3520000 	cmp	r2, #0
102ca470:	0a00001a 	beq	102ca4e0 <RIL_WDTMF_Send+0x9c>
    {
        RIL_DTMF_DEBUG( DBG_Buffer, "<-- WDTMF Send Fail, INVALID PARAM. -->\r\n");
        return RIL_AT_INVALID_PARAM;
    }

    callback_WDTMF = cb_WDTMF_hdl;
102ca474:	e59fc06c 	ldr	ip, [pc, #108]	; 102ca4e8 <RIL_WDTMF_Send+0xa4>
    
	Ql_memset( strAT, 0, sizeof(strAT) );
102ca478:	e1a01006 	mov	r1, r6
    {
        RIL_DTMF_DEBUG( DBG_Buffer, "<-- WDTMF Send Fail, INVALID PARAM. -->\r\n");
        return RIL_AT_INVALID_PARAM;
    }

    callback_WDTMF = cb_WDTMF_hdl;
102ca47c:	e58c300c 	str	r3, [ip, #12]
    
	Ql_memset( strAT, 0, sizeof(strAT) );
102ca480:	e3a020c8 	mov	r2, #200	; 0xc8
102ca484:	e59f3060 	ldr	r3, [pc, #96]	; 102ca4ec <RIL_WDTMF_Send+0xa8>
102ca488:	e28d0008 	add	r0, sp, #8
102ca48c:	e12fff33 	blx	r3
	Ql_sprintf( strAT, "AT+QWDTMF=%d,%d,\"%s\"\r\n", ul_volume, dl_volume, dtmfStr );
102ca490:	e59f0058 	ldr	r0, [pc, #88]	; 102ca4f0 <RIL_WDTMF_Send+0xac>
102ca494:	e59f1058 	ldr	r1, [pc, #88]	; 102ca4f4 <RIL_WDTMF_Send+0xb0>
102ca498:	e1a02005 	mov	r2, r5
102ca49c:	e1a03004 	mov	r3, r4
102ca4a0:	e58d7000 	str	r7, [sp]
102ca4a4:	e590c000 	ldr	ip, [r0]
102ca4a8:	e28d0008 	add	r0, sp, #8
102ca4ac:	e12fff3c 	blx	ip
	ret = Ql_RIL_SendATCmd( strAT, Ql_strlen(strAT), NULL, NULL, 0 ) ;
102ca4b0:	e59f3040 	ldr	r3, [pc, #64]	; 102ca4f8 <RIL_WDTMF_Send+0xb4>
102ca4b4:	e28d0008 	add	r0, sp, #8
102ca4b8:	e12fff33 	blx	r3
102ca4bc:	e1a02006 	mov	r2, r6
102ca4c0:	e58d6000 	str	r6, [sp]
102ca4c4:	e1a03006 	mov	r3, r6
102ca4c8:	e59fc02c 	ldr	ip, [pc, #44]	; 102ca4fc <RIL_WDTMF_Send+0xb8>
102ca4cc:	e1a01000 	mov	r1, r0
102ca4d0:	e28d0008 	add	r0, sp, #8
102ca4d4:	e12fff3c 	blx	ip
                  
    RIL_DTMF_DEBUG( DBG_Buffer, "<-- Send AT:%s, ret = %d -->\r\n", strAT, ret );
    
    return ret;
}
102ca4d8:	e28dd0d4 	add	sp, sp, #212	; 0xd4
102ca4dc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    if ( ( ul_volume < RIL_WDTMF_VOLUME0 || ul_volume > RIL_WDTMF_VOLUME7 )
        || ( dl_volume < RIL_WDTMF_VOLUME0 || dl_volume > RIL_WDTMF_VOLUME7 )
        || ( NULL == dtmfStr ) )
    {
        RIL_DTMF_DEBUG( DBG_Buffer, "<-- WDTMF Send Fail, INVALID PARAM. -->\r\n");
        return RIL_AT_INVALID_PARAM;
102ca4e0:	e3e00003 	mvn	r0, #3
102ca4e4:	eafffffb 	b	102ca4d8 <RIL_WDTMF_Send+0x94>
102ca4e8:	f03d50f4 	.word	0xf03d50f4
102ca4ec:	102e58f4 	.word	0x102e58f4
102ca4f0:	f03de540 	.word	0xf03de540
102ca4f4:	102ee3e4 	.word	0x102ee3e4
102ca4f8:	102e57a4 	.word	0x102e57a4
102ca4fc:	102e5168 	.word	0x102e5168

102ca500 <OnURCHandler_QWDTMF>:
*                   reserved, can be NULL.
* Return:        
*               
*****************************************************************/
void OnURCHandler_QWDTMF( const char* strURC, void* reserved )
{
102ca500:	e92d4030 	push	{r4, r5, lr}
	char buff[30];
    s32 result = -1;
        
 	if ( NULL != callback_WDTMF )
102ca504:	e59f4078 	ldr	r4, [pc, #120]	; 102ca584 <OnURCHandler_QWDTMF+0x84>
*                   reserved, can be NULL.
* Return:        
*               
*****************************************************************/
void OnURCHandler_QWDTMF( const char* strURC, void* reserved )
{
102ca508:	e24dd024 	sub	sp, sp, #36	; 0x24
	char buff[30];
    s32 result = -1;
        
 	if ( NULL != callback_WDTMF )
102ca50c:	e594300c 	ldr	r3, [r4, #12]
*                   reserved, can be NULL.
* Return:        
*               
*****************************************************************/
void OnURCHandler_QWDTMF( const char* strURC, void* reserved )
{
102ca510:	e1a05000 	mov	r5, r0
	char buff[30];
    s32 result = -1;
        
 	if ( NULL != callback_WDTMF )
102ca514:	e3530000 	cmp	r3, #0
102ca518:	0a000009 	beq	102ca544 <OnURCHandler_QWDTMF+0x44>
 	{
		Ql_strcpy( buff, "\r\n+QWDTMF:\0" );
102ca51c:	e59f1064 	ldr	r1, [pc, #100]	; 102ca588 <OnURCHandler_QWDTMF+0x88>
102ca520:	e59f3064 	ldr	r3, [pc, #100]	; 102ca58c <OnURCHandler_QWDTMF+0x8c>
102ca524:	e1a0000d 	mov	r0, sp
102ca528:	e12fff33 	blx	r3
		if( Ql_StrPrefixMatch(strURC, buff) )
102ca52c:	e1a00005 	mov	r0, r5
102ca530:	e1a0100d 	mov	r1, sp
102ca534:	e59f3054 	ldr	r3, [pc, #84]	; 102ca590 <OnURCHandler_QWDTMF+0x90>
102ca538:	e12fff33 	blx	r3
102ca53c:	e3500000 	cmp	r0, #0
102ca540:	1a000001 	bne	102ca54c <OnURCHandler_QWDTMF+0x4c>
			result = Ql_atof( buff );
			
			callback_WDTMF( result );
		}
	}
102ca544:	e28dd024 	add	sp, sp, #36	; 0x24
102ca548:	e8bd8030 	pop	{r4, r5, pc}
 	if ( NULL != callback_WDTMF )
 	{
		Ql_strcpy( buff, "\r\n+QWDTMF:\0" );
		if( Ql_StrPrefixMatch(strURC, buff) )
		{
			Ql_sscanf( strURC, "%*[^:]: %[^\r\n]", buff );
102ca54c:	e59f3040 	ldr	r3, [pc, #64]	; 102ca594 <OnURCHandler_QWDTMF+0x94>
102ca550:	e1a0200d 	mov	r2, sp
102ca554:	e59f103c 	ldr	r1, [pc, #60]	; 102ca598 <OnURCHandler_QWDTMF+0x98>
102ca558:	e5933000 	ldr	r3, [r3]
102ca55c:	e1a00005 	mov	r0, r5
102ca560:	e12fff33 	blx	r3
			result = Ql_atof( buff );
102ca564:	e1a0000d 	mov	r0, sp
102ca568:	e59f302c 	ldr	r3, [pc, #44]	; 102ca59c <OnURCHandler_QWDTMF+0x9c>
102ca56c:	e12fff33 	blx	r3
102ca570:	e59f3028 	ldr	r3, [pc, #40]	; 102ca5a0 <OnURCHandler_QWDTMF+0xa0>
102ca574:	e12fff33 	blx	r3
			
			callback_WDTMF( result );
102ca578:	e594300c 	ldr	r3, [r4, #12]
102ca57c:	e12fff33 	blx	r3
102ca580:	eaffffef 	b	102ca544 <OnURCHandler_QWDTMF+0x44>
102ca584:	f03d50f4 	.word	0xf03d50f4
102ca588:	102e65b4 	.word	0x102e65b4
102ca58c:	102e55fc 	.word	0x102e55fc
102ca590:	102ccd58 	.word	0x102ccd58
102ca594:	f03de548 	.word	0xf03de548
102ca598:	102ee3fc 	.word	0x102ee3fc
102ca59c:	102e5564 	.word	0x102e5564
102ca5a0:	102e3900 	.word	0x102e3900

102ca5a4 <ATRsp_QHTTP_Handler>:
    Ql_MEM_Free(strAT);
    return retRes; 
}

static s32 ATRsp_QHTTP_Handler(char* line, u32 len, void* param)
{
102ca5a4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102ca5a8:	e1a08002 	mov	r8, r2
    char* pHead = NULL;
    RIL_HTTP_DEBUG(DBG_Buffer, "RCV:%s, len:%d, m_httpAction:%d\r\n", line, len, m_httpAction);
    pHead = Ql_RIL_FindLine(line, len, "CONNECT");
102ca5ac:	e59f50f4 	ldr	r5, [pc, #244]	; 102ca6a8 <ATRsp_QHTTP_Handler+0x104>
102ca5b0:	e59f20f4 	ldr	r2, [pc, #244]	; 102ca6ac <ATRsp_QHTTP_Handler+0x108>
    Ql_MEM_Free(strAT);
    return retRes; 
}

static s32 ATRsp_QHTTP_Handler(char* line, u32 len, void* param)
{
102ca5b4:	e1a06000 	mov	r6, r0
102ca5b8:	e1a07001 	mov	r7, r1
    char* pHead = NULL;
    RIL_HTTP_DEBUG(DBG_Buffer, "RCV:%s, len:%d, m_httpAction:%d\r\n", line, len, m_httpAction);
    pHead = Ql_RIL_FindLine(line, len, "CONNECT");
102ca5bc:	e12fff35 	blx	r5
    if (pHead)
102ca5c0:	e2504000 	subs	r4, r0, #0
102ca5c4:	0a000013 	beq	102ca618 <ATRsp_QHTTP_Handler+0x74>
    {
        if (HTTP_ACTION_SETRUL == m_httpAction)
102ca5c8:	e59f30e0 	ldr	r3, [pc, #224]	; 102ca6b0 <ATRsp_QHTTP_Handler+0x10c>
102ca5cc:	e5d34000 	ldrb	r4, [r3]
102ca5d0:	e3540001 	cmp	r4, #1
102ca5d4:	0a000009 	beq	102ca600 <ATRsp_QHTTP_Handler+0x5c>
        {
            Ql_RIL_WriteDataToCore((u8*)http_url_addr, http_url_addr_len);
        }
        else if (HTTP_ACTION_POST_REQ == m_httpAction)
102ca5d8:	e3540003 	cmp	r4, #3
102ca5dc:	0a000001 	beq	102ca5e8 <ATRsp_QHTTP_Handler+0x44>
        }
        else if (HTTP_ACTION_READ_RSP == m_httpAction)
        {
            RIL_HTTP_DEBUG(DBG_Buffer, "<Enter data mode>\r\n");
        }
        return RIL_ATRSP_CONTINUE;  // wait for OK
102ca5e0:	e3a00001 	mov	r0, #1
102ca5e4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            Ql_RIL_WriteDataToCore((u8*)http_url_addr, http_url_addr_len);
        }
        else if (HTTP_ACTION_POST_REQ == m_httpAction)
        {
            RIL_HTTP_DEBUG(DBG_Buffer, "Post msg:len=%d, msg:%s\r\n", http_post_msg_len, http_post_msg);
            Ql_RIL_WriteDataToCore((u8*)http_post_msg, http_post_msg_len);
102ca5e8:	e1d311b0 	ldrh	r1, [r3, #16]
102ca5ec:	e593000c 	ldr	r0, [r3, #12]
102ca5f0:	e59f30bc 	ldr	r3, [pc, #188]	; 102ca6b4 <ATRsp_QHTTP_Handler+0x110>
102ca5f4:	e12fff33 	blx	r3
        }
        else if (HTTP_ACTION_READ_RSP == m_httpAction)
        {
            RIL_HTTP_DEBUG(DBG_Buffer, "<Enter data mode>\r\n");
        }
        return RIL_ATRSP_CONTINUE;  // wait for OK
102ca5f8:	e3a00001 	mov	r0, #1
102ca5fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    pHead = Ql_RIL_FindLine(line, len, "CONNECT");
    if (pHead)
    {
        if (HTTP_ACTION_SETRUL == m_httpAction)
        {
            Ql_RIL_WriteDataToCore((u8*)http_url_addr, http_url_addr_len);
102ca600:	e1d310b8 	ldrh	r1, [r3, #8]
102ca604:	e5930004 	ldr	r0, [r3, #4]
102ca608:	e59f30a4 	ldr	r3, [pc, #164]	; 102ca6b4 <ATRsp_QHTTP_Handler+0x110>
102ca60c:	e12fff33 	blx	r3
        }
        else if (HTTP_ACTION_READ_RSP == m_httpAction)
        {
            RIL_HTTP_DEBUG(DBG_Buffer, "<Enter data mode>\r\n");
        }
        return RIL_ATRSP_CONTINUE;  // wait for OK
102ca610:	e1a00004 	mov	r0, r4
102ca614:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
    pHead = Ql_RIL_FindLine(line, len, "OK");
102ca618:	e1a00006 	mov	r0, r6
102ca61c:	e1a01007 	mov	r1, r7
102ca620:	e59f2090 	ldr	r2, [pc, #144]	; 102ca6b8 <ATRsp_QHTTP_Handler+0x114>
102ca624:	e12fff35 	blx	r5
    if (pHead)
102ca628:	e3500000 	cmp	r0, #0
102ca62c:	0a000001 	beq	102ca638 <ATRsp_QHTTP_Handler+0x94>
    {
        return RIL_ATRSP_SUCCESS;
102ca630:	e1a00004 	mov	r0, r4
            Ql_sscanf(line, "%*[^: ]: %d[^\r\n]", (s32*)param);
        }
        return RIL_ATRSP_FAILED;
    }
    return RIL_ATRSP_CONTINUE;  // Just wait for the specified results above
}
102ca634:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    pHead = Ql_RIL_FindLine(line, len, "OK");
    if (pHead)
    {
        return RIL_ATRSP_SUCCESS;
    }
    pHead = Ql_RIL_FindLine(line, len, "ERROR");
102ca638:	e1a00006 	mov	r0, r6
102ca63c:	e1a01007 	mov	r1, r7
102ca640:	e59f2074 	ldr	r2, [pc, #116]	; 102ca6bc <ATRsp_QHTTP_Handler+0x118>
102ca644:	e12fff35 	blx	r5
    if (pHead)
102ca648:	e3500000 	cmp	r0, #0
102ca64c:	0a000004 	beq	102ca664 <ATRsp_QHTTP_Handler+0xc0>
    {
        if (param != NULL)
102ca650:	e3580000 	cmp	r8, #0
102ca654:	0a000011 	beq	102ca6a0 <ATRsp_QHTTP_Handler+0xfc>
        {
            *((s32*)param) = RIL_AT_FAILED;
102ca658:	e3e00000 	mvn	r0, #0
102ca65c:	e5880000 	str	r0, [r8]
102ca660:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        }
        return RIL_ATRSP_FAILED;
    }
    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");
102ca664:	e1a00006 	mov	r0, r6
102ca668:	e1a01007 	mov	r1, r7
102ca66c:	e59f204c 	ldr	r2, [pc, #76]	; 102ca6c0 <ATRsp_QHTTP_Handler+0x11c>
102ca670:	e59f304c 	ldr	r3, [pc, #76]	; 102ca6c4 <ATRsp_QHTTP_Handler+0x120>
102ca674:	e12fff33 	blx	r3
    if (pHead)
102ca678:	e3500000 	cmp	r0, #0
102ca67c:	0affffd7 	beq	102ca5e0 <ATRsp_QHTTP_Handler+0x3c>
    {
        if (param != NULL)
102ca680:	e3580000 	cmp	r8, #0
102ca684:	0a000005 	beq	102ca6a0 <ATRsp_QHTTP_Handler+0xfc>
        {
            Ql_sscanf(line, "%*[^: ]: %d[^\r\n]", (s32*)param);
102ca688:	e59f3038 	ldr	r3, [pc, #56]	; 102ca6c8 <ATRsp_QHTTP_Handler+0x124>
102ca68c:	e1a00006 	mov	r0, r6
102ca690:	e5933000 	ldr	r3, [r3]
102ca694:	e59f1030 	ldr	r1, [pc, #48]	; 102ca6cc <ATRsp_QHTTP_Handler+0x128>
102ca698:	e1a02008 	mov	r2, r8
102ca69c:	e12fff33 	blx	r3
        }
        return RIL_ATRSP_FAILED;
102ca6a0:	e3e00000 	mvn	r0, #0
102ca6a4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102ca6a8:	102ccf24 	.word	0x102ccf24
102ca6ac:	102ee40c 	.word	0x102ee40c
102ca6b0:	f03d5104 	.word	0xf03d5104
102ca6b4:	102e53c8 	.word	0x102e53c8
102ca6b8:	102ee5e8 	.word	0x102ee5e8
102ca6bc:	102ede00 	.word	0x102ede00
102ca6c0:	102ede08 	.word	0x102ede08
102ca6c4:	102cce98 	.word	0x102cce98
102ca6c8:	f03de548 	.word	0xf03de548
102ca6cc:	102ee414 	.word	0x102ee414

102ca6d0 <RIL_HTTP_SetServerURL>:
static s32 ATRsp_QHTTP_Handler(char* line, u32 len, void* param);

char* http_url_addr = NULL;
u16   http_url_addr_len = 0;
s32 RIL_HTTP_SetServerURL(char* strURL, u16 len)
{
102ca6d0:	e92d4010 	push	{r4, lr}
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
102ca6d4:	e3e03000 	mvn	r3, #0
static s32 ATRsp_QHTTP_Handler(char* line, u32 len, void* param);

char* http_url_addr = NULL;
u16   http_url_addr_len = 0;
s32 RIL_HTTP_SetServerURL(char* strURL, u16 len)
{
102ca6d8:	e24dd030 	sub	sp, sp, #48	; 0x30
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
    char strAT[30];

    if (!strURL)
102ca6dc:	e3500000 	cmp	r0, #0
static s32 ATRsp_QHTTP_Handler(char* line, u32 len, void* param);

char* http_url_addr = NULL;
u16   http_url_addr_len = 0;
s32 RIL_HTTP_SetServerURL(char* strURL, u16 len)
{
102ca6e0:	e1a04001 	mov	r4, r1
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
102ca6e4:	e58d300c 	str	r3, [sp, #12]
    char strAT[30];

    if (!strURL)
102ca6e8:	0a00001e 	beq	102ca768 <RIL_HTTP_SetServerURL+0x98>
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_url_addr = strURL;
102ca6ec:	e59fc07c 	ldr	ip, [pc, #124]	; 102ca770 <RIL_HTTP_SetServerURL+0xa0>
    http_url_addr_len = len;
    m_httpAction = HTTP_ACTION_SETRUL;
    Ql_sprintf(strAT, "AT+QHTTPURL=%d,%d\0", len, 120);
102ca6f0:	e1a02004 	mov	r2, r4

    if (!strURL)
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_url_addr = strURL;
102ca6f4:	e58c0004 	str	r0, [ip, #4]
    http_url_addr_len = len;
    m_httpAction = HTTP_ACTION_SETRUL;
    Ql_sprintf(strAT, "AT+QHTTPURL=%d,%d\0", len, 120);
102ca6f8:	e59f0074 	ldr	r0, [pc, #116]	; 102ca774 <RIL_HTTP_SetServerURL+0xa4>
    if (!strURL)
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_url_addr = strURL;
    http_url_addr_len = len;
102ca6fc:	e1cc40b8 	strh	r4, [ip, #8]
    m_httpAction = HTTP_ACTION_SETRUL;
102ca700:	e3a0e001 	mov	lr, #1
    Ql_sprintf(strAT, "AT+QHTTPURL=%d,%d\0", len, 120);
102ca704:	e59f106c 	ldr	r1, [pc, #108]	; 102ca778 <RIL_HTTP_SetServerURL+0xa8>
102ca708:	e3a03078 	mov	r3, #120	; 0x78
102ca70c:	e5904000 	ldr	r4, [r0]
102ca710:	e28d0010 	add	r0, sp, #16
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_url_addr = strURL;
    http_url_addr_len = len;
    m_httpAction = HTTP_ACTION_SETRUL;
102ca714:	e5cce000 	strb	lr, [ip]
    Ql_sprintf(strAT, "AT+QHTTPURL=%d,%d\0", len, 120);
102ca718:	e12fff34 	blx	r4
    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QHTTP_Handler, &errCode, 0);
102ca71c:	e59f3058 	ldr	r3, [pc, #88]	; 102ca77c <RIL_HTTP_SetServerURL+0xac>
102ca720:	e28d0010 	add	r0, sp, #16
102ca724:	e12fff33 	blx	r3
102ca728:	e3a03000 	mov	r3, #0
102ca72c:	e58d3000 	str	r3, [sp]
102ca730:	e59f2048 	ldr	r2, [pc, #72]	; 102ca780 <RIL_HTTP_SetServerURL+0xb0>
102ca734:	e28d300c 	add	r3, sp, #12
102ca738:	e59fc044 	ldr	ip, [pc, #68]	; 102ca784 <RIL_HTTP_SetServerURL+0xb4>
102ca73c:	e1a01000 	mov	r1, r0
102ca740:	e28d0010 	add	r0, sp, #16
102ca744:	e12fff3c 	blx	ip
    if (retRes != RIL_AT_SUCCESS)
102ca748:	e2503000 	subs	r3, r0, #0
102ca74c:	01a00003 	moveq	r0, r3
102ca750:	0a000002 	beq	102ca760 <RIL_HTTP_SetServerURL+0x90>
    {
        if (RIL_AT_FAILED == errCode)
102ca754:	e59d000c 	ldr	r0, [sp, #12]
102ca758:	e3700001 	cmn	r0, #1
102ca75c:	01a00003 	moveq	r0, r3
        } else {
            return errCode;
        }
    }
    return retRes; 
}
102ca760:	e28dd030 	add	sp, sp, #48	; 0x30
102ca764:	e8bd8010 	pop	{r4, pc}
    s32  errCode = RIL_AT_FAILED;
    char strAT[30];

    if (!strURL)
    {
        return RIL_AT_INVALID_PARAM;
102ca768:	e3e00003 	mvn	r0, #3
102ca76c:	eafffffb 	b	102ca760 <RIL_HTTP_SetServerURL+0x90>
102ca770:	f03d5104 	.word	0xf03d5104
102ca774:	f03de540 	.word	0xf03de540
102ca778:	102e65c0 	.word	0x102e65c0
102ca77c:	102e57a4 	.word	0x102e57a4
102ca780:	102ca5a4 	.word	0x102ca5a4
102ca784:	102e5168 	.word	0x102e5168

102ca788 <RIL_HTTP_RequestToGet>:
    }
    return retRes; 
}

s32 RIL_HTTP_RequestToGet(u32 timeout)
{
102ca788:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
102ca78c:	e3e03000 	mvn	r3, #0
    }
    return retRes; 
}

s32 RIL_HTTP_RequestToGet(u32 timeout)
{
102ca790:	e24dd034 	sub	sp, sp, #52	; 0x34
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
102ca794:	e58d300c 	str	r3, [sp, #12]
    char strAT[30];

    m_httpAction = HTTP_ACTION_GET_REQ;
    Ql_sprintf(strAT, "AT+QHTTPGET=%d\0", timeout);
102ca798:	e59f3068 	ldr	r3, [pc, #104]	; 102ca808 <RIL_HTTP_RequestToGet+0x80>
{
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
    char strAT[30];

    m_httpAction = HTTP_ACTION_GET_REQ;
102ca79c:	e59fc068 	ldr	ip, [pc, #104]	; 102ca80c <RIL_HTTP_RequestToGet+0x84>
    }
    return retRes; 
}

s32 RIL_HTTP_RequestToGet(u32 timeout)
{
102ca7a0:	e1a02000 	mov	r2, r0
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
    char strAT[30];

    m_httpAction = HTTP_ACTION_GET_REQ;
102ca7a4:	e3a0e002 	mov	lr, #2
    Ql_sprintf(strAT, "AT+QHTTPGET=%d\0", timeout);
102ca7a8:	e59f1060 	ldr	r1, [pc, #96]	; 102ca810 <RIL_HTTP_RequestToGet+0x88>
102ca7ac:	e5933000 	ldr	r3, [r3]
102ca7b0:	e28d0010 	add	r0, sp, #16
{
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
    char strAT[30];

    m_httpAction = HTTP_ACTION_GET_REQ;
102ca7b4:	e5cce000 	strb	lr, [ip]
    Ql_sprintf(strAT, "AT+QHTTPGET=%d\0", timeout);
102ca7b8:	e12fff33 	blx	r3
    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QHTTP_Handler, &errCode, 0);
102ca7bc:	e59f3050 	ldr	r3, [pc, #80]	; 102ca814 <RIL_HTTP_RequestToGet+0x8c>
102ca7c0:	e28d0010 	add	r0, sp, #16
102ca7c4:	e12fff33 	blx	r3
102ca7c8:	e3a03000 	mov	r3, #0
102ca7cc:	e58d3000 	str	r3, [sp]
102ca7d0:	e59f2040 	ldr	r2, [pc, #64]	; 102ca818 <RIL_HTTP_RequestToGet+0x90>
102ca7d4:	e28d300c 	add	r3, sp, #12
102ca7d8:	e59fc03c 	ldr	ip, [pc, #60]	; 102ca81c <RIL_HTTP_RequestToGet+0x94>
102ca7dc:	e1a01000 	mov	r1, r0
102ca7e0:	e28d0010 	add	r0, sp, #16
102ca7e4:	e12fff3c 	blx	ip
    if (retRes != RIL_AT_SUCCESS)
102ca7e8:	e2503000 	subs	r3, r0, #0
102ca7ec:	01a00003 	moveq	r0, r3
102ca7f0:	0a000002 	beq	102ca800 <RIL_HTTP_RequestToGet+0x78>
    {
        if (RIL_AT_FAILED == errCode)
102ca7f4:	e59d000c 	ldr	r0, [sp, #12]
102ca7f8:	e3700001 	cmn	r0, #1
102ca7fc:	01a00003 	moveq	r0, r3
        } else {
            return errCode;
        }
    }
    return retRes; 
}
102ca800:	e28dd034 	add	sp, sp, #52	; 0x34
102ca804:	e8bd8000 	ldmfd	sp!, {pc}
102ca808:	f03de540 	.word	0xf03de540
102ca80c:	f03d5104 	.word	0xf03d5104
102ca810:	102e65d4 	.word	0x102e65d4
102ca814:	102e57a4 	.word	0x102e57a4
102ca818:	102ca5a4 	.word	0x102ca5a4
102ca81c:	102e5168 	.word	0x102e5168

102ca820 <RIL_HTTP_RequestToPost>:

char* http_post_msg = NULL;
u16   http_post_msg_len = 0;
s32 RIL_HTTP_RequestToPost(char* strPostMsg, u16 len)
{
102ca820:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
102ca824:	e3e03000 	mvn	r3, #0
}

char* http_post_msg = NULL;
u16   http_post_msg_len = 0;
s32 RIL_HTTP_RequestToPost(char* strPostMsg, u16 len)
{
102ca828:	e24dd034 	sub	sp, sp, #52	; 0x34
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
    char strAT[30];

    if (!strPostMsg)
102ca82c:	e3500000 	cmp	r0, #0
}

char* http_post_msg = NULL;
u16   http_post_msg_len = 0;
s32 RIL_HTTP_RequestToPost(char* strPostMsg, u16 len)
{
102ca830:	e1a0c001 	mov	ip, r1
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
102ca834:	e58d300c 	str	r3, [sp, #12]
    char strAT[30];

    if (!strPostMsg)
102ca838:	0a00001d 	beq	102ca8b4 <RIL_HTTP_RequestToPost+0x94>
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_post_msg = strPostMsg;
102ca83c:	e59f3078 	ldr	r3, [pc, #120]	; 102ca8bc <RIL_HTTP_RequestToPost+0x9c>
    http_post_msg_len = len;
    m_httpAction = HTTP_ACTION_POST_REQ;
    Ql_sprintf(strAT, "AT+QHTTPPOST=%d,120,120\0", len);
102ca840:	e1a0200c 	mov	r2, ip

    if (!strPostMsg)
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_post_msg = strPostMsg;
102ca844:	e583000c 	str	r0, [r3, #12]
    http_post_msg_len = len;
    m_httpAction = HTTP_ACTION_POST_REQ;
    Ql_sprintf(strAT, "AT+QHTTPPOST=%d,120,120\0", len);
102ca848:	e59f0070 	ldr	r0, [pc, #112]	; 102ca8c0 <RIL_HTTP_RequestToPost+0xa0>
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_post_msg = strPostMsg;
    http_post_msg_len = len;
    m_httpAction = HTTP_ACTION_POST_REQ;
102ca84c:	e3a0e003 	mov	lr, #3
    Ql_sprintf(strAT, "AT+QHTTPPOST=%d,120,120\0", len);
102ca850:	e59f106c 	ldr	r1, [pc, #108]	; 102ca8c4 <RIL_HTTP_RequestToPost+0xa4>
    if (!strPostMsg)
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_post_msg = strPostMsg;
    http_post_msg_len = len;
102ca854:	e1c3c1b0 	strh	ip, [r3, #16]
    m_httpAction = HTTP_ACTION_POST_REQ;
    Ql_sprintf(strAT, "AT+QHTTPPOST=%d,120,120\0", len);
102ca858:	e590c000 	ldr	ip, [r0]
102ca85c:	e28d0010 	add	r0, sp, #16
    {
        return RIL_AT_INVALID_PARAM;
    }
    http_post_msg = strPostMsg;
    http_post_msg_len = len;
    m_httpAction = HTTP_ACTION_POST_REQ;
102ca860:	e5c3e000 	strb	lr, [r3]
    Ql_sprintf(strAT, "AT+QHTTPPOST=%d,120,120\0", len);
102ca864:	e12fff3c 	blx	ip
    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QHTTP_Handler, &errCode, 0);
102ca868:	e59f3058 	ldr	r3, [pc, #88]	; 102ca8c8 <RIL_HTTP_RequestToPost+0xa8>
102ca86c:	e28d0010 	add	r0, sp, #16
102ca870:	e12fff33 	blx	r3
102ca874:	e3a03000 	mov	r3, #0
102ca878:	e58d3000 	str	r3, [sp]
102ca87c:	e59f2048 	ldr	r2, [pc, #72]	; 102ca8cc <RIL_HTTP_RequestToPost+0xac>
102ca880:	e28d300c 	add	r3, sp, #12
102ca884:	e59fc044 	ldr	ip, [pc, #68]	; 102ca8d0 <RIL_HTTP_RequestToPost+0xb0>
102ca888:	e1a01000 	mov	r1, r0
102ca88c:	e28d0010 	add	r0, sp, #16
102ca890:	e12fff3c 	blx	ip
    if (retRes != RIL_AT_SUCCESS)
102ca894:	e2503000 	subs	r3, r0, #0
102ca898:	01a00003 	moveq	r0, r3
102ca89c:	0a000002 	beq	102ca8ac <RIL_HTTP_RequestToPost+0x8c>
    {
        if (RIL_AT_FAILED == errCode)
102ca8a0:	e59d000c 	ldr	r0, [sp, #12]
102ca8a4:	e3700001 	cmn	r0, #1
102ca8a8:	01a00003 	moveq	r0, r3
        } else {
            return errCode;
        }
    }
    return retRes; 
}
102ca8ac:	e28dd034 	add	sp, sp, #52	; 0x34
102ca8b0:	e8bd8000 	ldmfd	sp!, {pc}
    s32  errCode = RIL_AT_FAILED;
    char strAT[30];

    if (!strPostMsg)
    {
        return RIL_AT_INVALID_PARAM;
102ca8b4:	e3e00003 	mvn	r0, #3
102ca8b8:	eafffffb 	b	102ca8ac <RIL_HTTP_RequestToPost+0x8c>
102ca8bc:	f03d5104 	.word	0xf03d5104
102ca8c0:	f03de540 	.word	0xf03de540
102ca8c4:	102e65e4 	.word	0x102e65e4
102ca8c8:	102e57a4 	.word	0x102e57a4
102ca8cc:	102ca5a4 	.word	0x102ca5a4
102ca8d0:	102e5168 	.word	0x102e5168

102ca8d4 <RIL_HTTP_ReadResponse>:
    }
    return retRes; 
}

s32 RIL_HTTP_ReadResponse(u32 timeout, CB_RIL_RcvDataFrmCore cb_rcvData)
{
102ca8d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
102ca8d8:	e3e03000 	mvn	r3, #0
    }
    return retRes; 
}

s32 RIL_HTTP_ReadResponse(u32 timeout, CB_RIL_RcvDataFrmCore cb_rcvData)
{
102ca8dc:	e24dd034 	sub	sp, sp, #52	; 0x34
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
    char strAT[30];
    extern CB_RIL_RcvDataFrmCore cb_rcvCoreData;

    if (!cb_rcvData)
102ca8e0:	e251c000 	subs	ip, r1, #0
}

s32 RIL_HTTP_ReadResponse(u32 timeout, CB_RIL_RcvDataFrmCore cb_rcvData)
{
    s32  retRes;
    s32  errCode = RIL_AT_FAILED;
102ca8e4:	e58d300c 	str	r3, [sp, #12]
    char strAT[30];
    extern CB_RIL_RcvDataFrmCore cb_rcvCoreData;

    if (!cb_rcvData)
102ca8e8:	0a00001d 	beq	102ca964 <RIL_HTTP_ReadResponse+0x90>
    {
        return RIL_AT_INVALID_PARAM;
    }
    cb_rcvCoreData = cb_rcvData;
102ca8ec:	e59f3078 	ldr	r3, [pc, #120]	; 102ca96c <RIL_HTTP_ReadResponse+0x98>
    m_httpAction = HTTP_ACTION_READ_RSP;
    Ql_sprintf(strAT, "AT+QHTTPREAD=%d\0", timeout);
102ca8f0:	e1a02000 	mov	r2, r0

    if (!cb_rcvData)
    {
        return RIL_AT_INVALID_PARAM;
    }
    cb_rcvCoreData = cb_rcvData;
102ca8f4:	e583c000 	str	ip, [r3]
    m_httpAction = HTTP_ACTION_READ_RSP;
    Ql_sprintf(strAT, "AT+QHTTPREAD=%d\0", timeout);
102ca8f8:	e59f3070 	ldr	r3, [pc, #112]	; 102ca970 <RIL_HTTP_ReadResponse+0x9c>
    if (!cb_rcvData)
    {
        return RIL_AT_INVALID_PARAM;
    }
    cb_rcvCoreData = cb_rcvData;
    m_httpAction = HTTP_ACTION_READ_RSP;
102ca8fc:	e59fc070 	ldr	ip, [pc, #112]	; 102ca974 <RIL_HTTP_ReadResponse+0xa0>
102ca900:	e3a0e004 	mov	lr, #4
    Ql_sprintf(strAT, "AT+QHTTPREAD=%d\0", timeout);
102ca904:	e59f106c 	ldr	r1, [pc, #108]	; 102ca978 <RIL_HTTP_ReadResponse+0xa4>
102ca908:	e5933000 	ldr	r3, [r3]
102ca90c:	e28d0010 	add	r0, sp, #16
    if (!cb_rcvData)
    {
        return RIL_AT_INVALID_PARAM;
    }
    cb_rcvCoreData = cb_rcvData;
    m_httpAction = HTTP_ACTION_READ_RSP;
102ca910:	e5cce000 	strb	lr, [ip]
    Ql_sprintf(strAT, "AT+QHTTPREAD=%d\0", timeout);
102ca914:	e12fff33 	blx	r3
    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_QHTTP_Handler, &errCode, 0);
102ca918:	e59f305c 	ldr	r3, [pc, #92]	; 102ca97c <RIL_HTTP_ReadResponse+0xa8>
102ca91c:	e28d0010 	add	r0, sp, #16
102ca920:	e12fff33 	blx	r3
102ca924:	e3a03000 	mov	r3, #0
102ca928:	e58d3000 	str	r3, [sp]
102ca92c:	e59f204c 	ldr	r2, [pc, #76]	; 102ca980 <RIL_HTTP_ReadResponse+0xac>
102ca930:	e28d300c 	add	r3, sp, #12
102ca934:	e59fc048 	ldr	ip, [pc, #72]	; 102ca984 <RIL_HTTP_ReadResponse+0xb0>
102ca938:	e1a01000 	mov	r1, r0
102ca93c:	e28d0010 	add	r0, sp, #16
102ca940:	e12fff3c 	blx	ip
    if (retRes != RIL_AT_SUCCESS)
102ca944:	e2503000 	subs	r3, r0, #0
102ca948:	01a00003 	moveq	r0, r3
102ca94c:	0a000002 	beq	102ca95c <RIL_HTTP_ReadResponse+0x88>
    {
        if (RIL_AT_FAILED == errCode)
102ca950:	e59d000c 	ldr	r0, [sp, #12]
102ca954:	e3700001 	cmn	r0, #1
102ca958:	01a00003 	moveq	r0, r3
        } else {
            return errCode;
        }
    }
    return retRes; 
}
102ca95c:	e28dd034 	add	sp, sp, #52	; 0x34
102ca960:	e8bd8000 	ldmfd	sp!, {pc}
    char strAT[30];
    extern CB_RIL_RcvDataFrmCore cb_rcvCoreData;

    if (!cb_rcvData)
    {
        return RIL_AT_INVALID_PARAM;
102ca964:	e3e00003 	mvn	r0, #3
102ca968:	eafffffb 	b	102ca95c <RIL_HTTP_ReadResponse+0x88>
102ca96c:	f03d50f0 	.word	0xf03d50f0
102ca970:	f03de540 	.word	0xf03de540
102ca974:	f03d5104 	.word	0xf03d5104
102ca978:	102e6600 	.word	0x102e6600
102ca97c:	102e57a4 	.word	0x102e57a4
102ca980:	102ca5a4 	.word	0x102ca5a4
102ca984:	102e5168 	.word	0x102e5168

102ca988 <RIL_HTTP_DownloadFile>:
s32 RIL_HTTP_DownloadFile(char* filePath, u32 size, CB_HTTP_DwnldFile cb)
{
    s32  retRes;
    char* strAT = NULL;

    callback_http_dwnld = cb;
102ca988:	e59fc08c 	ldr	ip, [pc, #140]	; 102caa1c <RIL_HTTP_DownloadFile+0x94>
    return retRes; 
}

CB_HTTP_DwnldFile callback_http_dwnld = NULL;
s32 RIL_HTTP_DownloadFile(char* filePath, u32 size, CB_HTTP_DwnldFile cb)
{
102ca98c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    s32  retRes;
    char* strAT = NULL;

    callback_http_dwnld = cb;
    m_httpAction = HTTP_ACTION_DOWNLOAD_FILE;
102ca990:	e3a03005 	mov	r3, #5
    return retRes; 
}

CB_HTTP_DwnldFile callback_http_dwnld = NULL;
s32 RIL_HTTP_DownloadFile(char* filePath, u32 size, CB_HTTP_DwnldFile cb)
{
102ca994:	e24dd00c 	sub	sp, sp, #12
    s32  retRes;
    char* strAT = NULL;

    callback_http_dwnld = cb;
    m_httpAction = HTTP_ACTION_DOWNLOAD_FILE;
    strAT = (char*)Ql_MEM_Alloc(Ql_strlen(filePath) + 20);
102ca998:	e59f5080 	ldr	r5, [pc, #128]	; 102caa20 <RIL_HTTP_DownloadFile+0x98>
    return retRes; 
}

CB_HTTP_DwnldFile callback_http_dwnld = NULL;
s32 RIL_HTTP_DownloadFile(char* filePath, u32 size, CB_HTTP_DwnldFile cb)
{
102ca99c:	e1a06001 	mov	r6, r1
    s32  retRes;
    char* strAT = NULL;

    callback_http_dwnld = cb;
102ca9a0:	e58c2014 	str	r2, [ip, #20]
    m_httpAction = HTTP_ACTION_DOWNLOAD_FILE;
102ca9a4:	e5cc3000 	strb	r3, [ip]
    return retRes; 
}

CB_HTTP_DwnldFile callback_http_dwnld = NULL;
s32 RIL_HTTP_DownloadFile(char* filePath, u32 size, CB_HTTP_DwnldFile cb)
{
102ca9a8:	e1a07000 	mov	r7, r0
    s32  retRes;
    char* strAT = NULL;

    callback_http_dwnld = cb;
    m_httpAction = HTTP_ACTION_DOWNLOAD_FILE;
    strAT = (char*)Ql_MEM_Alloc(Ql_strlen(filePath) + 20);
102ca9ac:	e12fff35 	blx	r5
102ca9b0:	e59f306c 	ldr	r3, [pc, #108]	; 102caa24 <RIL_HTTP_DownloadFile+0x9c>
102ca9b4:	e2800014 	add	r0, r0, #20
102ca9b8:	e12fff33 	blx	r3
    Ql_sprintf(strAT, "AT+QHTTPDL=\"%s\",%d\0", filePath, size);
102ca9bc:	e59fc064 	ldr	ip, [pc, #100]	; 102caa28 <RIL_HTTP_DownloadFile+0xa0>
102ca9c0:	e1a02007 	mov	r2, r7
102ca9c4:	e1a03006 	mov	r3, r6
102ca9c8:	e59f105c 	ldr	r1, [pc, #92]	; 102caa2c <RIL_HTTP_DownloadFile+0xa4>
102ca9cc:	e59cc000 	ldr	ip, [ip]
    s32  retRes;
    char* strAT = NULL;

    callback_http_dwnld = cb;
    m_httpAction = HTTP_ACTION_DOWNLOAD_FILE;
    strAT = (char*)Ql_MEM_Alloc(Ql_strlen(filePath) + 20);
102ca9d0:	e1a04000 	mov	r4, r0
    Ql_sprintf(strAT, "AT+QHTTPDL=\"%s\",%d\0", filePath, size);
102ca9d4:	e12fff3c 	blx	ip
    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102ca9d8:	e1a00004 	mov	r0, r4
102ca9dc:	e12fff35 	blx	r5
102ca9e0:	e3a0c000 	mov	ip, #0
102ca9e4:	e1a0200c 	mov	r2, ip
102ca9e8:	e1a0300c 	mov	r3, ip
102ca9ec:	e58dc000 	str	ip, [sp]
102ca9f0:	e59fc038 	ldr	ip, [pc, #56]	; 102caa30 <RIL_HTTP_DownloadFile+0xa8>
102ca9f4:	e1a01000 	mov	r1, r0
102ca9f8:	e1a00004 	mov	r0, r4
102ca9fc:	e12fff3c 	blx	ip
    Ql_MEM_Free(strAT);
102caa00:	e59f302c 	ldr	r3, [pc, #44]	; 102caa34 <RIL_HTTP_DownloadFile+0xac>

    callback_http_dwnld = cb;
    m_httpAction = HTTP_ACTION_DOWNLOAD_FILE;
    strAT = (char*)Ql_MEM_Alloc(Ql_strlen(filePath) + 20);
    Ql_sprintf(strAT, "AT+QHTTPDL=\"%s\",%d\0", filePath, size);
    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), NULL, NULL, 0);
102caa04:	e1a05000 	mov	r5, r0
    Ql_MEM_Free(strAT);
102caa08:	e1a00004 	mov	r0, r4
102caa0c:	e12fff33 	blx	r3
    return retRes; 
}
102caa10:	e1a00005 	mov	r0, r5
102caa14:	e28dd00c 	add	sp, sp, #12
102caa18:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
102caa1c:	f03d5104 	.word	0xf03d5104
102caa20:	102e57a4 	.word	0x102e57a4
102caa24:	102e4840 	.word	0x102e4840
102caa28:	f03de540 	.word	0xf03de540
102caa2c:	102e6614 	.word	0x102e6614
102caa30:	102e5168 	.word	0x102e5168
102caa34:	102e48b8 	.word	0x102e48b8

102caa38 <RIL_GetInitCmdCnt>:
};

u32 RIL_GetInitCmdCnt(void)
{
    return NUM_ELEMS(g_InitCmds);
}
102caa38:	e3a00006 	mov	r0, #6
102caa3c:	e12fff1e 	bx	lr

102caa40 <RIL_GetLimitedCmdCnt>:
    "AT+CLIP",
};
u32 RIL_GetLimitedCmdCnt(void)
{
    return NUM_ELEMS(g_LimitedCmds);
}
102caa40:	e3a00002 	mov	r0, #2
102caa44:	e12fff1e 	bx	lr

102caa48 <RIL_GetLocation>:
#endif

static CB_LocInfo callback_loc = NULL;

s32 RIL_GetLocation(CB_LocInfo cb_loc)
{
102caa48:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	APP_DEBUG("<-- Getting module location... -->\r\n");
102caa4c:	e59f40ec 	ldr	r4, [pc, #236]	; 102cab40 <RIL_GetLocation+0xf8>
102caa50:	e59f60ec 	ldr	r6, [pc, #236]	; 102cab44 <RIL_GetLocation+0xfc>
#endif

static CB_LocInfo callback_loc = NULL;

s32 RIL_GetLocation(CB_LocInfo cb_loc)
{
102caa54:	e24dd0d0 	sub	sp, sp, #208	; 0xd0
	APP_DEBUG("<-- Getting module location... -->\r\n");
102caa58:	e3a02c02 	mov	r2, #512	; 0x200
#endif

static CB_LocInfo callback_loc = NULL;

s32 RIL_GetLocation(CB_LocInfo cb_loc)
{
102caa5c:	e1a08000 	mov	r8, r0
	APP_DEBUG("<-- Getting module location... -->\r\n");
102caa60:	e3a01000 	mov	r1, #0
102caa64:	e59f70dc 	ldr	r7, [pc, #220]	; 102cab48 <RIL_GetLocation+0x100>
102caa68:	e1a00004 	mov	r0, r4
102caa6c:	e12fff37 	blx	r7
102caa70:	e59f10d4 	ldr	r1, [pc, #212]	; 102cab4c <RIL_GetLocation+0x104>
102caa74:	e5963000 	ldr	r3, [r6]
102caa78:	e1a00004 	mov	r0, r4
102caa7c:	e12fff33 	blx	r3
102caa80:	e59f50c8 	ldr	r5, [pc, #200]	; 102cab50 <RIL_GetLocation+0x108>
102caa84:	e1a00004 	mov	r0, r4
102caa88:	e12fff35 	blx	r5
102caa8c:	e1a01004 	mov	r1, r4
102caa90:	e59f30bc 	ldr	r3, [pc, #188]	; 102cab54 <RIL_GetLocation+0x10c>
102caa94:	e1a02000 	mov	r2, r0
102caa98:	e3a0000a 	mov	r0, #10
102caa9c:	e12fff33 	blx	r3
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 
    callback_loc = cb_loc;

	Ql_memset(strAT, 0, sizeof(strAT));
102caaa0:	e3a020c8 	mov	r2, #200	; 0xc8
102caaa4:	e3a01000 	mov	r1, #0
102caaa8:	e28d0008 	add	r0, sp, #8
s32 RIL_GetLocation(CB_LocInfo cb_loc)
{
	APP_DEBUG("<-- Getting module location... -->\r\n");
	s32 ret = RIL_AT_FAILED;
	char strAT[200]; 
    callback_loc = cb_loc;
102caaac:	e5848200 	str	r8, [r4, #512]	; 0x200

	Ql_memset(strAT, 0, sizeof(strAT));
102caab0:	e12fff37 	blx	r7
	Ql_sprintf(strAT, "AT+QLOCCFG=\"ASYNCH\",1\r\n");
102caab4:	e59f109c 	ldr	r1, [pc, #156]	; 102cab58 <RIL_GetLocation+0x110>
102caab8:	e5963000 	ldr	r3, [r6]
102caabc:	e28d0008 	add	r0, sp, #8
102caac0:	e12fff33 	blx	r3
	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102caac4:	e28d0008 	add	r0, sp, #8
102caac8:	e12fff35 	blx	r5
102caacc:	e3a03000 	mov	r3, #0
102caad0:	e1a02003 	mov	r2, r3
102caad4:	e58d3000 	str	r3, [sp]
102caad8:	e59f807c 	ldr	r8, [pc, #124]	; 102cab5c <RIL_GetLocation+0x114>
102caadc:	e1a01000 	mov	r1, r0
102caae0:	e28d0008 	add	r0, sp, #8
102caae4:	e12fff38 	blx	r8
	if (RIL_AT_SUCCESS == ret)
102caae8:	e2504000 	subs	r4, r0, #0
102caaec:	1a000010 	bne	102cab34 <RIL_GetLocation+0xec>
	{
        Ql_memset(strAT, 0, sizeof(strAT));
102caaf0:	e3a020c8 	mov	r2, #200	; 0xc8
102caaf4:	e1a01004 	mov	r1, r4
102caaf8:	e28d0008 	add	r0, sp, #8
102caafc:	e12fff37 	blx	r7
        Ql_sprintf(strAT, "AT+QCELLLOC=1\n");                
102cab00:	e59f1058 	ldr	r1, [pc, #88]	; 102cab60 <RIL_GetLocation+0x118>
102cab04:	e5963000 	ldr	r3, [r6]
102cab08:	e28d0008 	add	r0, sp, #8
102cab0c:	e12fff33 	blx	r3
        RIL_LOC_DEBUG(DBG_Buffer,"<-- Send AT:%s, ret = %d -->\r\n",strAT, ret);        
        ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102cab10:	e28d0008 	add	r0, sp, #8
102cab14:	e12fff35 	blx	r5
102cab18:	e1a02004 	mov	r2, r4
102cab1c:	e58d4000 	str	r4, [sp]
102cab20:	e1a03004 	mov	r3, r4
102cab24:	e1a01000 	mov	r1, r0
102cab28:	e28d0008 	add	r0, sp, #8
102cab2c:	e12fff38 	blx	r8
102cab30:	e1a04000 	mov	r4, r0
	}
    return ret;
}
102cab34:	e1a00004 	mov	r0, r4
102cab38:	e28dd0d0 	add	sp, sp, #208	; 0xd0
102cab3c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102cab40:	f03d511c 	.word	0xf03d511c
102cab44:	f03de540 	.word	0xf03de540
102cab48:	102e58f4 	.word	0x102e58f4
102cab4c:	102ee480 	.word	0x102ee480
102cab50:	102e57a4 	.word	0x102e57a4
102cab54:	102e6230 	.word	0x102e6230
102cab58:	102ee4a8 	.word	0x102ee4a8
102cab5c:	102e5168 	.word	0x102e5168
102cab60:	102ee4c0 	.word	0x102ee4c0

102cab64 <RIL_GetLocationByCell>:

s32 RIL_GetLocationByCell(ST_CellInfo* cell, CB_LocInfo cb_loc)
{
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];
    callback_loc = cb_loc;        
102cab64:	e59f30cc 	ldr	r3, [pc, #204]	; 102cac38 <RIL_GetLocationByCell+0xd4>
	}
    return ret;
}

s32 RIL_GetLocationByCell(ST_CellInfo* cell, CB_LocInfo cb_loc)
{
102cab68:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];
    callback_loc = cb_loc;        

	Ql_memset(strAT, 0, sizeof(strAT));
	Ql_sprintf(strAT, "AT+QLOCCFG=\"ASYNCH\",1\r\n");
102cab6c:	e59f80c8 	ldr	r8, [pc, #200]	; 102cac3c <RIL_GetLocationByCell+0xd8>
	}
    return ret;
}

s32 RIL_GetLocationByCell(ST_CellInfo* cell, CB_LocInfo cb_loc)
{
102cab70:	e24dd0dc 	sub	sp, sp, #220	; 0xdc
102cab74:	e1a05000 	mov	r5, r0
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];
    callback_loc = cb_loc;        

	Ql_memset(strAT, 0, sizeof(strAT));
102cab78:	e3a020c8 	mov	r2, #200	; 0xc8

s32 RIL_GetLocationByCell(ST_CellInfo* cell, CB_LocInfo cb_loc)
{
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];
    callback_loc = cb_loc;        
102cab7c:	e5831200 	str	r1, [r3, #512]	; 0x200

	Ql_memset(strAT, 0, sizeof(strAT));
102cab80:	e59fa0b8 	ldr	sl, [pc, #184]	; 102cac40 <RIL_GetLocationByCell+0xdc>
102cab84:	e3a01000 	mov	r1, #0
102cab88:	e28d0010 	add	r0, sp, #16
102cab8c:	e12fff3a 	blx	sl
	Ql_sprintf(strAT, "AT+QLOCCFG=\"ASYNCH\",1\r\n");
102cab90:	e5983000 	ldr	r3, [r8]
102cab94:	e59f10a8 	ldr	r1, [pc, #168]	; 102cac44 <RIL_GetLocationByCell+0xe0>
102cab98:	e28d0010 	add	r0, sp, #16
102cab9c:	e12fff33 	blx	r3
	Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102caba0:	e59f70a0 	ldr	r7, [pc, #160]	; 102cac48 <RIL_GetLocationByCell+0xe4>
102caba4:	e28d0010 	add	r0, sp, #16
102caba8:	e12fff37 	blx	r7
102cabac:	e3a04000 	mov	r4, #0
102cabb0:	e1a03004 	mov	r3, r4
102cabb4:	e1a02004 	mov	r2, r4
102cabb8:	e58d4000 	str	r4, [sp]
102cabbc:	e59f6088 	ldr	r6, [pc, #136]	; 102cac4c <RIL_GetLocationByCell+0xe8>
102cabc0:	e1a01000 	mov	r1, r0
102cabc4:	e28d0010 	add	r0, sp, #16
102cabc8:	e12fff36 	blx	r6
	if (RIL_AT_SUCCESS == ret)
	{
        Ql_memset(strAT, 0, sizeof(strAT));
102cabcc:	e1a01004 	mov	r1, r4
102cabd0:	e28d0010 	add	r0, sp, #16
102cabd4:	e3a020c8 	mov	r2, #200	; 0xc8
102cabd8:	e12fff3a 	blx	sl
        Ql_sprintf(strAT, "AT+QCELLLOC=3,%d,%d,%d,%d,%d,%d\n",cell->cellId,cell->lac,cell->mnc,cell->mcc,cell->rssi,cell->timeAd);
102cabdc:	e1d5e0b0 	ldrh	lr, [r5]
102cabe0:	e1d5a0b2 	ldrh	sl, [r5, #2]
102cabe4:	e1d5c0fc 	ldrsh	ip, [r5, #12]
102cabe8:	e1d500be 	ldrh	r0, [r5, #14]
102cabec:	e5952008 	ldr	r2, [r5, #8]
102cabf0:	e5953004 	ldr	r3, [r5, #4]
102cabf4:	e59f1054 	ldr	r1, [pc, #84]	; 102cac50 <RIL_GetLocationByCell+0xec>
102cabf8:	e88d4400 	stm	sp, {sl, lr}
102cabfc:	e58dc008 	str	ip, [sp, #8]
102cac00:	e58d000c 	str	r0, [sp, #12]
102cac04:	e598c000 	ldr	ip, [r8]
102cac08:	e28d0010 	add	r0, sp, #16
102cac0c:	e12fff3c 	blx	ip
        ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102cac10:	e28d0010 	add	r0, sp, #16
102cac14:	e12fff37 	blx	r7
102cac18:	e1a02004 	mov	r2, r4
102cac1c:	e58d4000 	str	r4, [sp]
102cac20:	e1a03004 	mov	r3, r4
102cac24:	e1a01000 	mov	r1, r0
102cac28:	e28d0010 	add	r0, sp, #16
102cac2c:	e12fff36 	blx	r6
    }
    return ret;
}
102cac30:	e28dd0dc 	add	sp, sp, #220	; 0xdc
102cac34:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
102cac38:	f03d511c 	.word	0xf03d511c
102cac3c:	f03de540 	.word	0xf03de540
102cac40:	102e58f4 	.word	0x102e58f4
102cac44:	102ee4a8 	.word	0x102ee4a8
102cac48:	102e57a4 	.word	0x102e57a4
102cac4c:	102e5168 	.word	0x102e5168
102cac50:	102ee4d0 	.word	0x102ee4d0

102cac54 <OnURCHandler_QCELLLocation>:

void OnURCHandler_QCELLLocation(const char* strURC,void* reserved)
{
102cac54:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	char buff[30];
	ST_LocInfo loclnfo;
 	if (NULL != callback_loc)
102cac58:	e59f50a8 	ldr	r5, [pc, #168]	; 102cad08 <OnURCHandler_QCELLLocation+0xb4>
    }
    return ret;
}

void OnURCHandler_QCELLLocation(const char* strURC,void* reserved)
{
102cac5c:	e24dd028 	sub	sp, sp, #40	; 0x28
	char buff[30];
	ST_LocInfo loclnfo;
 	if (NULL != callback_loc)
102cac60:	e5953200 	ldr	r3, [r5, #512]	; 0x200
    }
    return ret;
}

void OnURCHandler_QCELLLocation(const char* strURC,void* reserved)
{
102cac64:	e1a04000 	mov	r4, r0
	char buff[30];
	ST_LocInfo loclnfo;
 	if (NULL != callback_loc)
102cac68:	e3530000 	cmp	r3, #0
102cac6c:	0a000009 	beq	102cac98 <OnURCHandler_QCELLLocation+0x44>
 	{
		Ql_strcpy(buff,"\r\n+QCELLLOC:\0");
102cac70:	e59f1094 	ldr	r1, [pc, #148]	; 102cad0c <OnURCHandler_QCELLLocation+0xb8>
102cac74:	e59f3094 	ldr	r3, [pc, #148]	; 102cad10 <OnURCHandler_QCELLLocation+0xbc>
102cac78:	e28d0008 	add	r0, sp, #8
102cac7c:	e12fff33 	blx	r3
		if(Ql_StrPrefixMatch(strURC,buff))
102cac80:	e1a00004 	mov	r0, r4
102cac84:	e28d1008 	add	r1, sp, #8
102cac88:	e59f3084 	ldr	r3, [pc, #132]	; 102cad14 <OnURCHandler_QCELLLocation+0xc0>
102cac8c:	e12fff33 	blx	r3
102cac90:	e3500000 	cmp	r0, #0
102cac94:	1a000001 	bne	102caca0 <OnURCHandler_QCELLLocation+0x4c>
			loclnfo.latitude = Ql_atof(buff);

			callback_loc(0,&loclnfo);
		}
	}
}
102cac98:	e28dd028 	add	sp, sp, #40	; 0x28
102cac9c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 	if (NULL != callback_loc)
 	{
		Ql_strcpy(buff,"\r\n+QCELLLOC:\0");
		if(Ql_StrPrefixMatch(strURC,buff))
		{
			Ql_sscanf(strURC,"%*[^:]: %[^,]",buff);
102caca0:	e59f8070 	ldr	r8, [pc, #112]	; 102cad18 <OnURCHandler_QCELLLocation+0xc4>
102caca4:	e28d2008 	add	r2, sp, #8
102caca8:	e5983000 	ldr	r3, [r8]
102cacac:	e59f1068 	ldr	r1, [pc, #104]	; 102cad1c <OnURCHandler_QCELLLocation+0xc8>
102cacb0:	e1a00004 	mov	r0, r4
102cacb4:	e12fff33 	blx	r3
			loclnfo.longitude = Ql_atof(buff);
102cacb8:	e59f7060 	ldr	r7, [pc, #96]	; 102cad20 <OnURCHandler_QCELLLocation+0xcc>
102cacbc:	e28d0008 	add	r0, sp, #8
102cacc0:	e12fff37 	blx	r7
102cacc4:	e59f6058 	ldr	r6, [pc, #88]	; 102cad24 <OnURCHandler_QCELLLocation+0xd0>
102cacc8:	e12fff36 	blx	r6
			
			Ql_sscanf(strURC,"%*[^,],%[^\r\n]",buff);
102caccc:	e5983000 	ldr	r3, [r8]
102cacd0:	e28d2008 	add	r2, sp, #8
102cacd4:	e59f104c 	ldr	r1, [pc, #76]	; 102cad28 <OnURCHandler_QCELLLocation+0xd4>
 	{
		Ql_strcpy(buff,"\r\n+QCELLLOC:\0");
		if(Ql_StrPrefixMatch(strURC,buff))
		{
			Ql_sscanf(strURC,"%*[^:]: %[^,]",buff);
			loclnfo.longitude = Ql_atof(buff);
102cacd8:	e58d0000 	str	r0, [sp]
			
			Ql_sscanf(strURC,"%*[^,],%[^\r\n]",buff);
102cacdc:	e1a00004 	mov	r0, r4
102cace0:	e12fff33 	blx	r3
			loclnfo.latitude = Ql_atof(buff);
102cace4:	e28d0008 	add	r0, sp, #8
102cace8:	e12fff37 	blx	r7
102cacec:	e12fff36 	blx	r6

			callback_loc(0,&loclnfo);
102cacf0:	e5953200 	ldr	r3, [r5, #512]	; 0x200
102cacf4:	e1a0100d 	mov	r1, sp
		{
			Ql_sscanf(strURC,"%*[^:]: %[^,]",buff);
			loclnfo.longitude = Ql_atof(buff);
			
			Ql_sscanf(strURC,"%*[^,],%[^\r\n]",buff);
			loclnfo.latitude = Ql_atof(buff);
102cacf8:	e58d0004 	str	r0, [sp, #4]

			callback_loc(0,&loclnfo);
102cacfc:	e3a00000 	mov	r0, #0
102cad00:	e12fff33 	blx	r3
102cad04:	eaffffe3 	b	102cac98 <OnURCHandler_QCELLLocation+0x44>
102cad08:	f03d511c 	.word	0xf03d511c
102cad0c:	102e6628 	.word	0x102e6628
102cad10:	102e55fc 	.word	0x102e55fc
102cad14:	102ccd58 	.word	0x102ccd58
102cad18:	f03de548 	.word	0xf03de548
102cad1c:	102ee3c4 	.word	0x102ee3c4
102cad20:	102e5564 	.word	0x102e5564
102cad24:	102e39b0 	.word	0x102e39b0
102cad28:	102ee3d4 	.word	0x102ee3d4

102cad2c <ATRsp_COPS_Handler>:
    char strAT[20] = "AT+QIDEACT\0";
    return Ql_RIL_SendATCmd("AT+QIDEACT\n", Ql_strlen(strAT), ATRsp_QIDEACT_Hdlr, NULL, 0);
}

static s32 ATRsp_COPS_Handler(char* line, u32 len, void* param)
{
102cad2c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102cad30:	e1a06002 	mov	r6, r2
    char* pStr = (char *)param;
    char* pHead = Ql_RIL_FindString(line, len, "+COPS:"); //continue wait
102cad34:	e59f50e8 	ldr	r5, [pc, #232]	; 102cae24 <ATRsp_COPS_Handler+0xf8>
102cad38:	e59f20e8 	ldr	r2, [pc, #232]	; 102cae28 <ATRsp_COPS_Handler+0xfc>
    char strAT[20] = "AT+QIDEACT\0";
    return Ql_RIL_SendATCmd("AT+QIDEACT\n", Ql_strlen(strAT), ATRsp_QIDEACT_Hdlr, NULL, 0);
}

static s32 ATRsp_COPS_Handler(char* line, u32 len, void* param)
{
102cad3c:	e1a08000 	mov	r8, r0
102cad40:	e1a07001 	mov	r7, r1
    char* pStr = (char *)param;
    char* pHead = Ql_RIL_FindString(line, len, "+COPS:"); //continue wait
102cad44:	e12fff35 	blx	r5
    if (pHead)
102cad48:	e2504000 	subs	r4, r0, #0
102cad4c:	0a00001b 	beq	102cadc0 <ATRsp_COPS_Handler+0x94>
    {
        char str[100] = {0};
        char *p = NULL;
        char *q = NULL; 
        p = pHead + Ql_strlen("+COPS: ");
102cad50:	e59f30d4 	ldr	r3, [pc, #212]	; 102cae2c <ATRsp_COPS_Handler+0x100>
102cad54:	e59f00d4 	ldr	r0, [pc, #212]	; 102cae30 <ATRsp_COPS_Handler+0x104>
102cad58:	e12fff33 	blx	r3
        q = Ql_strstr(p, "\"");
102cad5c:	e59f50d0 	ldr	r5, [pc, #208]	; 102cae34 <ATRsp_COPS_Handler+0x108>
102cad60:	e59f10d0 	ldr	r1, [pc, #208]	; 102cae38 <ATRsp_COPS_Handler+0x10c>
    if (pHead)
    {
        char str[100] = {0};
        char *p = NULL;
        char *q = NULL; 
        p = pHead + Ql_strlen("+COPS: ");
102cad64:	e0844000 	add	r4, r4, r0
        q = Ql_strstr(p, "\"");
102cad68:	e1a00004 	mov	r0, r4
102cad6c:	e12fff35 	blx	r5
        if (p)
102cad70:	e3540000 	cmp	r4, #0
102cad74:	0a00000e 	beq	102cadb4 <ATRsp_COPS_Handler+0x88>
        {// the response is like: +COPS: 0,0,"CHINA MOBILE"
            p = q + 1;
102cad78:	e2807001 	add	r7, r0, #1
            q = Ql_strstr(p, "\"");
102cad7c:	e1a00007 	mov	r0, r7
102cad80:	e59f10b0 	ldr	r1, [pc, #176]	; 102cae38 <ATRsp_COPS_Handler+0x10c>
102cad84:	e12fff35 	blx	r5
            if (q != NULL)
102cad88:	e3500000 	cmp	r0, #0
102cad8c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
            {
                Ql_memcpy(pStr, p, q - p);
102cad90:	e0675000 	rsb	r5, r7, r0
102cad94:	e1a01007 	mov	r1, r7
102cad98:	e1a00006 	mov	r0, r6
102cad9c:	e1a02005 	mov	r2, r5
102cada0:	e59f3094 	ldr	r3, [pc, #148]	; 102cae3c <ATRsp_COPS_Handler+0x110>
102cada4:	e12fff33 	blx	r3
                pStr[q - p] = '\0';
102cada8:	e3a00000 	mov	r0, #0
102cadac:	e7c60005 	strb	r0, [r6, r5]
102cadb0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            }
        }
        else
        {//  the response is like +COPS: 0
            *pStr = '\0';
102cadb4:	e5c64000 	strb	r4, [r6]
        }
        return  RIL_ATRSP_SUCCESS;
102cadb8:	e1a00004 	mov	r0, r4
102cadbc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

   pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cadc0:	e1a00008 	mov	r0, r8
102cadc4:	e1a01007 	mov	r1, r7
102cadc8:	e59f2070 	ldr	r2, [pc, #112]	; 102cae40 <ATRsp_COPS_Handler+0x114>
102cadcc:	e59f6070 	ldr	r6, [pc, #112]	; 102cae44 <ATRsp_COPS_Handler+0x118>
102cadd0:	e12fff36 	blx	r6
   if (pHead)
102cadd4:	e3500000 	cmp	r0, #0
102cadd8:	0a000001 	beq	102cade4 <ATRsp_COPS_Handler+0xb8>
   {  
       return  RIL_ATRSP_SUCCESS;
102caddc:	e1a00004 	mov	r0, r4
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
102cade0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   if (pHead)
   {  
       return  RIL_ATRSP_SUCCESS;
   }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102cade4:	e1a00008 	mov	r0, r8
102cade8:	e1a01007 	mov	r1, r7
102cadec:	e59f2054 	ldr	r2, [pc, #84]	; 102cae48 <ATRsp_COPS_Handler+0x11c>
102cadf0:	e12fff36 	blx	r6
    if (pHead)
102cadf4:	e3500000 	cmp	r0, #0
102cadf8:	1a000007 	bne	102cae1c <ATRsp_COPS_Handler+0xf0>
    {  
        return  RIL_ATRSP_FAILED;
    } 

    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102cadfc:	e1a00008 	mov	r0, r8
102cae00:	e1a01007 	mov	r1, r7
102cae04:	e59f2040 	ldr	r2, [pc, #64]	; 102cae4c <ATRsp_COPS_Handler+0x120>
102cae08:	e12fff35 	blx	r5
    if (pHead)
102cae0c:	e3500000 	cmp	r0, #0
102cae10:	1a000001 	bne	102cae1c <ATRsp_COPS_Handler+0xf0>
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
102cae14:	e3a00001 	mov	r0, #1
102cae18:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return  RIL_ATRSP_FAILED;
102cae1c:	e3e00000 	mvn	r0, #0
102cae20:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102cae24:	102cce98 	.word	0x102cce98
102cae28:	102ee4f4 	.word	0x102ee4f4
102cae2c:	102e57a4 	.word	0x102e57a4
102cae30:	102ee4fc 	.word	0x102ee4fc
102cae34:	102e5a04 	.word	0x102e5a04
102cae38:	102ee03c 	.word	0x102ee03c
102cae3c:	102e597c 	.word	0x102e597c
102cae40:	102ee5e8 	.word	0x102ee5e8
102cae44:	102ccf24 	.word	0x102ccf24
102cae48:	102ede00 	.word	0x102ede00
102cae4c:	102ede08 	.word	0x102ede08

102cae50 <ATRsp_QIDEACT_Hdlr>:
    retRes = Ql_RIL_SendATCmd(strAT, strATLen, NULL, NULL, 0);
    return retRes;
}

static s32 ATRsp_QIDEACT_Hdlr(char* line, u32 len, void* userData)
{
102cae50:	e92d4070 	push	{r4, r5, r6, lr}
    if (Ql_RIL_FindLine(line, len, "DEACT OK"))
102cae54:	e59f203c 	ldr	r2, [pc, #60]	; 102cae98 <ATRsp_QIDEACT_Hdlr+0x48>
102cae58:	e59f403c 	ldr	r4, [pc, #60]	; 102cae9c <ATRsp_QIDEACT_Hdlr+0x4c>
    retRes = Ql_RIL_SendATCmd(strAT, strATLen, NULL, NULL, 0);
    return retRes;
}

static s32 ATRsp_QIDEACT_Hdlr(char* line, u32 len, void* userData)
{
102cae5c:	e1a06000 	mov	r6, r0
102cae60:	e1a05001 	mov	r5, r1
    if (Ql_RIL_FindLine(line, len, "DEACT OK"))
102cae64:	e12fff34 	blx	r4
102cae68:	e3500000 	cmp	r0, #0
102cae6c:	0a000001 	beq	102cae78 <ATRsp_QIDEACT_Hdlr+0x28>
    {
        return  RIL_ATRSP_SUCCESS;
102cae70:	e3a00000 	mov	r0, #0
    else if (Ql_RIL_FindLine(line, len, "ERROR"))
    {
        return  RIL_ATRSP_FAILED;
    }
    return RIL_ATRSP_CONTINUE; //continue wait
}
102cae74:	e8bd8070 	pop	{r4, r5, r6, pc}
{
    if (Ql_RIL_FindLine(line, len, "DEACT OK"))
    {
        return  RIL_ATRSP_SUCCESS;
    } 
    else if (Ql_RIL_FindLine(line, len, "ERROR"))
102cae78:	e1a00006 	mov	r0, r6
102cae7c:	e1a01005 	mov	r1, r5
102cae80:	e59f2018 	ldr	r2, [pc, #24]	; 102caea0 <ATRsp_QIDEACT_Hdlr+0x50>
102cae84:	e12fff34 	blx	r4
102cae88:	e3500000 	cmp	r0, #0
    {
        return  RIL_ATRSP_FAILED;
102cae8c:	03a00001 	moveq	r0, #1
102cae90:	13e00000 	mvnne	r0, #0
102cae94:	e8bd8070 	pop	{r4, r5, r6, pc}
102cae98:	102ee504 	.word	0x102ee504
102cae9c:	102ccf24 	.word	0x102ccf24
102caea0:	102ede00 	.word	0x102ede00

102caea4 <ATResponse_CSQ_Handler>:
*               1.Can't send any new AT commands in this function.
*               2.RIL handle the AT response line by line, so this function may 
*                 be called multiple times.
******************************************************************************/
static s32 ATResponse_CSQ_Handler(char* line, u32 len, void* userdata)
{
102caea4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102caea8:	e1a05002 	mov	r5, r2
    ST_CSQ_Reponse *CSQ_Reponse = (ST_CSQ_Reponse*)userdata;

    char *head = Ql_RIL_FindString(line, len, "+CSQ:"); //continue wait
102caeac:	e59f4098 	ldr	r4, [pc, #152]	; 102caf4c <ATResponse_CSQ_Handler+0xa8>
102caeb0:	e59f2098 	ldr	r2, [pc, #152]	; 102caf50 <ATResponse_CSQ_Handler+0xac>
*               1.Can't send any new AT commands in this function.
*               2.RIL handle the AT response line by line, so this function may 
*                 be called multiple times.
******************************************************************************/
static s32 ATResponse_CSQ_Handler(char* line, u32 len, void* userdata)
{
102caeb4:	e1a07000 	mov	r7, r0
102caeb8:	e1a06001 	mov	r6, r1
    ST_CSQ_Reponse *CSQ_Reponse = (ST_CSQ_Reponse*)userdata;

    char *head = Ql_RIL_FindString(line, len, "+CSQ:"); //continue wait
102caebc:	e12fff34 	blx	r4
    if(head)
102caec0:	e2508000 	subs	r8, r0, #0
102caec4:	0a000007 	beq	102caee8 <ATResponse_CSQ_Handler+0x44>
    {
        Ql_sscanf(head,"%*[^ ]%d,%d,%[^\r\n]",&CSQ_Reponse->rssi,&CSQ_Reponse->ber);
102caec8:	e59f3084 	ldr	r3, [pc, #132]	; 102caf54 <ATResponse_CSQ_Handler+0xb0>
102caecc:	e1a02005 	mov	r2, r5
102caed0:	e593c000 	ldr	ip, [r3]
102caed4:	e59f107c 	ldr	r1, [pc, #124]	; 102caf58 <ATResponse_CSQ_Handler+0xb4>
102caed8:	e2853004 	add	r3, r5, #4
102caedc:	e12fff3c 	blx	ip
        return  RIL_ATRSP_CONTINUE;
102caee0:	e3a00001 	mov	r0, #1
102caee4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102caee8:	e1a00007 	mov	r0, r7
102caeec:	e1a01006 	mov	r1, r6
102caef0:	e59f2064 	ldr	r2, [pc, #100]	; 102caf5c <ATResponse_CSQ_Handler+0xb8>
102caef4:	e59f5064 	ldr	r5, [pc, #100]	; 102caf60 <ATResponse_CSQ_Handler+0xbc>
102caef8:	e12fff35 	blx	r5
    if(head)
102caefc:	e3500000 	cmp	r0, #0
102caf00:	0a000001 	beq	102caf0c <ATResponse_CSQ_Handler+0x68>
    {  
        return  RIL_ATRSP_SUCCESS;
102caf04:	e1a00008 	mov	r0, r8
102caf08:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102caf0c:	e1a00007 	mov	r0, r7
102caf10:	e1a01006 	mov	r1, r6
102caf14:	e59f2048 	ldr	r2, [pc, #72]	; 102caf64 <ATResponse_CSQ_Handler+0xc0>
102caf18:	e12fff35 	blx	r5
    if(head)
102caf1c:	e3500000 	cmp	r0, #0
102caf20:	1a000007 	bne	102caf44 <ATResponse_CSQ_Handler+0xa0>
    {  
        return  RIL_ATRSP_FAILED;
    } 

    head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102caf24:	e1a00007 	mov	r0, r7
102caf28:	e1a01006 	mov	r1, r6
102caf2c:	e59f2034 	ldr	r2, [pc, #52]	; 102caf68 <ATResponse_CSQ_Handler+0xc4>
102caf30:	e12fff34 	blx	r4
    if(head)
102caf34:	e3500000 	cmp	r0, #0
    {
        return  RIL_ATRSP_FAILED;
102caf38:	03a00001 	moveq	r0, #1
102caf3c:	13e00000 	mvnne	r0, #0
102caf40:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if(head)
    {  
        return  RIL_ATRSP_FAILED;
102caf44:	e3e00000 	mvn	r0, #0
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
102caf48:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102caf4c:	102cce98 	.word	0x102cce98
102caf50:	102ee510 	.word	0x102ee510
102caf54:	f03de548 	.word	0xf03de548
102caf58:	102ee518 	.word	0x102ee518
102caf5c:	102ee5e8 	.word	0x102ee5e8
102caf60:	102ccf24 	.word	0x102ccf24
102caf64:	102ede00 	.word	0x102ede00
102caf68:	102ede08 	.word	0x102ede08

102caf6c <ATResponse_CGREG_Handler>:
*               1.Can't send any new AT commands in this function.
*               2.RIL handle the AT response line by line, so this function may 
*                 be called multiple times.
******************************************************************************/
static s32 ATResponse_CGREG_Handler(char* line, u32 len, void* userdata)
{
102caf6c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102caf70:	e1a05002 	mov	r5, r2
102caf74:	e24dd008 	sub	sp, sp, #8
    char *head = Ql_RIL_FindString(line, len, "+CGREG:"); //continue wait
102caf78:	e59f409c 	ldr	r4, [pc, #156]	; 102cb01c <ATResponse_CGREG_Handler+0xb0>
102caf7c:	e59f209c 	ldr	r2, [pc, #156]	; 102cb020 <ATResponse_CGREG_Handler+0xb4>
*               1.Can't send any new AT commands in this function.
*               2.RIL handle the AT response line by line, so this function may 
*                 be called multiple times.
******************************************************************************/
static s32 ATResponse_CGREG_Handler(char* line, u32 len, void* userdata)
{
102caf80:	e1a07000 	mov	r7, r0
102caf84:	e1a06001 	mov	r6, r1
    char *head = Ql_RIL_FindString(line, len, "+CGREG:"); //continue wait
102caf88:	e12fff34 	blx	r4
    if(head)
102caf8c:	e2508000 	subs	r8, r0, #0
102caf90:	0a00000a 	beq	102cafc0 <ATResponse_CGREG_Handler+0x54>
    {
        s32 n = 0;
102caf94:	e28d2008 	add	r2, sp, #8
102caf98:	e3a03000 	mov	r3, #0
102caf9c:	e5223004 	str	r3, [r2, #-4]!
        s32 *state = (s32 *)userdata;
        Ql_sscanf(head,"%*[^ ]%d,%d,%[^\r\n]",&n,state);
102cafa0:	e59f307c 	ldr	r3, [pc, #124]	; 102cb024 <ATResponse_CGREG_Handler+0xb8>
102cafa4:	e59f107c 	ldr	r1, [pc, #124]	; 102cb028 <ATResponse_CGREG_Handler+0xbc>
102cafa8:	e5934000 	ldr	r4, [r3]
102cafac:	e1a03005 	mov	r3, r5
102cafb0:	e12fff34 	blx	r4
        return  RIL_ATRSP_CONTINUE;
102cafb4:	e3a00001 	mov	r0, #1
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
102cafb8:	e28dd008 	add	sp, sp, #8
102cafbc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        s32 *state = (s32 *)userdata;
        Ql_sscanf(head,"%*[^ ]%d,%d,%[^\r\n]",&n,state);
        return  RIL_ATRSP_CONTINUE;
    }

   head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cafc0:	e1a00007 	mov	r0, r7
102cafc4:	e1a01006 	mov	r1, r6
102cafc8:	e59f205c 	ldr	r2, [pc, #92]	; 102cb02c <ATResponse_CGREG_Handler+0xc0>
102cafcc:	e59f505c 	ldr	r5, [pc, #92]	; 102cb030 <ATResponse_CGREG_Handler+0xc4>
102cafd0:	e12fff35 	blx	r5
   if(head)
102cafd4:	e3500000 	cmp	r0, #0
   {  
       return  RIL_ATRSP_SUCCESS;
102cafd8:	11a00008 	movne	r0, r8
        Ql_sscanf(head,"%*[^ ]%d,%d,%[^\r\n]",&n,state);
        return  RIL_ATRSP_CONTINUE;
    }

   head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
   if(head)
102cafdc:	1afffff5 	bne	102cafb8 <ATResponse_CGREG_Handler+0x4c>
   {  
       return  RIL_ATRSP_SUCCESS;
   }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102cafe0:	e1a00007 	mov	r0, r7
102cafe4:	e1a01006 	mov	r1, r6
102cafe8:	e59f2044 	ldr	r2, [pc, #68]	; 102cb034 <ATResponse_CGREG_Handler+0xc8>
102cafec:	e12fff35 	blx	r5
    if(head)
102caff0:	e3500000 	cmp	r0, #0
    {  
        return  RIL_ATRSP_FAILED;
102caff4:	13e00000 	mvnne	r0, #0
   {  
       return  RIL_ATRSP_SUCCESS;
   }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if(head)
102caff8:	1affffee 	bne	102cafb8 <ATResponse_CGREG_Handler+0x4c>
    {  
        return  RIL_ATRSP_FAILED;
    } 

    head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102caffc:	e1a00007 	mov	r0, r7
102cb000:	e1a01006 	mov	r1, r6
102cb004:	e59f202c 	ldr	r2, [pc, #44]	; 102cb038 <ATResponse_CGREG_Handler+0xcc>
102cb008:	e12fff34 	blx	r4
    if(head)
102cb00c:	e3500000 	cmp	r0, #0
    {
        return  RIL_ATRSP_FAILED;
102cb010:	03a00001 	moveq	r0, #1
102cb014:	13e00000 	mvnne	r0, #0
102cb018:	eaffffe6 	b	102cafb8 <ATResponse_CGREG_Handler+0x4c>
102cb01c:	102cce98 	.word	0x102cce98
102cb020:	102ee52c 	.word	0x102ee52c
102cb024:	f03de548 	.word	0xf03de548
102cb028:	102ee518 	.word	0x102ee518
102cb02c:	102ee5e8 	.word	0x102ee5e8
102cb030:	102ccf24 	.word	0x102ccf24
102cb034:	102ede00 	.word	0x102ede00
102cb038:	102ede08 	.word	0x102ede08

102cb03c <ATResponse_CREG_Handler>:
*               1.Can't send any new AT commands in this function.
*               2.RIL handle the AT response line by line, so this function may 
*                 be called multiple times.
******************************************************************************/
static s32 ATResponse_CREG_Handler(char* line, u32 len, void* userdata)
{
102cb03c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102cb040:	e1a05002 	mov	r5, r2
102cb044:	e24dd008 	sub	sp, sp, #8
    char *head = Ql_RIL_FindString(line, len, "+CREG:"); //continue wait
102cb048:	e59f409c 	ldr	r4, [pc, #156]	; 102cb0ec <ATResponse_CREG_Handler+0xb0>
102cb04c:	e59f209c 	ldr	r2, [pc, #156]	; 102cb0f0 <ATResponse_CREG_Handler+0xb4>
*               1.Can't send any new AT commands in this function.
*               2.RIL handle the AT response line by line, so this function may 
*                 be called multiple times.
******************************************************************************/
static s32 ATResponse_CREG_Handler(char* line, u32 len, void* userdata)
{
102cb050:	e1a07000 	mov	r7, r0
102cb054:	e1a06001 	mov	r6, r1
    char *head = Ql_RIL_FindString(line, len, "+CREG:"); //continue wait
102cb058:	e12fff34 	blx	r4
    if(head)
102cb05c:	e2508000 	subs	r8, r0, #0
102cb060:	0a00000a 	beq	102cb090 <ATResponse_CREG_Handler+0x54>
    {
        s32 n = 0;
102cb064:	e28d2008 	add	r2, sp, #8
102cb068:	e3a03000 	mov	r3, #0
102cb06c:	e5223004 	str	r3, [r2, #-4]!
        s32 *state = (s32 *)userdata;
        Ql_sscanf(head,"%*[^ ]%d,%d,%[^\r\n]",&n,state);
102cb070:	e59f307c 	ldr	r3, [pc, #124]	; 102cb0f4 <ATResponse_CREG_Handler+0xb8>
102cb074:	e59f107c 	ldr	r1, [pc, #124]	; 102cb0f8 <ATResponse_CREG_Handler+0xbc>
102cb078:	e5934000 	ldr	r4, [r3]
102cb07c:	e1a03005 	mov	r3, r5
102cb080:	e12fff34 	blx	r4
        return  RIL_ATRSP_CONTINUE;
102cb084:	e3a00001 	mov	r0, #1
    {
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
102cb088:	e28dd008 	add	sp, sp, #8
102cb08c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        s32 *state = (s32 *)userdata;
        Ql_sscanf(head,"%*[^ ]%d,%d,%[^\r\n]",&n,state);
        return  RIL_ATRSP_CONTINUE;
    }

   head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cb090:	e1a00007 	mov	r0, r7
102cb094:	e1a01006 	mov	r1, r6
102cb098:	e59f205c 	ldr	r2, [pc, #92]	; 102cb0fc <ATResponse_CREG_Handler+0xc0>
102cb09c:	e59f505c 	ldr	r5, [pc, #92]	; 102cb100 <ATResponse_CREG_Handler+0xc4>
102cb0a0:	e12fff35 	blx	r5
   if(head)
102cb0a4:	e3500000 	cmp	r0, #0
   {
       return  RIL_ATRSP_SUCCESS;
102cb0a8:	11a00008 	movne	r0, r8
        Ql_sscanf(head,"%*[^ ]%d,%d,%[^\r\n]",&n,state);
        return  RIL_ATRSP_CONTINUE;
    }

   head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
   if(head)
102cb0ac:	1afffff5 	bne	102cb088 <ATResponse_CREG_Handler+0x4c>
   {
       return  RIL_ATRSP_SUCCESS;
   }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102cb0b0:	e1a00007 	mov	r0, r7
102cb0b4:	e1a01006 	mov	r1, r6
102cb0b8:	e59f2044 	ldr	r2, [pc, #68]	; 102cb104 <ATResponse_CREG_Handler+0xc8>
102cb0bc:	e12fff35 	blx	r5
    if(head)
102cb0c0:	e3500000 	cmp	r0, #0
    {  
        return  RIL_ATRSP_FAILED;
102cb0c4:	13e00000 	mvnne	r0, #0
   {
       return  RIL_ATRSP_SUCCESS;
   }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if(head)
102cb0c8:	1affffee 	bne	102cb088 <ATResponse_CREG_Handler+0x4c>
    {  
        return  RIL_ATRSP_FAILED;
    } 

    head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102cb0cc:	e1a00007 	mov	r0, r7
102cb0d0:	e1a01006 	mov	r1, r6
102cb0d4:	e59f202c 	ldr	r2, [pc, #44]	; 102cb108 <ATResponse_CREG_Handler+0xcc>
102cb0d8:	e12fff34 	blx	r4
    if(head)
102cb0dc:	e3500000 	cmp	r0, #0
    {
        return  RIL_ATRSP_FAILED;
102cb0e0:	03a00001 	moveq	r0, #1
102cb0e4:	13e00000 	mvnne	r0, #0
102cb0e8:	eaffffe6 	b	102cb088 <ATResponse_CREG_Handler+0x4c>
102cb0ec:	102cce98 	.word	0x102cce98
102cb0f0:	102ee534 	.word	0x102ee534
102cb0f4:	f03de548 	.word	0xf03de548
102cb0f8:	102ee518 	.word	0x102ee518
102cb0fc:	102ee5e8 	.word	0x102ee5e8
102cb100:	102ccf24 	.word	0x102ccf24
102cb104:	102ede00 	.word	0x102ede00
102cb108:	102ede08 	.word	0x102ede08

102cb10c <RIL_NW_GetGSMState>:
******************************************************************************/
s32  RIL_NW_GetGSMState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CREG?\0";
102cb10c:	e59f305c 	ldr	r3, [pc, #92]	; 102cb170 <RIL_NW_GetGSMState+0x64>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_NW_GetGSMState(s32 *stat)
{
102cb110:	e92d4030 	push	{r4, r5, lr}
102cb114:	e1a05000 	mov	r5, r0
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CREG?\0";
102cb118:	e8930007 	ldm	r3, {r0, r1, r2}
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_NW_GetGSMState(s32 *stat)
{
102cb11c:	e24dd01c 	sub	sp, sp, #28
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CREG?\0";
102cb120:	e28d300c 	add	r3, sp, #12
102cb124:	e8a30003 	stmia	r3!, {r0, r1}
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_NW_GetGSMState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
102cb128:	e3a04000 	mov	r4, #0
    char strAT[] = "AT+CREG?\0";
102cb12c:	e1c320b0 	strh	r2, [r3]

    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATResponse_CREG_Handler, &nStat, 0);
102cb130:	e28d000c 	add	r0, sp, #12
102cb134:	e59f3038 	ldr	r3, [pc, #56]	; 102cb174 <RIL_NW_GetGSMState+0x68>
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_NW_GetGSMState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
102cb138:	e58d4008 	str	r4, [sp, #8]
    char strAT[] = "AT+CREG?\0";

    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATResponse_CREG_Handler, &nStat, 0);
102cb13c:	e12fff33 	blx	r3
102cb140:	e28d3008 	add	r3, sp, #8
102cb144:	e58d4000 	str	r4, [sp]
102cb148:	e59f2028 	ldr	r2, [pc, #40]	; 102cb178 <RIL_NW_GetGSMState+0x6c>
102cb14c:	e59fc028 	ldr	ip, [pc, #40]	; 102cb17c <RIL_NW_GetGSMState+0x70>
102cb150:	e1a01000 	mov	r1, r0
102cb154:	e28d000c 	add	r0, sp, #12
102cb158:	e12fff3c 	blx	ip
    if(RIL_AT_SUCCESS == retRes)
102cb15c:	e3500000 	cmp	r0, #0
    {
       *stat = nStat; 
102cb160:	059d3008 	ldreq	r3, [sp, #8]
102cb164:	05853000 	streq	r3, [r5]
    }
    return retRes;
}
102cb168:	e28dd01c 	add	sp, sp, #28
102cb16c:	e8bd8030 	pop	{r4, r5, pc}
102cb170:	102e6638 	.word	0x102e6638
102cb174:	102e57a4 	.word	0x102e57a4
102cb178:	102cb03c 	.word	0x102cb03c
102cb17c:	102e5168 	.word	0x102e5168

102cb180 <RIL_NW_GetGPRSState>:
******************************************************************************/
s32  RIL_NW_GetGPRSState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CGREG?\0";
102cb180:	e59f3064 	ldr	r3, [pc, #100]	; 102cb1ec <RIL_NW_GetGPRSState+0x6c>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_NW_GetGPRSState(s32 *stat)
{
102cb184:	e92d4030 	push	{r4, r5, lr}
102cb188:	e1a05000 	mov	r5, r0
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CGREG?\0";
102cb18c:	e8930007 	ldm	r3, {r0, r1, r2}
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_NW_GetGPRSState(s32 *stat)
{
102cb190:	e24dd01c 	sub	sp, sp, #28
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CGREG?\0";
102cb194:	e28d300c 	add	r3, sp, #12
102cb198:	e8a30003 	stmia	r3!, {r0, r1}
102cb19c:	e1a01822 	lsr	r1, r2, #16
102cb1a0:	e0c320b2 	strh	r2, [r3], #2
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_NW_GetGPRSState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
102cb1a4:	e3a04000 	mov	r4, #0
    char strAT[] = "AT+CGREG?\0";
102cb1a8:	e5c31000 	strb	r1, [r3]

    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATResponse_CGREG_Handler, &nStat, 0);
102cb1ac:	e28d000c 	add	r0, sp, #12
102cb1b0:	e59f3038 	ldr	r3, [pc, #56]	; 102cb1f0 <RIL_NW_GetGPRSState+0x70>
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_NW_GetGPRSState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
102cb1b4:	e58d4008 	str	r4, [sp, #8]
    char strAT[] = "AT+CGREG?\0";

    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATResponse_CGREG_Handler, &nStat, 0);
102cb1b8:	e12fff33 	blx	r3
102cb1bc:	e28d3008 	add	r3, sp, #8
102cb1c0:	e58d4000 	str	r4, [sp]
102cb1c4:	e59f2028 	ldr	r2, [pc, #40]	; 102cb1f4 <RIL_NW_GetGPRSState+0x74>
102cb1c8:	e59fc028 	ldr	ip, [pc, #40]	; 102cb1f8 <RIL_NW_GetGPRSState+0x78>
102cb1cc:	e1a01000 	mov	r1, r0
102cb1d0:	e28d000c 	add	r0, sp, #12
102cb1d4:	e12fff3c 	blx	ip
    if(RIL_AT_SUCCESS == retRes)
102cb1d8:	e3500000 	cmp	r0, #0
    {
       *stat = nStat; 
102cb1dc:	059d3008 	ldreq	r3, [sp, #8]
102cb1e0:	05853000 	streq	r3, [r5]
    }
    return retRes;
}
102cb1e4:	e28dd01c 	add	sp, sp, #28
102cb1e8:	e8bd8030 	pop	{r4, r5, pc}
102cb1ec:	102e6644 	.word	0x102e6644
102cb1f0:	102e57a4 	.word	0x102e57a4
102cb1f4:	102caf6c 	.word	0x102caf6c
102cb1f8:	102e5168 	.word	0x102e5168

102cb1fc <RIL_NW_GetSignalQuality>:
*                                      and then call Ql_RIL_Initialize to initialize RIL. 
******************************************************************************/
s32  RIL_NW_GetSignalQuality(u32* rssi, u32* ber)
{
    s32 retRes = 0;
    char strAT[] = "AT+CSQ\0";
102cb1fc:	e59f3074 	ldr	r3, [pc, #116]	; 102cb278 <RIL_NW_GetSignalQuality+0x7c>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL. 
******************************************************************************/
s32  RIL_NW_GetSignalQuality(u32* rssi, u32* ber)
{
102cb200:	e92d4070 	push	{r4, r5, r6, lr}
102cb204:	e1a06000 	mov	r6, r0
102cb208:	e24dd018 	sub	sp, sp, #24
102cb20c:	e1a05001 	mov	r5, r1
    s32 retRes = 0;
    char strAT[] = "AT+CSQ\0";
102cb210:	e8930003 	ldm	r3, {r0, r1}
102cb214:	e28d4008 	add	r4, sp, #8
102cb218:	e8840003 	stm	r4, {r0, r1}
    ST_CSQ_Reponse pCSQ_Reponse;
    Ql_memset(&pCSQ_Reponse,0, sizeof(pCSQ_Reponse));
102cb21c:	e3a02008 	mov	r2, #8
102cb220:	e3a01000 	mov	r1, #0
102cb224:	e28d0010 	add	r0, sp, #16
102cb228:	e59f304c 	ldr	r3, [pc, #76]	; 102cb27c <RIL_NW_GetSignalQuality+0x80>
102cb22c:	e12fff33 	blx	r3
    retRes = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT), ATResponse_CSQ_Handler,(void*)&pCSQ_Reponse,0);
102cb230:	e1a00004 	mov	r0, r4
102cb234:	e59f3044 	ldr	r3, [pc, #68]	; 102cb280 <RIL_NW_GetSignalQuality+0x84>
102cb238:	e12fff33 	blx	r3
102cb23c:	e3a03000 	mov	r3, #0
102cb240:	e58d3000 	str	r3, [sp]
102cb244:	e59f2038 	ldr	r2, [pc, #56]	; 102cb284 <RIL_NW_GetSignalQuality+0x88>
102cb248:	e28d3010 	add	r3, sp, #16
102cb24c:	e59fc034 	ldr	ip, [pc, #52]	; 102cb288 <RIL_NW_GetSignalQuality+0x8c>
102cb250:	e1a01000 	mov	r1, r0
102cb254:	e1a00004 	mov	r0, r4
102cb258:	e12fff3c 	blx	ip
    if(RIL_AT_SUCCESS == retRes)
102cb25c:	e3500000 	cmp	r0, #0
    {
       *rssi = pCSQ_Reponse.rssi; 
102cb260:	059d3010 	ldreq	r3, [sp, #16]
102cb264:	05863000 	streq	r3, [r6]
       *ber = pCSQ_Reponse.ber;
102cb268:	059d3014 	ldreq	r3, [sp, #20]
102cb26c:	05853000 	streq	r3, [r5]
    }
 
    return retRes;
}
102cb270:	e28dd018 	add	sp, sp, #24
102cb274:	e8bd8070 	pop	{r4, r5, r6, pc}
102cb278:	102e6650 	.word	0x102e6650
102cb27c:	102e58f4 	.word	0x102e58f4
102cb280:	102e57a4 	.word	0x102e57a4
102cb284:	102caea4 	.word	0x102caea4
102cb288:	102e5168 	.word	0x102e5168

102cb28c <RIL_NW_SetGPRSContext>:

s32  RIL_NW_SetGPRSContext(u8 foregroundContext)
{
102cb28c:	e92d4010 	push	{r4, lr}
102cb290:	e24dd020 	sub	sp, sp, #32
102cb294:	e1a04000 	mov	r4, r0
    s32 retRes = 0;
    char strAT[20] ;

    Ql_memset(strAT,0x00, sizeof(strAT));
102cb298:	e3a01000 	mov	r1, #0
102cb29c:	e3a02014 	mov	r2, #20
102cb2a0:	e28d000c 	add	r0, sp, #12
102cb2a4:	e59f3048 	ldr	r3, [pc, #72]	; 102cb2f4 <RIL_NW_SetGPRSContext+0x68>
102cb2a8:	e12fff33 	blx	r3
    Ql_sprintf(strAT,"AT+QIFGCNT=%d",foregroundContext);
102cb2ac:	e59f3044 	ldr	r3, [pc, #68]	; 102cb2f8 <RIL_NW_SetGPRSContext+0x6c>
102cb2b0:	e1a02004 	mov	r2, r4
102cb2b4:	e59f1040 	ldr	r1, [pc, #64]	; 102cb2fc <RIL_NW_SetGPRSContext+0x70>
102cb2b8:	e5933000 	ldr	r3, [r3]
102cb2bc:	e28d000c 	add	r0, sp, #12
102cb2c0:	e12fff33 	blx	r3
    retRes = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT), NULL,NULL,0);
102cb2c4:	e28d000c 	add	r0, sp, #12
102cb2c8:	e59f3030 	ldr	r3, [pc, #48]	; 102cb300 <RIL_NW_SetGPRSContext+0x74>
102cb2cc:	e12fff33 	blx	r3
102cb2d0:	e3a03000 	mov	r3, #0
102cb2d4:	e1a02003 	mov	r2, r3
102cb2d8:	e58d3000 	str	r3, [sp]
102cb2dc:	e59fc020 	ldr	ip, [pc, #32]	; 102cb304 <RIL_NW_SetGPRSContext+0x78>
102cb2e0:	e1a01000 	mov	r1, r0
102cb2e4:	e28d000c 	add	r0, sp, #12
102cb2e8:	e12fff3c 	blx	ip
    return retRes;
}
102cb2ec:	e28dd020 	add	sp, sp, #32
102cb2f0:	e8bd8010 	pop	{r4, pc}
102cb2f4:	102e58f4 	.word	0x102e58f4
102cb2f8:	f03de540 	.word	0xf03de540
102cb2fc:	102ee53c 	.word	0x102ee53c
102cb300:	102e57a4 	.word	0x102e57a4
102cb304:	102e5168 	.word	0x102e5168

102cb308 <RIL_NW_SetAPN>:

s32  RIL_NW_SetAPN(u8 mode, char* apn, char* userName, char* pw)
{
102cb308:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102cb30c:	e24dd0d4 	sub	sp, sp, #212	; 0xd4
102cb310:	e1a04001 	mov	r4, r1
102cb314:	e1a05002 	mov	r5, r2
102cb318:	e1a06000 	mov	r6, r0
    s32 retRes = 0;
    char strAT[200] ;

    Ql_memset(strAT,0x00, sizeof(strAT));
102cb31c:	e3a01000 	mov	r1, #0
102cb320:	e28d0008 	add	r0, sp, #8
102cb324:	e3a020c8 	mov	r2, #200	; 0xc8
102cb328:	e59fc0d0 	ldr	ip, [pc, #208]	; 102cb400 <RIL_NW_SetAPN+0xf8>
    retRes = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT), NULL,NULL,0);
    return retRes;
}

s32  RIL_NW_SetAPN(u8 mode, char* apn, char* userName, char* pw)
{
102cb32c:	e1a07003 	mov	r7, r3
    s32 retRes = 0;
    char strAT[200] ;

    Ql_memset(strAT,0x00, sizeof(strAT));
102cb330:	e12fff3c 	blx	ip
    if((NULL != apn) && (NULL != userName) && (NULL != pw))
102cb334:	e2943000 	adds	r3, r4, #0
102cb338:	13a03001 	movne	r3, #1
102cb33c:	e3550000 	cmp	r5, #0
102cb340:	13540000 	cmpne	r4, #0
102cb344:	0a00000b 	beq	102cb378 <RIL_NW_SetAPN+0x70>
102cb348:	e3570000 	cmp	r7, #0
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn,userName,pw);
102cb34c:	e58d5000 	str	r5, [sp]
{
    s32 retRes = 0;
    char strAT[200] ;

    Ql_memset(strAT,0x00, sizeof(strAT));
    if((NULL != apn) && (NULL != userName) && (NULL != pw))
102cb350:	0a00001d 	beq	102cb3cc <RIL_NW_SetAPN+0xc4>
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn,userName,pw);
102cb354:	e59f30a8 	ldr	r3, [pc, #168]	; 102cb404 <RIL_NW_SetAPN+0xfc>
102cb358:	e58d7004 	str	r7, [sp, #4]
102cb35c:	e28d0008 	add	r0, sp, #8
102cb360:	e593c000 	ldr	ip, [r3]
102cb364:	e59f109c 	ldr	r1, [pc, #156]	; 102cb408 <RIL_NW_SetAPN+0x100>
102cb368:	e1a02006 	mov	r2, r6
102cb36c:	e1a03004 	mov	r3, r4
102cb370:	e12fff3c 	blx	ip
102cb374:	ea000008 	b	102cb39c <RIL_NW_SetAPN+0x94>
    }
    else if((NULL != apn) && (NULL != userName))
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn,userName);
    }
    else if(NULL != apn)
102cb378:	e3530000 	cmp	r3, #0
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn);
102cb37c:	e28d0008 	add	r0, sp, #8
102cb380:	e59f307c 	ldr	r3, [pc, #124]	; 102cb404 <RIL_NW_SetAPN+0xfc>
    }
    else if((NULL != apn) && (NULL != userName))
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn,userName);
    }
    else if(NULL != apn)
102cb384:	0a000018 	beq	102cb3ec <RIL_NW_SetAPN+0xe4>
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn);
102cb388:	e593c000 	ldr	ip, [r3]
102cb38c:	e59f1074 	ldr	r1, [pc, #116]	; 102cb408 <RIL_NW_SetAPN+0x100>
102cb390:	e1a02006 	mov	r2, r6
102cb394:	e1a03004 	mov	r3, r4
102cb398:	e12fff3c 	blx	ip
    else
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d",mode);
    }
        
    retRes = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT), NULL,NULL,0);
102cb39c:	e28d0008 	add	r0, sp, #8
102cb3a0:	e59f3064 	ldr	r3, [pc, #100]	; 102cb40c <RIL_NW_SetAPN+0x104>
102cb3a4:	e12fff33 	blx	r3
102cb3a8:	e3a03000 	mov	r3, #0
102cb3ac:	e1a02003 	mov	r2, r3
102cb3b0:	e58d3000 	str	r3, [sp]
102cb3b4:	e59fc054 	ldr	ip, [pc, #84]	; 102cb410 <RIL_NW_SetAPN+0x108>
102cb3b8:	e1a01000 	mov	r1, r0
102cb3bc:	e28d0008 	add	r0, sp, #8
102cb3c0:	e12fff3c 	blx	ip
    return retRes;

}
102cb3c4:	e28dd0d4 	add	sp, sp, #212	; 0xd4
102cb3c8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn,userName,pw);
    }
    else if((NULL != apn) && (NULL != userName))
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn,userName);
102cb3cc:	e59f3030 	ldr	r3, [pc, #48]	; 102cb404 <RIL_NW_SetAPN+0xfc>
102cb3d0:	e28d0008 	add	r0, sp, #8
102cb3d4:	e593c000 	ldr	ip, [r3]
102cb3d8:	e59f1028 	ldr	r1, [pc, #40]	; 102cb408 <RIL_NW_SetAPN+0x100>
102cb3dc:	e1a02006 	mov	r2, r6
102cb3e0:	e1a03004 	mov	r3, r4
102cb3e4:	e12fff3c 	blx	ip
102cb3e8:	eaffffeb 	b	102cb39c <RIL_NW_SetAPN+0x94>
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d,\"%s\"",mode,apn);
    }
    else
    {
        Ql_sprintf(strAT,"AT+QICSGP=%d",mode);
102cb3ec:	e5933000 	ldr	r3, [r3]
102cb3f0:	e59f101c 	ldr	r1, [pc, #28]	; 102cb414 <RIL_NW_SetAPN+0x10c>
102cb3f4:	e1a02006 	mov	r2, r6
102cb3f8:	e12fff33 	blx	r3
102cb3fc:	eaffffe6 	b	102cb39c <RIL_NW_SetAPN+0x94>
102cb400:	102e58f4 	.word	0x102e58f4
102cb404:	f03de540 	.word	0xf03de540
102cb408:	102ee54c 	.word	0x102ee54c
102cb40c:	102e57a4 	.word	0x102e57a4
102cb410:	102e5168 	.word	0x102e5168
102cb414:	102ee560 	.word	0x102ee560

102cb418 <RIL_NW_GetIpStatusByName>:
    return retRes;

}

s32 RIL_NW_GetIpStatusByName(char* ipStsStr, u32 len)
{
102cb418:	e92d4070 	push	{r4, r5, r6, lr}
    s32 ipSts = IP_INITIAL;
    if (Ql_strncmp(ipStsStr, "IP INITIAL", len) == 0)
102cb41c:	e1a02001 	mov	r2, r1
    return retRes;

}

s32 RIL_NW_GetIpStatusByName(char* ipStsStr, u32 len)
{
102cb420:	e1a05001 	mov	r5, r1
    s32 ipSts = IP_INITIAL;
    if (Ql_strncmp(ipStsStr, "IP INITIAL", len) == 0)
102cb424:	e59f4150 	ldr	r4, [pc, #336]	; 102cb57c <RIL_NW_GetIpStatusByName+0x164>
102cb428:	e59f1150 	ldr	r1, [pc, #336]	; 102cb580 <RIL_NW_GetIpStatusByName+0x168>
    return retRes;

}

s32 RIL_NW_GetIpStatusByName(char* ipStsStr, u32 len)
{
102cb42c:	e1a06000 	mov	r6, r0
    s32 ipSts = IP_INITIAL;
    if (Ql_strncmp(ipStsStr, "IP INITIAL", len) == 0)
102cb430:	e12fff34 	blx	r4
102cb434:	e3500000 	cmp	r0, #0
102cb438:	1a000001 	bne	102cb444 <RIL_NW_GetIpStatusByName+0x2c>
    {
        ipSts = IP_INITIAL;
102cb43c:	e3a00000 	mov	r0, #0
102cb440:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "IP START", len) == 0)
102cb444:	e1a00006 	mov	r0, r6
102cb448:	e59f1134 	ldr	r1, [pc, #308]	; 102cb584 <RIL_NW_GetIpStatusByName+0x16c>
102cb44c:	e1a02005 	mov	r2, r5
102cb450:	e12fff34 	blx	r4
102cb454:	e3500000 	cmp	r0, #0
102cb458:	1a000001 	bne	102cb464 <RIL_NW_GetIpStatusByName+0x4c>
    {
        ipSts = IP_START;
102cb45c:	e3a00001 	mov	r0, #1
102cb460:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "IP CONFIG", len) == 0)
102cb464:	e1a00006 	mov	r0, r6
102cb468:	e59f1118 	ldr	r1, [pc, #280]	; 102cb588 <RIL_NW_GetIpStatusByName+0x170>
102cb46c:	e1a02005 	mov	r2, r5
102cb470:	e12fff34 	blx	r4
102cb474:	e3500000 	cmp	r0, #0
102cb478:	1a000001 	bne	102cb484 <RIL_NW_GetIpStatusByName+0x6c>
    {
        ipSts = IP_CONFIG;
102cb47c:	e3a00002 	mov	r0, #2
102cb480:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "IP IND", len) == 0)
102cb484:	e1a00006 	mov	r0, r6
102cb488:	e59f10fc 	ldr	r1, [pc, #252]	; 102cb58c <RIL_NW_GetIpStatusByName+0x174>
102cb48c:	e1a02005 	mov	r2, r5
102cb490:	e12fff34 	blx	r4
102cb494:	e3500000 	cmp	r0, #0
102cb498:	1a000001 	bne	102cb4a4 <RIL_NW_GetIpStatusByName+0x8c>
    {
        ipSts = IP_IND;
102cb49c:	e3a00003 	mov	r0, #3
102cb4a0:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "IP GPRSACT", len) == 0)
102cb4a4:	e1a00006 	mov	r0, r6
102cb4a8:	e59f10e0 	ldr	r1, [pc, #224]	; 102cb590 <RIL_NW_GetIpStatusByName+0x178>
102cb4ac:	e1a02005 	mov	r2, r5
102cb4b0:	e12fff34 	blx	r4
102cb4b4:	e3500000 	cmp	r0, #0
102cb4b8:	1a000001 	bne	102cb4c4 <RIL_NW_GetIpStatusByName+0xac>
    {
        ipSts = IP_GPRSACT;
102cb4bc:	e3a00004 	mov	r0, #4
102cb4c0:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "IP STATUS", len) == 0)
102cb4c4:	e1a00006 	mov	r0, r6
102cb4c8:	e59f10c4 	ldr	r1, [pc, #196]	; 102cb594 <RIL_NW_GetIpStatusByName+0x17c>
102cb4cc:	e1a02005 	mov	r2, r5
102cb4d0:	e12fff34 	blx	r4
102cb4d4:	e3500000 	cmp	r0, #0
102cb4d8:	1a000001 	bne	102cb4e4 <RIL_NW_GetIpStatusByName+0xcc>
    {
        ipSts = IP_STATUS;
102cb4dc:	e3a00005 	mov	r0, #5
102cb4e0:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "TCP CONNECTING", len) == 0)
102cb4e4:	e1a00006 	mov	r0, r6
102cb4e8:	e59f10a8 	ldr	r1, [pc, #168]	; 102cb598 <RIL_NW_GetIpStatusByName+0x180>
102cb4ec:	e1a02005 	mov	r2, r5
102cb4f0:	e12fff34 	blx	r4
102cb4f4:	e3500000 	cmp	r0, #0
102cb4f8:	1a000001 	bne	102cb504 <RIL_NW_GetIpStatusByName+0xec>
    {
        ipSts = TCP_PROCESSING;
102cb4fc:	e3a00006 	mov	r0, #6
102cb500:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "UDP CONNECTING", len) == 0)
102cb504:	e1a00006 	mov	r0, r6
102cb508:	e59f108c 	ldr	r1, [pc, #140]	; 102cb59c <RIL_NW_GetIpStatusByName+0x184>
102cb50c:	e1a02005 	mov	r2, r5
102cb510:	e12fff34 	blx	r4
102cb514:	e3500000 	cmp	r0, #0
102cb518:	0afffff7 	beq	102cb4fc <RIL_NW_GetIpStatusByName+0xe4>
    {
        ipSts = UDP_PROCESSING;
    }
    else if (Ql_strncmp(ipStsStr, "IP CLOSE", len) == 0)
102cb51c:	e1a00006 	mov	r0, r6
102cb520:	e59f1078 	ldr	r1, [pc, #120]	; 102cb5a0 <RIL_NW_GetIpStatusByName+0x188>
102cb524:	e1a02005 	mov	r2, r5
102cb528:	e12fff34 	blx	r4
102cb52c:	e3500000 	cmp	r0, #0
102cb530:	1a000001 	bne	102cb53c <RIL_NW_GetIpStatusByName+0x124>
    {
        ipSts = IP_CLOSE;
102cb534:	e3a00007 	mov	r0, #7
102cb538:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "CONNECT OK", len) == 0)
102cb53c:	e1a00006 	mov	r0, r6
102cb540:	e59f105c 	ldr	r1, [pc, #92]	; 102cb5a4 <RIL_NW_GetIpStatusByName+0x18c>
102cb544:	e1a02005 	mov	r2, r5
102cb548:	e12fff34 	blx	r4
102cb54c:	e3500000 	cmp	r0, #0
102cb550:	1a000001 	bne	102cb55c <RIL_NW_GetIpStatusByName+0x144>
    {
        ipSts = CONNECT_OK;
102cb554:	e3a00008 	mov	r0, #8
    else if (Ql_strncmp(ipStsStr, "PDP DEACT", len) == 0)
    {
        ipSts = GPRS_CONTEXT_DEACT;
    }
    return ipSts;
}
102cb558:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(ipStsStr, "CONNECT OK", len) == 0)
    {
        ipSts = CONNECT_OK;
    }
    else if (Ql_strncmp(ipStsStr, "PDP DEACT", len) == 0)
102cb55c:	e1a00006 	mov	r0, r6
102cb560:	e59f1040 	ldr	r1, [pc, #64]	; 102cb5a8 <RIL_NW_GetIpStatusByName+0x190>
102cb564:	e1a02005 	mov	r2, r5
102cb568:	e12fff34 	blx	r4
102cb56c:	e3500000 	cmp	r0, #0
102cb570:	1affffb1 	bne	102cb43c <RIL_NW_GetIpStatusByName+0x24>
    {
        ipSts = GPRS_CONTEXT_DEACT;
102cb574:	e3a00009 	mov	r0, #9
102cb578:	e8bd8070 	pop	{r4, r5, r6, pc}
102cb57c:	102e5884 	.word	0x102e5884
102cb580:	102ee570 	.word	0x102ee570
102cb584:	102ee57c 	.word	0x102ee57c
102cb588:	102ee588 	.word	0x102ee588
102cb58c:	102ee594 	.word	0x102ee594
102cb590:	102ee59c 	.word	0x102ee59c
102cb594:	102ee5a8 	.word	0x102ee5a8
102cb598:	102ee5b4 	.word	0x102ee5b4
102cb59c:	102ee5c4 	.word	0x102ee5c4
102cb5a0:	102ee5d4 	.word	0x102ee5d4
102cb5a4:	102ee5e0 	.word	0x102ee5e0
102cb5a8:	102ee5ec 	.word	0x102ee5ec

102cb5ac <ATResponse_IPStatus_Handler>:
    }
    return ipSts;
}
static s32 ATResponse_IPStatus_Handler(char* line, u32 len, void* userdata)
{
102cb5ac:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    s32 *result = (s32 *)userdata;
    char *head = Ql_RIL_FindString(line, len, "\r\nSTATE:"); //continue wait
102cb5b0:	e59f30ec 	ldr	r3, [pc, #236]	; 102cb6a4 <ATResponse_IPStatus_Handler+0xf8>
        ipSts = GPRS_CONTEXT_DEACT;
    }
    return ipSts;
}
static s32 ATResponse_IPStatus_Handler(char* line, u32 len, void* userdata)
{
102cb5b4:	e24dd020 	sub	sp, sp, #32
102cb5b8:	e1a07002 	mov	r7, r2
    s32 *result = (s32 *)userdata;
    char *head = Ql_RIL_FindString(line, len, "\r\nSTATE:"); //continue wait
102cb5bc:	e59f20e4 	ldr	r2, [pc, #228]	; 102cb6a8 <ATResponse_IPStatus_Handler+0xfc>
        ipSts = GPRS_CONTEXT_DEACT;
    }
    return ipSts;
}
static s32 ATResponse_IPStatus_Handler(char* line, u32 len, void* userdata)
{
102cb5c0:	e1a06000 	mov	r6, r0
102cb5c4:	e1a04001 	mov	r4, r1
    s32 *result = (s32 *)userdata;
    char *head = Ql_RIL_FindString(line, len, "\r\nSTATE:"); //continue wait
102cb5c8:	e12fff33 	blx	r3
    if(head)
102cb5cc:	e2505000 	subs	r5, r0, #0
102cb5d0:	0a000023 	beq	102cb664 <ATResponse_IPStatus_Handler+0xb8>
    {
        char str[30] = {0};
102cb5d4:	e3a03000 	mov	r3, #0
        char *p = NULL;
        char *q = NULL; 
        p = head + Ql_strlen("\r\nSTATE:");
102cb5d8:	e59f00c8 	ldr	r0, [pc, #200]	; 102cb6a8 <ATResponse_IPStatus_Handler+0xfc>
102cb5dc:	e59f60c8 	ldr	r6, [pc, #200]	; 102cb6ac <ATResponse_IPStatus_Handler+0x100>
{
    s32 *result = (s32 *)userdata;
    char *head = Ql_RIL_FindString(line, len, "\r\nSTATE:"); //continue wait
    if(head)
    {
        char str[30] = {0};
102cb5e0:	e58d3000 	str	r3, [sp]
102cb5e4:	e58d3004 	str	r3, [sp, #4]
102cb5e8:	e58d3008 	str	r3, [sp, #8]
102cb5ec:	e58d300c 	str	r3, [sp, #12]
102cb5f0:	e58d3010 	str	r3, [sp, #16]
102cb5f4:	e58d3014 	str	r3, [sp, #20]
102cb5f8:	e58d3018 	str	r3, [sp, #24]
102cb5fc:	e1cd31bc 	strh	r3, [sp, #28]
        char *p = NULL;
        char *q = NULL; 
        p = head + Ql_strlen("\r\nSTATE:");
102cb600:	e12fff36 	blx	r6
        q = Ql_strstr(p,"\r\n");
102cb604:	e59f10a4 	ldr	r1, [pc, #164]	; 102cb6b0 <ATResponse_IPStatus_Handler+0x104>
102cb608:	e59f30a4 	ldr	r3, [pc, #164]	; 102cb6b4 <ATResponse_IPStatus_Handler+0x108>
        if (p)
        {
            Ql_memcpy(str, p, q - p);
102cb60c:	e1a0400d 	mov	r4, sp
    if(head)
    {
        char str[30] = {0};
        char *p = NULL;
        char *q = NULL; 
        p = head + Ql_strlen("\r\nSTATE:");
102cb610:	e0855000 	add	r5, r5, r0
        q = Ql_strstr(p,"\r\n");
102cb614:	e1a00005 	mov	r0, r5
102cb618:	e12fff33 	blx	r3
        if (p)
102cb61c:	e3550000 	cmp	r5, #0
    {
        char str[30] = {0};
        char *p = NULL;
        char *q = NULL; 
        p = head + Ql_strlen("\r\nSTATE:");
        q = Ql_strstr(p,"\r\n");
102cb620:	e1a02000 	mov	r2, r0
        if (p)
102cb624:	0a000004 	beq	102cb63c <ATResponse_IPStatus_Handler+0x90>
        {
            Ql_memcpy(str, p, q - p);
102cb628:	e1a01005 	mov	r1, r5
102cb62c:	e1a0000d 	mov	r0, sp
102cb630:	e0652002 	rsb	r2, r5, r2
102cb634:	e59f307c 	ldr	r3, [pc, #124]	; 102cb6b8 <ATResponse_IPStatus_Handler+0x10c>
102cb638:	e12fff33 	blx	r3
        }
        
        *result = RIL_NW_GetIpStatusByName(str, Ql_strlen(str));
102cb63c:	e1a0000d 	mov	r0, sp
102cb640:	e12fff36 	blx	r6
102cb644:	e1a01000 	mov	r1, r0
102cb648:	e1a0000d 	mov	r0, sp
102cb64c:	ebffff71 	bl	102cb418 <RIL_NW_GetIpStatusByName>
        return  RIL_ATRSP_SUCCESS;
102cb650:	e3a03000 	mov	r3, #0
        if (p)
        {
            Ql_memcpy(str, p, q - p);
        }
        
        *result = RIL_NW_GetIpStatusByName(str, Ql_strlen(str));
102cb654:	e5870000 	str	r0, [r7]
        *result = IP_INITIAL;
        return  RIL_ATRSP_FAILED;
    } 

    return RIL_ATRSP_FAILED; //not supported
}
102cb658:	e1a00003 	mov	r0, r3
102cb65c:	e28dd020 	add	sp, sp, #32
102cb660:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        
        *result = RIL_NW_GetIpStatusByName(str, Ql_strlen(str));
        return  RIL_ATRSP_SUCCESS;
    }

    head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cb664:	e1a00006 	mov	r0, r6
102cb668:	e1a01004 	mov	r1, r4
102cb66c:	e59f2048 	ldr	r2, [pc, #72]	; 102cb6bc <ATResponse_IPStatus_Handler+0x110>
102cb670:	e59f5048 	ldr	r5, [pc, #72]	; 102cb6c0 <ATResponse_IPStatus_Handler+0x114>
102cb674:	e12fff35 	blx	r5
    if(head)
102cb678:	e2508000 	subs	r8, r0, #0
    {  
       return  RIL_ATRSP_CONTINUE;
102cb67c:	13a03001 	movne	r3, #1
        *result = RIL_NW_GetIpStatusByName(str, Ql_strlen(str));
        return  RIL_ATRSP_SUCCESS;
    }

    head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
    if(head)
102cb680:	1afffff4 	bne	102cb658 <ATResponse_IPStatus_Handler+0xac>
    {  
       return  RIL_ATRSP_CONTINUE;
    }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102cb684:	e1a00006 	mov	r0, r6
102cb688:	e1a01004 	mov	r1, r4
102cb68c:	e59f2030 	ldr	r2, [pc, #48]	; 102cb6c4 <ATResponse_IPStatus_Handler+0x118>
102cb690:	e12fff35 	blx	r5
    {  
        *result = IP_INITIAL;
        return  RIL_ATRSP_FAILED;
    } 

    return RIL_ATRSP_FAILED; //not supported
102cb694:	e3e03000 	mvn	r3, #0
    {  
       return  RIL_ATRSP_CONTINUE;
    }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if(head)
102cb698:	e3500000 	cmp	r0, #0
    {  
        *result = IP_INITIAL;
102cb69c:	15878000 	strne	r8, [r7]
102cb6a0:	eaffffec 	b	102cb658 <ATResponse_IPStatus_Handler+0xac>
102cb6a4:	102cce98 	.word	0x102cce98
102cb6a8:	102ee5f8 	.word	0x102ee5f8
102cb6ac:	102e57a4 	.word	0x102e57a4
102cb6b0:	102ee78c 	.word	0x102ee78c
102cb6b4:	102e5a04 	.word	0x102e5a04
102cb6b8:	102e597c 	.word	0x102e597c
102cb6bc:	102ee5e8 	.word	0x102ee5e8
102cb6c0:	102ccf24 	.word	0x102ccf24
102cb6c4:	102ede00 	.word	0x102ede00

102cb6c8 <RIL_NW_GetIPStatus>:

    return RIL_ATRSP_FAILED; //not supported
}

s32  RIL_NW_GetIPStatus(void)
{
102cb6c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102cb6cc:	e24dd014 	sub	sp, sp, #20
    s32 retRes;
    s32 ip_status = IP_INITIAL;
102cb6d0:	e3a02000 	mov	r2, #0
102cb6d4:	e28d3010 	add	r3, sp, #16
102cb6d8:	e5232004 	str	r2, [r3, #-4]!
    retRes = Ql_RIL_SendATCmd("AT+QISTAT\0", 10, ATResponse_IPStatus_Handler, &ip_status, 0);
102cb6dc:	e3a0100a 	mov	r1, #10
102cb6e0:	e58d2000 	str	r2, [sp]
102cb6e4:	e59fc018 	ldr	ip, [pc, #24]	; 102cb704 <RIL_NW_GetIPStatus+0x3c>
102cb6e8:	e59f2018 	ldr	r2, [pc, #24]	; 102cb708 <RIL_NW_GetIPStatus+0x40>
102cb6ec:	e59f0018 	ldr	r0, [pc, #24]	; 102cb70c <RIL_NW_GetIPStatus+0x44>
102cb6f0:	e12fff3c 	blx	ip
    if (RIL_AT_SUCCESS == retRes)
102cb6f4:	e3500000 	cmp	r0, #0
    {
        return ip_status;
102cb6f8:	059d000c 	ldreq	r0, [sp, #12]
    }else{
        return retRes;
    }
}
102cb6fc:	e28dd014 	add	sp, sp, #20
102cb700:	e8bd8000 	ldmfd	sp!, {pc}
102cb704:	102e5168 	.word	0x102e5168
102cb708:	102cb5ac 	.word	0x102cb5ac
102cb70c:	102e6658 	.word	0x102e6658

102cb710 <RIL_NW_OpenPDPContext>:
//
// This function activates pdp context for AT command mode.
s32  RIL_NW_OpenPDPContext(void)
{
102cb710:	e92d4070 	push	{r4, r5, r6, lr}
    s32 retRes;
    char strAT[20];
    u32  strATLen;
    
    strATLen = Ql_sprintf(strAT, "AT+QIREGAPP\0");
102cb714:	e59f608c 	ldr	r6, [pc, #140]	; 102cb7a8 <RIL_NW_OpenPDPContext+0x98>
    }
}
//
// This function activates pdp context for AT command mode.
s32  RIL_NW_OpenPDPContext(void)
{
102cb718:	e24dd020 	sub	sp, sp, #32
    s32 retRes;
    char strAT[20];
    u32  strATLen;
    
    strATLen = Ql_sprintf(strAT, "AT+QIREGAPP\0");
102cb71c:	e59f1088 	ldr	r1, [pc, #136]	; 102cb7ac <RIL_NW_OpenPDPContext+0x9c>
102cb720:	e5963000 	ldr	r3, [r6]
102cb724:	e28d000c 	add	r0, sp, #12
102cb728:	e12fff33 	blx	r3
    retRes = Ql_RIL_SendATCmd(strAT, strATLen ,NULL, NULL, 0);
102cb72c:	e3a03000 	mov	r3, #0
102cb730:	e1a02003 	mov	r2, r3
102cb734:	e58d3000 	str	r3, [sp]
102cb738:	e59f5070 	ldr	r5, [pc, #112]	; 102cb7b0 <RIL_NW_OpenPDPContext+0xa0>
{
    s32 retRes;
    char strAT[20];
    u32  strATLen;
    
    strATLen = Ql_sprintf(strAT, "AT+QIREGAPP\0");
102cb73c:	e1a01000 	mov	r1, r0
    retRes = Ql_RIL_SendATCmd(strAT, strATLen ,NULL, NULL, 0);
102cb740:	e28d000c 	add	r0, sp, #12
102cb744:	e12fff35 	blx	r5
    if (RIL_AT_SUCCESS != retRes)
102cb748:	e2504000 	subs	r4, r0, #0
102cb74c:	1a000012 	bne	102cb79c <RIL_NW_OpenPDPContext+0x8c>
    {
        return retRes;
    }
    
    Ql_Sleep(100);  // Wait for the QISTAT state changing to "IP start"
102cb750:	e3a00064 	mov	r0, #100	; 0x64
102cb754:	e59f3058 	ldr	r3, [pc, #88]	; 102cb7b4 <RIL_NW_OpenPDPContext+0xa4>
102cb758:	e12fff33 	blx	r3

    // AT+QIACT
    Ql_memset(strAT, 0, sizeof(strAT));
102cb75c:	e1a01004 	mov	r1, r4
102cb760:	e3a02014 	mov	r2, #20
102cb764:	e59f304c 	ldr	r3, [pc, #76]	; 102cb7b8 <RIL_NW_OpenPDPContext+0xa8>
102cb768:	e28d000c 	add	r0, sp, #12
102cb76c:	e12fff33 	blx	r3
    strATLen = Ql_sprintf(strAT, "AT+QIACT\0");
102cb770:	e59f1044 	ldr	r1, [pc, #68]	; 102cb7bc <RIL_NW_OpenPDPContext+0xac>
102cb774:	e5963000 	ldr	r3, [r6]
102cb778:	e28d000c 	add	r0, sp, #12
102cb77c:	e12fff33 	blx	r3
    retRes = Ql_RIL_SendATCmd(strAT, strATLen, NULL, NULL, 0);
102cb780:	e1a02004 	mov	r2, r4
102cb784:	e58d4000 	str	r4, [sp]
102cb788:	e1a03004 	mov	r3, r4
    
    Ql_Sleep(100);  // Wait for the QISTAT state changing to "IP start"

    // AT+QIACT
    Ql_memset(strAT, 0, sizeof(strAT));
    strATLen = Ql_sprintf(strAT, "AT+QIACT\0");
102cb78c:	e1a01000 	mov	r1, r0
    retRes = Ql_RIL_SendATCmd(strAT, strATLen, NULL, NULL, 0);
102cb790:	e28d000c 	add	r0, sp, #12
102cb794:	e12fff35 	blx	r5
102cb798:	e1a04000 	mov	r4, r0
    return retRes;
}
102cb79c:	e1a00004 	mov	r0, r4
102cb7a0:	e28dd020 	add	sp, sp, #32
102cb7a4:	e8bd8070 	pop	{r4, r5, r6, pc}
102cb7a8:	f03de540 	.word	0xf03de540
102cb7ac:	102e6664 	.word	0x102e6664
102cb7b0:	102e5168 	.word	0x102e5168
102cb7b4:	102e5b10 	.word	0x102e5b10
102cb7b8:	102e58f4 	.word	0x102e58f4
102cb7bc:	102e6674 	.word	0x102e6674

102cb7c0 <RIL_NW_ClosePDPContext>:
    return RIL_ATRSP_CONTINUE; //continue wait
}

s32 RIL_NW_ClosePDPContext(void)
{
    char strAT[20] = "AT+QIDEACT\0";
102cb7c0:	e59f204c 	ldr	r2, [pc, #76]	; 102cb814 <RIL_NW_ClosePDPContext+0x54>
    }
    return RIL_ATRSP_CONTINUE; //continue wait
}

s32 RIL_NW_ClosePDPContext(void)
{
102cb7c4:	e92d4010 	push	{r4, lr}
    char strAT[20] = "AT+QIDEACT\0";
102cb7c8:	e8920007 	ldm	r2, {r0, r1, r2}
    }
    return RIL_ATRSP_CONTINUE; //continue wait
}

s32 RIL_NW_ClosePDPContext(void)
{
102cb7cc:	e24dd020 	sub	sp, sp, #32
    char strAT[20] = "AT+QIDEACT\0";
102cb7d0:	e28d300c 	add	r3, sp, #12
102cb7d4:	e3a04000 	mov	r4, #0
102cb7d8:	e8830007 	stm	r3, {r0, r1, r2}
    return Ql_RIL_SendATCmd("AT+QIDEACT\n", Ql_strlen(strAT), ATRsp_QIDEACT_Hdlr, NULL, 0);
102cb7dc:	e1a00003 	mov	r0, r3
102cb7e0:	e59f3030 	ldr	r3, [pc, #48]	; 102cb818 <RIL_NW_ClosePDPContext+0x58>
    return RIL_ATRSP_CONTINUE; //continue wait
}

s32 RIL_NW_ClosePDPContext(void)
{
    char strAT[20] = "AT+QIDEACT\0";
102cb7e4:	e58d4018 	str	r4, [sp, #24]
102cb7e8:	e58d401c 	str	r4, [sp, #28]
    return Ql_RIL_SendATCmd("AT+QIDEACT\n", Ql_strlen(strAT), ATRsp_QIDEACT_Hdlr, NULL, 0);
102cb7ec:	e12fff33 	blx	r3
102cb7f0:	e58d4000 	str	r4, [sp]
102cb7f4:	e59f2020 	ldr	r2, [pc, #32]	; 102cb81c <RIL_NW_ClosePDPContext+0x5c>
102cb7f8:	e1a03004 	mov	r3, r4
102cb7fc:	e59fc01c 	ldr	ip, [pc, #28]	; 102cb820 <RIL_NW_ClosePDPContext+0x60>
102cb800:	e1a01000 	mov	r1, r0
102cb804:	e59f0018 	ldr	r0, [pc, #24]	; 102cb824 <RIL_NW_ClosePDPContext+0x64>
102cb808:	e12fff3c 	blx	ip
}
102cb80c:	e28dd020 	add	sp, sp, #32
102cb810:	e8bd8010 	pop	{r4, pc}
102cb814:	102e6680 	.word	0x102e6680
102cb818:	102e57a4 	.word	0x102e57a4
102cb81c:	102cae50 	.word	0x102cae50
102cb820:	102e5168 	.word	0x102e5168
102cb824:	102ee604 	.word	0x102ee604

102cb828 <RIL_NW_GetOperator>:
    return RIL_ATRSP_CONTINUE; //continue wait
}

s32 RIL_NW_GetOperator(char* operator)
{
    char strAT[] = "AT+COPS?\0";
102cb828:	e59f205c 	ldr	r2, [pc, #92]	; 102cb88c <RIL_NW_GetOperator+0x64>

    return RIL_ATRSP_CONTINUE; //continue wait
}

s32 RIL_NW_GetOperator(char* operator)
{
102cb82c:	e92d4010 	push	{r4, lr}
102cb830:	e1a04000 	mov	r4, r0
    char strAT[] = "AT+COPS?\0";
102cb834:	e8920007 	ldm	r2, {r0, r1, r2}

    return RIL_ATRSP_CONTINUE; //continue wait
}

s32 RIL_NW_GetOperator(char* operator)
{
102cb838:	e24dd018 	sub	sp, sp, #24
    char strAT[] = "AT+COPS?\0";
102cb83c:	e28dc00c 	add	ip, sp, #12
    if (NULL == operator)
102cb840:	e3540000 	cmp	r4, #0
    return RIL_ATRSP_CONTINUE; //continue wait
}

s32 RIL_NW_GetOperator(char* operator)
{
    char strAT[] = "AT+COPS?\0";
102cb844:	e8ac0003 	stmia	ip!, {r0, r1}
102cb848:	e1cc20b0 	strh	r2, [ip]
    if (NULL == operator)
102cb84c:	0a00000c 	beq	102cb884 <RIL_NW_GetOperator+0x5c>
    {
        return RIL_AT_INVALID_PARAM;
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_COPS_Handler,(void*)operator, 0);
102cb850:	e59f3038 	ldr	r3, [pc, #56]	; 102cb890 <RIL_NW_GetOperator+0x68>
102cb854:	e28d000c 	add	r0, sp, #12
102cb858:	e12fff33 	blx	r3
102cb85c:	e3a03000 	mov	r3, #0
102cb860:	e58d3000 	str	r3, [sp]
102cb864:	e59f2028 	ldr	r2, [pc, #40]	; 102cb894 <RIL_NW_GetOperator+0x6c>
102cb868:	e1a03004 	mov	r3, r4
102cb86c:	e59fc024 	ldr	ip, [pc, #36]	; 102cb898 <RIL_NW_GetOperator+0x70>
102cb870:	e1a01000 	mov	r1, r0
102cb874:	e28d000c 	add	r0, sp, #12
102cb878:	e12fff3c 	blx	ip
}
102cb87c:	e28dd018 	add	sp, sp, #24
102cb880:	e8bd8010 	pop	{r4, pc}
s32 RIL_NW_GetOperator(char* operator)
{
    char strAT[] = "AT+COPS?\0";
    if (NULL == operator)
    {
        return RIL_AT_INVALID_PARAM;
102cb884:	e3e00003 	mvn	r0, #3
102cb888:	eafffffb 	b	102cb87c <RIL_NW_GetOperator+0x54>
102cb88c:	102e6694 	.word	0x102e6694
102cb890:	102e57a4 	.word	0x102e57a4
102cb894:	102cad2c 	.word	0x102cad2c
102cb898:	102e5168 	.word	0x102e5168

102cb89c <ATResponse_SPN_Handler>:
 *  Function get service provider name
 */


static s32 ATResponse_SPN_Handler(char* line, u32 len, void* userdata)
{
102cb89c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102cb8a0:	e1a04002 	mov	r4, r2
	ST_SPN_Reponse *SPN_Reponse = (ST_SPN_Reponse*)userdata;

	    char *head = Ql_RIL_FindString(line, len, "+QSPN:"); //continue wait
102cb8a4:	e59f50f4 	ldr	r5, [pc, #244]	; 102cb9a0 <ATResponse_SPN_Handler+0x104>
102cb8a8:	e59f20f4 	ldr	r2, [pc, #244]	; 102cb9a4 <ATResponse_SPN_Handler+0x108>
 *  Function get service provider name
 */


static s32 ATResponse_SPN_Handler(char* line, u32 len, void* userdata)
{
102cb8ac:	e1a08000 	mov	r8, r0
102cb8b0:	e1a07001 	mov	r7, r1
	ST_SPN_Reponse *SPN_Reponse = (ST_SPN_Reponse*)userdata;

	    char *head = Ql_RIL_FindString(line, len, "+QSPN:"); //continue wait
102cb8b4:	e12fff35 	blx	r5
	    if(head)
102cb8b8:	e2506000 	subs	r6, r0, #0
102cb8bc:	0a00001e 	beq	102cb93c <ATResponse_SPN_Handler+0xa0>
	    {
	        Ql_sscanf(head,"%*[^ ]%s,%[^ \r\n]",&SPN_Reponse->servideprovider);
102cb8c0:	e59f30e0 	ldr	r3, [pc, #224]	; 102cb9a8 <ATResponse_SPN_Handler+0x10c>
102cb8c4:	e1a02004 	mov	r2, r4
102cb8c8:	e59f10dc 	ldr	r1, [pc, #220]	; 102cb9ac <ATResponse_SPN_Handler+0x110>
102cb8cc:	e5933000 	ldr	r3, [r3]
102cb8d0:	e12fff33 	blx	r3
	        char *token = strtok(&SPN_Reponse->servideprovider, "\"");
102cb8d4:	e1a00004 	mov	r0, r4
102cb8d8:	e59f10d0 	ldr	r1, [pc, #208]	; 102cb9b0 <ATResponse_SPN_Handler+0x114>
102cb8dc:	e59f30d0 	ldr	r3, [pc, #208]	; 102cb9b4 <ATResponse_SPN_Handler+0x118>
102cb8e0:	e12fff33 	blx	r3
	        APP_DEBUG("<-- SPN = %s  %s  -->\r\n",SPN_Reponse->servideprovider,head);	//ssid
102cb8e4:	e3a01000 	mov	r1, #0
102cb8e8:	e3a02c02 	mov	r2, #512	; 0x200
102cb8ec:	e59f30c4 	ldr	r3, [pc, #196]	; 102cb9b8 <ATResponse_SPN_Handler+0x11c>
102cb8f0:	e59f00c4 	ldr	r0, [pc, #196]	; 102cb9bc <ATResponse_SPN_Handler+0x120>
102cb8f4:	e12fff33 	blx	r3
102cb8f8:	e59f00c0 	ldr	r0, [pc, #192]	; 102cb9c0 <ATResponse_SPN_Handler+0x124>
102cb8fc:	e1a02004 	mov	r2, r4
102cb900:	e590c000 	ldr	ip, [r0]
102cb904:	e59f10b8 	ldr	r1, [pc, #184]	; 102cb9c4 <ATResponse_SPN_Handler+0x128>
102cb908:	e1a03006 	mov	r3, r6
102cb90c:	e59f00a8 	ldr	r0, [pc, #168]	; 102cb9bc <ATResponse_SPN_Handler+0x120>
102cb910:	e12fff3c 	blx	ip
102cb914:	e59f30ac 	ldr	r3, [pc, #172]	; 102cb9c8 <ATResponse_SPN_Handler+0x12c>
102cb918:	e59f009c 	ldr	r0, [pc, #156]	; 102cb9bc <ATResponse_SPN_Handler+0x120>
102cb91c:	e12fff33 	blx	r3
102cb920:	e59f1094 	ldr	r1, [pc, #148]	; 102cb9bc <ATResponse_SPN_Handler+0x120>
102cb924:	e59f30a0 	ldr	r3, [pc, #160]	; 102cb9cc <ATResponse_SPN_Handler+0x130>
102cb928:	e1a02000 	mov	r2, r0
102cb92c:	e3a0000a 	mov	r0, #10
102cb930:	e12fff33 	blx	r3
	        return  RIL_ATRSP_CONTINUE;
102cb934:	e3a00001 	mov	r0, #1
102cb938:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	    }

	    head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cb93c:	e1a00008 	mov	r0, r8
102cb940:	e1a01007 	mov	r1, r7
102cb944:	e59f2084 	ldr	r2, [pc, #132]	; 102cb9d0 <ATResponse_SPN_Handler+0x134>
102cb948:	e59f4084 	ldr	r4, [pc, #132]	; 102cb9d4 <ATResponse_SPN_Handler+0x138>
102cb94c:	e12fff34 	blx	r4
	    if(head)
102cb950:	e3500000 	cmp	r0, #0
102cb954:	0a000001 	beq	102cb960 <ATResponse_SPN_Handler+0xc4>
	    {
	        return  RIL_ATRSP_SUCCESS;
102cb958:	e1a00006 	mov	r0, r6
	    {
	        return  RIL_ATRSP_FAILED;
	    }

	    return RIL_ATRSP_CONTINUE; //continue wait
}
102cb95c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	    if(head)
	    {
	        return  RIL_ATRSP_SUCCESS;
	    }

	    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102cb960:	e1a00008 	mov	r0, r8
102cb964:	e1a01007 	mov	r1, r7
102cb968:	e59f2068 	ldr	r2, [pc, #104]	; 102cb9d8 <ATResponse_SPN_Handler+0x13c>
102cb96c:	e12fff34 	blx	r4
	    if(head)
102cb970:	e3500000 	cmp	r0, #0
102cb974:	1a000007 	bne	102cb998 <ATResponse_SPN_Handler+0xfc>
	    {
	        return  RIL_ATRSP_FAILED;
	    }

	    head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102cb978:	e1a00008 	mov	r0, r8
102cb97c:	e1a01007 	mov	r1, r7
102cb980:	e59f2054 	ldr	r2, [pc, #84]	; 102cb9dc <ATResponse_SPN_Handler+0x140>
102cb984:	e12fff35 	blx	r5
	    if(head)
102cb988:	e3500000 	cmp	r0, #0
102cb98c:	1a000001 	bne	102cb998 <ATResponse_SPN_Handler+0xfc>
	    {
	        return  RIL_ATRSP_FAILED;
	    }

	    return RIL_ATRSP_CONTINUE; //continue wait
102cb990:	e3a00001 	mov	r0, #1
102cb994:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	    }

	    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
	    if(head)
	    {
	        return  RIL_ATRSP_FAILED;
102cb998:	e3e00000 	mvn	r0, #0
102cb99c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102cb9a0:	102cce98 	.word	0x102cce98
102cb9a4:	102ee610 	.word	0x102ee610
102cb9a8:	f03de548 	.word	0xf03de548
102cb9ac:	102ee618 	.word	0x102ee618
102cb9b0:	102ee03c 	.word	0x102ee03c
102cb9b4:	102e0f79 	.word	0x102e0f79
102cb9b8:	102e58f4 	.word	0x102e58f4
102cb9bc:	f03d5320 	.word	0xf03d5320
102cb9c0:	f03de540 	.word	0xf03de540
102cb9c4:	102ee62c 	.word	0x102ee62c
102cb9c8:	102e57a4 	.word	0x102e57a4
102cb9cc:	102e6230 	.word	0x102e6230
102cb9d0:	102ee5e8 	.word	0x102ee5e8
102cb9d4:	102ccf24 	.word	0x102ccf24
102cb9d8:	102ede00 	.word	0x102ede00
102cb9dc:	102ede08 	.word	0x102ede08

102cb9e0 <ATRsp_CCID_Handler>:
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_IMSI_Handler,(void*)imsi, 0);
}

static s32 ATRsp_CCID_Handler(char* line, u32 len, void* param)
{
102cb9e0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102cb9e4:	e1a05002 	mov	r5, r2
    char* pHead = Ql_RIL_FindString(line, len, "+CCID:");
102cb9e8:	e59f4094 	ldr	r4, [pc, #148]	; 102cba84 <ATRsp_CCID_Handler+0xa4>
102cb9ec:	e59f2094 	ldr	r2, [pc, #148]	; 102cba88 <ATRsp_CCID_Handler+0xa8>
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_IMSI_Handler,(void*)imsi, 0);
}

static s32 ATRsp_CCID_Handler(char* line, u32 len, void* param)
{
102cb9f0:	e1a07000 	mov	r7, r0
102cb9f4:	e1a06001 	mov	r6, r1
    char* pHead = Ql_RIL_FindString(line, len, "+CCID:");
102cb9f8:	e12fff34 	blx	r4
    if (pHead)
102cb9fc:	e2508000 	subs	r8, r0, #0
102cba00:	0a000006 	beq	102cba20 <ATRsp_CCID_Handler+0x40>
    {
        Ql_sscanf(pHead,"%*[^: \"]: \"%[^\"\r\n]", (char*)param);
102cba04:	e59f3080 	ldr	r3, [pc, #128]	; 102cba8c <ATRsp_CCID_Handler+0xac>
102cba08:	e59f1080 	ldr	r1, [pc, #128]	; 102cba90 <ATRsp_CCID_Handler+0xb0>
102cba0c:	e5933000 	ldr	r3, [r3]
102cba10:	e1a02005 	mov	r2, r5
102cba14:	e12fff33 	blx	r3
        return  RIL_ATRSP_CONTINUE; // wait for OK
102cba18:	e3a00001 	mov	r0, #1
102cba1c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cba20:	e1a00007 	mov	r0, r7
102cba24:	e1a01006 	mov	r1, r6
102cba28:	e59f2064 	ldr	r2, [pc, #100]	; 102cba94 <ATRsp_CCID_Handler+0xb4>
102cba2c:	e59f5064 	ldr	r5, [pc, #100]	; 102cba98 <ATRsp_CCID_Handler+0xb8>
102cba30:	e12fff35 	blx	r5
    if (pHead)
102cba34:	e3500000 	cmp	r0, #0
102cba38:	0a000001 	beq	102cba44 <ATRsp_CCID_Handler+0x64>
    {  
        return RIL_ATRSP_SUCCESS;
102cba3c:	e1a00008 	mov	r0, r8
102cba40:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102cba44:	e1a00007 	mov	r0, r7
102cba48:	e1a01006 	mov	r1, r6
102cba4c:	e59f2048 	ldr	r2, [pc, #72]	; 102cba9c <ATRsp_CCID_Handler+0xbc>
102cba50:	e12fff35 	blx	r5
    if (pHead)
102cba54:	e3500000 	cmp	r0, #0
102cba58:	1a000007 	bne	102cba7c <ATRsp_CCID_Handler+0x9c>
    {  
        return RIL_ATRSP_FAILED;
    } 

    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102cba5c:	e1a00007 	mov	r0, r7
102cba60:	e1a01006 	mov	r1, r6
102cba64:	e59f2034 	ldr	r2, [pc, #52]	; 102cbaa0 <ATRsp_CCID_Handler+0xc0>
102cba68:	e12fff34 	blx	r4
    if (pHead)
102cba6c:	e3500000 	cmp	r0, #0
    {
        return RIL_ATRSP_FAILED;
102cba70:	03a00001 	moveq	r0, #1
102cba74:	13e00000 	mvnne	r0, #0
102cba78:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return RIL_ATRSP_FAILED;
102cba7c:	e3e00000 	mvn	r0, #0
    {
        return RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
102cba80:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102cba84:	102cce98 	.word	0x102cce98
102cba88:	102ee644 	.word	0x102ee644
102cba8c:	f03de548 	.word	0xf03de548
102cba90:	102ee64c 	.word	0x102ee64c
102cba94:	102ee5e8 	.word	0x102ee5e8
102cba98:	102ccf24 	.word	0x102ccf24
102cba9c:	102ede00 	.word	0x102ede00
102cbaa0:	102ede08 	.word	0x102ede08

102cbaa4 <ATRsp_IMSI_Handler>:
    }
    return retRes;
}

static s32 ATRsp_IMSI_Handler(char* line, u32 len, void* param)
{
102cbaa4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102cbaa8:	e1a07002 	mov	r7, r2
    char* pHead = NULL;
    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cbaac:	e59f4074 	ldr	r4, [pc, #116]	; 102cbb28 <ATRsp_IMSI_Handler+0x84>
102cbab0:	e59f2074 	ldr	r2, [pc, #116]	; 102cbb2c <ATRsp_IMSI_Handler+0x88>
    }
    return retRes;
}

static s32 ATRsp_IMSI_Handler(char* line, u32 len, void* param)
{
102cbab4:	e1a06000 	mov	r6, r0
102cbab8:	e1a05001 	mov	r5, r1
    char* pHead = NULL;
    pHead = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cbabc:	e12fff34 	blx	r4
    if (pHead)
102cbac0:	e3500000 	cmp	r0, #0
102cbac4:	0a000001 	beq	102cbad0 <ATRsp_IMSI_Handler+0x2c>
    {  
        return RIL_ATRSP_SUCCESS;
102cbac8:	e3a00000 	mov	r0, #0
102cbacc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102cbad0:	e1a00006 	mov	r0, r6
102cbad4:	e1a01005 	mov	r1, r5
102cbad8:	e59f2050 	ldr	r2, [pc, #80]	; 102cbb30 <ATRsp_IMSI_Handler+0x8c>
102cbadc:	e12fff34 	blx	r4
    if (pHead)
102cbae0:	e3500000 	cmp	r0, #0
102cbae4:	1a00000d 	bne	102cbb20 <ATRsp_IMSI_Handler+0x7c>
    {  
        return RIL_ATRSP_FAILED;
    } 

    pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102cbae8:	e1a00006 	mov	r0, r6
102cbaec:	e1a01005 	mov	r1, r5
102cbaf0:	e59f203c 	ldr	r2, [pc, #60]	; 102cbb34 <ATRsp_IMSI_Handler+0x90>
102cbaf4:	e59f303c 	ldr	r3, [pc, #60]	; 102cbb38 <ATRsp_IMSI_Handler+0x94>
102cbaf8:	e12fff33 	blx	r3
    if (pHead)
102cbafc:	e3500000 	cmp	r0, #0
102cbb00:	1a000006 	bne	102cbb20 <ATRsp_IMSI_Handler+0x7c>
    {
        return RIL_ATRSP_FAILED;
    }
    Ql_memcpy((char*)param, line, len - 2); // <imsi number>\r\n
102cbb04:	e1a00007 	mov	r0, r7
102cbb08:	e1a01006 	mov	r1, r6
102cbb0c:	e2452002 	sub	r2, r5, #2
102cbb10:	e59f3024 	ldr	r3, [pc, #36]	; 102cbb3c <ATRsp_IMSI_Handler+0x98>
102cbb14:	e12fff33 	blx	r3
    return RIL_ATRSP_CONTINUE; //continue wait
102cbb18:	e3a00001 	mov	r0, #1
102cbb1c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    }

    pHead = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
    if (pHead)
    {  
        return RIL_ATRSP_FAILED;
102cbb20:	e3e00000 	mvn	r0, #0
    {
        return RIL_ATRSP_FAILED;
    }
    Ql_memcpy((char*)param, line, len - 2); // <imsi number>\r\n
    return RIL_ATRSP_CONTINUE; //continue wait
}
102cbb24:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102cbb28:	102ccf24 	.word	0x102ccf24
102cbb2c:	102ee5e8 	.word	0x102ee5e8
102cbb30:	102ede00 	.word	0x102ede00
102cbb34:	102ede08 	.word	0x102ede08
102cbb38:	102cce98 	.word	0x102cce98
102cbb3c:	102e597c 	.word	0x102e597c

102cbb40 <RIL_SIM_GetSimStateByName>:
#ifdef __OCPU_RIL_SUPPORT__



s32 RIL_SIM_GetSimStateByName(char* simStat, u32 len)
{
102cbb40:	e92d4070 	push	{r4, r5, r6, lr}
    s32 ss = SIM_STAT_UNSPECIFIED;
    if (Ql_strncmp(simStat, "READY", len) == 0)
102cbb44:	e1a02001 	mov	r2, r1
#ifdef __OCPU_RIL_SUPPORT__



s32 RIL_SIM_GetSimStateByName(char* simStat, u32 len)
{
102cbb48:	e1a05001 	mov	r5, r1
    s32 ss = SIM_STAT_UNSPECIFIED;
    if (Ql_strncmp(simStat, "READY", len) == 0)
102cbb4c:	e59f4130 	ldr	r4, [pc, #304]	; 102cbc84 <RIL_SIM_GetSimStateByName+0x144>
102cbb50:	e59f1130 	ldr	r1, [pc, #304]	; 102cbc88 <RIL_SIM_GetSimStateByName+0x148>
#ifdef __OCPU_RIL_SUPPORT__



s32 RIL_SIM_GetSimStateByName(char* simStat, u32 len)
{
102cbb54:	e1a06000 	mov	r6, r0
    s32 ss = SIM_STAT_UNSPECIFIED;
    if (Ql_strncmp(simStat, "READY", len) == 0)
102cbb58:	e12fff34 	blx	r4
102cbb5c:	e3500000 	cmp	r0, #0
102cbb60:	1a000001 	bne	102cbb6c <RIL_SIM_GetSimStateByName+0x2c>
    {
        ss = SIM_STAT_READY;
102cbb64:	e3a00001 	mov	r0, #1
102cbb68:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(simStat, "NOT INSERTED", len) == 0)
102cbb6c:	e1a00006 	mov	r0, r6
102cbb70:	e59f1114 	ldr	r1, [pc, #276]	; 102cbc8c <RIL_SIM_GetSimStateByName+0x14c>
102cbb74:	e1a02005 	mov	r2, r5
102cbb78:	e12fff34 	blx	r4
102cbb7c:	e3500000 	cmp	r0, #0
102cbb80:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
        ss = SIM_STAT_NOT_INSERTED;
    }
    else if (Ql_strncmp(simStat, "SIM PIN", len) == 0)
102cbb84:	e1a00006 	mov	r0, r6
102cbb88:	e59f1100 	ldr	r1, [pc, #256]	; 102cbc90 <RIL_SIM_GetSimStateByName+0x150>
102cbb8c:	e1a02005 	mov	r2, r5
102cbb90:	e12fff34 	blx	r4
102cbb94:	e3500000 	cmp	r0, #0
102cbb98:	1a000001 	bne	102cbba4 <RIL_SIM_GetSimStateByName+0x64>
    {
        ss = SIM_STAT_PIN_REQ;
102cbb9c:	e3a00002 	mov	r0, #2
102cbba0:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(simStat, "SIM PUK", len) == 0)
102cbba4:	e1a00006 	mov	r0, r6
102cbba8:	e59f10e4 	ldr	r1, [pc, #228]	; 102cbc94 <RIL_SIM_GetSimStateByName+0x154>
102cbbac:	e1a02005 	mov	r2, r5
102cbbb0:	e12fff34 	blx	r4
102cbbb4:	e3500000 	cmp	r0, #0
102cbbb8:	1a000001 	bne	102cbbc4 <RIL_SIM_GetSimStateByName+0x84>
    {
        ss = SIM_STAT_PUK_REQ;
102cbbbc:	e3a00003 	mov	r0, #3
102cbbc0:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(simStat, "PH-SIM PIN", len) == 0)
102cbbc4:	e1a00006 	mov	r0, r6
102cbbc8:	e59f10c8 	ldr	r1, [pc, #200]	; 102cbc98 <RIL_SIM_GetSimStateByName+0x158>
102cbbcc:	e1a02005 	mov	r2, r5
102cbbd0:	e12fff34 	blx	r4
102cbbd4:	e3500000 	cmp	r0, #0
102cbbd8:	1a000001 	bne	102cbbe4 <RIL_SIM_GetSimStateByName+0xa4>
    {
        ss = SIM_STAT_PH_PIN_REQ;
102cbbdc:	e3a00004 	mov	r0, #4
102cbbe0:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(simStat, "PH-SIM PUK", len) == 0)
102cbbe4:	e1a00006 	mov	r0, r6
102cbbe8:	e59f10ac 	ldr	r1, [pc, #172]	; 102cbc9c <RIL_SIM_GetSimStateByName+0x15c>
102cbbec:	e1a02005 	mov	r2, r5
102cbbf0:	e12fff34 	blx	r4
102cbbf4:	e3500000 	cmp	r0, #0
102cbbf8:	1a000001 	bne	102cbc04 <RIL_SIM_GetSimStateByName+0xc4>
    {
        ss = SIM_STAT_PH_PUK_REQ;
102cbbfc:	e3a00005 	mov	r0, #5
102cbc00:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(simStat, "SIM PIN2", len) == 0)
102cbc04:	e1a00006 	mov	r0, r6
102cbc08:	e59f1090 	ldr	r1, [pc, #144]	; 102cbca0 <RIL_SIM_GetSimStateByName+0x160>
102cbc0c:	e1a02005 	mov	r2, r5
102cbc10:	e12fff34 	blx	r4
102cbc14:	e3500000 	cmp	r0, #0
102cbc18:	1a000001 	bne	102cbc24 <RIL_SIM_GetSimStateByName+0xe4>
    {
        ss = SIM_STAT_PIN2_REQ;
102cbc1c:	e3a00006 	mov	r0, #6
102cbc20:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(simStat, "SIM PUK2", len) == 0)
102cbc24:	e1a00006 	mov	r0, r6
102cbc28:	e59f1074 	ldr	r1, [pc, #116]	; 102cbca4 <RIL_SIM_GetSimStateByName+0x164>
102cbc2c:	e1a02005 	mov	r2, r5
102cbc30:	e12fff34 	blx	r4
102cbc34:	e3500000 	cmp	r0, #0
102cbc38:	1a000001 	bne	102cbc44 <RIL_SIM_GetSimStateByName+0x104>
    {
        ss = SIM_STAT_PUK2_REQ;
102cbc3c:	e3a00007 	mov	r0, #7
102cbc40:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(simStat, "SIM BUSY", len) == 0)
102cbc44:	e1a00006 	mov	r0, r6
102cbc48:	e59f1058 	ldr	r1, [pc, #88]	; 102cbca8 <RIL_SIM_GetSimStateByName+0x168>
102cbc4c:	e1a02005 	mov	r2, r5
102cbc50:	e12fff34 	blx	r4
102cbc54:	e3500000 	cmp	r0, #0
102cbc58:	1a000001 	bne	102cbc64 <RIL_SIM_GetSimStateByName+0x124>
    {
        ss = SIM_STAT_BUSY;
102cbc5c:	e3a00008 	mov	r0, #8
    else if (Ql_strncmp(simStat, "NOT READY", len) == 0)
    {
        ss = SIM_STAT_NOT_READY;
    }
    return ss;
}
102cbc60:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else if (Ql_strncmp(simStat, "SIM BUSY", len) == 0)
    {
        ss = SIM_STAT_BUSY;
    }
    else if (Ql_strncmp(simStat, "NOT READY", len) == 0)
102cbc64:	e1a00006 	mov	r0, r6
102cbc68:	e59f103c 	ldr	r1, [pc, #60]	; 102cbcac <RIL_SIM_GetSimStateByName+0x16c>
102cbc6c:	e1a02005 	mov	r2, r5
102cbc70:	e12fff34 	blx	r4



s32 RIL_SIM_GetSimStateByName(char* simStat, u32 len)
{
    s32 ss = SIM_STAT_UNSPECIFIED;
102cbc74:	e3500000 	cmp	r0, #0
102cbc78:	03a00009 	moveq	r0, #9
102cbc7c:	13a0000a 	movne	r0, #10
102cbc80:	e8bd8070 	pop	{r4, r5, r6, pc}
102cbc84:	102e5884 	.word	0x102e5884
102cbc88:	102ee6c0 	.word	0x102ee6c0
102cbc8c:	102ee660 	.word	0x102ee660
102cbc90:	102ee670 	.word	0x102ee670
102cbc94:	102ee678 	.word	0x102ee678
102cbc98:	102ee680 	.word	0x102ee680
102cbc9c:	102ee68c 	.word	0x102ee68c
102cbca0:	102ee698 	.word	0x102ee698
102cbca4:	102ee6a4 	.word	0x102ee6a4
102cbca8:	102ee6b0 	.word	0x102ee6b0
102cbcac:	102ee6bc 	.word	0x102ee6bc

102cbcb0 <ATResponse_CPIN_Handler>:
*               1.Can't send any new AT commands in this function.
*               2.RIL handle the AT response line by line, so this function may 
*                 be called multiple times.
******************************************************************************/
static s32 ATResponse_CPIN_Handler(char* line, u32 len, void* userdata)
{
102cbcb0:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
102cbcb4:	e1a06002 	mov	r6, r2
102cbcb8:	e24dd06c 	sub	sp, sp, #108	; 0x6c
    s32 *result = (s32 *)userdata;
    char *head = Ql_RIL_FindString(line, len, "+CPIN:"); //continue wait
102cbcbc:	e59f5128 	ldr	r5, [pc, #296]	; 102cbdec <ATResponse_CPIN_Handler+0x13c>
102cbcc0:	e59f2128 	ldr	r2, [pc, #296]	; 102cbdf0 <ATResponse_CPIN_Handler+0x140>
*               1.Can't send any new AT commands in this function.
*               2.RIL handle the AT response line by line, so this function may 
*                 be called multiple times.
******************************************************************************/
static s32 ATResponse_CPIN_Handler(char* line, u32 len, void* userdata)
{
102cbcc4:	e1a08000 	mov	r8, r0
102cbcc8:	e1a07001 	mov	r7, r1
    s32 *result = (s32 *)userdata;
    char *head = Ql_RIL_FindString(line, len, "+CPIN:"); //continue wait
102cbccc:	e12fff35 	blx	r5
    if(head)
102cbcd0:	e2504000 	subs	r4, r0, #0
102cbcd4:	0a00001e 	beq	102cbd54 <ATResponse_CPIN_Handler+0xa4>
    {
        char str[100] = {0};
102cbcd8:	e3a02064 	mov	r2, #100	; 0x64
102cbcdc:	e3a01000 	mov	r1, #0
102cbce0:	e59f310c 	ldr	r3, [pc, #268]	; 102cbdf4 <ATResponse_CPIN_Handler+0x144>
102cbce4:	e28d0004 	add	r0, sp, #4
102cbce8:	e12fff33 	blx	r3
        char *p = NULL;
        char *q = NULL; 
        p = head + Ql_strlen("+CPIN: ");
102cbcec:	e59f5104 	ldr	r5, [pc, #260]	; 102cbdf8 <ATResponse_CPIN_Handler+0x148>
102cbcf0:	e59f0104 	ldr	r0, [pc, #260]	; 102cbdfc <ATResponse_CPIN_Handler+0x14c>
102cbcf4:	e12fff35 	blx	r5
        q = Ql_strstr(p,"\r\n");
102cbcf8:	e59f1100 	ldr	r1, [pc, #256]	; 102cbe00 <ATResponse_CPIN_Handler+0x150>
102cbcfc:	e59f3100 	ldr	r3, [pc, #256]	; 102cbe04 <ATResponse_CPIN_Handler+0x154>
    if(head)
    {
        char str[100] = {0};
        char *p = NULL;
        char *q = NULL; 
        p = head + Ql_strlen("+CPIN: ");
102cbd00:	e0844000 	add	r4, r4, r0
        q = Ql_strstr(p,"\r\n");
102cbd04:	e1a00004 	mov	r0, r4
102cbd08:	e12fff33 	blx	r3
        if (p)
102cbd0c:	e3540000 	cmp	r4, #0
    {
        char str[100] = {0};
        char *p = NULL;
        char *q = NULL; 
        p = head + Ql_strlen("+CPIN: ");
        q = Ql_strstr(p,"\r\n");
102cbd10:	e1a02000 	mov	r2, r0
        if (p)
102cbd14:	0a000004 	beq	102cbd2c <ATResponse_CPIN_Handler+0x7c>
        {
            Ql_memcpy(str, p, q - p);
102cbd18:	e1a01004 	mov	r1, r4
102cbd1c:	e28d0004 	add	r0, sp, #4
102cbd20:	e0642002 	rsb	r2, r4, r2
102cbd24:	e59f30dc 	ldr	r3, [pc, #220]	; 102cbe08 <ATResponse_CPIN_Handler+0x158>
102cbd28:	e12fff33 	blx	r3
        }
        
        *result = RIL_SIM_GetSimStateByName(str,Ql_strlen(str));
102cbd2c:	e28d0004 	add	r0, sp, #4
102cbd30:	e12fff35 	blx	r5
        return  RIL_ATRSP_SUCCESS;
102cbd34:	e3a04000 	mov	r4, #0
        if (p)
        {
            Ql_memcpy(str, p, q - p);
        }
        
        *result = RIL_SIM_GetSimStateByName(str,Ql_strlen(str));
102cbd38:	e1a01000 	mov	r1, r0
102cbd3c:	e28d0004 	add	r0, sp, #4
102cbd40:	ebffff7e 	bl	102cbb40 <RIL_SIM_GetSimStateByName>
102cbd44:	e5860000 	str	r0, [r6]
        *result = RIL_SIM_GetSimStateByErrCode(err);
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
102cbd48:	e1a00004 	mov	r0, r4
102cbd4c:	e28dd06c 	add	sp, sp, #108	; 0x6c
102cbd50:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
        
        *result = RIL_SIM_GetSimStateByName(str,Ql_strlen(str));
        return  RIL_ATRSP_SUCCESS;
    }

   head = Ql_RIL_FindLine(line, len, "OK"); // find <CR><LF>OK<CR><LF>, <CR>OK<CR>£¬<LF>OK<LF>
102cbd54:	e1a00008 	mov	r0, r8
102cbd58:	e1a01007 	mov	r1, r7
102cbd5c:	e59f20a8 	ldr	r2, [pc, #168]	; 102cbe0c <ATResponse_CPIN_Handler+0x15c>
102cbd60:	e59fa0a8 	ldr	sl, [pc, #168]	; 102cbe10 <ATResponse_CPIN_Handler+0x160>
102cbd64:	e12fff3a 	blx	sl
   if(head)
102cbd68:	e3500000 	cmp	r0, #0
102cbd6c:	1afffff5 	bne	102cbd48 <ATResponse_CPIN_Handler+0x98>
   {  
       return  RIL_ATRSP_SUCCESS;
   }

    head = Ql_RIL_FindLine(line, len, "ERROR");// find <CR><LF>ERROR<CR><LF>, <CR>ERROR<CR>£¬<LF>ERROR<LF>
102cbd70:	e1a00008 	mov	r0, r8
102cbd74:	e1a01007 	mov	r1, r7
102cbd78:	e59f2094 	ldr	r2, [pc, #148]	; 102cbe14 <ATResponse_CPIN_Handler+0x164>
102cbd7c:	e12fff3a 	blx	sl
    if(head)
102cbd80:	e2504000 	subs	r4, r0, #0
102cbd84:	1a000016 	bne	102cbde4 <ATResponse_CPIN_Handler+0x134>
    {  
        *result = SIM_STAT_UNSPECIFIED;
        return  RIL_ATRSP_FAILED;
    } 

    head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102cbd88:	e1a00008 	mov	r0, r8
102cbd8c:	e1a01007 	mov	r1, r7
102cbd90:	e59f2080 	ldr	r2, [pc, #128]	; 102cbe18 <ATResponse_CPIN_Handler+0x168>
102cbd94:	e12fff35 	blx	r5
    if(head)
102cbd98:	e3500000 	cmp	r0, #0
        Ql_sscanf(head,"%*[^ ]%d,%[^\r\n]",&err);
        *result = RIL_SIM_GetSimStateByErrCode(err);
        return  RIL_ATRSP_FAILED;
    }

    return RIL_ATRSP_CONTINUE; //continue wait
102cbd9c:	03a04001 	moveq	r4, #1
        *result = SIM_STAT_UNSPECIFIED;
        return  RIL_ATRSP_FAILED;
    } 

    head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
    if(head)
102cbda0:	0affffe8 	beq	102cbd48 <ATResponse_CPIN_Handler+0x98>
    {
        s32 err = 0;
        Ql_sscanf(head,"%*[^ ]%d,%[^\r\n]",&err);
102cbda4:	e59f3070 	ldr	r3, [pc, #112]	; 102cbe1c <ATResponse_CPIN_Handler+0x16c>
    } 

    head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
    if(head)
    {
        s32 err = 0;
102cbda8:	e28d2068 	add	r2, sp, #104	; 0x68
102cbdac:	e5224068 	str	r4, [r2, #-104]!	; 0xffffff98
        Ql_sscanf(head,"%*[^ ]%d,%[^\r\n]",&err);
102cbdb0:	e5933000 	ldr	r3, [r3]
102cbdb4:	e59f1064 	ldr	r1, [pc, #100]	; 102cbe20 <ATResponse_CPIN_Handler+0x170>
102cbdb8:	e1a0200d 	mov	r2, sp
102cbdbc:	e12fff33 	blx	r3
102cbdc0:	e59d3000 	ldr	r3, [sp]
102cbdc4:	e243300a 	sub	r3, r3, #10
102cbdc8:	e3530008 	cmp	r3, #8
102cbdcc:	8a000004 	bhi	102cbde4 <ATResponse_CPIN_Handler+0x134>
102cbdd0:	e59f204c 	ldr	r2, [pc, #76]	; 102cbe24 <ATResponse_CPIN_Handler+0x174>
102cbdd4:	e7923103 	ldr	r3, [r2, r3, lsl #2]
        *result = RIL_SIM_GetSimStateByErrCode(err);
102cbdd8:	e5863000 	str	r3, [r6]
        return  RIL_ATRSP_FAILED;
102cbddc:	e3e04000 	mvn	r4, #0
102cbde0:	eaffffd8 	b	102cbd48 <ATResponse_CPIN_Handler+0x98>
102cbde4:	e3a0300a 	mov	r3, #10
102cbde8:	eafffffa 	b	102cbdd8 <ATResponse_CPIN_Handler+0x128>
102cbdec:	102cce98 	.word	0x102cce98
102cbdf0:	102ee6c8 	.word	0x102ee6c8
102cbdf4:	102df9d5 	.word	0x102df9d5
102cbdf8:	102e57a4 	.word	0x102e57a4
102cbdfc:	102ee6d0 	.word	0x102ee6d0
102cbe00:	102ee78c 	.word	0x102ee78c
102cbe04:	102e5a04 	.word	0x102e5a04
102cbe08:	102e597c 	.word	0x102e597c
102cbe0c:	102ee5e8 	.word	0x102ee5e8
102cbe10:	102ccf24 	.word	0x102ccf24
102cbe14:	102ede00 	.word	0x102ede00
102cbe18:	102ede08 	.word	0x102ede08
102cbe1c:	f03de548 	.word	0xf03de548
102cbe20:	102ee6d8 	.word	0x102ee6d8
102cbe24:	102e66a0 	.word	0x102e66a0

102cbe28 <RIL_SIM_GetSimState>:
******************************************************************************/
s32  RIL_SIM_GetSimState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CPIN?\0";
102cbe28:	e59f305c 	ldr	r3, [pc, #92]	; 102cbe8c <RIL_SIM_GetSimState+0x64>
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_SIM_GetSimState(s32 *stat)
{
102cbe2c:	e92d4030 	push	{r4, r5, lr}
102cbe30:	e1a05000 	mov	r5, r0
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CPIN?\0";
102cbe34:	e8930007 	ldm	r3, {r0, r1, r2}
*                RIL_AT_INVALID_PARAM, invalid input parameter.
*                RIL_AT_UNINITIALIZED, RIL is not ready, need to wait for MSG_ID_RIL_READY
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_SIM_GetSimState(s32 *stat)
{
102cbe38:	e24dd01c 	sub	sp, sp, #28
    s32 retRes = -1;
    s32 nStat = 0;
    char strAT[] = "AT+CPIN?\0";
102cbe3c:	e28d300c 	add	r3, sp, #12
102cbe40:	e8a30003 	stmia	r3!, {r0, r1}
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_SIM_GetSimState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
102cbe44:	e3a04000 	mov	r4, #0
    char strAT[] = "AT+CPIN?\0";
102cbe48:	e1c320b0 	strh	r2, [r3]

    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATResponse_CPIN_Handler, &nStat, 0);
102cbe4c:	e28d000c 	add	r0, sp, #12
102cbe50:	e59f3038 	ldr	r3, [pc, #56]	; 102cbe90 <RIL_SIM_GetSimState+0x68>
*                                      and then call Ql_RIL_Initialize to initialize RIL.
******************************************************************************/
s32  RIL_SIM_GetSimState(s32 *stat)
{
    s32 retRes = -1;
    s32 nStat = 0;
102cbe54:	e58d4008 	str	r4, [sp, #8]
    char strAT[] = "AT+CPIN?\0";

    retRes = Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATResponse_CPIN_Handler, &nStat, 0);
102cbe58:	e12fff33 	blx	r3
102cbe5c:	e28d3008 	add	r3, sp, #8
102cbe60:	e58d4000 	str	r4, [sp]
102cbe64:	e59f2028 	ldr	r2, [pc, #40]	; 102cbe94 <RIL_SIM_GetSimState+0x6c>
102cbe68:	e59fc028 	ldr	ip, [pc, #40]	; 102cbe98 <RIL_SIM_GetSimState+0x70>
102cbe6c:	e1a01000 	mov	r1, r0
102cbe70:	e28d000c 	add	r0, sp, #12
102cbe74:	e12fff3c 	blx	ip
    if(RIL_AT_SUCCESS == retRes)
102cbe78:	e3500000 	cmp	r0, #0
    {
       *stat = nStat; 
102cbe7c:	059d3008 	ldreq	r3, [sp, #8]
102cbe80:	05853000 	streq	r3, [r5]
    }
    return retRes;
}
102cbe84:	e28dd01c 	add	sp, sp, #28
102cbe88:	e8bd8030 	pop	{r4, r5, pc}
102cbe8c:	102e66c4 	.word	0x102e66c4
102cbe90:	102e57a4 	.word	0x102e57a4
102cbe94:	102cbcb0 	.word	0x102cbcb0
102cbe98:	102e5168 	.word	0x102e5168

102cbe9c <RIL_SIM_GetIMSI>:
    Ql_memcpy((char*)param, line, len - 2); // <imsi number>\r\n
    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetIMSI(char* imsi)
{
    char strAT[] = "AT+CIMI\0";
102cbe9c:	e59f205c 	ldr	r2, [pc, #92]	; 102cbf00 <RIL_SIM_GetIMSI+0x64>
    }
    Ql_memcpy((char*)param, line, len - 2); // <imsi number>\r\n
    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetIMSI(char* imsi)
{
102cbea0:	e92d4010 	push	{r4, lr}
102cbea4:	e1a04000 	mov	r4, r0
    char strAT[] = "AT+CIMI\0";
102cbea8:	e8920007 	ldm	r2, {r0, r1, r2}
    }
    Ql_memcpy((char*)param, line, len - 2); // <imsi number>\r\n
    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetIMSI(char* imsi)
{
102cbeac:	e24dd018 	sub	sp, sp, #24
    char strAT[] = "AT+CIMI\0";
102cbeb0:	e28dc00c 	add	ip, sp, #12
    if (NULL == imsi)
102cbeb4:	e3540000 	cmp	r4, #0
    Ql_memcpy((char*)param, line, len - 2); // <imsi number>\r\n
    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetIMSI(char* imsi)
{
    char strAT[] = "AT+CIMI\0";
102cbeb8:	e8ac0003 	stmia	ip!, {r0, r1}
102cbebc:	e5cc2000 	strb	r2, [ip]
    if (NULL == imsi)
102cbec0:	0a00000c 	beq	102cbef8 <RIL_SIM_GetIMSI+0x5c>
    {
        return RIL_AT_INVALID_PARAM;
    }
    return Ql_RIL_SendATCmd(strAT, Ql_strlen(strAT), ATRsp_IMSI_Handler,(void*)imsi, 0);
102cbec4:	e59f3038 	ldr	r3, [pc, #56]	; 102cbf04 <RIL_SIM_GetIMSI+0x68>
102cbec8:	e28d000c 	add	r0, sp, #12
102cbecc:	e12fff33 	blx	r3
102cbed0:	e3a03000 	mov	r3, #0
102cbed4:	e58d3000 	str	r3, [sp]
102cbed8:	e59f2028 	ldr	r2, [pc, #40]	; 102cbf08 <RIL_SIM_GetIMSI+0x6c>
102cbedc:	e1a03004 	mov	r3, r4
102cbee0:	e59fc024 	ldr	ip, [pc, #36]	; 102cbf0c <RIL_SIM_GetIMSI+0x70>
102cbee4:	e1a01000 	mov	r1, r0
102cbee8:	e28d000c 	add	r0, sp, #12
102cbeec:	e12fff3c 	blx	ip
}
102cbef0:	e28dd018 	add	sp, sp, #24
102cbef4:	e8bd8010 	pop	{r4, pc}
s32 RIL_SIM_GetIMSI(char* imsi)
{
    char strAT[] = "AT+CIMI\0";
    if (NULL == imsi)
    {
        return RIL_AT_INVALID_PARAM;
102cbef8:	e3e00003 	mvn	r0, #3
102cbefc:	eafffffb 	b	102cbef0 <RIL_SIM_GetIMSI+0x54>
102cbf00:	102e66d0 	.word	0x102e66d0
102cbf04:	102e57a4 	.word	0x102e57a4
102cbf08:	102cbaa4 	.word	0x102cbaa4
102cbf0c:	102e5168 	.word	0x102e5168

102cbf10 <RIL_SIM_GetCCID>:

    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetCCID(char* ccid)
{
    char strAT[] = "AT+CCID\0";
102cbf10:	e59f205c 	ldr	r2, [pc, #92]	; 102cbf74 <RIL_SIM_GetCCID+0x64>
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetCCID(char* ccid)
{
102cbf14:	e92d4010 	push	{r4, lr}
102cbf18:	e1a04000 	mov	r4, r0
    char strAT[] = "AT+CCID\0";
102cbf1c:	e8920007 	ldm	r2, {r0, r1, r2}
    }

    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetCCID(char* ccid)
{
102cbf20:	e24dd018 	sub	sp, sp, #24
    char strAT[] = "AT+CCID\0";
102cbf24:	e28dc00c 	add	ip, sp, #12
    if (NULL == ccid)
102cbf28:	e3540000 	cmp	r4, #0

    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetCCID(char* ccid)
{
    char strAT[] = "AT+CCID\0";
102cbf2c:	e8ac0003 	stmia	ip!, {r0, r1}
102cbf30:	e5cc2000 	strb	r2, [ip]
    if (NULL == ccid)
102cbf34:	0a00000c 	beq	102cbf6c <RIL_SIM_GetCCID+0x5c>
    {
        return RIL_AT_INVALID_PARAM;
    }
    return Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT), ATRsp_CCID_Handler,(void*)ccid, 0);
102cbf38:	e59f3038 	ldr	r3, [pc, #56]	; 102cbf78 <RIL_SIM_GetCCID+0x68>
102cbf3c:	e28d000c 	add	r0, sp, #12
102cbf40:	e12fff33 	blx	r3
102cbf44:	e3a03000 	mov	r3, #0
102cbf48:	e58d3000 	str	r3, [sp]
102cbf4c:	e59f2028 	ldr	r2, [pc, #40]	; 102cbf7c <RIL_SIM_GetCCID+0x6c>
102cbf50:	e1a03004 	mov	r3, r4
102cbf54:	e59fc024 	ldr	ip, [pc, #36]	; 102cbf80 <RIL_SIM_GetCCID+0x70>
102cbf58:	e1a01000 	mov	r1, r0
102cbf5c:	e28d000c 	add	r0, sp, #12
102cbf60:	e12fff3c 	blx	ip
}
102cbf64:	e28dd018 	add	sp, sp, #24
102cbf68:	e8bd8010 	pop	{r4, pc}
s32 RIL_SIM_GetCCID(char* ccid)
{
    char strAT[] = "AT+CCID\0";
    if (NULL == ccid)
    {
        return RIL_AT_INVALID_PARAM;
102cbf6c:	e3e00003 	mvn	r0, #3
102cbf70:	eafffffb 	b	102cbf64 <RIL_SIM_GetCCID+0x54>
102cbf74:	102e66dc 	.word	0x102e66dc
102cbf78:	102e57a4 	.word	0x102e57a4
102cbf7c:	102cb9e0 	.word	0x102cb9e0
102cbf80:	102e5168 	.word	0x102e5168

102cbf84 <RIL_SIM_GetSPN>:
	    }

	    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetSPN(char* spn,u32* mode)
{
102cbf84:	e92d4070 	push	{r4, r5, r6, lr}
	s32 retRes = 0;
	APP_DEBUG("\r\n<-- Getting SPN	 -->\r\n");
102cbf88:	e3a02c02 	mov	r2, #512	; 0x200
	    }

	    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetSPN(char* spn,u32* mode)
{
102cbf8c:	e24dd050 	sub	sp, sp, #80	; 0x50
	s32 retRes = 0;
	APP_DEBUG("\r\n<-- Getting SPN	 -->\r\n");
102cbf90:	e3a01000 	mov	r1, #0
102cbf94:	e59f50ac 	ldr	r5, [pc, #172]	; 102cc048 <RIL_SIM_GetSPN+0xc4>
	    }

	    return RIL_ATRSP_CONTINUE; //continue wait
}
s32 RIL_SIM_GetSPN(char* spn,u32* mode)
{
102cbf98:	e1a06000 	mov	r6, r0
	s32 retRes = 0;
	APP_DEBUG("\r\n<-- Getting SPN	 -->\r\n");
102cbf9c:	e59f00a8 	ldr	r0, [pc, #168]	; 102cc04c <RIL_SIM_GetSPN+0xc8>
102cbfa0:	e12fff35 	blx	r5
102cbfa4:	e59f30a4 	ldr	r3, [pc, #164]	; 102cc050 <RIL_SIM_GetSPN+0xcc>
102cbfa8:	e59f10a4 	ldr	r1, [pc, #164]	; 102cc054 <RIL_SIM_GetSPN+0xd0>
102cbfac:	e5933000 	ldr	r3, [r3]
102cbfb0:	e59f0094 	ldr	r0, [pc, #148]	; 102cc04c <RIL_SIM_GetSPN+0xc8>
102cbfb4:	e12fff33 	blx	r3
102cbfb8:	e59f4098 	ldr	r4, [pc, #152]	; 102cc058 <RIL_SIM_GetSPN+0xd4>
102cbfbc:	e59f0088 	ldr	r0, [pc, #136]	; 102cc04c <RIL_SIM_GetSPN+0xc8>
102cbfc0:	e12fff34 	blx	r4
102cbfc4:	e59f1080 	ldr	r1, [pc, #128]	; 102cc04c <RIL_SIM_GetSPN+0xc8>
102cbfc8:	e59f308c 	ldr	r3, [pc, #140]	; 102cc05c <RIL_SIM_GetSPN+0xd8>
102cbfcc:	e1a02000 	mov	r2, r0
102cbfd0:	e3a0000a 	mov	r0, #10
102cbfd4:	e12fff33 	blx	r3
	char strAT[] = "AT+QSPN?\0";
102cbfd8:	e59f3080 	ldr	r3, [pc, #128]	; 102cc060 <RIL_SIM_GetSPN+0xdc>
102cbfdc:	e8930007 	ldm	r3, {r0, r1, r2}
102cbfe0:	e28d300c 	add	r3, sp, #12
102cbfe4:	e8a30003 	stmia	r3!, {r0, r1}
	ST_SPN_Reponse pSPN_Response;
	 Ql_memset(&pSPN_Response,0, sizeof(pSPN_Response));
102cbfe8:	e3a01000 	mov	r1, #0
}
s32 RIL_SIM_GetSPN(char* spn,u32* mode)
{
	s32 retRes = 0;
	APP_DEBUG("\r\n<-- Getting SPN	 -->\r\n");
	char strAT[] = "AT+QSPN?\0";
102cbfec:	e1c320b0 	strh	r2, [r3]
	ST_SPN_Reponse pSPN_Response;
	 Ql_memset(&pSPN_Response,0, sizeof(pSPN_Response));
102cbff0:	e28d0018 	add	r0, sp, #24
102cbff4:	e3a02038 	mov	r2, #56	; 0x38
102cbff8:	e12fff35 	blx	r5
	 retRes = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT), ATResponse_SPN_Handler,(void*)&pSPN_Response,0);
102cbffc:	e28d000c 	add	r0, sp, #12
102cc000:	e12fff34 	blx	r4
102cc004:	e3a03000 	mov	r3, #0
102cc008:	e58d3000 	str	r3, [sp]
102cc00c:	e59f2050 	ldr	r2, [pc, #80]	; 102cc064 <RIL_SIM_GetSPN+0xe0>
102cc010:	e28d3018 	add	r3, sp, #24
102cc014:	e59fc04c 	ldr	ip, [pc, #76]	; 102cc068 <RIL_SIM_GetSPN+0xe4>
102cc018:	e1a01000 	mov	r1, r0
102cc01c:	e28d000c 	add	r0, sp, #12
102cc020:	e12fff3c 	blx	ip
	 if(RIL_AT_SUCCESS == retRes)
102cc024:	e2504000 	subs	r4, r0, #0
102cc028:	1a000003 	bne	102cc03c <RIL_SIM_GetSPN+0xb8>
	 {
		 Ql_strcpy(spn,&pSPN_Response.servideprovider);
102cc02c:	e1a00006 	mov	r0, r6
102cc030:	e28d1018 	add	r1, sp, #24
102cc034:	e59f3030 	ldr	r3, [pc, #48]	; 102cc06c <RIL_SIM_GetSPN+0xe8>
102cc038:	e12fff33 	blx	r3
	 }

	    return retRes;
}
102cc03c:	e1a00004 	mov	r0, r4
102cc040:	e28dd050 	add	sp, sp, #80	; 0x50
102cc044:	e8bd8070 	pop	{r4, r5, r6, pc}
102cc048:	102e58f4 	.word	0x102e58f4
102cc04c:	f03d5320 	.word	0xf03d5320
102cc050:	f03de540 	.word	0xf03de540
102cc054:	102ee6e8 	.word	0x102ee6e8
102cc058:	102e57a4 	.word	0x102e57a4
102cc05c:	102e6230 	.word	0x102e6230
102cc060:	102e66e8 	.word	0x102e66e8
102cc064:	102cb89c 	.word	0x102cb89c
102cc068:	102e5168 	.word	0x102e5168
102cc06c:	102e55fc 	.word	0x102e55fc

102cc070 <OnURCHandler_HTTP>:
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_CFUN_STATE_IND, cfun);
    }
}

static void OnURCHandler_HTTP(const char* strURC, void* reserved)
{
102cc070:	e92d4030 	push	{r4, r5, lr}
102cc074:	e24dd01c 	sub	sp, sp, #28
    u32 contentLen = 0;
    s32 errCode = 0;
    extern CB_HTTP_DwnldFile callback_http_dwnld;

    //+QHTTPDL: 23772,23772,0
    Ql_sscanf(strURC, "%*[^: ]: %d,%d,%d[^\r\n]", &dwnLoadedSize, &contentLen, &errCode);
102cc078:	e28d3014 	add	r3, sp, #20
102cc07c:	e58d3000 	str	r3, [sp]
102cc080:	e59f3048 	ldr	r3, [pc, #72]	; 102cc0d0 <OnURCHandler_HTTP+0x60>
    }
}

static void OnURCHandler_HTTP(const char* strURC, void* reserved)
{
    u32 dwnLoadedSize = 0;
102cc084:	e3a04000 	mov	r4, #0
    s32 errCode = 0;
    extern CB_HTTP_DwnldFile callback_http_dwnld;

    //+QHTTPDL: 23772,23772,0
    Ql_sscanf(strURC, "%*[^: ]: %d,%d,%d[^\r\n]", &dwnLoadedSize, &contentLen, &errCode);
    if (callback_http_dwnld)
102cc088:	e59f5044 	ldr	r5, [pc, #68]	; 102cc0d4 <OnURCHandler_HTTP+0x64>
    u32 contentLen = 0;
    s32 errCode = 0;
    extern CB_HTTP_DwnldFile callback_http_dwnld;

    //+QHTTPDL: 23772,23772,0
    Ql_sscanf(strURC, "%*[^: ]: %d,%d,%d[^\r\n]", &dwnLoadedSize, &contentLen, &errCode);
102cc08c:	e593c000 	ldr	ip, [r3]
    }
}

static void OnURCHandler_HTTP(const char* strURC, void* reserved)
{
    u32 dwnLoadedSize = 0;
102cc090:	e58d400c 	str	r4, [sp, #12]
    u32 contentLen = 0;
    s32 errCode = 0;
    extern CB_HTTP_DwnldFile callback_http_dwnld;

    //+QHTTPDL: 23772,23772,0
    Ql_sscanf(strURC, "%*[^: ]: %d,%d,%d[^\r\n]", &dwnLoadedSize, &contentLen, &errCode);
102cc094:	e28d3010 	add	r3, sp, #16
}

static void OnURCHandler_HTTP(const char* strURC, void* reserved)
{
    u32 dwnLoadedSize = 0;
    u32 contentLen = 0;
102cc098:	e58d4010 	str	r4, [sp, #16]
    s32 errCode = 0;
102cc09c:	e58d4014 	str	r4, [sp, #20]
    extern CB_HTTP_DwnldFile callback_http_dwnld;

    //+QHTTPDL: 23772,23772,0
    Ql_sscanf(strURC, "%*[^: ]: %d,%d,%d[^\r\n]", &dwnLoadedSize, &contentLen, &errCode);
102cc0a0:	e59f1030 	ldr	r1, [pc, #48]	; 102cc0d8 <OnURCHandler_HTTP+0x68>
102cc0a4:	e28d200c 	add	r2, sp, #12
102cc0a8:	e12fff3c 	blx	ip
    if (callback_http_dwnld)
102cc0ac:	e5953000 	ldr	r3, [r5]
102cc0b0:	e1530004 	cmp	r3, r4
102cc0b4:	0a000003 	beq	102cc0c8 <OnURCHandler_HTTP+0x58>
    {
        callback_http_dwnld(dwnLoadedSize, contentLen, errCode);
102cc0b8:	e28d000c 	add	r0, sp, #12
102cc0bc:	e8900007 	ldm	r0, {r0, r1, r2}
102cc0c0:	e12fff33 	blx	r3
        callback_http_dwnld = NULL;
102cc0c4:	e5854000 	str	r4, [r5]
    }
}
102cc0c8:	e28dd01c 	add	sp, sp, #28
102cc0cc:	e8bd8030 	pop	{r4, r5, pc}
102cc0d0:	f03de548 	.word	0xf03de548
102cc0d4:	f03d5118 	.word	0xf03d5118
102cc0d8:	102ee704 	.word	0x102ee704

102cc0dc <OnURCHandler_AudPlayInd>:
{
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_END, 0);
}

static void OnURCHandler_AudPlayInd(const char* strURC, void* reserved)
{
102cc0dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    s32 errCode1 = 0;
102cc0e0:	e3a03000 	mov	r3, #0
{
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_END, 0);
}

static void OnURCHandler_AudPlayInd(const char* strURC, void* reserved)
{
102cc0e4:	e24dd00c 	sub	sp, sp, #12
    s32 errCode1 = 0;
102cc0e8:	e58d3000 	str	r3, [sp]
    s32 errCode2 = 0;
102cc0ec:	e58d3004 	str	r3, [sp, #4]
    extern RIL_AUD_PLAY_IND cb_aud_play;

    //"+QAUDPIND: 0,<errCode>"
    //"+QPLAYRES: 0,%d"
    //"+QPRESBG: 0,%d"
    Ql_sscanf(strURC, "%*[^: ]: %d,%d[^\r\n]", &errCode1, &errCode2);
102cc0f0:	e59f3030 	ldr	r3, [pc, #48]	; 102cc128 <OnURCHandler_AudPlayInd+0x4c>
102cc0f4:	e59f1030 	ldr	r1, [pc, #48]	; 102cc12c <OnURCHandler_AudPlayInd+0x50>
102cc0f8:	e593c000 	ldr	ip, [r3]
102cc0fc:	e1a0200d 	mov	r2, sp
102cc100:	e28d3004 	add	r3, sp, #4
102cc104:	e12fff3c 	blx	ip
    if (cb_aud_play)
102cc108:	e59f3020 	ldr	r3, [pc, #32]	; 102cc130 <OnURCHandler_AudPlayInd+0x54>
102cc10c:	e5933000 	ldr	r3, [r3]
102cc110:	e3530000 	cmp	r3, #0
102cc114:	0a000001 	beq	102cc120 <OnURCHandler_AudPlayInd+0x44>
    {
        cb_aud_play(errCode2);
102cc118:	e59d0004 	ldr	r0, [sp, #4]
102cc11c:	e12fff33 	blx	r3
    }
}
102cc120:	e28dd00c 	add	sp, sp, #12
102cc124:	e8bd8000 	ldmfd	sp!, {pc}
102cc128:	f03de548 	.word	0xf03de548
102cc12c:	102ee71c 	.word	0x102ee71c
102cc130:	f03d5054 	.word	0xf03d5054

102cc134 <OnURCHandler_FTP>:
        callback_http_dwnld = NULL;
    }
}

static void OnURCHandler_FTP(const char* strURC, void* reserved)
{
102cc134:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    char* p1 = NULL;
    char* p2 = NULL;
    s32 nFtpDlLen = 0;
    char strTmp[10];
       
    p1 = Ql_strstr(strURC, "\r\n+QFTPGET:");
102cc138:	e59f1140 	ldr	r1, [pc, #320]	; 102cc280 <OnURCHandler_FTP+0x14c>
        callback_http_dwnld = NULL;
    }
}

static void OnURCHandler_FTP(const char* strURC, void* reserved)
{
102cc13c:	e24dd010 	sub	sp, sp, #16
    char* p1 = NULL;
    char* p2 = NULL;
    s32 nFtpDlLen = 0;
    char strTmp[10];
       
    p1 = Ql_strstr(strURC, "\r\n+QFTPGET:");
102cc140:	e59f413c 	ldr	r4, [pc, #316]	; 102cc284 <OnURCHandler_FTP+0x150>
        callback_http_dwnld = NULL;
    }
}

static void OnURCHandler_FTP(const char* strURC, void* reserved)
{
102cc144:	e1a08000 	mov	r8, r0
    char* p1 = NULL;
    char* p2 = NULL;
    s32 nFtpDlLen = 0;
    char strTmp[10];
       
    p1 = Ql_strstr(strURC, "\r\n+QFTPGET:");
102cc148:	e12fff34 	blx	r4
    p1 += Ql_strlen("\r\n+QFTPGET:");
102cc14c:	e59f6134 	ldr	r6, [pc, #308]	; 102cc288 <OnURCHandler_FTP+0x154>
    char* p1 = NULL;
    char* p2 = NULL;
    s32 nFtpDlLen = 0;
    char strTmp[10];
       
    p1 = Ql_strstr(strURC, "\r\n+QFTPGET:");
102cc150:	e1a05000 	mov	r5, r0
    p1 += Ql_strlen("\r\n+QFTPGET:");
102cc154:	e59f0124 	ldr	r0, [pc, #292]	; 102cc280 <OnURCHandler_FTP+0x14c>
102cc158:	e12fff36 	blx	r6
    p2 = Ql_strstr(p1, "\r\n");
102cc15c:	e59f1128 	ldr	r1, [pc, #296]	; 102cc28c <OnURCHandler_FTP+0x158>
    char* p2 = NULL;
    s32 nFtpDlLen = 0;
    char strTmp[10];
       
    p1 = Ql_strstr(strURC, "\r\n+QFTPGET:");
    p1 += Ql_strlen("\r\n+QFTPGET:");
102cc160:	e0855000 	add	r5, r5, r0
    p2 = Ql_strstr(p1, "\r\n");
102cc164:	e1a00005 	mov	r0, r5
102cc168:	e12fff34 	blx	r4
    if (p1 && p2)
102cc16c:	e3550000 	cmp	r5, #0
102cc170:	13500000 	cmpne	r0, #0
102cc174:	e1a07000 	mov	r7, r0
102cc178:	0a000019 	beq	102cc1e4 <OnURCHandler_FTP+0xb0>
    {
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc17c:	e3a0200a 	mov	r2, #10
102cc180:	e3a01000 	mov	r1, #0
102cc184:	e59f3104 	ldr	r3, [pc, #260]	; 102cc290 <OnURCHandler_FTP+0x15c>
102cc188:	e28d0004 	add	r0, sp, #4
102cc18c:	e12fff33 	blx	r3
        Ql_memcpy(strTmp, p1, p2 - p1);
102cc190:	e1a01005 	mov	r1, r5
102cc194:	e0652007 	rsb	r2, r5, r7
102cc198:	e59f30f4 	ldr	r3, [pc, #244]	; 102cc294 <OnURCHandler_FTP+0x160>
102cc19c:	e28d0004 	add	r0, sp, #4
102cc1a0:	e12fff33 	blx	r3
        nFtpDlLen = Ql_atoi(strTmp);
102cc1a4:	e59f30ec 	ldr	r3, [pc, #236]	; 102cc298 <OnURCHandler_FTP+0x164>
102cc1a8:	e28d0004 	add	r0, sp, #4
102cc1ac:	e12fff33 	blx	r3
        //TODO:
        if(NULL != FtpGet_IND_CB)
102cc1b0:	e59f50e4 	ldr	r5, [pc, #228]	; 102cc29c <OnURCHandler_FTP+0x168>
102cc1b4:	e5953000 	ldr	r3, [r5]
102cc1b8:	e3530000 	cmp	r3, #0
    p2 = Ql_strstr(p1, "\r\n");
    if (p1 && p2)
    {
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
        Ql_memcpy(strTmp, p1, p2 - p1);
        nFtpDlLen = Ql_atoi(strTmp);
102cc1bc:	e1a01000 	mov	r1, r0
        //TODO:
        if(NULL != FtpGet_IND_CB)
102cc1c0:	0a000007 	beq	102cc1e4 <OnURCHandler_FTP+0xb0>
        {
            if(nFtpDlLen < 0)
102cc1c4:	e3500000 	cmp	r0, #0
            {
                FtpGet_IND_CB(0,nFtpDlLen);
102cc1c8:	b3a00000 	movlt	r0, #0
            }
            else
            {
                FtpGet_IND_CB(1,nFtpDlLen);
102cc1cc:	a3a00001 	movge	r0, #1
102cc1d0:	e12fff33 	blx	r3
            }
            FtpGet_IND_CB = NULL;
102cc1d4:	e3a03000 	mov	r3, #0
102cc1d8:	e5853000 	str	r3, [r5]
            }
            FtpPut_IND_CB = NULL;
            return;
        }
    }
}
102cc1dc:	e28dd010 	add	sp, sp, #16
102cc1e0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        }
    }

    p1 = NULL;
    p2 = NULL;
    p1 = Ql_strstr(strURC, "\r\n+QFTPPUT:");
102cc1e4:	e59f10b4 	ldr	r1, [pc, #180]	; 102cc2a0 <OnURCHandler_FTP+0x16c>
102cc1e8:	e1a00008 	mov	r0, r8
102cc1ec:	e12fff34 	blx	r4
102cc1f0:	e1a05000 	mov	r5, r0
    p1 += Ql_strlen("\r\n+QFTPPUT:");
102cc1f4:	e59f00a4 	ldr	r0, [pc, #164]	; 102cc2a0 <OnURCHandler_FTP+0x16c>
102cc1f8:	e12fff36 	blx	r6
    p2 = Ql_strstr(p1, "\r\n");
102cc1fc:	e59f1088 	ldr	r1, [pc, #136]	; 102cc28c <OnURCHandler_FTP+0x158>
    }

    p1 = NULL;
    p2 = NULL;
    p1 = Ql_strstr(strURC, "\r\n+QFTPPUT:");
    p1 += Ql_strlen("\r\n+QFTPPUT:");
102cc200:	e0855000 	add	r5, r5, r0
    p2 = Ql_strstr(p1, "\r\n");
102cc204:	e1a00005 	mov	r0, r5
102cc208:	e12fff34 	blx	r4
    if (p1 && p2)
102cc20c:	e3550000 	cmp	r5, #0
102cc210:	13500000 	cmpne	r0, #0
102cc214:	e1a04000 	mov	r4, r0
102cc218:	0affffef 	beq	102cc1dc <OnURCHandler_FTP+0xa8>
    {
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc21c:	e3a0200a 	mov	r2, #10
102cc220:	e3a01000 	mov	r1, #0
102cc224:	e59f3064 	ldr	r3, [pc, #100]	; 102cc290 <OnURCHandler_FTP+0x15c>
102cc228:	e28d0004 	add	r0, sp, #4
102cc22c:	e12fff33 	blx	r3
        Ql_memcpy(strTmp, p1, p2 - p1);
102cc230:	e1a01005 	mov	r1, r5
102cc234:	e0652004 	rsb	r2, r5, r4
102cc238:	e59f3054 	ldr	r3, [pc, #84]	; 102cc294 <OnURCHandler_FTP+0x160>
102cc23c:	e28d0004 	add	r0, sp, #4
102cc240:	e12fff33 	blx	r3
        nFtpDlLen = Ql_atoi(strTmp);
102cc244:	e59f304c 	ldr	r3, [pc, #76]	; 102cc298 <OnURCHandler_FTP+0x164>
102cc248:	e28d0004 	add	r0, sp, #4
102cc24c:	e12fff33 	blx	r3
        //TODO:
        if(NULL != FtpPut_IND_CB)
102cc250:	e59f5044 	ldr	r5, [pc, #68]	; 102cc29c <OnURCHandler_FTP+0x168>
102cc254:	e5953004 	ldr	r3, [r5, #4]
102cc258:	e3530000 	cmp	r3, #0
    p2 = Ql_strstr(p1, "\r\n");
    if (p1 && p2)
    {
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
        Ql_memcpy(strTmp, p1, p2 - p1);
        nFtpDlLen = Ql_atoi(strTmp);
102cc25c:	e1a01000 	mov	r1, r0
        //TODO:
        if(NULL != FtpPut_IND_CB)
102cc260:	0affffdd 	beq	102cc1dc <OnURCHandler_FTP+0xa8>
        {
            if(nFtpDlLen < 0)
102cc264:	e3500000 	cmp	r0, #0
            {
                FtpPut_IND_CB(0,nFtpDlLen);
102cc268:	b3a00000 	movlt	r0, #0
            }
            else
            {
                FtpPut_IND_CB(1,nFtpDlLen);
102cc26c:	a3a00001 	movge	r0, #1
102cc270:	e12fff33 	blx	r3
            }
            FtpPut_IND_CB = NULL;
102cc274:	e3a03000 	mov	r3, #0
102cc278:	e5853004 	str	r3, [r5, #4]
102cc27c:	eaffffd6 	b	102cc1dc <OnURCHandler_FTP+0xa8>
102cc280:	102ee730 	.word	0x102ee730
102cc284:	102e5a04 	.word	0x102e5a04
102cc288:	102e57a4 	.word	0x102e57a4
102cc28c:	102ee78c 	.word	0x102ee78c
102cc290:	102e58f4 	.word	0x102e58f4
102cc294:	102e597c 	.word	0x102e597c
102cc298:	102e5a8c 	.word	0x102e5a8c
102cc29c:	f03d5520 	.word	0xf03d5520
102cc2a0:	102ee73c 	.word	0x102ee73c

102cc2a4 <OnURCHandler_AlarmRing>:
    }
}

static void OnURCHandler_AlarmRing(const char* strURC, void* reserved)
{
	Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_ALARM_RING_IND, 0);
102cc2a4:	e3a00000 	mov	r0, #0
        }
    }
}

static void OnURCHandler_AlarmRing(const char* strURC, void* reserved)
{
102cc2a8:	e92d4008 	push	{r3, lr}
	Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_ALARM_RING_IND, 0);
102cc2ac:	e59f1010 	ldr	r1, [pc, #16]	; 102cc2c4 <OnURCHandler_AlarmRing+0x20>
102cc2b0:	e3a0200a 	mov	r2, #10
102cc2b4:	e1a03000 	mov	r3, r0
102cc2b8:	e59fc008 	ldr	ip, [pc, #8]	; 102cc2c8 <OnURCHandler_AlarmRing+0x24>
102cc2bc:	e12fff3c 	blx	ip
102cc2c0:	e8bd8008 	pop	{r3, pc}
102cc2c4:	00001002 	.word	0x00001002
102cc2c8:	102e5cb4 	.word	0x102e5cb4

102cc2cc <OnURCHandler_InitStat>:
    }
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_MODULE_VOLTAGE_IND, volState);
}

static void OnURCHandler_InitStat(const char* strURC, void* reserved)
{
102cc2cc:	e92d4038 	push	{r3, r4, r5, lr}
    u32 sysInitStat = SYS_STATE_START;
    
    if (Ql_strstr(strURC, "\r\nCall Ready\r\n") != NULL)
102cc2d0:	e59f1048 	ldr	r1, [pc, #72]	; 102cc320 <OnURCHandler_InitStat+0x54>
102cc2d4:	e59f4048 	ldr	r4, [pc, #72]	; 102cc324 <OnURCHandler_InitStat+0x58>
    }
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_MODULE_VOLTAGE_IND, volState);
}

static void OnURCHandler_InitStat(const char* strURC, void* reserved)
{
102cc2d8:	e1a05000 	mov	r5, r0
    u32 sysInitStat = SYS_STATE_START;
    
    if (Ql_strstr(strURC, "\r\nCall Ready\r\n") != NULL)
102cc2dc:	e12fff34 	blx	r4
102cc2e0:	e3500000 	cmp	r0, #0
    {
        sysInitStat = SYS_STATE_PHBOK;
102cc2e4:	13a03002 	movne	r3, #2

static void OnURCHandler_InitStat(const char* strURC, void* reserved)
{
    u32 sysInitStat = SYS_STATE_START;
    
    if (Ql_strstr(strURC, "\r\nCall Ready\r\n") != NULL)
102cc2e8:	0a000005 	beq	102cc304 <OnURCHandler_InitStat+0x38>
    }
    else if(Ql_strstr(strURC, "\r\nSMS Ready\r\n") != NULL)
    {
        sysInitStat = SYS_STATE_SMSOK;
    }
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SYS_INIT_STATE_IND, sysInitStat);
102cc2ec:	e59f1034 	ldr	r1, [pc, #52]	; 102cc328 <OnURCHandler_InitStat+0x5c>
102cc2f0:	e3a02001 	mov	r2, #1
102cc2f4:	e59fc030 	ldr	ip, [pc, #48]	; 102cc32c <OnURCHandler_InitStat+0x60>
102cc2f8:	e3a00000 	mov	r0, #0
102cc2fc:	e12fff3c 	blx	ip
102cc300:	e8bd8038 	pop	{r3, r4, r5, pc}
    
    if (Ql_strstr(strURC, "\r\nCall Ready\r\n") != NULL)
    {
        sysInitStat = SYS_STATE_PHBOK;
    }
    else if(Ql_strstr(strURC, "\r\nSMS Ready\r\n") != NULL)
102cc304:	e1a00005 	mov	r0, r5
102cc308:	e59f1020 	ldr	r1, [pc, #32]	; 102cc330 <OnURCHandler_InitStat+0x64>
102cc30c:	e12fff34 	blx	r4
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_MODULE_VOLTAGE_IND, volState);
}

static void OnURCHandler_InitStat(const char* strURC, void* reserved)
{
    u32 sysInitStat = SYS_STATE_START;
102cc310:	e3500000 	cmp	r0, #0
102cc314:	13a03003 	movne	r3, #3
102cc318:	03a03000 	moveq	r3, #0
102cc31c:	eafffff2 	b	102cc2ec <OnURCHandler_InitStat+0x20>
102cc320:	102ee748 	.word	0x102ee748
102cc324:	102e5a04 	.word	0x102e5a04
102cc328:	00001002 	.word	0x00001002
102cc32c:	102e5cb4 	.word	0x102e5cb4
102cc330:	102ee758 	.word	0x102ee758

102cc334 <OnURCHandler_CFUN>:
    }
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SYS_INIT_STATE_IND, sysInitStat);
}

static void OnURCHandler_CFUN(const char* strURC, void* reserved)
{
102cc334:	e92d4030 	push	{r4, r5, lr}
    char* p2 = NULL;
    char strTmp[10];
    s32 len;
    u32 cfun;

    len = Ql_strlen("\r\n+CFUN: ");
102cc338:	e59f3090 	ldr	r3, [pc, #144]	; 102cc3d0 <OnURCHandler_CFUN+0x9c>
    }
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SYS_INIT_STATE_IND, sysInitStat);
}

static void OnURCHandler_CFUN(const char* strURC, void* reserved)
{
102cc33c:	e24dd014 	sub	sp, sp, #20
102cc340:	e1a05000 	mov	r5, r0
    char* p2 = NULL;
    char strTmp[10];
    s32 len;
    u32 cfun;

    len = Ql_strlen("\r\n+CFUN: ");
102cc344:	e59f0088 	ldr	r0, [pc, #136]	; 102cc3d4 <OnURCHandler_CFUN+0xa0>
102cc348:	e12fff33 	blx	r3
    p1 = Ql_strstr(strURC, "\r\n+CFUN: ");
102cc34c:	e59f1080 	ldr	r1, [pc, #128]	; 102cc3d4 <OnURCHandler_CFUN+0xa0>
    char* p2 = NULL;
    char strTmp[10];
    s32 len;
    u32 cfun;

    len = Ql_strlen("\r\n+CFUN: ");
102cc350:	e1a04000 	mov	r4, r0
    p1 = Ql_strstr(strURC, "\r\n+CFUN: ");
102cc354:	e1a00005 	mov	r0, r5
102cc358:	e59f5078 	ldr	r5, [pc, #120]	; 102cc3d8 <OnURCHandler_CFUN+0xa4>
102cc35c:	e12fff35 	blx	r5
    p1 += len;
    p2 = Ql_strstr(p1, "\r\n");
102cc360:	e59f1074 	ldr	r1, [pc, #116]	; 102cc3dc <OnURCHandler_CFUN+0xa8>
    s32 len;
    u32 cfun;

    len = Ql_strlen("\r\n+CFUN: ");
    p1 = Ql_strstr(strURC, "\r\n+CFUN: ");
    p1 += len;
102cc364:	e0804004 	add	r4, r0, r4
    p2 = Ql_strstr(p1, "\r\n");
102cc368:	e1a00004 	mov	r0, r4
102cc36c:	e12fff35 	blx	r5
    if (p1 && p2)
102cc370:	e3540000 	cmp	r4, #0
102cc374:	13500000 	cmpne	r0, #0
102cc378:	0a000012 	beq	102cc3c8 <OnURCHandler_CFUN+0x94>
    {
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc37c:	e3a0200a 	mov	r2, #10
102cc380:	e3a01000 	mov	r1, #0
102cc384:	e59f3054 	ldr	r3, [pc, #84]	; 102cc3e0 <OnURCHandler_CFUN+0xac>
102cc388:	e28d0004 	add	r0, sp, #4
102cc38c:	e12fff33 	blx	r3
        Ql_memcpy(strTmp, p1, 1);
102cc390:	e1a01004 	mov	r1, r4
102cc394:	e3a02001 	mov	r2, #1
102cc398:	e59f3044 	ldr	r3, [pc, #68]	; 102cc3e4 <OnURCHandler_CFUN+0xb0>
102cc39c:	e28d0004 	add	r0, sp, #4
102cc3a0:	e12fff33 	blx	r3
        cfun = Ql_atoi(strTmp);
102cc3a4:	e59f303c 	ldr	r3, [pc, #60]	; 102cc3e8 <OnURCHandler_CFUN+0xb4>
102cc3a8:	e28d0004 	add	r0, sp, #4
102cc3ac:	e12fff33 	blx	r3
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_CFUN_STATE_IND, cfun);
102cc3b0:	e59f1034 	ldr	r1, [pc, #52]	; 102cc3ec <OnURCHandler_CFUN+0xb8>
102cc3b4:	e3a02005 	mov	r2, #5
102cc3b8:	e59fc030 	ldr	ip, [pc, #48]	; 102cc3f0 <OnURCHandler_CFUN+0xbc>
    p2 = Ql_strstr(p1, "\r\n");
    if (p1 && p2)
    {
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
        Ql_memcpy(strTmp, p1, 1);
        cfun = Ql_atoi(strTmp);
102cc3bc:	e1a03000 	mov	r3, r0
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_CFUN_STATE_IND, cfun);
102cc3c0:	e3a00000 	mov	r0, #0
102cc3c4:	e12fff3c 	blx	ip
    }
}
102cc3c8:	e28dd014 	add	sp, sp, #20
102cc3cc:	e8bd8030 	pop	{r4, r5, pc}
102cc3d0:	102e57a4 	.word	0x102e57a4
102cc3d4:	102ee768 	.word	0x102ee768
102cc3d8:	102e5a04 	.word	0x102e5a04
102cc3dc:	102ee78c 	.word	0x102ee78c
102cc3e0:	102e58f4 	.word	0x102e58f4
102cc3e4:	102e597c 	.word	0x102e597c
102cc3e8:	102e5a8c 	.word	0x102e5a8c
102cc3ec:	00001002 	.word	0x00001002
102cc3f0:	102e5cb4 	.word	0x102e5cb4

102cc3f4 <OnURCHandler_Voltage>:
    {
    }
}

static void OnURCHandler_Voltage(const char* strURC, void* reserved)
{
102cc3f4:	e92d4038 	push	{r3, r4, r5, lr}
    u32 volState = VBATT_UNDER_WRN;
    
    if (Ql_StrPrefixMatch(strURC, "\r\nUNDER_VOLTAGE WARNING \r\n"))
102cc3f8:	e59f107c 	ldr	r1, [pc, #124]	; 102cc47c <OnURCHandler_Voltage+0x88>
102cc3fc:	e59f407c 	ldr	r4, [pc, #124]	; 102cc480 <OnURCHandler_Voltage+0x8c>
    {
    }
}

static void OnURCHandler_Voltage(const char* strURC, void* reserved)
{
102cc400:	e1a05000 	mov	r5, r0
    u32 volState = VBATT_UNDER_WRN;
    
    if (Ql_StrPrefixMatch(strURC, "\r\nUNDER_VOLTAGE WARNING \r\n"))
102cc404:	e12fff34 	blx	r4
102cc408:	e3500000 	cmp	r0, #0
102cc40c:	1a00000b 	bne	102cc440 <OnURCHandler_Voltage+0x4c>
    {
        volState = VBATT_UNDER_WRN;
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nUNDER_VOLTAGE POWER DOWN \r\n"))
102cc410:	e1a00005 	mov	r0, r5
102cc414:	e59f1068 	ldr	r1, [pc, #104]	; 102cc484 <OnURCHandler_Voltage+0x90>
102cc418:	e12fff34 	blx	r4
102cc41c:	e3500000 	cmp	r0, #0
    {
        volState = VBATT_UNDER_PDN;
102cc420:	13a03001 	movne	r3, #1
    
    if (Ql_StrPrefixMatch(strURC, "\r\nUNDER_VOLTAGE WARNING \r\n"))
    {
        volState = VBATT_UNDER_WRN;
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nUNDER_VOLTAGE POWER DOWN \r\n"))
102cc424:	0a000007 	beq	102cc448 <OnURCHandler_Voltage+0x54>
    {
        volState = VBATT_OVER_PDN;
    }else{
        return;
    }
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_MODULE_VOLTAGE_IND, volState);
102cc428:	e59f1058 	ldr	r1, [pc, #88]	; 102cc488 <OnURCHandler_Voltage+0x94>
102cc42c:	e3a02009 	mov	r2, #9
102cc430:	e59fc054 	ldr	ip, [pc, #84]	; 102cc48c <OnURCHandler_Voltage+0x98>
102cc434:	e3a00000 	mov	r0, #0
102cc438:	e12fff3c 	blx	ip
102cc43c:	e8bd8038 	pop	{r3, r4, r5, pc}
{
    u32 volState = VBATT_UNDER_WRN;
    
    if (Ql_StrPrefixMatch(strURC, "\r\nUNDER_VOLTAGE WARNING \r\n"))
    {
        volState = VBATT_UNDER_WRN;
102cc440:	e3a03000 	mov	r3, #0
102cc444:	eafffff7 	b	102cc428 <OnURCHandler_Voltage+0x34>
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nUNDER_VOLTAGE POWER DOWN \r\n"))
    {
        volState = VBATT_UNDER_PDN;
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nOVER_VOLTAGE WARNING \r\n"))
102cc448:	e1a00005 	mov	r0, r5
102cc44c:	e59f103c 	ldr	r1, [pc, #60]	; 102cc490 <OnURCHandler_Voltage+0x9c>
102cc450:	e12fff34 	blx	r4
102cc454:	e3500000 	cmp	r0, #0
    {
        volState = VBATT_OVER_WRN;
102cc458:	13a03002 	movne	r3, #2
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nUNDER_VOLTAGE POWER DOWN \r\n"))
    {
        volState = VBATT_UNDER_PDN;
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nOVER_VOLTAGE WARNING \r\n"))
102cc45c:	1afffff1 	bne	102cc428 <OnURCHandler_Voltage+0x34>
    {
        volState = VBATT_OVER_WRN;
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nOVER_VOLTAGE POWER DOWN \r\n"))
102cc460:	e1a00005 	mov	r0, r5
102cc464:	e59f1028 	ldr	r1, [pc, #40]	; 102cc494 <OnURCHandler_Voltage+0xa0>
102cc468:	e12fff34 	blx	r4
102cc46c:	e3500000 	cmp	r0, #0
    {
        volState = VBATT_OVER_PDN;
102cc470:	13a03003 	movne	r3, #3
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nOVER_VOLTAGE WARNING \r\n"))
    {
        volState = VBATT_OVER_WRN;
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nOVER_VOLTAGE POWER DOWN \r\n"))
102cc474:	1affffeb 	bne	102cc428 <OnURCHandler_Voltage+0x34>
102cc478:	e8bd8038 	pop	{r3, r4, r5, pc}
102cc47c:	102ee774 	.word	0x102ee774
102cc480:	102ccd58 	.word	0x102ccd58
102cc484:	102ee790 	.word	0x102ee790
102cc488:	00001002 	.word	0x00001002
102cc48c:	102e5cb4 	.word	0x102e5cb4
102cc490:	102ee7b0 	.word	0x102ee7b0
102cc494:	102ee7cc 	.word	0x102ee7cc

102cc498 <OnURCHandler_Network>:


}

static void OnURCHandler_Network(const char* strURC, void* reserved)
{
102cc498:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    
    if (Ql_StrPrefixMatch(strURC, "\r\n+CREG: "))
102cc49c:	e59f1150 	ldr	r1, [pc, #336]	; 102cc5f4 <OnURCHandler_Network+0x15c>


}

static void OnURCHandler_Network(const char* strURC, void* reserved)
{
102cc4a0:	e24dd014 	sub	sp, sp, #20
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    
    if (Ql_StrPrefixMatch(strURC, "\r\n+CREG: "))
102cc4a4:	e59f414c 	ldr	r4, [pc, #332]	; 102cc5f8 <OnURCHandler_Network+0x160>


}

static void OnURCHandler_Network(const char* strURC, void* reserved)
{
102cc4a8:	e1a05000 	mov	r5, r0
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    
    if (Ql_StrPrefixMatch(strURC, "\r\n+CREG: "))
102cc4ac:	e12fff34 	blx	r4
102cc4b0:	e2506000 	subs	r6, r0, #0
102cc4b4:	0a000011 	beq	102cc500 <OnURCHandler_Network+0x68>
    {
        u32 nwStat;
        p1 = Ql_strstr(strURC, "\r\n+CREG: ");
102cc4b8:	e59f1134 	ldr	r1, [pc, #308]	; 102cc5f4 <OnURCHandler_Network+0x15c>
102cc4bc:	e59f6138 	ldr	r6, [pc, #312]	; 102cc5fc <OnURCHandler_Network+0x164>
102cc4c0:	e1a00005 	mov	r0, r5
102cc4c4:	e12fff36 	blx	r6
        p1 += Ql_strlen("\r\n+CREG: ");
102cc4c8:	e59f3130 	ldr	r3, [pc, #304]	; 102cc600 <OnURCHandler_Network+0x168>
    char strTmp[10];
    
    if (Ql_StrPrefixMatch(strURC, "\r\n+CREG: "))
    {
        u32 nwStat;
        p1 = Ql_strstr(strURC, "\r\n+CREG: ");
102cc4cc:	e1a04000 	mov	r4, r0
        p1 += Ql_strlen("\r\n+CREG: ");
102cc4d0:	e59f011c 	ldr	r0, [pc, #284]	; 102cc5f4 <OnURCHandler_Network+0x15c>
102cc4d4:	e12fff33 	blx	r3
        p2 = Ql_strstr(p1, "\r\n");
102cc4d8:	e59f1124 	ldr	r1, [pc, #292]	; 102cc604 <OnURCHandler_Network+0x16c>
    
    if (Ql_StrPrefixMatch(strURC, "\r\n+CREG: "))
    {
        u32 nwStat;
        p1 = Ql_strstr(strURC, "\r\n+CREG: ");
        p1 += Ql_strlen("\r\n+CREG: ");
102cc4dc:	e0844000 	add	r4, r4, r0
        p2 = Ql_strstr(p1, "\r\n");
102cc4e0:	e1a00004 	mov	r0, r4
102cc4e4:	e12fff36 	blx	r6
        if (p1 && p2)
102cc4e8:	e3540000 	cmp	r4, #0
102cc4ec:	13500000 	cmpne	r0, #0
102cc4f0:	e1a05000 	mov	r5, r0
102cc4f4:	1a00002a 	bne	102cc5a4 <OnURCHandler_Network+0x10c>
            Ql_memcpy(strTmp, p1, p2 - p1);
            nwStat = Ql_atoi(strTmp);
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GPRS_NW_STATE_IND, nwStat);
        }
    }
}
102cc4f8:	e28dd014 	add	sp, sp, #20
102cc4fc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
            Ql_memcpy(strTmp, p1, p2 - p1);
            nwStat = Ql_atoi(strTmp);
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GSM_NW_STATE_IND, nwStat);
        }
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\n+CGREG: "))
102cc500:	e1a00005 	mov	r0, r5
102cc504:	e59f10fc 	ldr	r1, [pc, #252]	; 102cc608 <OnURCHandler_Network+0x170>
102cc508:	e12fff34 	blx	r4
102cc50c:	e3500000 	cmp	r0, #0
102cc510:	0afffff8 	beq	102cc4f8 <OnURCHandler_Network+0x60>
    {
        u32 nwStat;
        p1 = Ql_strstr(strURC, "\r\n+CGREG: ");
102cc514:	e59f10ec 	ldr	r1, [pc, #236]	; 102cc608 <OnURCHandler_Network+0x170>
102cc518:	e59f70dc 	ldr	r7, [pc, #220]	; 102cc5fc <OnURCHandler_Network+0x164>
102cc51c:	e1a00005 	mov	r0, r5
102cc520:	e12fff37 	blx	r7
        p1 += Ql_strlen("\r\n+CGREG: ");
102cc524:	e59f30d4 	ldr	r3, [pc, #212]	; 102cc600 <OnURCHandler_Network+0x168>
        }
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\n+CGREG: "))
    {
        u32 nwStat;
        p1 = Ql_strstr(strURC, "\r\n+CGREG: ");
102cc528:	e1a04000 	mov	r4, r0
        p1 += Ql_strlen("\r\n+CGREG: ");
102cc52c:	e59f00d4 	ldr	r0, [pc, #212]	; 102cc608 <OnURCHandler_Network+0x170>
102cc530:	e12fff33 	blx	r3
        p2 = Ql_strstr(p1, "\r\n");
102cc534:	e59f10c8 	ldr	r1, [pc, #200]	; 102cc604 <OnURCHandler_Network+0x16c>
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\n+CGREG: "))
    {
        u32 nwStat;
        p1 = Ql_strstr(strURC, "\r\n+CGREG: ");
        p1 += Ql_strlen("\r\n+CGREG: ");
102cc538:	e0844000 	add	r4, r4, r0
        p2 = Ql_strstr(p1, "\r\n");
102cc53c:	e1a00004 	mov	r0, r4
102cc540:	e12fff37 	blx	r7
        if (p1 && p2)
102cc544:	e3540000 	cmp	r4, #0
102cc548:	13500000 	cmpne	r0, #0
102cc54c:	e1a05000 	mov	r5, r0
102cc550:	0affffe8 	beq	102cc4f8 <OnURCHandler_Network+0x60>
        {
            Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc554:	e1a01006 	mov	r1, r6
102cc558:	e3a0200a 	mov	r2, #10
102cc55c:	e28d0004 	add	r0, sp, #4
102cc560:	e59f30a4 	ldr	r3, [pc, #164]	; 102cc60c <OnURCHandler_Network+0x174>
102cc564:	e12fff33 	blx	r3
            Ql_memcpy(strTmp, p1, p2 - p1);
102cc568:	e1a01004 	mov	r1, r4
102cc56c:	e0642005 	rsb	r2, r4, r5
102cc570:	e28d0004 	add	r0, sp, #4
102cc574:	e59f3094 	ldr	r3, [pc, #148]	; 102cc610 <OnURCHandler_Network+0x178>
102cc578:	e12fff33 	blx	r3
            nwStat = Ql_atoi(strTmp);
102cc57c:	e28d0004 	add	r0, sp, #4
102cc580:	e59f308c 	ldr	r3, [pc, #140]	; 102cc614 <OnURCHandler_Network+0x17c>
102cc584:	e12fff33 	blx	r3
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GPRS_NW_STATE_IND, nwStat);
102cc588:	e59f1088 	ldr	r1, [pc, #136]	; 102cc618 <OnURCHandler_Network+0x180>
102cc58c:	e3a02004 	mov	r2, #4
102cc590:	e59fc084 	ldr	ip, [pc, #132]	; 102cc61c <OnURCHandler_Network+0x184>
        p2 = Ql_strstr(p1, "\r\n");
        if (p1 && p2)
        {
            Ql_memset(strTmp, 0x0, sizeof(strTmp));
            Ql_memcpy(strTmp, p1, p2 - p1);
            nwStat = Ql_atoi(strTmp);
102cc594:	e1a03000 	mov	r3, r0
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GPRS_NW_STATE_IND, nwStat);
102cc598:	e1a00006 	mov	r0, r6
102cc59c:	e12fff3c 	blx	ip
102cc5a0:	eaffffd4 	b	102cc4f8 <OnURCHandler_Network+0x60>
        p1 = Ql_strstr(strURC, "\r\n+CREG: ");
        p1 += Ql_strlen("\r\n+CREG: ");
        p2 = Ql_strstr(p1, "\r\n");
        if (p1 && p2)
        {
            Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc5a4:	e28d0004 	add	r0, sp, #4
102cc5a8:	e3a0200a 	mov	r2, #10
102cc5ac:	e3a01000 	mov	r1, #0
102cc5b0:	e59f3054 	ldr	r3, [pc, #84]	; 102cc60c <OnURCHandler_Network+0x174>
102cc5b4:	e12fff33 	blx	r3
            Ql_memcpy(strTmp, p1, p2 - p1);
102cc5b8:	e1a01004 	mov	r1, r4
102cc5bc:	e0642005 	rsb	r2, r4, r5
102cc5c0:	e28d0004 	add	r0, sp, #4
102cc5c4:	e59f3044 	ldr	r3, [pc, #68]	; 102cc610 <OnURCHandler_Network+0x178>
102cc5c8:	e12fff33 	blx	r3
            nwStat = Ql_atoi(strTmp);
102cc5cc:	e28d0004 	add	r0, sp, #4
102cc5d0:	e59f303c 	ldr	r3, [pc, #60]	; 102cc614 <OnURCHandler_Network+0x17c>
102cc5d4:	e12fff33 	blx	r3
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GSM_NW_STATE_IND, nwStat);
102cc5d8:	e59f1038 	ldr	r1, [pc, #56]	; 102cc618 <OnURCHandler_Network+0x180>
102cc5dc:	e3a02003 	mov	r2, #3
102cc5e0:	e59fc034 	ldr	ip, [pc, #52]	; 102cc61c <OnURCHandler_Network+0x184>
        p2 = Ql_strstr(p1, "\r\n");
        if (p1 && p2)
        {
            Ql_memset(strTmp, 0x0, sizeof(strTmp));
            Ql_memcpy(strTmp, p1, p2 - p1);
            nwStat = Ql_atoi(strTmp);
102cc5e4:	e1a03000 	mov	r3, r0
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GSM_NW_STATE_IND, nwStat);
102cc5e8:	e3a00000 	mov	r0, #0
102cc5ec:	e12fff3c 	blx	ip
102cc5f0:	eaffffc0 	b	102cc4f8 <OnURCHandler_Network+0x60>
102cc5f4:	102ee7ec 	.word	0x102ee7ec
102cc5f8:	102ccd58 	.word	0x102ccd58
102cc5fc:	102e5a04 	.word	0x102e5a04
102cc600:	102e57a4 	.word	0x102e57a4
102cc604:	102ee78c 	.word	0x102ee78c
102cc608:	102ee7f8 	.word	0x102ee7f8
102cc60c:	102e58f4 	.word	0x102e58f4
102cc610:	102e597c 	.word	0x102e597c
102cc614:	102e5a8c 	.word	0x102e5a8c
102cc618:	00001002 	.word	0x00001002
102cc61c:	102e5cb4 	.word	0x102e5cb4

102cc620 <OnURCHandler_Call>:
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GPRS_NW_STATE_IND, nwStat);
        }
    }
}
static void OnURCHandler_Call(const char* strURC, void* reserved)
{
102cc620:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    if (Ql_StrPrefixMatch(strURC, "\r\nRING\r\n") || 
102cc624:	e59f123c 	ldr	r1, [pc, #572]	; 102cc868 <OnURCHandler_Call+0x248>
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GPRS_NW_STATE_IND, nwStat);
        }
    }
}
static void OnURCHandler_Call(const char* strURC, void* reserved)
{
102cc628:	e24dd010 	sub	sp, sp, #16
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    if (Ql_StrPrefixMatch(strURC, "\r\nRING\r\n") || 
102cc62c:	e59f4238 	ldr	r4, [pc, #568]	; 102cc86c <OnURCHandler_Call+0x24c>
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_GPRS_NW_STATE_IND, nwStat);
        }
    }
}
static void OnURCHandler_Call(const char* strURC, void* reserved)
{
102cc630:	e1a05000 	mov	r5, r0
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    if (Ql_StrPrefixMatch(strURC, "\r\nRING\r\n") || 
102cc634:	e12fff34 	blx	r4
102cc638:	e3500000 	cmp	r0, #0
102cc63c:	1a000004 	bne	102cc654 <OnURCHandler_Call+0x34>
        Ql_StrPrefixMatch(strURC, "\r\n+CLIP:") ||
102cc640:	e1a00005 	mov	r0, r5
102cc644:	e59f1224 	ldr	r1, [pc, #548]	; 102cc870 <OnURCHandler_Call+0x250>
102cc648:	e12fff34 	blx	r4
static void OnURCHandler_Call(const char* strURC, void* reserved)
{
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    if (Ql_StrPrefixMatch(strURC, "\r\nRING\r\n") || 
102cc64c:	e3500000 	cmp	r0, #0
102cc650:	0a00004a 	beq	102cc780 <OnURCHandler_Call+0x160>
        Ql_StrPrefixMatch(strURC, "\r\n+CRING: VOICE\r\n"))
    {// Coming call
        extern ST_ComingCallInfo  g_comingCall;
        u16 len;

        p1 = Ql_strstr(strURC, "\r\n+CLIP:");
102cc654:	e1a00005 	mov	r0, r5
102cc658:	e59f1210 	ldr	r1, [pc, #528]	; 102cc870 <OnURCHandler_Call+0x250>
102cc65c:	e59f5210 	ldr	r5, [pc, #528]	; 102cc874 <OnURCHandler_Call+0x254>
102cc660:	e12fff35 	blx	r5
        if (!p1)
102cc664:	e250a000 	subs	sl, r0, #0
102cc668:	0a000042 	beq	102cc778 <OnURCHandler_Call+0x158>
        {
            return;
        }

        g_comingCall.ringCnt++;
102cc66c:	e59f4204 	ldr	r4, [pc, #516]	; 102cc878 <OnURCHandler_Call+0x258>
        {
            g_comingCall.ringCnt %= 6;
        }

        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
102cc670:	e59f01f8 	ldr	r0, [pc, #504]	; 102cc870 <OnURCHandler_Call+0x250>
        if (!p1)
        {
            return;
        }

        g_comingCall.ringCnt++;
102cc674:	e5943000 	ldr	r3, [r4]

        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
        p2 = Ql_strstr(p1 + 1, ",");
        len = p2 - (p1 + 2) - 1;
        Ql_memcpy(g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber, p1 + 2, len);
102cc678:	e59f81fc 	ldr	r8, [pc, #508]	; 102cc87c <OnURCHandler_Call+0x25c>
        if (!p1)
        {
            return;
        }

        g_comingCall.ringCnt++;
102cc67c:	e2833001 	add	r3, r3, #1
        if ((g_comingCall.ringCnt / 6) > 0)
102cc680:	e3530005 	cmp	r3, #5
        {
            g_comingCall.ringCnt %= 6;
102cc684:	859f21f4 	ldrhi	r2, [pc, #500]	; 102cc880 <OnURCHandler_Call+0x260>
        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
        p2 = Ql_strstr(p1 + 1, ",");
        len = p2 - (p1 + 2) - 1;
        Ql_memcpy(g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber, p1 + 2, len);
        g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber[len] = '\0';
102cc688:	e3a06000 	mov	r6, #0
        }

        g_comingCall.ringCnt++;
        if ((g_comingCall.ringCnt / 6) > 0)
        {
            g_comingCall.ringCnt %= 6;
102cc68c:	80821293 	umullhi	r1, r2, r3, r2
102cc690:	81a02122 	lsrhi	r2, r2, #2
102cc694:	80822082 	addhi	r2, r2, r2, lsl #1
102cc698:	80433082 	subhi	r3, r3, r2, lsl #1
102cc69c:	e5843000 	str	r3, [r4]
        }

        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
102cc6a0:	e59f31dc 	ldr	r3, [pc, #476]	; 102cc884 <OnURCHandler_Call+0x264>
102cc6a4:	e12fff33 	blx	r3
        p2 = Ql_strstr(p1 + 1, ",");
102cc6a8:	e59f11d8 	ldr	r1, [pc, #472]	; 102cc888 <OnURCHandler_Call+0x268>
        {
            g_comingCall.ringCnt %= 6;
        }

        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
102cc6ac:	e08aa000 	add	sl, sl, r0
        p2 = Ql_strstr(p1 + 1, ",");
102cc6b0:	e28a0001 	add	r0, sl, #1
102cc6b4:	e12fff35 	blx	r5
        len = p2 - (p1 + 2) - 1;
102cc6b8:	e28a1002 	add	r1, sl, #2
        Ql_memcpy(g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber, p1 + 2, len);
102cc6bc:	e5943000 	ldr	r3, [r4]
102cc6c0:	e0833083 	add	r3, r3, r3, lsl #1
        }

        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
        p2 = Ql_strstr(p1 + 1, ",");
        len = p2 - (p1 + 2) - 1;
102cc6c4:	e0619000 	rsb	r9, r1, r0
102cc6c8:	e2499001 	sub	r9, r9, #1
102cc6cc:	e1a09809 	lsl	r9, r9, #16
            g_comingCall.ringCnt %= 6;
        }

        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
        p2 = Ql_strstr(p1 + 1, ",");
102cc6d0:	e1a07000 	mov	r7, r0
        len = p2 - (p1 + 2) - 1;
102cc6d4:	e1a09829 	lsr	r9, r9, #16
        Ql_memcpy(g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber, p1 + 2, len);
102cc6d8:	e0840203 	add	r0, r4, r3, lsl #4
102cc6dc:	e1a02009 	mov	r2, r9
102cc6e0:	e2800008 	add	r0, r0, #8
102cc6e4:	e12fff38 	blx	r8
        g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber[len] = '\0';
102cc6e8:	e5943000 	ldr	r3, [r4]

        // Retrieve number type
        p1 = p2;
        p2 = Ql_strstr(p1 + 1, ",");
102cc6ec:	e287a001 	add	sl, r7, #1
        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
        p2 = Ql_strstr(p1 + 1, ",");
        len = p2 - (p1 + 2) - 1;
        Ql_memcpy(g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber, p1 + 2, len);
        g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber[len] = '\0';
102cc6f0:	e0833083 	add	r3, r3, r3, lsl #1
102cc6f4:	e0899203 	add	r9, r9, r3, lsl #4
102cc6f8:	e0849009 	add	r9, r4, r9

        // Retrieve number type
        p1 = p2;
        p2 = Ql_strstr(p1 + 1, ",");
102cc6fc:	e59f1184 	ldr	r1, [pc, #388]	; 102cc888 <OnURCHandler_Call+0x268>
102cc700:	e1a0000a 	mov	r0, sl
        // Retrieve phone number
        p1 += Ql_strlen("\r\n+CLIP:");
        p2 = Ql_strstr(p1 + 1, ",");
        len = p2 - (p1 + 2) - 1;
        Ql_memcpy(g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber, p1 + 2, len);
        g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber[len] = '\0';
102cc704:	e5c96008 	strb	r6, [r9, #8]

        // Retrieve number type
        p1 = p2;
        p2 = Ql_strstr(p1 + 1, ",");
102cc708:	e12fff35 	blx	r5
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc70c:	e59f3178 	ldr	r3, [pc, #376]	; 102cc88c <OnURCHandler_Call+0x26c>
102cc710:	e1a01006 	mov	r1, r6
102cc714:	e3a0200a 	mov	r2, #10
        Ql_memcpy(g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber, p1 + 2, len);
        g_comingCall.comingCall[g_comingCall.ringCnt].phoneNumber[len] = '\0';

        // Retrieve number type
        p1 = p2;
        p2 = Ql_strstr(p1 + 1, ",");
102cc718:	e1a05000 	mov	r5, r0
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc71c:	e28d0004 	add	r0, sp, #4
102cc720:	e12fff33 	blx	r3
        Ql_memcpy(strTmp, p1 + 1, p2 - p1 -1);
102cc724:	e0672005 	rsb	r2, r7, r5
102cc728:	e1a0100a 	mov	r1, sl
102cc72c:	e2422001 	sub	r2, r2, #1
102cc730:	e28d0004 	add	r0, sp, #4
102cc734:	e12fff38 	blx	r8
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
102cc738:	e59f3150 	ldr	r3, [pc, #336]	; 102cc890 <OnURCHandler_Call+0x270>
102cc73c:	e28d0004 	add	r0, sp, #4
102cc740:	e5945000 	ldr	r5, [r4]
102cc744:	e12fff33 	blx	r3
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
102cc748:	e5943000 	ldr	r3, [r4]
        // Retrieve number type
        p1 = p2;
        p2 = Ql_strstr(p1 + 1, ",");
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
        Ql_memcpy(strTmp, p1 + 1, p2 - p1 -1);
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
102cc74c:	e0855085 	add	r5, r5, r5, lsl #1
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
102cc750:	e0833083 	add	r3, r3, r3, lsl #1
        // Retrieve number type
        p1 = p2;
        p2 = Ql_strstr(p1 + 1, ",");
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
        Ql_memcpy(strTmp, p1 + 1, p2 - p1 -1);
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
102cc754:	e0845205 	add	r5, r4, r5, lsl #4
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
102cc758:	e0843203 	add	r3, r4, r3, lsl #4
102cc75c:	e59f1130 	ldr	r1, [pc, #304]	; 102cc894 <OnURCHandler_Call+0x274>
102cc760:	e3a02006 	mov	r2, #6
102cc764:	e2833004 	add	r3, r3, #4
102cc768:	e59fc128 	ldr	ip, [pc, #296]	; 102cc898 <OnURCHandler_Call+0x278>
        // Retrieve number type
        p1 = p2;
        p2 = Ql_strstr(p1 + 1, ",");
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
        Ql_memcpy(strTmp, p1 + 1, p2 - p1 -1);
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
102cc76c:	e5850004 	str	r0, [r5, #4]
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
102cc770:	e1a00006 	mov	r0, r6
102cc774:	e12fff3c 	blx	ip
        }else{
            return;
        }
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_CALL_STATE_IND, callStat);
    }
}
102cc778:	e28dd010 	add	sp, sp, #16
102cc77c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    if (Ql_StrPrefixMatch(strURC, "\r\nRING\r\n") || 
        Ql_StrPrefixMatch(strURC, "\r\n+CLIP:") ||
        Ql_StrPrefixMatch(strURC, "\r\n+CRING: VOICE\r\n"))
102cc780:	e1a00005 	mov	r0, r5
102cc784:	e59f1110 	ldr	r1, [pc, #272]	; 102cc89c <OnURCHandler_Call+0x27c>
102cc788:	e12fff34 	blx	r4
{
    char* p1 = NULL;
    char* p2 = NULL;
    char strTmp[10];
    if (Ql_StrPrefixMatch(strURC, "\r\nRING\r\n") || 
        Ql_StrPrefixMatch(strURC, "\r\n+CLIP:") ||
102cc78c:	e3500000 	cmp	r0, #0
102cc790:	1affffaf 	bne	102cc654 <OnURCHandler_Call+0x34>
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
        Ql_memcpy(strTmp, p1 + 1, p2 - p1 -1);
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nBUSY\r\n")         ||
102cc794:	e1a00005 	mov	r0, r5
102cc798:	e59f1100 	ldr	r1, [pc, #256]	; 102cc8a0 <OnURCHandler_Call+0x280>
102cc79c:	e12fff34 	blx	r4
102cc7a0:	e3500000 	cmp	r0, #0
102cc7a4:	1a000004 	bne	102cc7bc <OnURCHandler_Call+0x19c>
             Ql_StrPrefixMatch(strURC, "\r\nNO ANSWER\r\n")    ||
102cc7a8:	e1a00005 	mov	r0, r5
102cc7ac:	e59f10f0 	ldr	r1, [pc, #240]	; 102cc8a4 <OnURCHandler_Call+0x284>
102cc7b0:	e12fff34 	blx	r4
        Ql_memset(strTmp, 0x0, sizeof(strTmp));
        Ql_memcpy(strTmp, p1 + 1, p2 - p1 -1);
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nBUSY\r\n")         ||
102cc7b4:	e3500000 	cmp	r0, #0
102cc7b8:	0a00001f 	beq	102cc83c <OnURCHandler_Call+0x21c>
             Ql_StrPrefixMatch(strURC, "\r\nNO CARRIER\r\n")   ||
             Ql_StrPrefixMatch(strURC, "\r\nNO DIALTONE\r\n"))
    {
        u32 callStat;

        if (Ql_StrPrefixMatch(strURC, "\r\nBUSY\r\n"))
102cc7bc:	e1a00005 	mov	r0, r5
102cc7c0:	e59f10d8 	ldr	r1, [pc, #216]	; 102cc8a0 <OnURCHandler_Call+0x280>
102cc7c4:	e12fff34 	blx	r4
102cc7c8:	e59f409c 	ldr	r4, [pc, #156]	; 102cc86c <OnURCHandler_Call+0x24c>
102cc7cc:	e3500000 	cmp	r0, #0
102cc7d0:	0a000006 	beq	102cc7f0 <OnURCHandler_Call+0x1d0>
        {
            callStat = CALL_STATE_BUSY;
102cc7d4:	e3a03001 	mov	r3, #1
        {
            callStat = CALL_STATE_NO_DIALTONE;
        }else{
            return;
        }
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_CALL_STATE_IND, callStat);
102cc7d8:	e59f10b4 	ldr	r1, [pc, #180]	; 102cc894 <OnURCHandler_Call+0x274>
102cc7dc:	e3a02007 	mov	r2, #7
102cc7e0:	e59fc0b0 	ldr	ip, [pc, #176]	; 102cc898 <OnURCHandler_Call+0x278>
102cc7e4:	e3a00000 	mov	r0, #0
102cc7e8:	e12fff3c 	blx	ip
102cc7ec:	eaffffe1 	b	102cc778 <OnURCHandler_Call+0x158>

        if (Ql_StrPrefixMatch(strURC, "\r\nBUSY\r\n"))
        {
            callStat = CALL_STATE_BUSY;
        }
        else if (Ql_StrPrefixMatch(strURC, "\r\nNO ANSWER\r\n"))
102cc7f0:	e1a00005 	mov	r0, r5
102cc7f4:	e59f10a8 	ldr	r1, [pc, #168]	; 102cc8a4 <OnURCHandler_Call+0x284>
102cc7f8:	e12fff34 	blx	r4
102cc7fc:	e3500000 	cmp	r0, #0
        {
            callStat = CALL_STATE_NO_ANSWER;
102cc800:	13a03002 	movne	r3, #2

        if (Ql_StrPrefixMatch(strURC, "\r\nBUSY\r\n"))
        {
            callStat = CALL_STATE_BUSY;
        }
        else if (Ql_StrPrefixMatch(strURC, "\r\nNO ANSWER\r\n"))
102cc804:	1afffff3 	bne	102cc7d8 <OnURCHandler_Call+0x1b8>
        {
            callStat = CALL_STATE_NO_ANSWER;
        }
        else if (Ql_StrPrefixMatch(strURC, "\r\nNO CARRIER\r\n"))
102cc808:	e1a00005 	mov	r0, r5
102cc80c:	e59f1094 	ldr	r1, [pc, #148]	; 102cc8a8 <OnURCHandler_Call+0x288>
102cc810:	e12fff34 	blx	r4
102cc814:	e3500000 	cmp	r0, #0
        {
            callStat = CALL_STATE_NO_CARRIER;
102cc818:	13a03003 	movne	r3, #3
        }
        else if (Ql_StrPrefixMatch(strURC, "\r\nNO ANSWER\r\n"))
        {
            callStat = CALL_STATE_NO_ANSWER;
        }
        else if (Ql_StrPrefixMatch(strURC, "\r\nNO CARRIER\r\n"))
102cc81c:	1affffed 	bne	102cc7d8 <OnURCHandler_Call+0x1b8>
        {
            callStat = CALL_STATE_NO_CARRIER;
        }
        else if (Ql_StrPrefixMatch(strURC, "\r\nNO DIALTONE\r\n"))
102cc820:	e1a00005 	mov	r0, r5
102cc824:	e59f1080 	ldr	r1, [pc, #128]	; 102cc8ac <OnURCHandler_Call+0x28c>
102cc828:	e12fff34 	blx	r4
102cc82c:	e3500000 	cmp	r0, #0
        {
            callStat = CALL_STATE_NO_DIALTONE;
102cc830:	13a03004 	movne	r3, #4
        }
        else if (Ql_StrPrefixMatch(strURC, "\r\nNO CARRIER\r\n"))
        {
            callStat = CALL_STATE_NO_CARRIER;
        }
        else if (Ql_StrPrefixMatch(strURC, "\r\nNO DIALTONE\r\n"))
102cc834:	1affffe7 	bne	102cc7d8 <OnURCHandler_Call+0x1b8>
102cc838:	eaffffce 	b	102cc778 <OnURCHandler_Call+0x158>
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nBUSY\r\n")         ||
             Ql_StrPrefixMatch(strURC, "\r\nNO ANSWER\r\n")    ||
             Ql_StrPrefixMatch(strURC, "\r\nNO CARRIER\r\n")   ||
102cc83c:	e1a00005 	mov	r0, r5
102cc840:	e59f1060 	ldr	r1, [pc, #96]	; 102cc8a8 <OnURCHandler_Call+0x288>
102cc844:	e12fff34 	blx	r4
        Ql_memcpy(strTmp, p1 + 1, p2 - p1 -1);
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nBUSY\r\n")         ||
             Ql_StrPrefixMatch(strURC, "\r\nNO ANSWER\r\n")    ||
102cc848:	e3500000 	cmp	r0, #0
102cc84c:	1affffda 	bne	102cc7bc <OnURCHandler_Call+0x19c>
             Ql_StrPrefixMatch(strURC, "\r\nNO CARRIER\r\n")   ||
             Ql_StrPrefixMatch(strURC, "\r\nNO DIALTONE\r\n"))
102cc850:	e1a00005 	mov	r0, r5
102cc854:	e59f1050 	ldr	r1, [pc, #80]	; 102cc8ac <OnURCHandler_Call+0x28c>
102cc858:	e12fff34 	blx	r4
        g_comingCall.comingCall[g_comingCall.ringCnt].type = Ql_atoi(strTmp);
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_COMING_CALL_IND, (u32)(&(g_comingCall.comingCall[g_comingCall.ringCnt])));
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\nBUSY\r\n")         ||
             Ql_StrPrefixMatch(strURC, "\r\nNO ANSWER\r\n")    ||
             Ql_StrPrefixMatch(strURC, "\r\nNO CARRIER\r\n")   ||
102cc85c:	e3500000 	cmp	r0, #0
102cc860:	1affffd5 	bne	102cc7bc <OnURCHandler_Call+0x19c>
102cc864:	eaffffc3 	b	102cc778 <OnURCHandler_Call+0x158>
102cc868:	102ee804 	.word	0x102ee804
102cc86c:	102ccd58 	.word	0x102ccd58
102cc870:	102ee810 	.word	0x102ee810
102cc874:	102e5a04 	.word	0x102e5a04
102cc878:	f03db7c8 	.word	0xf03db7c8
102cc87c:	102e597c 	.word	0x102e597c
102cc880:	aaaaaaab 	.word	0xaaaaaaab
102cc884:	102e57a4 	.word	0x102e57a4
102cc888:	102ee830 	.word	0x102ee830
102cc88c:	102e58f4 	.word	0x102e58f4
102cc890:	102e5a8c 	.word	0x102e5a8c
102cc894:	00001002 	.word	0x00001002
102cc898:	102e5cb4 	.word	0x102e5cb4
102cc89c:	102ee81c 	.word	0x102ee81c
102cc8a0:	102ee834 	.word	0x102ee834
102cc8a4:	102ee840 	.word	0x102ee840
102cc8a8:	102ee850 	.word	0x102ee850
102cc8ac:	102ee860 	.word	0x102ee860

102cc8b0 <OnURCHandler_SIM>:
    {"\r\n+QTONEDET:",                            OnURCHandler_QToneDet},
    {"\r\n+QWDTMF:",                              OnURCHandler_QWDTMF},
};

static void OnURCHandler_SIM(const char* strURC, void* reserved)
{
102cc8b0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102cc8b4:	e24dd01c 	sub	sp, sp, #28
    char* p2 = NULL;
    char strTmp[20];
    s32 len;
    extern s32 RIL_SIM_GetSimStateByName(char* simStat, u32 len);

    Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc8b8:	e3a02014 	mov	r2, #20
    {"\r\n+QTONEDET:",                            OnURCHandler_QToneDet},
    {"\r\n+QWDTMF:",                              OnURCHandler_QWDTMF},
};

static void OnURCHandler_SIM(const char* strURC, void* reserved)
{
102cc8bc:	e1a04000 	mov	r4, r0
    char* p2 = NULL;
    char strTmp[20];
    s32 len;
    extern s32 RIL_SIM_GetSimStateByName(char* simStat, u32 len);

    Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc8c0:	e3a01000 	mov	r1, #0
102cc8c4:	e28d0004 	add	r0, sp, #4
102cc8c8:	e59f50b8 	ldr	r5, [pc, #184]	; 102cc988 <OnURCHandler_SIM+0xd8>
102cc8cc:	e12fff35 	blx	r5
    len = Ql_sprintf(strTmp, "\r\n+CPIN: ");
102cc8d0:	e59f30b4 	ldr	r3, [pc, #180]	; 102cc98c <OnURCHandler_SIM+0xdc>
102cc8d4:	e59f10b4 	ldr	r1, [pc, #180]	; 102cc990 <OnURCHandler_SIM+0xe0>
102cc8d8:	e5933000 	ldr	r3, [r3]
102cc8dc:	e28d0004 	add	r0, sp, #4
102cc8e0:	e12fff33 	blx	r3
    if (Ql_StrPrefixMatch(strURC, strTmp))
102cc8e4:	e28d1004 	add	r1, sp, #4
102cc8e8:	e59f30a4 	ldr	r3, [pc, #164]	; 102cc994 <OnURCHandler_SIM+0xe4>
    char strTmp[20];
    s32 len;
    extern s32 RIL_SIM_GetSimStateByName(char* simStat, u32 len);

    Ql_memset(strTmp, 0x0, sizeof(strTmp));
    len = Ql_sprintf(strTmp, "\r\n+CPIN: ");
102cc8ec:	e1a06000 	mov	r6, r0
    if (Ql_StrPrefixMatch(strURC, strTmp))
102cc8f0:	e1a00004 	mov	r0, r4
102cc8f4:	e12fff33 	blx	r3
102cc8f8:	e3500000 	cmp	r0, #0
102cc8fc:	1a000001 	bne	102cc908 <OnURCHandler_SIM+0x58>
            Ql_memcpy(strTmp, p1, p2 - p1);
            cpinStat = (u32)RIL_SIM_GetSimStateByName(strTmp, p2 - p1);
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SIM_CARD_STATE_IND, cpinStat);
        }
    }
}
102cc900:	e28dd01c 	add	sp, sp, #28
102cc904:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

    Ql_memset(strTmp, 0x0, sizeof(strTmp));
    len = Ql_sprintf(strTmp, "\r\n+CPIN: ");
    if (Ql_StrPrefixMatch(strURC, strTmp))
    {
        p1 = Ql_strstr(strURC, "\r\n+CPIN: ");
102cc908:	e59f1080 	ldr	r1, [pc, #128]	; 102cc990 <OnURCHandler_SIM+0xe0>
102cc90c:	e59f7084 	ldr	r7, [pc, #132]	; 102cc998 <OnURCHandler_SIM+0xe8>
102cc910:	e1a00004 	mov	r0, r4
102cc914:	e12fff37 	blx	r7
        p1 += len;
        p2 = Ql_strstr(p1, "\r\n");
102cc918:	e59f107c 	ldr	r1, [pc, #124]	; 102cc99c <OnURCHandler_SIM+0xec>
    Ql_memset(strTmp, 0x0, sizeof(strTmp));
    len = Ql_sprintf(strTmp, "\r\n+CPIN: ");
    if (Ql_StrPrefixMatch(strURC, strTmp))
    {
        p1 = Ql_strstr(strURC, "\r\n+CPIN: ");
        p1 += len;
102cc91c:	e0804006 	add	r4, r0, r6
        p2 = Ql_strstr(p1, "\r\n");
102cc920:	e1a00004 	mov	r0, r4
102cc924:	e12fff37 	blx	r7
        if (p1 && p2)
102cc928:	e3540000 	cmp	r4, #0
102cc92c:	13500000 	cmpne	r0, #0
102cc930:	0afffff2 	beq	102cc900 <OnURCHandler_SIM+0x50>
        {
            u32 cpinStat;
            Ql_memset(strTmp, 0x0, sizeof(strTmp));
            Ql_memcpy(strTmp, p1, p2 - p1);
102cc934:	e0646000 	rsb	r6, r4, r0
        p1 += len;
        p2 = Ql_strstr(p1, "\r\n");
        if (p1 && p2)
        {
            u32 cpinStat;
            Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cc938:	e3a01000 	mov	r1, #0
102cc93c:	e3a02014 	mov	r2, #20
102cc940:	e28d0004 	add	r0, sp, #4
102cc944:	e12fff35 	blx	r5
            Ql_memcpy(strTmp, p1, p2 - p1);
102cc948:	e1a02006 	mov	r2, r6
102cc94c:	e1a01004 	mov	r1, r4
102cc950:	e28d0004 	add	r0, sp, #4
102cc954:	e59f3044 	ldr	r3, [pc, #68]	; 102cc9a0 <OnURCHandler_SIM+0xf0>
102cc958:	e12fff33 	blx	r3
            cpinStat = (u32)RIL_SIM_GetSimStateByName(strTmp, p2 - p1);
102cc95c:	e1a01006 	mov	r1, r6
102cc960:	e28d0004 	add	r0, sp, #4
102cc964:	e59f3038 	ldr	r3, [pc, #56]	; 102cc9a4 <OnURCHandler_SIM+0xf4>
102cc968:	e12fff33 	blx	r3
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SIM_CARD_STATE_IND, cpinStat);
102cc96c:	e59f1034 	ldr	r1, [pc, #52]	; 102cc9a8 <OnURCHandler_SIM+0xf8>
102cc970:	e3a02002 	mov	r2, #2
102cc974:	e59fc030 	ldr	ip, [pc, #48]	; 102cc9ac <OnURCHandler_SIM+0xfc>
        if (p1 && p2)
        {
            u32 cpinStat;
            Ql_memset(strTmp, 0x0, sizeof(strTmp));
            Ql_memcpy(strTmp, p1, p2 - p1);
            cpinStat = (u32)RIL_SIM_GetSimStateByName(strTmp, p2 - p1);
102cc978:	e1a03000 	mov	r3, r0
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SIM_CARD_STATE_IND, cpinStat);
102cc97c:	e3a00000 	mov	r0, #0
102cc980:	e12fff3c 	blx	ip
102cc984:	eaffffdd 	b	102cc900 <OnURCHandler_SIM+0x50>
102cc988:	102e58f4 	.word	0x102e58f4
102cc98c:	f03de540 	.word	0xf03de540
102cc990:	102ee870 	.word	0x102ee870
102cc994:	102ccd58 	.word	0x102ccd58
102cc998:	102e5a04 	.word	0x102e5a04
102cc99c:	102ee78c 	.word	0x102ee78c
102cc9a0:	102e597c 	.word	0x102e597c
102cc9a4:	102cbb40 	.word	0x102cbb40
102cc9a8:	00001002 	.word	0x00001002
102cc9ac:	102e5cb4 	.word	0x102e5cb4

102cc9b0 <OnURCHandler_Recvssl>:
    }
}

//+QSSLURC: "recv",0,0
static void OnURCHandler_Recvssl(const char* strURC, void* reserved)
{
102cc9b0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    char* p2 = NULL;
    char strTmp[10];
    
	// APP_DEBUG("strURC : %s\r\n", strURC);
	
    if (Ql_StrPrefixMatch(strURC, "\r\n+QSSLURC: "))
102cc9b4:	e59f10dc 	ldr	r1, [pc, #220]	; 102cca98 <OnURCHandler_Recvssl+0xe8>
    }
}

//+QSSLURC: "recv",0,0
static void OnURCHandler_Recvssl(const char* strURC, void* reserved)
{
102cc9b8:	e24dd010 	sub	sp, sp, #16
    char* p2 = NULL;
    char strTmp[10];
    
	// APP_DEBUG("strURC : %s\r\n", strURC);
	
    if (Ql_StrPrefixMatch(strURC, "\r\n+QSSLURC: "))
102cc9bc:	e59f30d8 	ldr	r3, [pc, #216]	; 102cca9c <OnURCHandler_Recvssl+0xec>
    }
}

//+QSSLURC: "recv",0,0
static void OnURCHandler_Recvssl(const char* strURC, void* reserved)
{
102cc9c0:	e1a04000 	mov	r4, r0
    char* p2 = NULL;
    char strTmp[10];
    
	// APP_DEBUG("strURC : %s\r\n", strURC);
	
    if (Ql_StrPrefixMatch(strURC, "\r\n+QSSLURC: "))
102cc9c4:	e12fff33 	blx	r3
102cc9c8:	e3500000 	cmp	r0, #0
102cc9cc:	1a000001 	bne	102cc9d8 <OnURCHandler_Recvssl+0x28>
			Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SSL_RECV_IND, ssid);
		}
    }


}
102cc9d0:	e28dd010 	add	sp, sp, #16
102cc9d4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
		
		char *strUrcRecv = "\r\n+QSSLURC: \"recv\"";
		u32 cid;
		u32 ssid;
		
		if(Ql_strncmp(strURC, strUrcRecv, Ql_strlen(strUrcRecv)) == 0)
102cc9d8:	e59f00c0 	ldr	r0, [pc, #192]	; 102ccaa0 <OnURCHandler_Recvssl+0xf0>
102cc9dc:	e59f50c0 	ldr	r5, [pc, #192]	; 102ccaa4 <OnURCHandler_Recvssl+0xf4>
102cc9e0:	e12fff35 	blx	r5
102cc9e4:	e59f10b4 	ldr	r1, [pc, #180]	; 102ccaa0 <OnURCHandler_Recvssl+0xf0>
102cc9e8:	e59f30b8 	ldr	r3, [pc, #184]	; 102ccaa8 <OnURCHandler_Recvssl+0xf8>
102cc9ec:	e1a02000 	mov	r2, r0
102cc9f0:	e1a00004 	mov	r0, r4
102cc9f4:	e12fff33 	blx	r3
102cc9f8:	e2506000 	subs	r6, r0, #0
102cc9fc:	1afffff3 	bne	102cc9d0 <OnURCHandler_Recvssl+0x20>
		{
			p1 = strURC+Ql_strlen(strUrcRecv)+1;
102cca00:	e59f0098 	ldr	r0, [pc, #152]	; 102ccaa0 <OnURCHandler_Recvssl+0xf0>
102cca04:	e12fff35 	blx	r5
			Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cca08:	e59fa09c 	ldr	sl, [pc, #156]	; 102ccaac <OnURCHandler_Recvssl+0xfc>
102cca0c:	e1a01006 	mov	r1, r6
102cca10:	e3a0200a 	mov	r2, #10
			Ql_memcpy(strTmp, p1, 1);
102cca14:	e59f8094 	ldr	r8, [pc, #148]	; 102ccab0 <OnURCHandler_Recvssl+0x100>
			cid = Ql_atoi(strTmp);
102cca18:	e59f7094 	ldr	r7, [pc, #148]	; 102ccab4 <OnURCHandler_Recvssl+0x104>
		u32 cid;
		u32 ssid;
		
		if(Ql_strncmp(strURC, strUrcRecv, Ql_strlen(strUrcRecv)) == 0)
		{
			p1 = strURC+Ql_strlen(strUrcRecv)+1;
102cca1c:	e2800001 	add	r0, r0, #1
102cca20:	e0849000 	add	r9, r4, r0
			Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cca24:	e28d0004 	add	r0, sp, #4
102cca28:	e12fff3a 	blx	sl
			Ql_memcpy(strTmp, p1, 1);
102cca2c:	e1a01009 	mov	r1, r9
102cca30:	e3a02001 	mov	r2, #1
102cca34:	e28d0004 	add	r0, sp, #4
102cca38:	e12fff38 	blx	r8
			cid = Ql_atoi(strTmp);
102cca3c:	e28d0004 	add	r0, sp, #4
102cca40:	e12fff37 	blx	r7
			// APP_DEBUG("cid: %d\r\n", cid);
			
			p1 = strURC+Ql_strlen(strUrcRecv)+3;
102cca44:	e59f0054 	ldr	r0, [pc, #84]	; 102ccaa0 <OnURCHandler_Recvssl+0xf0>
102cca48:	e12fff35 	blx	r5
			Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cca4c:	e1a01006 	mov	r1, r6
102cca50:	e3a0200a 	mov	r2, #10
			Ql_memset(strTmp, 0x0, sizeof(strTmp));
			Ql_memcpy(strTmp, p1, 1);
			cid = Ql_atoi(strTmp);
			// APP_DEBUG("cid: %d\r\n", cid);
			
			p1 = strURC+Ql_strlen(strUrcRecv)+3;
102cca54:	e2800003 	add	r0, r0, #3
102cca58:	e0844000 	add	r4, r4, r0
			Ql_memset(strTmp, 0x0, sizeof(strTmp));
102cca5c:	e28d0004 	add	r0, sp, #4
102cca60:	e12fff3a 	blx	sl
			Ql_memcpy(strTmp, p1, 1);
102cca64:	e1a01004 	mov	r1, r4
102cca68:	e3a02001 	mov	r2, #1
102cca6c:	e28d0004 	add	r0, sp, #4
102cca70:	e12fff38 	blx	r8
			ssid = Ql_atoi(strTmp);
102cca74:	e28d0004 	add	r0, sp, #4
102cca78:	e12fff37 	blx	r7
			// APP_DEBUG("ssid: %d\r\n", ssid);
			
			Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SSL_RECV_IND, ssid);
102cca7c:	e59f1034 	ldr	r1, [pc, #52]	; 102ccab8 <OnURCHandler_Recvssl+0x108>
102cca80:	e3a0200b 	mov	r2, #11
102cca84:	e59fc030 	ldr	ip, [pc, #48]	; 102ccabc <OnURCHandler_Recvssl+0x10c>
			// APP_DEBUG("cid: %d\r\n", cid);
			
			p1 = strURC+Ql_strlen(strUrcRecv)+3;
			Ql_memset(strTmp, 0x0, sizeof(strTmp));
			Ql_memcpy(strTmp, p1, 1);
			ssid = Ql_atoi(strTmp);
102cca88:	e1a03000 	mov	r3, r0
			// APP_DEBUG("ssid: %d\r\n", ssid);
			
			Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_SSL_RECV_IND, ssid);
102cca8c:	e1a00006 	mov	r0, r6
102cca90:	e12fff3c 	blx	ip
102cca94:	eaffffcd 	b	102cc9d0 <OnURCHandler_Recvssl+0x20>
102cca98:	102ee87c 	.word	0x102ee87c
102cca9c:	102ccd58 	.word	0x102ccd58
102ccaa0:	102ee88c 	.word	0x102ee88c
102ccaa4:	102e57a4 	.word	0x102e57a4
102ccaa8:	102e5884 	.word	0x102e5884
102ccaac:	102e58f4 	.word	0x102e58f4
102ccab0:	102e597c 	.word	0x102e597c
102ccab4:	102e5a8c 	.word	0x102e5a8c
102ccab8:	00001002 	.word	0x00001002
102ccabc:	102e5cb4 	.word	0x102e5cb4

102ccac0 <OnURCHandler_SMS>:
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_CALL_STATE_IND, callStat);
    }
}

static void OnURCHandler_SMS(const char* strURC, void* reserved)
{
102ccac0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    char* p1 = NULL;
    char* p2 = NULL;

    //TODO: Something wrong with long SMS
    if (Ql_StrPrefixMatch(strURC, "\r\n+CMTI:")) 
102ccac4:	e59f110c 	ldr	r1, [pc, #268]	; 102ccbd8 <OnURCHandler_SMS+0x118>
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_CALL_STATE_IND, callStat);
    }
}

static void OnURCHandler_SMS(const char* strURC, void* reserved)
{
102ccac8:	e24dd014 	sub	sp, sp, #20
    char* p1 = NULL;
    char* p2 = NULL;

    //TODO: Something wrong with long SMS
    if (Ql_StrPrefixMatch(strURC, "\r\n+CMTI:")) 
102ccacc:	e59f4108 	ldr	r4, [pc, #264]	; 102ccbdc <OnURCHandler_SMS+0x11c>
        Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_CALL_STATE_IND, callStat);
    }
}

static void OnURCHandler_SMS(const char* strURC, void* reserved)
{
102ccad0:	e1a06000 	mov	r6, r0
    char* p1 = NULL;
    char* p2 = NULL;

    //TODO: Something wrong with long SMS
    if (Ql_StrPrefixMatch(strURC, "\r\n+CMTI:")) 
102ccad4:	e12fff34 	blx	r4
102ccad8:	e3500000 	cmp	r0, #0
102ccadc:	0a000018 	beq	102ccb44 <OnURCHandler_SMS+0x84>
    {
        u32 smsIndex;
        char mem[4];

        // Get 'mem'
        p1 = Ql_strstr(strURC, ":");
102ccae0:	e59f10f8 	ldr	r1, [pc, #248]	; 102ccbe0 <OnURCHandler_SMS+0x120>
102ccae4:	e59f50f8 	ldr	r5, [pc, #248]	; 102ccbe4 <OnURCHandler_SMS+0x124>
102ccae8:	e1a00006 	mov	r0, r6
102ccaec:	e12fff35 	blx	r5
        p1 += 3;
        p2 = Ql_strstr(p1, ",");
102ccaf0:	e59f10f0 	ldr	r1, [pc, #240]	; 102ccbe8 <OnURCHandler_SMS+0x128>
        u32 smsIndex;
        char mem[4];

        // Get 'mem'
        p1 = Ql_strstr(strURC, ":");
        p1 += 3;
102ccaf4:	e2806003 	add	r6, r0, #3
        p2 = Ql_strstr(p1, ",");
102ccaf8:	e1a00006 	mov	r0, r6
102ccafc:	e12fff35 	blx	r5
        if (p1 && p2)
102ccb00:	e2907000 	adds	r7, r0, #0
102ccb04:	13a07001 	movne	r7, #1
102ccb08:	e3560000 	cmp	r6, #0
102ccb0c:	13500000 	cmpne	r0, #0
102ccb10:	e1a04000 	mov	r4, r0
102ccb14:	1a000023 	bne	102ccba8 <OnURCHandler_SMS+0xe8>
            Ql_strncpy(mem, p1, (p2 - p1 - 1));
        }

        // Get index
        p1 = p2;
        p2 = Ql_strstr(p1, "\r\n");
102ccb18:	e1a00004 	mov	r0, r4
102ccb1c:	e59f10c8 	ldr	r1, [pc, #200]	; 102ccbec <OnURCHandler_SMS+0x12c>
102ccb20:	e12fff35 	blx	r5
        if (p1 && p2)
102ccb24:	e3500000 	cmp	r0, #0
102ccb28:	03a07000 	moveq	r7, #0
102ccb2c:	12077001 	andne	r7, r7, #1
102ccb30:	e3570000 	cmp	r7, #0
102ccb34:	e1a05000 	mov	r5, r0
102ccb38:	1a000005 	bne	102ccb54 <OnURCHandler_SMS+0x94>
        }
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\n+CMT:"))
    {
    }
}
102ccb3c:	e28dd014 	add	sp, sp, #20
102ccb40:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
            Ql_strncpy(strIndex, p1 + 1, p2 - p1 - 1);
            smsIndex = Ql_atoi(strIndex);
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_NEW_SMS_IND, smsIndex);
        }
    }
    else if (Ql_StrPrefixMatch(strURC, "\r\n+CMT:"))
102ccb44:	e1a00006 	mov	r0, r6
102ccb48:	e59f10a0 	ldr	r1, [pc, #160]	; 102ccbf0 <OnURCHandler_SMS+0x130>
102ccb4c:	e12fff34 	blx	r4
102ccb50:	eafffff9 	b	102ccb3c <OnURCHandler_SMS+0x7c>
        p1 = p2;
        p2 = Ql_strstr(p1, "\r\n");
        if (p1 && p2)
        {
            char strIndex[10];
            Ql_memset(strIndex, 0x0, sizeof(strIndex));
102ccb54:	e28d0004 	add	r0, sp, #4
102ccb58:	e3a01000 	mov	r1, #0
102ccb5c:	e3a0200a 	mov	r2, #10
102ccb60:	e59f308c 	ldr	r3, [pc, #140]	; 102ccbf4 <OnURCHandler_SMS+0x134>
102ccb64:	e12fff33 	blx	r3
            Ql_strncpy(strIndex, p1 + 1, p2 - p1 - 1);
102ccb68:	e0642005 	rsb	r2, r4, r5
102ccb6c:	e2841001 	add	r1, r4, #1
102ccb70:	e2422001 	sub	r2, r2, #1
102ccb74:	e28d0004 	add	r0, sp, #4
102ccb78:	e59f3078 	ldr	r3, [pc, #120]	; 102ccbf8 <OnURCHandler_SMS+0x138>
102ccb7c:	e12fff33 	blx	r3
            smsIndex = Ql_atoi(strIndex);
102ccb80:	e28d0004 	add	r0, sp, #4
102ccb84:	e59f3070 	ldr	r3, [pc, #112]	; 102ccbfc <OnURCHandler_SMS+0x13c>
102ccb88:	e12fff33 	blx	r3
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_NEW_SMS_IND, smsIndex);
102ccb8c:	e59f106c 	ldr	r1, [pc, #108]	; 102ccc00 <OnURCHandler_SMS+0x140>
102ccb90:	e3a02008 	mov	r2, #8
102ccb94:	e59fc068 	ldr	ip, [pc, #104]	; 102ccc04 <OnURCHandler_SMS+0x144>
        if (p1 && p2)
        {
            char strIndex[10];
            Ql_memset(strIndex, 0x0, sizeof(strIndex));
            Ql_strncpy(strIndex, p1 + 1, p2 - p1 - 1);
            smsIndex = Ql_atoi(strIndex);
102ccb98:	e1a03000 	mov	r3, r0
            Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_NEW_SMS_IND, smsIndex);
102ccb9c:	e3a00000 	mov	r0, #0
102ccba0:	e12fff3c 	blx	ip
102ccba4:	eaffffe4 	b	102ccb3c <OnURCHandler_SMS+0x7c>
        p1 = Ql_strstr(strURC, ":");
        p1 += 3;
        p2 = Ql_strstr(p1, ",");
        if (p1 && p2)
        {
            Ql_memset(mem, 0x0, sizeof(mem));
102ccba8:	e3a01000 	mov	r1, #0
102ccbac:	e3a02004 	mov	r2, #4
102ccbb0:	e1a0000d 	mov	r0, sp
102ccbb4:	e59f3038 	ldr	r3, [pc, #56]	; 102ccbf4 <OnURCHandler_SMS+0x134>
102ccbb8:	e12fff33 	blx	r3
            Ql_strncpy(mem, p1, (p2 - p1 - 1));
102ccbbc:	e0662004 	rsb	r2, r6, r4
102ccbc0:	e1a0000d 	mov	r0, sp
102ccbc4:	e1a01006 	mov	r1, r6
102ccbc8:	e2422001 	sub	r2, r2, #1
102ccbcc:	e59f3024 	ldr	r3, [pc, #36]	; 102ccbf8 <OnURCHandler_SMS+0x138>
102ccbd0:	e12fff33 	blx	r3
102ccbd4:	eaffffcf 	b	102ccb18 <OnURCHandler_SMS+0x58>
102ccbd8:	102ee8a0 	.word	0x102ee8a0
102ccbdc:	102ccd58 	.word	0x102ccd58
102ccbe0:	102efa10 	.word	0x102efa10
102ccbe4:	102e5a04 	.word	0x102e5a04
102ccbe8:	102ee830 	.word	0x102ee830
102ccbec:	102ee78c 	.word	0x102ee78c
102ccbf0:	102ee8ac 	.word	0x102ee8ac
102ccbf4:	102e58f4 	.word	0x102e58f4
102ccbf8:	102e569c 	.word	0x102e569c
102ccbfc:	102e5a8c 	.word	0x102e5a8c
102ccc00:	00001002 	.word	0x00001002
102ccc04:	102e5cb4 	.word	0x102e5cb4

102ccc08 <OnURCHandler>:
*                   reserved, can be NULL.
* Return:        
*               The function returns "ptrUrc".
*****************************************************************/
void OnURCHandler(const char* strURC, void* reserved)
{
102ccc08:	e92d45f8 	push	{r3, r4, r5, r6, r7, r8, sl, lr}
    s32 i;
    
    if (NULL == strURC)
102ccc0c:	e2506000 	subs	r6, r0, #0
*                   reserved, can be NULL.
* Return:        
*               The function returns "ptrUrc".
*****************************************************************/
void OnURCHandler(const char* strURC, void* reserved)
{
102ccc10:	e1a0a001 	mov	sl, r1
    s32 i;
    
    if (NULL == strURC)
102ccc14:	08bd85f8 	popeq	{r3, r4, r5, r6, r7, r8, sl, pc}
102ccc18:	e59f80a4 	ldr	r8, [pc, #164]	; 102cccc4 <OnURCHandler+0xbc>
102ccc1c:	e59f70a4 	ldr	r7, [pc, #164]	; 102cccc8 <OnURCHandler+0xc0>
102ccc20:	e3a04000 	mov	r4, #0
102ccc24:	ea000001 	b	102ccc30 <OnURCHandler+0x28>
    {
        return;
    }

    // For system URCs
    for (i = 0; i < NUM_ELEMS(m_SysURCHdlEntry); i++)
102ccc28:	e3540016 	cmp	r4, #22
102ccc2c:	0a00000c 	beq	102ccc64 <OnURCHandler+0x5c>
    {
        if (Ql_strstr(strURC, m_SysURCHdlEntry[i].keyword))
102ccc30:	e0645184 	rsb	r5, r4, r4, lsl #3
102ccc34:	e0885185 	add	r5, r8, r5, lsl #3
102ccc38:	e1a00006 	mov	r0, r6
102ccc3c:	e1a01005 	mov	r1, r5
102ccc40:	e12fff37 	blx	r7
    {
        return;
    }

    // For system URCs
    for (i = 0; i < NUM_ELEMS(m_SysURCHdlEntry); i++)
102ccc44:	e2844001 	add	r4, r4, #1
    {
        if (Ql_strstr(strURC, m_SysURCHdlEntry[i].keyword))
102ccc48:	e3500000 	cmp	r0, #0
102ccc4c:	0afffff5 	beq	102ccc28 <OnURCHandler+0x20>
        {
            m_SysURCHdlEntry[i].handler(strURC, reserved);
102ccc50:	e5953034 	ldr	r3, [r5, #52]	; 0x34
102ccc54:	e1a00006 	mov	r0, r6
102ccc58:	e1a0100a 	mov	r1, sl
102ccc5c:	e12fff33 	blx	r3
            return;
102ccc60:	e8bd85f8 	pop	{r3, r4, r5, r6, r7, r8, sl, pc}
102ccc64:	e59f8060 	ldr	r8, [pc, #96]	; 102ccccc <OnURCHandler+0xc4>
    {
        return;
    }

    // For system URCs
    for (i = 0; i < NUM_ELEMS(m_SysURCHdlEntry); i++)
102ccc68:	e1a04000 	mov	r4, r0
    }

    // For AT URCs
    for (i = 0; i < NUM_ELEMS(m_AtURCHdlEntry); i++)
    {
        if (Ql_strstr(strURC, m_AtURCHdlEntry[i].keyword))
102ccc6c:	e0645184 	rsb	r5, r4, r4, lsl #3
102ccc70:	e1a05185 	lsl	r5, r5, #3
102ccc74:	e1a00006 	mov	r0, r6
102ccc78:	e0881005 	add	r1, r8, r5
102ccc7c:	e12fff37 	blx	r7
            return;
        }
    }

    // For AT URCs
    for (i = 0; i < NUM_ELEMS(m_AtURCHdlEntry); i++)
102ccc80:	e2844001 	add	r4, r4, #1
    {
        if (Ql_strstr(strURC, m_AtURCHdlEntry[i].keyword))
102ccc84:	e2503000 	subs	r3, r0, #0
102ccc88:	1a000006 	bne	102ccca8 <OnURCHandler+0xa0>
            return;
        }
    }

    // For AT URCs
    for (i = 0; i < NUM_ELEMS(m_AtURCHdlEntry); i++)
102ccc8c:	e3540011 	cmp	r4, #17
102ccc90:	1afffff5 	bne	102ccc6c <OnURCHandler+0x64>
	Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_ALARM_RING_IND, 0);
}

static void OnURCHandler_Undefined(const char* strURC, void* reserved)
{
    Ql_OS_SendMessage(URC_RCV_TASK_ID, MSG_ID_URC_INDICATION, URC_END, 0);
102ccc94:	e59f1034 	ldr	r1, [pc, #52]	; 102cccd0 <OnURCHandler+0xc8>
102ccc98:	e3a02065 	mov	r2, #101	; 0x65
102ccc9c:	e59fc030 	ldr	ip, [pc, #48]	; 102cccd4 <OnURCHandler+0xcc>
102ccca0:	e12fff3c 	blx	ip
102ccca4:	e8bd85f8 	pop	{r3, r4, r5, r6, r7, r8, sl, pc}
    // For AT URCs
    for (i = 0; i < NUM_ELEMS(m_AtURCHdlEntry); i++)
    {
        if (Ql_strstr(strURC, m_AtURCHdlEntry[i].keyword))
        {
            m_AtURCHdlEntry[i].handler(strURC, reserved);
102ccca8:	e59f3014 	ldr	r3, [pc, #20]	; 102cccc4 <OnURCHandler+0xbc>
102cccac:	e1a00006 	mov	r0, r6
102cccb0:	e0835005 	add	r5, r3, r5
102cccb4:	e5953504 	ldr	r3, [r5, #1284]	; 0x504
102cccb8:	e1a0100a 	mov	r1, sl
102cccbc:	e12fff33 	blx	r3
            return;
102cccc0:	e8bd85f8 	pop	{r3, r4, r5, r6, r7, r8, sl, pc}
102cccc4:	102e66f4 	.word	0x102e66f4
102cccc8:	102e5a04 	.word	0x102e5a04
102ccccc:	102e6bc4 	.word	0x102e6bc4
102cccd0:	00001002 	.word	0x00001002
102cccd4:	102e5cb4 	.word	0x102e5cb4

102cccd8 <Ql_RIL_IsURCStr>:
* Return:  
*               0 : not URC information
*               1 : URC information
******************************************************************************/
s32 Ql_RIL_IsURCStr(const char* strRsp)
{
102cccd8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102cccdc:	e59f7068 	ldr	r7, [pc, #104]	; 102ccd4c <Ql_RIL_IsURCStr+0x74>
102ccce0:	e59f6068 	ldr	r6, [pc, #104]	; 102ccd50 <Ql_RIL_IsURCStr+0x78>
102ccce4:	e1a05000 	mov	r5, r0
    s32 i;
    for (i = 0; i < NUM_ELEMS(m_SysURCHdlEntry); i++) 
102ccce8:	e3a04000 	mov	r4, #0
102cccec:	ea000001 	b	102cccf8 <Ql_RIL_IsURCStr+0x20>
102cccf0:	e3540016 	cmp	r4, #22
102cccf4:	0a000008 	beq	102ccd1c <Ql_RIL_IsURCStr+0x44>
    {
        if (Ql_strstr(strRsp, m_SysURCHdlEntry[i].keyword)) 
102cccf8:	e0641184 	rsb	r1, r4, r4, lsl #3
102cccfc:	e1a00005 	mov	r0, r5
102ccd00:	e0871181 	add	r1, r7, r1, lsl #3
102ccd04:	e12fff36 	blx	r6
*               1 : URC information
******************************************************************************/
s32 Ql_RIL_IsURCStr(const char* strRsp)
{
    s32 i;
    for (i = 0; i < NUM_ELEMS(m_SysURCHdlEntry); i++) 
102ccd08:	e2844001 	add	r4, r4, #1
    {
        if (Ql_strstr(strRsp, m_SysURCHdlEntry[i].keyword)) 
102ccd0c:	e3500000 	cmp	r0, #0
102ccd10:	0afffff6 	beq	102cccf0 <Ql_RIL_IsURCStr+0x18>
        {
            return 1;
102ccd14:	e3a00001 	mov	r0, #1
102ccd18:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102ccd1c:	e59f7030 	ldr	r7, [pc, #48]	; 102ccd54 <Ql_RIL_IsURCStr+0x7c>
*               1 : URC information
******************************************************************************/
s32 Ql_RIL_IsURCStr(const char* strRsp)
{
    s32 i;
    for (i = 0; i < NUM_ELEMS(m_SysURCHdlEntry); i++) 
102ccd20:	e1a04000 	mov	r4, r0
            return 1;
        }
    }
    for (i = 0; i < NUM_ELEMS(m_AtURCHdlEntry); i++) 
    {
        if (Ql_strstr(strRsp, m_AtURCHdlEntry[i].keyword)) 
102ccd24:	e0641184 	rsb	r1, r4, r4, lsl #3
102ccd28:	e1a00005 	mov	r0, r5
102ccd2c:	e0871181 	add	r1, r7, r1, lsl #3
102ccd30:	e12fff36 	blx	r6
        if (Ql_strstr(strRsp, m_SysURCHdlEntry[i].keyword)) 
        {
            return 1;
        }
    }
    for (i = 0; i < NUM_ELEMS(m_AtURCHdlEntry); i++) 
102ccd34:	e2844001 	add	r4, r4, #1
    {
        if (Ql_strstr(strRsp, m_AtURCHdlEntry[i].keyword)) 
102ccd38:	e3500000 	cmp	r0, #0
102ccd3c:	1afffff4 	bne	102ccd14 <Ql_RIL_IsURCStr+0x3c>
        if (Ql_strstr(strRsp, m_SysURCHdlEntry[i].keyword)) 
        {
            return 1;
        }
    }
    for (i = 0; i < NUM_ELEMS(m_AtURCHdlEntry); i++) 
102ccd40:	e3540011 	cmp	r4, #17
102ccd44:	1afffff6 	bne	102ccd24 <Ql_RIL_IsURCStr+0x4c>
        {
            return 1;
        }
    }
    return 0;
}
102ccd48:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102ccd4c:	102e66f4 	.word	0x102e66f4
102ccd50:	102e5a04 	.word	0x102e5a04
102ccd54:	102e6bc4 	.word	0x102e6bc4

102ccd58 <Ql_StrPrefixMatch>:
#include "ql_memory.h"
#include "ql_stdlib.h"
#include "string.h"
s32 Ql_StrPrefixMatch(const char* str, const char *prefix)
{
    for ( ; *str != '\0' && *prefix != '\0' ; str++, prefix++) {
102ccd58:	e5d03000 	ldrb	r3, [r0]
102ccd5c:	e5d12000 	ldrb	r2, [r1]
102ccd60:	e3530000 	cmp	r3, #0
102ccd64:	1a000006 	bne	102ccd84 <Ql_StrPrefixMatch+0x2c>
102ccd68:	ea000007 	b	102ccd8c <Ql_StrPrefixMatch+0x34>
        if (*str != *prefix) {
102ccd6c:	e1530002 	cmp	r3, r2
102ccd70:	1a000008 	bne	102ccd98 <Ql_StrPrefixMatch+0x40>
#include "ql_memory.h"
#include "ql_stdlib.h"
#include "string.h"
s32 Ql_StrPrefixMatch(const char* str, const char *prefix)
{
    for ( ; *str != '\0' && *prefix != '\0' ; str++, prefix++) {
102ccd74:	e5f03001 	ldrb	r3, [r0, #1]!
102ccd78:	e3530000 	cmp	r3, #0
102ccd7c:	0a000007 	beq	102ccda0 <Ql_StrPrefixMatch+0x48>
102ccd80:	e5f12001 	ldrb	r2, [r1, #1]!
102ccd84:	e3520000 	cmp	r2, #0
102ccd88:	1afffff7 	bne	102ccd6c <Ql_StrPrefixMatch+0x14>
        if (*str != *prefix) {
            return 0;
        }
    }
    return *prefix == '\0';
102ccd8c:	e2720001 	rsbs	r0, r2, #1
102ccd90:	33a00000 	movcc	r0, #0
102ccd94:	e12fff1e 	bx	lr
#include "string.h"
s32 Ql_StrPrefixMatch(const char* str, const char *prefix)
{
    for ( ; *str != '\0' && *prefix != '\0' ; str++, prefix++) {
        if (*str != *prefix) {
            return 0;
102ccd98:	e3a00000 	mov	r0, #0
        }
    }
    return *prefix == '\0';
}
102ccd9c:	e12fff1e 	bx	lr
102ccda0:	e5d12001 	ldrb	r2, [r1, #1]
102ccda4:	eafffff8 	b	102ccd8c <Ql_StrPrefixMatch+0x34>

102ccda8 <Ql_StrToUpper>:

char* Ql_StrToUpper(char* str)
{
102ccda8:	e92d4070 	push	{r4, r5, r6, lr}
    char* pCh = str;
    if (!str)
102ccdac:	e2505000 	subs	r5, r0, #0
102ccdb0:	0a000010 	beq	102ccdf8 <Ql_StrToUpper+0x50>
    {
        return NULL;
    }
    for ( ; *pCh != '\0'; pCh++)
102ccdb4:	e5d50000 	ldrb	r0, [r5]
102ccdb8:	e3500000 	cmp	r0, #0
102ccdbc:	0a00000d 	beq	102ccdf8 <Ql_StrToUpper+0x50>
    {
        if (((*pCh) >= 'a') && ((*pCh) <= 'z'))
        {
            *pCh = Ql_toupper(*pCh);
102ccdc0:	e59f6038 	ldr	r6, [pc, #56]	; 102cce00 <Ql_StrToUpper+0x58>
        }
    }
    return *prefix == '\0';
}

char* Ql_StrToUpper(char* str)
102ccdc4:	e2854001 	add	r4, r5, #1
102ccdc8:	ea000002 	b	102ccdd8 <Ql_StrToUpper+0x30>
    char* pCh = str;
    if (!str)
    {
        return NULL;
    }
    for ( ; *pCh != '\0'; pCh++)
102ccdcc:	e4d40001 	ldrb	r0, [r4], #1
102ccdd0:	e3500000 	cmp	r0, #0
102ccdd4:	0a000007 	beq	102ccdf8 <Ql_StrToUpper+0x50>
    {
        if (((*pCh) >= 'a') && ((*pCh) <= 'z'))
102ccdd8:	e2403061 	sub	r3, r0, #97	; 0x61
102ccddc:	e3530019 	cmp	r3, #25
102ccde0:	8afffff9 	bhi	102ccdcc <Ql_StrToUpper+0x24>
        {
            *pCh = Ql_toupper(*pCh);
102ccde4:	e12fff36 	blx	r6
102ccde8:	e5440001 	strb	r0, [r4, #-1]
    char* pCh = str;
    if (!str)
    {
        return NULL;
    }
    for ( ; *pCh != '\0'; pCh++)
102ccdec:	e4d40001 	ldrb	r0, [r4], #1
102ccdf0:	e3500000 	cmp	r0, #0
102ccdf4:	1afffff7 	bne	102ccdd8 <Ql_StrToUpper+0x30>
        {
            *pCh = Ql_toupper(*pCh);
        }
    }
    return str;
}
102ccdf8:	e1a00005 	mov	r0, r5
102ccdfc:	e8bd8070 	pop	{r4, r5, r6, pc}
102cce00:	102e5a84 	.word	0x102e5a84

102cce04 <Ql_HexStrToInt>:
{
    u16 i = 0;
    u32 temp = 0;

    //ASSERT((str != NULL) && (val != NULL));
    if (NULL == str || NULL == val)
102cce04:	e3500000 	cmp	r0, #0
102cce08:	13510000 	cmpne	r1, #0
    }
    return str;
}

bool Ql_HexStrToInt(u8* str, u32* val)
{
102cce0c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    u16 i = 0;
    u32 temp = 0;

    //ASSERT((str != NULL) && (val != NULL));
    if (NULL == str || NULL == val)
102cce10:	e1a08001 	mov	r8, r1
102cce14:	13a04000 	movne	r4, #0
102cce18:	03a04001 	moveq	r4, #1
102cce1c:	e1a07000 	mov	r7, r0
102cce20:	1a000001 	bne	102cce2c <Ql_HexStrToInt+0x28>
    {
        return FALSE;
102cce24:	e3a00000 	mov	r0, #0
102cce28:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
    Ql_StrToUpper((char*)str);
102cce2c:	ebffffdd 	bl	102ccda8 <Ql_StrToUpper>

    while (str[i] != '\0')
102cce30:	e5d73000 	ldrb	r3, [r7]
102cce34:	e3530000 	cmp	r3, #0
102cce38:	0a000014 	beq	102cce90 <Ql_HexStrToInt+0x8c>
102cce3c:	e1a02004 	mov	r2, r4
102cce40:	e1a0c004 	mov	ip, r4
    {
        if (IS_NUMBER(str[i]))
102cce44:	e2434030 	sub	r4, r3, #48	; 0x30
        {
            temp = (temp << 4) + (str[i] - CHAR_0);
102cce48:	e0836202 	add	r6, r3, r2, lsl #4
    }
    Ql_StrToUpper((char*)str);

    while (str[i] != '\0')
    {
        if (IS_NUMBER(str[i]))
102cce4c:	e3540009 	cmp	r4, #9
        {
            temp = (temp << 4) + (str[i] - CHAR_0);
        }
        else if ((str[i] >= CHAR_A) && (str[i] <= CHAR_F))
        {
            temp = (temp << 4) + ((str[i] - CHAR_A) + 10);
102cce50:	e1a02006 	mov	r2, r6
    {
        if (IS_NUMBER(str[i]))
        {
            temp = (temp << 4) + (str[i] - CHAR_0);
        }
        else if ((str[i] >= CHAR_A) && (str[i] <= CHAR_F))
102cce54:	e2435041 	sub	r5, r3, #65	; 0x41

    while (str[i] != '\0')
    {
        if (IS_NUMBER(str[i]))
        {
            temp = (temp << 4) + (str[i] - CHAR_0);
102cce58:	92462030 	subls	r2, r6, #48	; 0x30
    }
    Ql_StrToUpper((char*)str);

    while (str[i] != '\0')
    {
        if (IS_NUMBER(str[i]))
102cce5c:	9a000002 	bls	102cce6c <Ql_HexStrToInt+0x68>
        {
            temp = (temp << 4) + (str[i] - CHAR_0);
        }
        else if ((str[i] >= CHAR_A) && (str[i] <= CHAR_F))
102cce60:	e3550005 	cmp	r5, #5
        {
            temp = (temp << 4) + ((str[i] - CHAR_A) + 10);
102cce64:	e2422037 	sub	r2, r2, #55	; 0x37
    {
        if (IS_NUMBER(str[i]))
        {
            temp = (temp << 4) + (str[i] - CHAR_0);
        }
        else if ((str[i] >= CHAR_A) && (str[i] <= CHAR_F))
102cce68:	8affffed 	bhi	102cce24 <Ql_HexStrToInt+0x20>
        {
            temp = (temp << 4) + ((str[i] - CHAR_A) + 10);
        }else{
            return FALSE;
        }
        i++;
102cce6c:	e28cc001 	add	ip, ip, #1
102cce70:	e1a0c80c 	lsl	ip, ip, #16
    {
        return FALSE;
    }
    Ql_StrToUpper((char*)str);

    while (str[i] != '\0')
102cce74:	e7d7382c 	ldrb	r3, [r7, ip, lsr #16]
        {
            temp = (temp << 4) + ((str[i] - CHAR_A) + 10);
        }else{
            return FALSE;
        }
        i++;
102cce78:	e1a0c82c 	lsr	ip, ip, #16
    {
        return FALSE;
    }
    Ql_StrToUpper((char*)str);

    while (str[i] != '\0')
102cce7c:	e3530000 	cmp	r3, #0
102cce80:	1affffef 	bne	102cce44 <Ql_HexStrToInt+0x40>
            return FALSE;
        }
        i++;
    }
    *val = temp;
    return TRUE;
102cce84:	e3a00001 	mov	r0, #1
        }else{
            return FALSE;
        }
        i++;
    }
    *val = temp;
102cce88:	e5882000 	str	r2, [r8]
    return TRUE;
}
102cce8c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
}

bool Ql_HexStrToInt(u8* str, u32* val)
{
    u16 i = 0;
    u32 temp = 0;
102cce90:	e1a02003 	mov	r2, r3
102cce94:	eafffffa 	b	102cce84 <Ql_HexStrToInt+0x80>

102cce98 <Ql_RIL_FindString>:
{
    s32 i;
    s32 strlen;
    char *p;

    if ((NULL == line) || (NULL == str))
102cce98:	e3500000 	cmp	r0, #0
102cce9c:	13520000 	cmpne	r2, #0
* Return:  
                The function returns a pointer to the located string,
                or a  null  pointer  if  the specified string is not found.
******************************************************************************/
char* Ql_RIL_FindString(char *line, u32 len,char *str)
{
102ccea0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    s32 i;
    s32 strlen;
    char *p;

    if ((NULL == line) || (NULL == str))
102ccea4:	e1a05002 	mov	r5, r2
102ccea8:	e1a04000 	mov	r4, r0
* Return:  
                The function returns a pointer to the located string,
                or a  null  pointer  if  the specified string is not found.
******************************************************************************/
char* Ql_RIL_FindString(char *line, u32 len,char *str)
{
102cceac:	e1a08001 	mov	r8, r1
    s32 i;
    s32 strlen;
    char *p;

    if ((NULL == line) || (NULL == str))
102cceb0:	0a000016 	beq	102ccf10 <Ql_RIL_FindString+0x78>
        return NULL;
    
    strlen = Ql_strlen(str);
102cceb4:	e1a00002 	mov	r0, r2
102cceb8:	e59f305c 	ldr	r3, [pc, #92]	; 102ccf1c <Ql_RIL_FindString+0x84>
102ccebc:	e12fff33 	blx	r3
    if(strlen > len)
102ccec0:	e1500008 	cmp	r0, r8
    char *p;

    if ((NULL == line) || (NULL == str))
        return NULL;
    
    strlen = Ql_strlen(str);
102ccec4:	e1a06000 	mov	r6, r0
    if(strlen > len)
102ccec8:	8a000010 	bhi	102ccf10 <Ql_RIL_FindString+0x78>
    {
        return NULL;
    }

    p = line;
    for (i = 0;i < len - strlen + 1; i++)
102ccecc:	e0608008 	rsb	r8, r0, r8
102cced0:	e2988001 	adds	r8, r8, #1
102cced4:	0a00000d 	beq	102ccf10 <Ql_RIL_FindString+0x78>
102cced8:	e59f7040 	ldr	r7, [pc, #64]	; 102ccf20 <Ql_RIL_FindString+0x88>
*
* Return:  
                The function returns a pointer to the located string,
                or a  null  pointer  if  the specified string is not found.
******************************************************************************/
char* Ql_RIL_FindString(char *line, u32 len,char *str)
102ccedc:	e0848008 	add	r8, r4, r8
102ccee0:	ea000002 	b	102ccef0 <Ql_RIL_FindString+0x58>
    {
        if (0 == Ql_strncmp (p, str, strlen))
        {
            return p;
        }else{
            p++;
102ccee4:	e2844001 	add	r4, r4, #1
    {
        return NULL;
    }

    p = line;
    for (i = 0;i < len - strlen + 1; i++)
102ccee8:	e1540008 	cmp	r4, r8
102cceec:	0a000007 	beq	102ccf10 <Ql_RIL_FindString+0x78>
    {
        if (0 == Ql_strncmp (p, str, strlen))
102ccef0:	e1a00004 	mov	r0, r4
102ccef4:	e1a01005 	mov	r1, r5
102ccef8:	e1a02006 	mov	r2, r6
102ccefc:	e12fff37 	blx	r7
102ccf00:	e3500000 	cmp	r0, #0
102ccf04:	1afffff6 	bne	102ccee4 <Ql_RIL_FindString+0x4c>
        }else{
            p++;
        }
    }
    return NULL;
}
102ccf08:	e1a00004 	mov	r0, r4
102ccf0c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    s32 i;
    s32 strlen;
    char *p;

    if ((NULL == line) || (NULL == str))
        return NULL;
102ccf10:	e3a04000 	mov	r4, #0
        }else{
            p++;
        }
    }
    return NULL;
}
102ccf14:	e1a00004 	mov	r0, r4
102ccf18:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102ccf1c:	102e57a4 	.word	0x102e57a4
102ccf20:	102e5884 	.word	0x102e5884

102ccf24 <Ql_RIL_FindLine>:
* Return:  
                The function returns a pointer to the located string,
                or a  null  pointer  if  the specified string is not found.
******************************************************************************/
char* Ql_RIL_FindLine(char *line, u32 len,char *str)
{
102ccf24:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    char *p = NULL;
    char *pStr = NULL;
    char *pStr2 = NULL;
    char *pStr3 = NULL;

    if ((NULL == line) || (NULL == str))
102ccf28:	e3500000 	cmp	r0, #0
102ccf2c:	13520000 	cmpne	r2, #0
* Return:  
                The function returns a pointer to the located string,
                or a  null  pointer  if  the specified string is not found.
******************************************************************************/
char* Ql_RIL_FindLine(char *line, u32 len,char *str)
{
102ccf30:	e24dd014 	sub	sp, sp, #20
    char *p = NULL;
    char *pStr = NULL;
    char *pStr2 = NULL;
    char *pStr3 = NULL;

    if ((NULL == line) || (NULL == str))
102ccf34:	e1a0a002 	mov	sl, r2
102ccf38:	e58d0004 	str	r0, [sp, #4]
102ccf3c:	13a06000 	movne	r6, #0
102ccf40:	03a06001 	moveq	r6, #1
* Return:  
                The function returns a pointer to the located string,
                or a  null  pointer  if  the specified string is not found.
******************************************************************************/
char* Ql_RIL_FindLine(char *line, u32 len,char *str)
{
102ccf44:	e58d100c 	str	r1, [sp, #12]
    char *p = NULL;
    char *pStr = NULL;
    char *pStr2 = NULL;
    char *pStr3 = NULL;

    if ((NULL == line) || (NULL == str))
102ccf48:	0a000067 	beq	102cd0ec <Ql_RIL_FindLine+0x1c8>
        return NULL;
    
    strlen = Ql_strlen (str);
102ccf4c:	e1a00002 	mov	r0, r2
102ccf50:	e59f3224 	ldr	r3, [pc, #548]	; 102cd17c <Ql_RIL_FindLine+0x258>
102ccf54:	e12fff33 	blx	r3
    
    pStr = Ql_MEM_Alloc(strlen + 4 + 1);
102ccf58:	e59f8220 	ldr	r8, [pc, #544]	; 102cd180 <Ql_RIL_FindLine+0x25c>
102ccf5c:	e280b005 	add	fp, r0, #5
    char *pStr3 = NULL;

    if ((NULL == line) || (NULL == str))
        return NULL;
    
    strlen = Ql_strlen (str);
102ccf60:	e58d0008 	str	r0, [sp, #8]
    
    pStr = Ql_MEM_Alloc(strlen + 4 + 1);
102ccf64:	e1a0000b 	mov	r0, fp
102ccf68:	e12fff38 	blx	r8
    if (NULL == pStr)
102ccf6c:	e2505000 	subs	r5, r0, #0
102ccf70:	0a00005d 	beq	102cd0ec <Ql_RIL_FindLine+0x1c8>
         return NULL;
    
    if (len >= strlen + 4)//two \r\n
102ccf74:	e59d3008 	ldr	r3, [sp, #8]
102ccf78:	e2834004 	add	r4, r3, #4
102ccf7c:	e59d300c 	ldr	r3, [sp, #12]
102ccf80:	e1540003 	cmp	r4, r3
102ccf84:	9a00005a 	bls	102cd0f4 <Ql_RIL_FindLine+0x1d0>
                p++;
            }
        }
    }

    if (len >= strlen + 2)//two \r or two\n
102ccf88:	e59d3008 	ldr	r3, [sp, #8]
102ccf8c:	e2834002 	add	r4, r3, #2
102ccf90:	e59d300c 	ldr	r3, [sp, #12]
102ccf94:	e1530004 	cmp	r3, r4
102ccf98:	359f41e4 	ldrcc	r4, [pc, #484]	; 102cd184 <Ql_RIL_FindLine+0x260>
102ccf9c:	3a000050 	bcc	102cd0e4 <Ql_RIL_FindLine+0x1c0>
    {
        p = line;

        // <CR>xx<CR>
        Ql_memset(pStr, 0, strlen + 5);
        Ql_sprintf(pStr,"\r%s\r",str);
102ccfa0:	e59f61e0 	ldr	r6, [pc, #480]	; 102cd188 <Ql_RIL_FindLine+0x264>
    if (len >= strlen + 2)//two \r or two\n
    {
        p = line;

        // <CR>xx<CR>
        Ql_memset(pStr, 0, strlen + 5);
102ccfa4:	e59f91e0 	ldr	r9, [pc, #480]	; 102cd18c <Ql_RIL_FindLine+0x268>
102ccfa8:	e1a0200b 	mov	r2, fp
102ccfac:	e3a01000 	mov	r1, #0
102ccfb0:	e1a00005 	mov	r0, r5
102ccfb4:	e12fff39 	blx	r9
        Ql_sprintf(pStr,"\r%s\r",str);
102ccfb8:	e5963000 	ldr	r3, [r6]
102ccfbc:	e59f11cc 	ldr	r1, [pc, #460]	; 102cd190 <Ql_RIL_FindLine+0x26c>
102ccfc0:	e1a0200a 	mov	r2, sl
102ccfc4:	e1a00005 	mov	r0, r5
102ccfc8:	e12fff33 	blx	r3

        // <LF>xx<LF>
        pStr2 = (char*)Ql_MEM_Alloc(strlen + 5);
102ccfcc:	e1a0000b 	mov	r0, fp
102ccfd0:	e12fff38 	blx	r8
        Ql_memset(pStr2, 0, strlen + 5);
102ccfd4:	e1a0200b 	mov	r2, fp
102ccfd8:	e3a01000 	mov	r1, #0
        // <CR>xx<CR>
        Ql_memset(pStr, 0, strlen + 5);
        Ql_sprintf(pStr,"\r%s\r",str);

        // <LF>xx<LF>
        pStr2 = (char*)Ql_MEM_Alloc(strlen + 5);
102ccfdc:	e1a07000 	mov	r7, r0
        Ql_memset(pStr2, 0, strlen + 5);
102ccfe0:	e12fff39 	blx	r9
        Ql_sprintf(pStr2,"\n%s\n",str);
102ccfe4:	e5963000 	ldr	r3, [r6]
102ccfe8:	e59f11a4 	ldr	r1, [pc, #420]	; 102cd194 <Ql_RIL_FindLine+0x270>
102ccfec:	e1a0200a 	mov	r2, sl
102ccff0:	e1a00007 	mov	r0, r7
102ccff4:	e12fff33 	blx	r3

        // xx<CR><LF>
        pStr3 = (char*)Ql_MEM_Alloc(strlen + 5);
102ccff8:	e1a0000b 	mov	r0, fp
102ccffc:	e12fff38 	blx	r8
        Ql_memset(pStr3, 0, strlen + 5);
102cd000:	e1a0200b 	mov	r2, fp
102cd004:	e3a01000 	mov	r1, #0
        pStr2 = (char*)Ql_MEM_Alloc(strlen + 5);
        Ql_memset(pStr2, 0, strlen + 5);
        Ql_sprintf(pStr2,"\n%s\n",str);

        // xx<CR><LF>
        pStr3 = (char*)Ql_MEM_Alloc(strlen + 5);
102cd008:	e1a08000 	mov	r8, r0
        Ql_memset(pStr3, 0, strlen + 5);
102cd00c:	e12fff39 	blx	r9
        Ql_sprintf(pStr3,"%s\r\n",str);
102cd010:	e5963000 	ldr	r3, [r6]
102cd014:	e1a0200a 	mov	r2, sl
102cd018:	e1a00008 	mov	r0, r8
102cd01c:	e59f1174 	ldr	r1, [pc, #372]	; 102cd198 <Ql_RIL_FindLine+0x274>
102cd020:	e12fff33 	blx	r3

        for (i = 0;i < len - (strlen + 2) + 1; i++)
102cd024:	e59d300c 	ldr	r3, [sp, #12]
102cd028:	e59d2008 	ldr	r2, [sp, #8]
102cd02c:	e062b003 	rsb	fp, r2, r3
102cd030:	e35b0001 	cmp	fp, #1
102cd034:	0a000025 	beq	102cd0d0 <Ql_RIL_FindLine+0x1ac>
*
* Return:  
                The function returns a pointer to the located string,
                or a  null  pointer  if  the specified string is not found.
******************************************************************************/
char* Ql_RIL_FindLine(char *line, u32 len,char *str)
102cd038:	e59d3004 	ldr	r3, [sp, #4]
102cd03c:	e59f6158 	ldr	r6, [pc, #344]	; 102cd19c <Ql_RIL_FindLine+0x278>
102cd040:	e24bb001 	sub	fp, fp, #1
102cd044:	e083b00b 	add	fp, r3, fp
102cd048:	e1a09003 	mov	r9, r3
        Ql_memset(pStr3, 0, strlen + 5);
        Ql_sprintf(pStr3,"%s\r\n",str);

        for (i = 0;i < len - (strlen + 2) + 1; i++)
        {
            if ((0 == Ql_strncmp (p, pStr, strlen + 2)) ||
102cd04c:	e1a0a006 	mov	sl, r6
102cd050:	ea00000b 	b	102cd084 <Ql_RIL_FindLine+0x160>
                (0 == Ql_strncmp (p, pStr2, strlen + 2)) ||
102cd054:	e12fff3a 	blx	sl
                (0 == Ql_strncmp (p, pStr3, strlen + 2)))
102cd058:	e1a01008 	mov	r1, r8
102cd05c:	e1a02004 	mov	r2, r4
        Ql_memset(pStr3, 0, strlen + 5);
        Ql_sprintf(pStr3,"%s\r\n",str);

        for (i = 0;i < len - (strlen + 2) + 1; i++)
        {
            if ((0 == Ql_strncmp (p, pStr, strlen + 2)) ||
102cd060:	e3500000 	cmp	r0, #0
                (0 == Ql_strncmp (p, pStr2, strlen + 2)) ||
                (0 == Ql_strncmp (p, pStr3, strlen + 2)))
102cd064:	e1a00009 	mov	r0, r9
        Ql_memset(pStr3, 0, strlen + 5);
        Ql_sprintf(pStr3,"%s\r\n",str);

        for (i = 0;i < len - (strlen + 2) + 1; i++)
        {
            if ((0 == Ql_strncmp (p, pStr, strlen + 2)) ||
102cd068:	0a00000e 	beq	102cd0a8 <Ql_RIL_FindLine+0x184>
                (0 == Ql_strncmp (p, pStr2, strlen + 2)) ||
                (0 == Ql_strncmp (p, pStr3, strlen + 2)))
102cd06c:	e12fff3a 	blx	sl
        Ql_sprintf(pStr3,"%s\r\n",str);

        for (i = 0;i < len - (strlen + 2) + 1; i++)
        {
            if ((0 == Ql_strncmp (p, pStr, strlen + 2)) ||
                (0 == Ql_strncmp (p, pStr2, strlen + 2)) ||
102cd070:	e3500000 	cmp	r0, #0
102cd074:	0a00000b 	beq	102cd0a8 <Ql_RIL_FindLine+0x184>
                pStr = NULL;
                pStr2 = NULL;
                pStr3 = NULL;
                return p;
            }else{
                p++;
102cd078:	e2899001 	add	r9, r9, #1
        // xx<CR><LF>
        pStr3 = (char*)Ql_MEM_Alloc(strlen + 5);
        Ql_memset(pStr3, 0, strlen + 5);
        Ql_sprintf(pStr3,"%s\r\n",str);

        for (i = 0;i < len - (strlen + 2) + 1; i++)
102cd07c:	e159000b 	cmp	r9, fp
102cd080:	0a000012 	beq	102cd0d0 <Ql_RIL_FindLine+0x1ac>
        {
            if ((0 == Ql_strncmp (p, pStr, strlen + 2)) ||
102cd084:	e1a01005 	mov	r1, r5
102cd088:	e1a02004 	mov	r2, r4
102cd08c:	e1a00009 	mov	r0, r9
102cd090:	e12fff36 	blx	r6
                (0 == Ql_strncmp (p, pStr2, strlen + 2)) ||
102cd094:	e1a01007 	mov	r1, r7
102cd098:	e1a02004 	mov	r2, r4
        Ql_memset(pStr3, 0, strlen + 5);
        Ql_sprintf(pStr3,"%s\r\n",str);

        for (i = 0;i < len - (strlen + 2) + 1; i++)
        {
            if ((0 == Ql_strncmp (p, pStr, strlen + 2)) ||
102cd09c:	e3500000 	cmp	r0, #0
                (0 == Ql_strncmp (p, pStr2, strlen + 2)) ||
102cd0a0:	e1a00009 	mov	r0, r9
        Ql_memset(pStr3, 0, strlen + 5);
        Ql_sprintf(pStr3,"%s\r\n",str);

        for (i = 0;i < len - (strlen + 2) + 1; i++)
        {
            if ((0 == Ql_strncmp (p, pStr, strlen + 2)) ||
102cd0a4:	1affffea 	bne	102cd054 <Ql_RIL_FindLine+0x130>
                (0 == Ql_strncmp (p, pStr2, strlen + 2)) ||
                (0 == Ql_strncmp (p, pStr3, strlen + 2)))
            {
                Ql_MEM_Free(pStr);
102cd0a8:	e59f40d4 	ldr	r4, [pc, #212]	; 102cd184 <Ql_RIL_FindLine+0x260>
102cd0ac:	e1a00005 	mov	r0, r5
102cd0b0:	e12fff34 	blx	r4
                Ql_MEM_Free(pStr2);
102cd0b4:	e1a00007 	mov	r0, r7
102cd0b8:	e12fff34 	blx	r4
                Ql_MEM_Free(pStr3);
102cd0bc:	e1a00008 	mov	r0, r8
102cd0c0:	e12fff34 	blx	r4
    }
    Ql_MEM_Free(pStr);
    pStr = NULL;
    
    return NULL;
}
102cd0c4:	e1a00009 	mov	r0, r9
102cd0c8:	e28dd014 	add	sp, sp, #20
102cd0cc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                return p;
            }else{
                p++;
            }
        }
        Ql_MEM_Free(pStr2);
102cd0d0:	e1a00007 	mov	r0, r7
102cd0d4:	e59f40a8 	ldr	r4, [pc, #168]	; 102cd184 <Ql_RIL_FindLine+0x260>
102cd0d8:	e12fff34 	blx	r4
        Ql_MEM_Free(pStr3);
102cd0dc:	e1a00008 	mov	r0, r8
102cd0e0:	e12fff34 	blx	r4
        pStr2 = NULL;
        pStr3 = NULL;
    }
    Ql_MEM_Free(pStr);
102cd0e4:	e1a00005 	mov	r0, r5
102cd0e8:	e12fff34 	blx	r4
    pStr = NULL;
    
    return NULL;
102cd0ec:	e3a09000 	mov	r9, #0
102cd0f0:	eafffff3 	b	102cd0c4 <Ql_RIL_FindLine+0x1a0>
         return NULL;
    
    if (len >= strlen + 4)//two \r\n
    {
        p = line;
        Ql_memset(pStr, 0, strlen + 5);
102cd0f4:	e1a01006 	mov	r1, r6
102cd0f8:	e1a0200b 	mov	r2, fp
102cd0fc:	e59f3088 	ldr	r3, [pc, #136]	; 102cd18c <Ql_RIL_FindLine+0x268>
102cd100:	e12fff33 	blx	r3
        Ql_sprintf(pStr,"\r\n%s\r\n",str);
102cd104:	e59f307c 	ldr	r3, [pc, #124]	; 102cd188 <Ql_RIL_FindLine+0x264>
102cd108:	e1a0200a 	mov	r2, sl
102cd10c:	e5933000 	ldr	r3, [r3]
102cd110:	e1a00005 	mov	r0, r5
102cd114:	e59f1084 	ldr	r1, [pc, #132]	; 102cd1a0 <Ql_RIL_FindLine+0x27c>
102cd118:	e12fff33 	blx	r3
        for (i = 0;i < len - (strlen + 4) + 1; i++)
102cd11c:	e59d300c 	ldr	r3, [sp, #12]
102cd120:	e59d2008 	ldr	r2, [sp, #8]
102cd124:	e0627003 	rsb	r7, r2, r3
102cd128:	e3570003 	cmp	r7, #3
102cd12c:	0affff95 	beq	102ccf88 <Ql_RIL_FindLine+0x64>
*
* Return:  
                The function returns a pointer to the located string,
                or a  null  pointer  if  the specified string is not found.
******************************************************************************/
char* Ql_RIL_FindLine(char *line, u32 len,char *str)
102cd130:	e59d3004 	ldr	r3, [sp, #4]
102cd134:	e2477003 	sub	r7, r7, #3
102cd138:	e59f605c 	ldr	r6, [pc, #92]	; 102cd19c <Ql_RIL_FindLine+0x278>
102cd13c:	e0837007 	add	r7, r3, r7
102cd140:	e1a09003 	mov	r9, r3
102cd144:	ea000002 	b	102cd154 <Ql_RIL_FindLine+0x230>
            if (0 == Ql_strncmp(p, pStr, strlen + 4))
            {
                Ql_MEM_Free(pStr);
                return p;
            }else{
                p++;
102cd148:	e2899001 	add	r9, r9, #1
    if (len >= strlen + 4)//two \r\n
    {
        p = line;
        Ql_memset(pStr, 0, strlen + 5);
        Ql_sprintf(pStr,"\r\n%s\r\n",str);
        for (i = 0;i < len - (strlen + 4) + 1; i++)
102cd14c:	e1590007 	cmp	r9, r7
102cd150:	0affff8c 	beq	102ccf88 <Ql_RIL_FindLine+0x64>
        {
            if (0 == Ql_strncmp(p, pStr, strlen + 4))
102cd154:	e1a00009 	mov	r0, r9
102cd158:	e1a01005 	mov	r1, r5
102cd15c:	e1a02004 	mov	r2, r4
102cd160:	e12fff36 	blx	r6
102cd164:	e3500000 	cmp	r0, #0
102cd168:	1afffff6 	bne	102cd148 <Ql_RIL_FindLine+0x224>
            {
                Ql_MEM_Free(pStr);
102cd16c:	e1a00005 	mov	r0, r5
102cd170:	e59f200c 	ldr	r2, [pc, #12]	; 102cd184 <Ql_RIL_FindLine+0x260>
102cd174:	e12fff32 	blx	r2
                return p;
102cd178:	eaffffd1 	b	102cd0c4 <Ql_RIL_FindLine+0x1a0>
102cd17c:	102e57a4 	.word	0x102e57a4
102cd180:	102e4840 	.word	0x102e4840
102cd184:	102e48b8 	.word	0x102e48b8
102cd188:	f03de540 	.word	0xf03de540
102cd18c:	102e58f4 	.word	0x102e58f4
102cd190:	102ee8bc 	.word	0x102ee8bc
102cd194:	102ee8c4 	.word	0x102ee8c4
102cd198:	102efa90 	.word	0x102efa90
102cd19c:	102e5884 	.word	0x102e5884
102cd1a0:	102ee8b4 	.word	0x102ee8b4

102cd1a4 <Ql_GenHash>:

u32 Ql_GenHash(char* strSrc, u32 len)
{
    u32 h, v;
    u32 i;
    for (h = 0, i = 0; i < len; i++)
102cd1a4:	e3510000 	cmp	r1, #0
    
    return NULL;
}

u32 Ql_GenHash(char* strSrc, u32 len)
{
102cd1a8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    u32 h, v;
    u32 i;
    for (h = 0, i = 0; i < len; i++)
102cd1ac:	0a00000e 	beq	102cd1ec <Ql_GenHash+0x48>
    {
        h = (u32)(5527 * h + 7 * strSrc[i]);
102cd1b0:	e59f403c 	ldr	r4, [pc, #60]	; 102cd1f4 <Ql_GenHash+0x50>
102cd1b4:	e1a03000 	mov	r3, r0
    pStr = NULL;
    
    return NULL;
}

u32 Ql_GenHash(char* strSrc, u32 len)
102cd1b8:	e080c001 	add	ip, r0, r1
{
    u32 h, v;
    u32 i;
    for (h = 0, i = 0; i < len; i++)
102cd1bc:	e3a00000 	mov	r0, #0
    {
        h = (u32)(5527 * h + 7 * strSrc[i]);
102cd1c0:	e4d31001 	ldrb	r1, [r3], #1
102cd1c4:	e0611181 	rsb	r1, r1, r1, lsl #3
102cd1c8:	e0201094 	mla	r0, r4, r0, r1

u32 Ql_GenHash(char* strSrc, u32 len)
{
    u32 h, v;
    u32 i;
    for (h = 0, i = 0; i < len; i++)
102cd1cc:	e153000c 	cmp	r3, ip
    {
        h = (u32)(5527 * h + 7 * strSrc[i]);
        v = h & 0x0000ffff;
102cd1d0:	e1a02800 	lsl	r2, r0, #16
102cd1d4:	e1a02822 	lsr	r2, r2, #16
        h ^= v * v;
102cd1d8:	e0010292 	mul	r1, r2, r2
102cd1dc:	e0210000 	eor	r0, r1, r0

u32 Ql_GenHash(char* strSrc, u32 len)
{
    u32 h, v;
    u32 i;
    for (h = 0, i = 0; i < len; i++)
102cd1e0:	1afffff6 	bne	102cd1c0 <Ql_GenHash+0x1c>
        h = (u32)(5527 * h + 7 * strSrc[i]);
        v = h & 0x0000ffff;
        h ^= v * v;
    }
    return h;
}
102cd1e4:	e8bd0010 	ldmfd	sp!, {r4}
102cd1e8:	e12fff1e 	bx	lr

u32 Ql_GenHash(char* strSrc, u32 len)
{
    u32 h, v;
    u32 i;
    for (h = 0, i = 0; i < len; i++)
102cd1ec:	e1a00001 	mov	r0, r1
102cd1f0:	eafffffb 	b	102cd1e4 <Ql_GenHash+0x40>
102cd1f4:	00001597 	.word	0x00001597

102cd1f8 <Callback_OnTimer>:
 * Return:
 *           void
 *****************************************************************/

void Callback_OnTimer(u32 timerId, void* param)
{
102cd1f8:	e92d4008 	push	{r3, lr}
	if(timerId ==  Timer_Delay)
102cd1fc:	e59f305c 	ldr	r3, [pc, #92]	; 102cd260 <Callback_OnTimer+0x68>
102cd200:	e5933000 	ldr	r3, [r3]
102cd204:	e1500003 	cmp	r0, r3
102cd208:	18bd8008 	popne	{r3, pc}
	{
		Ql_Timer_Stop(Timer_Delay);
102cd20c:	e59f3050 	ldr	r3, [pc, #80]	; 102cd264 <Callback_OnTimer+0x6c>
102cd210:	e12fff33 	blx	r3
#ifdef DEBUG_MSG
		APP_DEBUG("Timer Event : Timer_Delay\r\n");
102cd214:	e3a02c02 	mov	r2, #512	; 0x200
102cd218:	e3a01000 	mov	r1, #0
102cd21c:	e59f3044 	ldr	r3, [pc, #68]	; 102cd268 <Callback_OnTimer+0x70>
102cd220:	e59f0044 	ldr	r0, [pc, #68]	; 102cd26c <Callback_OnTimer+0x74>
102cd224:	e12fff33 	blx	r3
102cd228:	e59f3040 	ldr	r3, [pc, #64]	; 102cd270 <Callback_OnTimer+0x78>
102cd22c:	e59f1040 	ldr	r1, [pc, #64]	; 102cd274 <Callback_OnTimer+0x7c>
102cd230:	e5933000 	ldr	r3, [r3]
102cd234:	e59f0030 	ldr	r0, [pc, #48]	; 102cd26c <Callback_OnTimer+0x74>
102cd238:	e12fff33 	blx	r3
102cd23c:	e59f3034 	ldr	r3, [pc, #52]	; 102cd278 <Callback_OnTimer+0x80>
102cd240:	e59f0024 	ldr	r0, [pc, #36]	; 102cd26c <Callback_OnTimer+0x74>
102cd244:	e12fff33 	blx	r3
102cd248:	e59f101c 	ldr	r1, [pc, #28]	; 102cd26c <Callback_OnTimer+0x74>
102cd24c:	e59f3028 	ldr	r3, [pc, #40]	; 102cd27c <Callback_OnTimer+0x84>
102cd250:	e1a02000 	mov	r2, r0
102cd254:	e3a0000a 	mov	r0, #10
102cd258:	e12fff33 	blx	r3
102cd25c:	e8bd8008 	pop	{r3, pc}
102cd260:	f03d2024 	.word	0xf03d2024
102cd264:	102e60f0 	.word	0x102e60f0
102cd268:	102e58f4 	.word	0x102e58f4
102cd26c:	f03d5528 	.word	0xf03d5528
102cd270:	f03de540 	.word	0xf03de540
102cd274:	102ee8cc 	.word	0x102ee8cc
102cd278:	102e57a4 	.word	0x102e57a4
102cd27c:	102e6230 	.word	0x102e6230

102cd280 <Timer_register>:
{

	s32 ret;


	ret = Ql_Timer_Register(Timer_Delay, Callback_OnTimer, NULL);
102cd280:	e59f306c 	ldr	r3, [pc, #108]	; 102cd2f4 <Timer_register+0x74>
 * Return:
 *           void
 *****************************************************************/

void Timer_register(void)
{
102cd284:	e92d4010 	push	{r4, lr}

	s32 ret;


	ret = Ql_Timer_Register(Timer_Delay, Callback_OnTimer, NULL);
102cd288:	e5930000 	ldr	r0, [r3]
102cd28c:	e59f1064 	ldr	r1, [pc, #100]	; 102cd2f8 <Timer_register+0x78>
102cd290:	e3a02000 	mov	r2, #0
102cd294:	e59f3060 	ldr	r3, [pc, #96]	; 102cd2fc <Timer_register+0x7c>
102cd298:	e12fff33 	blx	r3
	if(ret <0)
102cd29c:	e2504000 	subs	r4, r0, #0
102cd2a0:	a8bd8010 	popge	{r4, pc}
	{
#ifdef INOUT
			APP_DEBUG("\r<-- Error, Ql_Timer_Register : Timer_TimeOut, ret : %d -->\r\n",ret);
102cd2a4:	e3a01000 	mov	r1, #0
102cd2a8:	e3a02c02 	mov	r2, #512	; 0x200
102cd2ac:	e59f304c 	ldr	r3, [pc, #76]	; 102cd300 <Timer_register+0x80>
102cd2b0:	e59f004c 	ldr	r0, [pc, #76]	; 102cd304 <Timer_register+0x84>
102cd2b4:	e12fff33 	blx	r3
102cd2b8:	e59f3048 	ldr	r3, [pc, #72]	; 102cd308 <Timer_register+0x88>
102cd2bc:	e1a02004 	mov	r2, r4
102cd2c0:	e59f1044 	ldr	r1, [pc, #68]	; 102cd30c <Timer_register+0x8c>
102cd2c4:	e5933000 	ldr	r3, [r3]
102cd2c8:	e59f0034 	ldr	r0, [pc, #52]	; 102cd304 <Timer_register+0x84>
102cd2cc:	e12fff33 	blx	r3
102cd2d0:	e59f3038 	ldr	r3, [pc, #56]	; 102cd310 <Timer_register+0x90>
102cd2d4:	e59f0028 	ldr	r0, [pc, #40]	; 102cd304 <Timer_register+0x84>
102cd2d8:	e12fff33 	blx	r3
102cd2dc:	e59f1020 	ldr	r1, [pc, #32]	; 102cd304 <Timer_register+0x84>
102cd2e0:	e59f302c 	ldr	r3, [pc, #44]	; 102cd314 <Timer_register+0x94>
102cd2e4:	e1a02000 	mov	r2, r0
102cd2e8:	e3a0000a 	mov	r0, #10
102cd2ec:	e12fff33 	blx	r3
102cd2f0:	e8bd8010 	pop	{r4, pc}
102cd2f4:	f03d2024 	.word	0xf03d2024
102cd2f8:	102cd1f8 	.word	0x102cd1f8
102cd2fc:	102e6010 	.word	0x102e6010
102cd300:	102e58f4 	.word	0x102e58f4
102cd304:	f03d5528 	.word	0xf03d5528
102cd308:	f03de540 	.word	0xf03de540
102cd30c:	102ee8e8 	.word	0x102ee8e8
102cd310:	102e57a4 	.word	0x102e57a4
102cd314:	102e6230 	.word	0x102e6230

102cd318 <timer_handler_watchdogFeed>:
}


void timer_handler_watchdogFeed(u32 timerId, void* param)
{
	Ql_WTD_Feed(wtdid);
102cd318:	e59f305c 	ldr	r3, [pc, #92]	; 102cd37c <timer_handler_watchdogFeed+0x64>
//
}


void timer_handler_watchdogFeed(u32 timerId, void* param)
{
102cd31c:	e92d4010 	push	{r4, lr}
	Ql_WTD_Feed(wtdid);
	APP_DEBUG("<-- Time to Feed Logic Watchdog -->\r\n");
102cd320:	e59f4058 	ldr	r4, [pc, #88]	; 102cd380 <timer_handler_watchdogFeed+0x68>
}


void timer_handler_watchdogFeed(u32 timerId, void* param)
{
	Ql_WTD_Feed(wtdid);
102cd324:	e5930000 	ldr	r0, [r3]
102cd328:	e59f3054 	ldr	r3, [pc, #84]	; 102cd384 <timer_handler_watchdogFeed+0x6c>
102cd32c:	e12fff33 	blx	r3
	APP_DEBUG("<-- Time to Feed Logic Watchdog -->\r\n");
102cd330:	e3a02c02 	mov	r2, #512	; 0x200
102cd334:	e3a01000 	mov	r1, #0
102cd338:	e1a00004 	mov	r0, r4
102cd33c:	e59f3044 	ldr	r3, [pc, #68]	; 102cd388 <timer_handler_watchdogFeed+0x70>
102cd340:	e12fff33 	blx	r3
102cd344:	e59f3040 	ldr	r3, [pc, #64]	; 102cd38c <timer_handler_watchdogFeed+0x74>
102cd348:	e59f1040 	ldr	r1, [pc, #64]	; 102cd390 <timer_handler_watchdogFeed+0x78>
102cd34c:	e5933000 	ldr	r3, [r3]
102cd350:	e1a00004 	mov	r0, r4
102cd354:	e12fff33 	blx	r3
102cd358:	e1a00004 	mov	r0, r4
102cd35c:	e59f3030 	ldr	r3, [pc, #48]	; 102cd394 <timer_handler_watchdogFeed+0x7c>
102cd360:	e12fff33 	blx	r3
102cd364:	e1a01004 	mov	r1, r4
102cd368:	e59f3028 	ldr	r3, [pc, #40]	; 102cd398 <timer_handler_watchdogFeed+0x80>
102cd36c:	e1a02000 	mov	r2, r0
102cd370:	e3a0000a 	mov	r0, #10
102cd374:	e12fff33 	blx	r3
102cd378:	e8bd8010 	pop	{r4, pc}
102cd37c:	f03da8c8 	.word	0xf03da8c8
102cd380:	f03d5528 	.word	0xf03d5528
102cd384:	102e642c 	.word	0x102e642c
102cd388:	102e58f4 	.word	0x102e58f4
102cd38c:	f03de540 	.word	0xf03de540
102cd390:	102ee928 	.word	0x102ee928
102cd394:	102e57a4 	.word	0x102e57a4
102cd398:	102e6230 	.word	0x102e6230

102cd39c <MQTTSerialize_connectLength>:
  * Determines the length of the MQTT connect packet that would be produced using the supplied connect options.
  * @param options the options to be used to build the connect packet
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_connectLength(MQTTPacket_connectData* options)
{
102cd39c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int len = 0;

	if (options->MQTTVersion == 3)
102cd3a0:	e5d05008 	ldrb	r5, [r0, #8]
  * Determines the length of the MQTT connect packet that would be produced using the supplied connect options.
  * @param options the options to be used to build the connect packet
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_connectLength(MQTTPacket_connectData* options)
{
102cd3a4:	e1a04000 	mov	r4, r0
	int len = 0;

	if (options->MQTTVersion == 3)
102cd3a8:	e3550003 	cmp	r5, #3
		len = 12; /* variable depending on MQTT or MQIsdp */
102cd3ac:	03a0500c 	moveq	r5, #12
  */
int MQTTSerialize_connectLength(MQTTPacket_connectData* options)
{
	int len = 0;

	if (options->MQTTVersion == 3)
102cd3b0:	0a000002 	beq	102cd3c0 <MQTTSerialize_connectLength+0x24>
  * @param options the options to be used to build the connect packet
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_connectLength(MQTTPacket_connectData* options)
{
	int len = 0;
102cd3b4:	e3550004 	cmp	r5, #4
102cd3b8:	03a0500a 	moveq	r5, #10
102cd3bc:	13a05000 	movne	r5, #0
	if (options->MQTTVersion == 3)
		len = 12; /* variable depending on MQTT or MQIsdp */
	else if (options->MQTTVersion == 4)
		len = 10;

	len += MQTTstrlen(options->clientID)+2;
102cd3c0:	e284300c 	add	r3, r4, #12
102cd3c4:	e8930007 	ldm	r3, {r0, r1, r2}
102cd3c8:	e59f60a8 	ldr	r6, [pc, #168]	; 102cd478 <MQTTSerialize_connectLength+0xdc>
102cd3cc:	e12fff36 	blx	r6
	if (options->willFlag)
102cd3d0:	e5d4301b 	ldrb	r3, [r4, #27]
102cd3d4:	e3530000 	cmp	r3, #0
	if (options->MQTTVersion == 3)
		len = 12; /* variable depending on MQTT or MQIsdp */
	else if (options->MQTTVersion == 4)
		len = 10;

	len += MQTTstrlen(options->clientID)+2;
102cd3d8:	e2800002 	add	r0, r0, #2
102cd3dc:	e0805005 	add	r5, r0, r5
	if (options->willFlag)
102cd3e0:	1a000019 	bne	102cd44c <MQTTSerialize_connectLength+0xb0>
		len += MQTTstrlen(options->will.topicName)+2 + MQTTstrlen(options->will.message)+2;
	if (options->username.cstring || options->username.lenstring.data)
102cd3e4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
102cd3e8:	e3530000 	cmp	r3, #0
102cd3ec:	0a00000e 	beq	102cd42c <MQTTSerialize_connectLength+0x90>
		len += MQTTstrlen(options->username)+2;
102cd3f0:	e2843040 	add	r3, r4, #64	; 0x40
102cd3f4:	e8930007 	ldm	r3, {r0, r1, r2}
102cd3f8:	e12fff36 	blx	r6
102cd3fc:	e2800002 	add	r0, r0, #2
102cd400:	e0855000 	add	r5, r5, r0
	if (options->password.cstring || options->password.lenstring.data)
102cd404:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
102cd408:	e3530000 	cmp	r3, #0
102cd40c:	0a00000a 	beq	102cd43c <MQTTSerialize_connectLength+0xa0>
		len += MQTTstrlen(options->password)+2;
102cd410:	e284404c 	add	r4, r4, #76	; 0x4c
102cd414:	e8940007 	ldm	r4, {r0, r1, r2}
102cd418:	e12fff36 	blx	r6
102cd41c:	e2800002 	add	r0, r0, #2
102cd420:	e0855000 	add	r5, r5, r0

	return len;
}
102cd424:	e1a00005 	mov	r0, r5
102cd428:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		len = 10;

	len += MQTTstrlen(options->clientID)+2;
	if (options->willFlag)
		len += MQTTstrlen(options->will.topicName)+2 + MQTTstrlen(options->will.message)+2;
	if (options->username.cstring || options->username.lenstring.data)
102cd42c:	e5943048 	ldr	r3, [r4, #72]	; 0x48
102cd430:	e3530000 	cmp	r3, #0
102cd434:	1affffed 	bne	102cd3f0 <MQTTSerialize_connectLength+0x54>
102cd438:	eafffff1 	b	102cd404 <MQTTSerialize_connectLength+0x68>
		len += MQTTstrlen(options->username)+2;
	if (options->password.cstring || options->password.lenstring.data)
102cd43c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
102cd440:	e3530000 	cmp	r3, #0
102cd444:	1afffff1 	bne	102cd410 <MQTTSerialize_connectLength+0x74>
102cd448:	eafffff5 	b	102cd424 <MQTTSerialize_connectLength+0x88>
	else if (options->MQTTVersion == 4)
		len = 10;

	len += MQTTstrlen(options->clientID)+2;
	if (options->willFlag)
		len += MQTTstrlen(options->will.topicName)+2 + MQTTstrlen(options->will.message)+2;
102cd44c:	e2843024 	add	r3, r4, #36	; 0x24
102cd450:	e8930007 	ldm	r3, {r0, r1, r2}
102cd454:	e12fff36 	blx	r6
102cd458:	e2843030 	add	r3, r4, #48	; 0x30
102cd45c:	e1a07000 	mov	r7, r0
102cd460:	e8930007 	ldm	r3, {r0, r1, r2}
102cd464:	e12fff36 	blx	r6
102cd468:	e0800007 	add	r0, r0, r7
102cd46c:	e2807004 	add	r7, r0, #4
102cd470:	e0855007 	add	r5, r5, r7
102cd474:	eaffffda 	b	102cd3e4 <MQTTSerialize_connectLength+0x48>
102cd478:	102cdcd4 	.word	0x102cdcd4

102cd47c <MQTTSerialize_connect>:
  * @param len the length in bytes of the supplied buffer
  * @param options the options to be used to build the connect packet
  * @return serialized length, or error if 0
  */
int MQTTSerialize_connect(unsigned char* buf, int buflen, MQTTPacket_connectData* options)
{
102cd47c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102cd480:	e1a06000 	mov	r6, r0
102cd484:	e24dd008 	sub	sp, sp, #8
	MQTTHeader header = {0};
	MQTTConnectFlags flags = {0};
	int len = 0;
	int rc = -1;

	if (MQTTPacket_len(len = MQTTSerialize_connectLength(options)) > buflen)
102cd488:	e1a00002 	mov	r0, r2
  * @param len the length in bytes of the supplied buffer
  * @param options the options to be used to build the connect packet
  * @return serialized length, or error if 0
  */
int MQTTSerialize_connect(unsigned char* buf, int buflen, MQTTPacket_connectData* options)
{
102cd48c:	e1a05001 	mov	r5, r1
102cd490:	e1a04002 	mov	r4, r2
	unsigned char *ptr = buf;
102cd494:	e58d6004 	str	r6, [sp, #4]
	MQTTHeader header = {0};
	MQTTConnectFlags flags = {0};
	int len = 0;
	int rc = -1;

	if (MQTTPacket_len(len = MQTTSerialize_connectLength(options)) > buflen)
102cd498:	ebffffbf 	bl	102cd39c <MQTTSerialize_connectLength>
102cd49c:	e59f31d8 	ldr	r3, [pc, #472]	; 102cd67c <MQTTSerialize_connect+0x200>
102cd4a0:	e1a08000 	mov	r8, r0
102cd4a4:	e12fff33 	blx	r3
102cd4a8:	e1500005 	cmp	r0, r5
102cd4ac:	ca000070 	bgt	102cd674 <MQTTSerialize_connect+0x1f8>
		return rc;
	}

	header.byte = 0;
	header.bits.type = CONNECT;
	writeChar(&ptr, header.byte); /* write header */
102cd4b0:	e28d0004 	add	r0, sp, #4
102cd4b4:	e3a01010 	mov	r1, #16
102cd4b8:	e59f51c0 	ldr	r5, [pc, #448]	; 102cd680 <MQTTSerialize_connect+0x204>
102cd4bc:	e12fff35 	blx	r5

	ptr += MQTTPacket_encode(ptr, len); /* write remaining length */
102cd4c0:	e59d7004 	ldr	r7, [sp, #4]
102cd4c4:	e1a01008 	mov	r1, r8
102cd4c8:	e1a00007 	mov	r0, r7
102cd4cc:	e59f31b0 	ldr	r3, [pc, #432]	; 102cd684 <MQTTSerialize_connect+0x208>
102cd4d0:	e12fff33 	blx	r3

	if (options->MQTTVersion == 4)
102cd4d4:	e5d48008 	ldrb	r8, [r4, #8]
102cd4d8:	e3580004 	cmp	r8, #4

	header.byte = 0;
	header.bits.type = CONNECT;
	writeChar(&ptr, header.byte); /* write header */

	ptr += MQTTPacket_encode(ptr, len); /* write remaining length */
102cd4dc:	e0870000 	add	r0, r7, r0
102cd4e0:	e58d0004 	str	r0, [sp, #4]

	if (options->MQTTVersion == 4)
102cd4e4:	0a000054 	beq	102cd63c <MQTTSerialize_connect+0x1c0>
		writeCString(&ptr, "MQTT");
		writeChar(&ptr, (char) 4);
	}
	else
	{
		writeCString(&ptr, "MQIsdp");
102cd4e8:	e59f1198 	ldr	r1, [pc, #408]	; 102cd688 <MQTTSerialize_connect+0x20c>
102cd4ec:	e28d0004 	add	r0, sp, #4
102cd4f0:	e59f3194 	ldr	r3, [pc, #404]	; 102cd68c <MQTTSerialize_connect+0x210>
102cd4f4:	e12fff33 	blx	r3
		writeChar(&ptr, (char) 3);
102cd4f8:	e28d0004 	add	r0, sp, #4
102cd4fc:	e3a01003 	mov	r1, #3
102cd500:	e12fff35 	blx	r5
	}

	flags.all = 0;
	flags.bits.cleansession = options->cleansession;
	flags.bits.will = (options->willFlag) ? 1 : 0;
102cd504:	e5d4301b 	ldrb	r3, [r4, #27]
		writeCString(&ptr, "MQIsdp");
		writeChar(&ptr, (char) 3);
	}

	flags.all = 0;
	flags.bits.cleansession = options->cleansession;
102cd508:	e5d4101a 	ldrb	r1, [r4, #26]
	flags.bits.will = (options->willFlag) ? 1 : 0;
102cd50c:	e2933000 	adds	r3, r3, #0
102cd510:	13a03001 	movne	r3, #1
		writeCString(&ptr, "MQIsdp");
		writeChar(&ptr, (char) 3);
	}

	flags.all = 0;
	flags.bits.cleansession = options->cleansession;
102cd514:	e2011001 	and	r1, r1, #1
	flags.bits.will = (options->willFlag) ? 1 : 0;
102cd518:	e1a02103 	lsl	r2, r3, #2
	if (flags.bits.will)
102cd51c:	e3530000 	cmp	r3, #0
		writeChar(&ptr, (char) 3);
	}

	flags.all = 0;
	flags.bits.cleansession = options->cleansession;
	flags.bits.will = (options->willFlag) ? 1 : 0;
102cd520:	e1821081 	orr	r1, r2, r1, lsl #1
	if (flags.bits.will)
102cd524:	1a000020 	bne	102cd5ac <MQTTSerialize_connect+0x130>
	{
		flags.bits.willQoS = options->will.qos;
		flags.bits.willRetain = options->will.retained;
	}

	if (options->username.cstring || options->username.lenstring.data)
102cd528:	e5943040 	ldr	r3, [r4, #64]	; 0x40
102cd52c:	e3530000 	cmp	r3, #0
102cd530:	0a000028 	beq	102cd5d8 <MQTTSerialize_connect+0x15c>
		flags.bits.username = 1;
102cd534:	e3811080 	orr	r1, r1, #128	; 0x80
102cd538:	e3a08001 	mov	r8, #1
	if (options->password.cstring || options->password.lenstring.data)
102cd53c:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
102cd540:	e3530000 	cmp	r3, #0
102cd544:	0a000044 	beq	102cd65c <MQTTSerialize_connect+0x1e0>
		flags.bits.password = 1;
102cd548:	e3811040 	orr	r1, r1, #64	; 0x40
102cd54c:	e3a07001 	mov	r7, #1

	writeChar(&ptr, flags.all);
102cd550:	e20110ff 	and	r1, r1, #255	; 0xff
102cd554:	e28d0004 	add	r0, sp, #4
102cd558:	e12fff35 	blx	r5
	writeInt(&ptr, options->keepAliveInterval);
102cd55c:	e28d0004 	add	r0, sp, #4
102cd560:	e1d411b8 	ldrh	r1, [r4, #24]
102cd564:	e59f3124 	ldr	r3, [pc, #292]	; 102cd690 <MQTTSerialize_connect+0x214>
102cd568:	e12fff33 	blx	r3
	writeMQTTString(&ptr, options->clientID);
102cd56c:	e284300c 	add	r3, r4, #12
102cd570:	e893000e 	ldm	r3, {r1, r2, r3}
102cd574:	e28d0004 	add	r0, sp, #4
102cd578:	e59f5114 	ldr	r5, [pc, #276]	; 102cd694 <MQTTSerialize_connect+0x218>
102cd57c:	e12fff35 	blx	r5
	if (options->willFlag)
102cd580:	e5d4301b 	ldrb	r3, [r4, #27]
102cd584:	e3530000 	cmp	r3, #0
102cd588:	1a000022 	bne	102cd618 <MQTTSerialize_connect+0x19c>
	{
		writeMQTTString(&ptr, options->will.topicName);
		writeMQTTString(&ptr, options->will.message);
	}
	if (flags.bits.username)
102cd58c:	e3580000 	cmp	r8, #0
102cd590:	1a00001b 	bne	102cd604 <MQTTSerialize_connect+0x188>
		writeMQTTString(&ptr, options->username);
	if (flags.bits.password)
102cd594:	e3570000 	cmp	r7, #0
102cd598:	1a000014 	bne	102cd5f0 <MQTTSerialize_connect+0x174>
		writeMQTTString(&ptr, options->password);

	rc = ptr - buf;
102cd59c:	e59d0004 	ldr	r0, [sp, #4]
102cd5a0:	e0660000 	rsb	r0, r6, r0
	return rc;
}
102cd5a4:	e28dd008 	add	sp, sp, #8
102cd5a8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	flags.all = 0;
	flags.bits.cleansession = options->cleansession;
	flags.bits.will = (options->willFlag) ? 1 : 0;
	if (flags.bits.will)
	{
		flags.bits.willQoS = options->will.qos;
102cd5ac:	e5d4203d 	ldrb	r2, [r4, #61]	; 0x3d
102cd5b0:	e3c11018 	bic	r1, r1, #24
102cd5b4:	e2022003 	and	r2, r2, #3
		flags.bits.willRetain = options->will.retained;
102cd5b8:	e5d4303c 	ldrb	r3, [r4, #60]	; 0x3c
	flags.all = 0;
	flags.bits.cleansession = options->cleansession;
	flags.bits.will = (options->willFlag) ? 1 : 0;
	if (flags.bits.will)
	{
		flags.bits.willQoS = options->will.qos;
102cd5bc:	e1811182 	orr	r1, r1, r2, lsl #3
		flags.bits.willRetain = options->will.retained;
102cd5c0:	e2033001 	and	r3, r3, #1
102cd5c4:	e3c11020 	bic	r1, r1, #32
102cd5c8:	e1811283 	orr	r1, r1, r3, lsl #5
	}

	if (options->username.cstring || options->username.lenstring.data)
102cd5cc:	e5943040 	ldr	r3, [r4, #64]	; 0x40
102cd5d0:	e3530000 	cmp	r3, #0
102cd5d4:	1affffd6 	bne	102cd534 <MQTTSerialize_connect+0xb8>
102cd5d8:	e5943048 	ldr	r3, [r4, #72]	; 0x48
102cd5dc:	e3530000 	cmp	r3, #0
102cd5e0:	01a083a1 	lsreq	r8, r1, #7
102cd5e4:	02088001 	andeq	r8, r8, #1
102cd5e8:	1affffd1 	bne	102cd534 <MQTTSerialize_connect+0xb8>
102cd5ec:	eaffffd2 	b	102cd53c <MQTTSerialize_connect+0xc0>
		writeMQTTString(&ptr, options->will.message);
	}
	if (flags.bits.username)
		writeMQTTString(&ptr, options->username);
	if (flags.bits.password)
		writeMQTTString(&ptr, options->password);
102cd5f0:	e284404c 	add	r4, r4, #76	; 0x4c
102cd5f4:	e28d0004 	add	r0, sp, #4
102cd5f8:	e894000e 	ldm	r4, {r1, r2, r3}
102cd5fc:	e12fff35 	blx	r5
102cd600:	eaffffe5 	b	102cd59c <MQTTSerialize_connect+0x120>
	{
		writeMQTTString(&ptr, options->will.topicName);
		writeMQTTString(&ptr, options->will.message);
	}
	if (flags.bits.username)
		writeMQTTString(&ptr, options->username);
102cd604:	e2843040 	add	r3, r4, #64	; 0x40
102cd608:	e28d0004 	add	r0, sp, #4
102cd60c:	e893000e 	ldm	r3, {r1, r2, r3}
102cd610:	e12fff35 	blx	r5
102cd614:	eaffffde 	b	102cd594 <MQTTSerialize_connect+0x118>
	writeChar(&ptr, flags.all);
	writeInt(&ptr, options->keepAliveInterval);
	writeMQTTString(&ptr, options->clientID);
	if (options->willFlag)
	{
		writeMQTTString(&ptr, options->will.topicName);
102cd618:	e2843024 	add	r3, r4, #36	; 0x24
102cd61c:	e893000e 	ldm	r3, {r1, r2, r3}
102cd620:	e28d0004 	add	r0, sp, #4
102cd624:	e12fff35 	blx	r5
		writeMQTTString(&ptr, options->will.message);
102cd628:	e2843030 	add	r3, r4, #48	; 0x30
102cd62c:	e28d0004 	add	r0, sp, #4
102cd630:	e893000e 	ldm	r3, {r1, r2, r3}
102cd634:	e12fff35 	blx	r5
102cd638:	eaffffd3 	b	102cd58c <MQTTSerialize_connect+0x110>

	ptr += MQTTPacket_encode(ptr, len); /* write remaining length */

	if (options->MQTTVersion == 4)
	{
		writeCString(&ptr, "MQTT");
102cd63c:	e28d0004 	add	r0, sp, #4
102cd640:	e59f1050 	ldr	r1, [pc, #80]	; 102cd698 <MQTTSerialize_connect+0x21c>
102cd644:	e59f3040 	ldr	r3, [pc, #64]	; 102cd68c <MQTTSerialize_connect+0x210>
102cd648:	e12fff33 	blx	r3
		writeChar(&ptr, (char) 4);
102cd64c:	e28d0004 	add	r0, sp, #4
102cd650:	e1a01008 	mov	r1, r8
102cd654:	e12fff35 	blx	r5
102cd658:	eaffffa9 	b	102cd504 <MQTTSerialize_connect+0x88>
		flags.bits.willRetain = options->will.retained;
	}

	if (options->username.cstring || options->username.lenstring.data)
		flags.bits.username = 1;
	if (options->password.cstring || options->password.lenstring.data)
102cd65c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
102cd660:	e3530000 	cmp	r3, #0
102cd664:	01a07321 	lsreq	r7, r1, #6
102cd668:	02077001 	andeq	r7, r7, #1
102cd66c:	1affffb5 	bne	102cd548 <MQTTSerialize_connect+0xcc>
102cd670:	eaffffb6 	b	102cd550 <MQTTSerialize_connect+0xd4>
	int rc = -1;

	if (MQTTPacket_len(len = MQTTSerialize_connectLength(options)) > buflen)
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		return rc;
102cd674:	e3e00001 	mvn	r0, #1
102cd678:	eaffffc9 	b	102cd5a4 <MQTTSerialize_connect+0x128>
102cd67c:	102cda60 	.word	0x102cda60
102cd680:	102cdae4 	.word	0x102cdae4
102cd684:	102cd98c 	.word	0x102cd98c
102cd688:	102ee958 	.word	0x102ee958
102cd68c:	102cdb34 	.word	0x102cdb34
102cd690:	102cdafc 	.word	0x102cdafc
102cd694:	102cdbbc 	.word	0x102cdbbc
102cd698:	102ee950 	.word	0x102ee950

102cd69c <MQTTDeserialize_connack>:
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param len the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_connack(unsigned char* sessionPresent, unsigned char* connack_rc, unsigned char* buf, int buflen)
{
102cd69c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102cd6a0:	e24dd008 	sub	sp, sp, #8
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
102cd6a4:	e28d4008 	add	r4, sp, #8
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param len the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_connack(unsigned char* sessionPresent, unsigned char* connack_rc, unsigned char* buf, int buflen)
{
102cd6a8:	e1a07000 	mov	r7, r0
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;
	MQTTConnackFlags flags = {0};

	header.byte = readChar(&curdata);
102cd6ac:	e59f5080 	ldr	r5, [pc, #128]	; 102cd734 <MQTTDeserialize_connack+0x98>
102cd6b0:	e1a0000d 	mov	r0, sp
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_connack(unsigned char* sessionPresent, unsigned char* connack_rc, unsigned char* buf, int buflen)
{
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
102cd6b4:	e5242008 	str	r2, [r4, #-8]!
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param len the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_connack(unsigned char* sessionPresent, unsigned char* connack_rc, unsigned char* buf, int buflen)
{
102cd6b8:	e1a06001 	mov	r6, r1
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;
	MQTTConnackFlags flags = {0};

	header.byte = readChar(&curdata);
102cd6bc:	e12fff35 	blx	r5
102cd6c0:	e20000ff 	and	r0, r0, #255	; 0xff
	if (header.bits.type != CONNACK)
102cd6c4:	e1a03220 	lsr	r3, r0, #4
102cd6c8:	e3530002 	cmp	r3, #2
		return rc;
102cd6cc:	13a03000 	movne	r3, #0
	int rc = 0;
	int mylen;
	MQTTConnackFlags flags = {0};

	header.byte = readChar(&curdata);
	if (header.bits.type != CONNACK)
102cd6d0:	0a000002 	beq	102cd6e0 <MQTTDeserialize_connack+0x44>
	*sessionPresent = flags.bits.sessionpresent;
	*connack_rc = readChar(&curdata);

	rc = 1;
	return rc;
}
102cd6d4:	e1a00003 	mov	r0, r3
102cd6d8:	e28dd008 	add	sp, sp, #8
102cd6dc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

	header.byte = readChar(&curdata);
	if (header.bits.type != CONNACK)
		return rc;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd6e0:	e59d8000 	ldr	r8, [sp]
102cd6e4:	e59f304c 	ldr	r3, [pc, #76]	; 102cd738 <MQTTDeserialize_connack+0x9c>
102cd6e8:	e1a00008 	mov	r0, r8
102cd6ec:	e28d1004 	add	r1, sp, #4
102cd6f0:	e12fff33 	blx	r3
	enddata = curdata + mylen;
	if (enddata - curdata < 2)
102cd6f4:	e59d2004 	ldr	r2, [sp, #4]
102cd6f8:	e3520001 	cmp	r2, #1

	header.byte = readChar(&curdata);
	if (header.bits.type != CONNACK)
		return rc;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd6fc:	e0888000 	add	r8, r8, r0
102cd700:	e1a03000 	mov	r3, r0
102cd704:	e58d8000 	str	r8, [sp]
	enddata = curdata + mylen;
	if (enddata - curdata < 2)
102cd708:	dafffff1 	ble	102cd6d4 <MQTTDeserialize_connack+0x38>
		return rc;

	flags.all = readChar(&curdata);
102cd70c:	e1a0000d 	mov	r0, sp
102cd710:	e12fff35 	blx	r5
102cd714:	e20000ff 	and	r0, r0, #255	; 0xff
	*sessionPresent = flags.bits.sessionpresent;
102cd718:	e1a033a0 	lsr	r3, r0, #7
102cd71c:	e5c73000 	strb	r3, [r7]
	*connack_rc = readChar(&curdata);
102cd720:	e1a0000d 	mov	r0, sp
102cd724:	e12fff35 	blx	r5

	rc = 1;
	return rc;
102cd728:	e3a03001 	mov	r3, #1
	if (enddata - curdata < 2)
		return rc;

	flags.all = readChar(&curdata);
	*sessionPresent = flags.bits.sessionpresent;
	*connack_rc = readChar(&curdata);
102cd72c:	e5c60000 	strb	r0, [r6]
102cd730:	eaffffe7 	b	102cd6d4 <MQTTDeserialize_connack+0x38>
102cd734:	102cdad0 	.word	0x102cdad0
102cd738:	102cda9c 	.word	0x102cda9c

102cd73c <MQTTSerialize_zero>:
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @param packettype the message type
  * @return serialized length, or error if 0
  */
int MQTTSerialize_zero(unsigned char* buf, int buflen, unsigned char packettype)
{
102cd73c:	e92d4030 	push	{r4, r5, lr}
	MQTTHeader header = {0};
	int rc = -1;
	unsigned char *ptr = buf;

	if (buflen < 2)
102cd740:	e3510001 	cmp	r1, #1
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @param packettype the message type
  * @return serialized length, or error if 0
  */
int MQTTSerialize_zero(unsigned char* buf, int buflen, unsigned char packettype)
{
102cd744:	e24dd00c 	sub	sp, sp, #12
102cd748:	e1a04000 	mov	r4, r0
	MQTTHeader header = {0};
	int rc = -1;
	unsigned char *ptr = buf;
102cd74c:	e58d0004 	str	r0, [sp, #4]

	if (buflen < 2)
102cd750:	da00000d 	ble	102cd78c <MQTTSerialize_zero+0x50>
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		return rc;
	}
	header.byte = 0;
	header.bits.type = packettype;
102cd754:	e1a01202 	lsl	r1, r2, #4
	writeChar(&ptr, header.byte); /* write header */
102cd758:	e28d0004 	add	r0, sp, #4
102cd75c:	e20110f0 	and	r1, r1, #240	; 0xf0
102cd760:	e59f302c 	ldr	r3, [pc, #44]	; 102cd794 <MQTTSerialize_zero+0x58>
102cd764:	e12fff33 	blx	r3

	ptr += MQTTPacket_encode(ptr, 0); /* write remaining length */
102cd768:	e59d5004 	ldr	r5, [sp, #4]
102cd76c:	e3a01000 	mov	r1, #0
102cd770:	e1a00005 	mov	r0, r5
102cd774:	e59f301c 	ldr	r3, [pc, #28]	; 102cd798 <MQTTSerialize_zero+0x5c>
102cd778:	e12fff33 	blx	r3
102cd77c:	e0850000 	add	r0, r5, r0
	rc = ptr - buf;
102cd780:	e0640000 	rsb	r0, r4, r0

	return rc;
}
102cd784:	e28dd00c 	add	sp, sp, #12
102cd788:	e8bd8030 	pop	{r4, r5, pc}
	unsigned char *ptr = buf;

	if (buflen < 2)
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		return rc;
102cd78c:	e3e00001 	mvn	r0, #1
102cd790:	eafffffb 	b	102cd784 <MQTTSerialize_zero+0x48>
102cd794:	102cdae4 	.word	0x102cdae4
102cd798:	102cd98c 	.word	0x102cd98c

102cd79c <MQTTSerialize_disconnect>:
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @return serialized length, or error if 0
  */
int MQTTSerialize_disconnect(unsigned char* buf, int buflen)
{
	return MQTTSerialize_zero(buf, buflen, DISCONNECT);
102cd79c:	e3a0200e 	mov	r2, #14
102cd7a0:	eaffffe5 	b	102cd73c <MQTTSerialize_zero>

102cd7a4 <MQTTSerialize_pingreq>:
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @return serialized length, or error if 0
  */
int MQTTSerialize_pingreq(unsigned char* buf, int buflen)
{
	return MQTTSerialize_zero(buf, buflen, PINGREQ);
102cd7a4:	e3a0200c 	mov	r2, #12
102cd7a8:	eaffffe3 	b	102cd73c <MQTTSerialize_zero>

102cd7ac <MQTTDeserialize_publish>:
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success
  */
int MQTTDeserialize_publish(unsigned char* dup, int* qos, unsigned char* retained, unsigned short* packetid, MQTTString* topicName,
		unsigned char** payload, int* payloadlen, unsigned char* buf, int buflen)
{
102cd7ac:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
102cd7b0:	e24dd00c 	sub	sp, sp, #12
102cd7b4:	e1a08003 	mov	r8, r3
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
102cd7b8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success
  */
int MQTTDeserialize_publish(unsigned char* dup, int* qos, unsigned char* retained, unsigned short* packetid, MQTTString* topicName,
		unsigned char** payload, int* payloadlen, unsigned char* buf, int buflen)
{
102cd7bc:	e1a0a000 	mov	sl, r0
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen = 0;
102cd7c0:	e3a04000 	mov	r4, #0

	header.byte = readChar(&curdata);
102cd7c4:	e1a0000d 	mov	r0, sp
102cd7c8:	e59fc0d4 	ldr	ip, [pc, #212]	; 102cd8a4 <MQTTDeserialize_publish+0xf8>
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success
  */
int MQTTDeserialize_publish(unsigned char* dup, int* qos, unsigned char* retained, unsigned short* packetid, MQTTString* topicName,
		unsigned char** payload, int* payloadlen, unsigned char* buf, int buflen)
{
102cd7cc:	e1a06001 	mov	r6, r1
102cd7d0:	e1a07002 	mov	r7, r2
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen = 0;
102cd7d4:	e88d0018 	stm	sp, {r3, r4}

	header.byte = readChar(&curdata);
102cd7d8:	e12fff3c 	blx	ip
102cd7dc:	e20000ff 	and	r0, r0, #255	; 0xff
	if (header.bits.type != PUBLISH)
102cd7e0:	e1a05220 	lsr	r5, r0, #4
102cd7e4:	e3550003 	cmp	r5, #3
102cd7e8:	0a000002 	beq	102cd7f8 <MQTTDeserialize_publish+0x4c>
	*payloadlen = enddata - curdata;
	*payload = curdata;
	rc = 1;

	return rc;
}
102cd7ec:	e1a00004 	mov	r0, r4
102cd7f0:	e28dd00c 	add	sp, sp, #12
102cd7f4:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
	}
	*dup = header.bits.dup;
	*qos = header.bits.qos;
	*retained = header.bits.retain;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd7f8:	e59d5000 	ldr	r5, [sp]
	header.byte = readChar(&curdata);
	if (header.bits.type != PUBLISH)
	{
		return rc;
	}
	*dup = header.bits.dup;
102cd7fc:	e1a021a0 	lsr	r2, r0, #3
	*qos = header.bits.qos;
102cd800:	e1a030a0 	lsr	r3, r0, #1
	*retained = header.bits.retain;
102cd804:	e200c001 	and	ip, r0, #1
	header.byte = readChar(&curdata);
	if (header.bits.type != PUBLISH)
	{
		return rc;
	}
	*dup = header.bits.dup;
102cd808:	e2022001 	and	r2, r2, #1
	*qos = header.bits.qos;
102cd80c:	e2033003 	and	r3, r3, #3
	header.byte = readChar(&curdata);
	if (header.bits.type != PUBLISH)
	{
		return rc;
	}
	*dup = header.bits.dup;
102cd810:	e5ca2000 	strb	r2, [sl]
	*qos = header.bits.qos;
	*retained = header.bits.retain;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd814:	e28d1004 	add	r1, sp, #4
	if (header.bits.type != PUBLISH)
	{
		return rc;
	}
	*dup = header.bits.dup;
	*qos = header.bits.qos;
102cd818:	e5863000 	str	r3, [r6]
	*retained = header.bits.retain;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd81c:	e1a00005 	mov	r0, r5
	{
		return rc;
	}
	*dup = header.bits.dup;
	*qos = header.bits.qos;
	*retained = header.bits.retain;
102cd820:	e5c7c000 	strb	ip, [r7]

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd824:	e59f307c 	ldr	r3, [pc, #124]	; 102cd8a8 <MQTTDeserialize_publish+0xfc>
102cd828:	e12fff33 	blx	r3
	enddata = curdata + mylen;

	if (!readMQTTLenString(topicName, &curdata, enddata) || (enddata - curdata < 0)) /* do we have enough data to read the protocol version byte? */
102cd82c:	e1a0100d 	mov	r1, sp
	}
	*dup = header.bits.dup;
	*qos = header.bits.qos;
	*retained = header.bits.retain;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd830:	e0853000 	add	r3, r5, r0
	enddata = curdata + mylen;
102cd834:	e59d5004 	ldr	r5, [sp, #4]
	}
	*dup = header.bits.dup;
	*qos = header.bits.qos;
	*retained = header.bits.retain;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd838:	e58d3000 	str	r3, [sp]
	enddata = curdata + mylen;
102cd83c:	e0835005 	add	r5, r3, r5
	}
	*dup = header.bits.dup;
	*qos = header.bits.qos;
	*retained = header.bits.retain;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd840:	e1a04000 	mov	r4, r0
	enddata = curdata + mylen;

	if (!readMQTTLenString(topicName, &curdata, enddata) || (enddata - curdata < 0)) /* do we have enough data to read the protocol version byte? */
102cd844:	e1a02005 	mov	r2, r5
102cd848:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
102cd84c:	e59f3058 	ldr	r3, [pc, #88]	; 102cd8ac <MQTTDeserialize_publish+0x100>
102cd850:	e12fff33 	blx	r3
102cd854:	e3500000 	cmp	r0, #0
102cd858:	0affffe3 	beq	102cd7ec <MQTTDeserialize_publish+0x40>
102cd85c:	e59d3000 	ldr	r3, [sp]
102cd860:	e0552003 	subs	r2, r5, r3
102cd864:	4affffe0 	bmi	102cd7ec <MQTTDeserialize_publish+0x40>
	{
		return rc;
	}

	if (*qos > 0)
102cd868:	e5961000 	ldr	r1, [r6]
102cd86c:	e3510000 	cmp	r1, #0
102cd870:	da000005 	ble	102cd88c <MQTTDeserialize_publish+0xe0>
		*packetid = readInt(&curdata);
102cd874:	e59f3034 	ldr	r3, [pc, #52]	; 102cd8b0 <MQTTDeserialize_publish+0x104>
102cd878:	e1a0000d 	mov	r0, sp
102cd87c:	e12fff33 	blx	r3
102cd880:	e59d3000 	ldr	r3, [sp]
102cd884:	e0632005 	rsb	r2, r3, r5
102cd888:	e1c800b0 	strh	r0, [r8]

	*payloadlen = enddata - curdata;
102cd88c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
	*payload = curdata;
	rc = 1;

	return rc;
102cd890:	e3a04001 	mov	r4, #1
	}

	if (*qos > 0)
		*packetid = readInt(&curdata);

	*payloadlen = enddata - curdata;
102cd894:	e5812000 	str	r2, [r1]
	*payload = curdata;
102cd898:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
102cd89c:	e5823000 	str	r3, [r2]
102cd8a0:	eaffffd1 	b	102cd7ec <MQTTDeserialize_publish+0x40>
102cd8a4:	102cdad0 	.word	0x102cdad0
102cd8a8:	102cda9c 	.word	0x102cda9c
102cd8ac:	102cdc6c 	.word	0x102cdc6c
102cd8b0:	102cdab4 	.word	0x102cdab4

102cd8b4 <MQTTDeserialize_ack>:
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_ack(unsigned char* packettype, unsigned char* dup, unsigned short* packetid, unsigned char* buf, int buflen)
{
102cd8b4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102cd8b8:	e24dd008 	sub	sp, sp, #8
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
102cd8bc:	e28d4008 	add	r4, sp, #8
102cd8c0:	e5243008 	str	r3, [r4, #-8]!
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_ack(unsigned char* packettype, unsigned char* dup, unsigned short* packetid, unsigned char* buf, int buflen)
{
102cd8c4:	e1a06000 	mov	r6, r0
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
102cd8c8:	e59f3070 	ldr	r3, [pc, #112]	; 102cd940 <MQTTDeserialize_ack+0x8c>
102cd8cc:	e1a0000d 	mov	r0, sp
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_ack(unsigned char* packettype, unsigned char* dup, unsigned short* packetid, unsigned char* buf, int buflen)
{
102cd8d0:	e1a07001 	mov	r7, r1
102cd8d4:	e1a08002 	mov	r8, r2
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
102cd8d8:	e12fff33 	blx	r3
	*dup = header.bits.dup;
	*packettype = header.bits.type;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd8dc:	e59d5000 	ldr	r5, [sp]
102cd8e0:	e28d1004 	add	r1, sp, #4
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
102cd8e4:	e20000ff 	and	r0, r0, #255	; 0xff
	*dup = header.bits.dup;
102cd8e8:	e1a021a0 	lsr	r2, r0, #3
102cd8ec:	e2022001 	and	r2, r2, #1
	*packettype = header.bits.type;
102cd8f0:	e1a03220 	lsr	r3, r0, #4
	int rc = 0;
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
	*dup = header.bits.dup;
102cd8f4:	e5c72000 	strb	r2, [r7]
	*packettype = header.bits.type;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd8f8:	e1a00005 	mov	r0, r5
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
	*dup = header.bits.dup;
	*packettype = header.bits.type;
102cd8fc:	e5c63000 	strb	r3, [r6]

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd900:	e59f303c 	ldr	r3, [pc, #60]	; 102cd944 <MQTTDeserialize_ack+0x90>
102cd904:	e12fff33 	blx	r3
	enddata = curdata + mylen;

	if (enddata - curdata < 2)
102cd908:	e59d2004 	ldr	r2, [sp, #4]
102cd90c:	e3520001 	cmp	r2, #1
	FUNC_ENTRY;
	header.byte = readChar(&curdata);
	*dup = header.bits.dup;
	*packettype = header.bits.type;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102cd910:	e0855000 	add	r5, r5, r0
102cd914:	e1a03000 	mov	r3, r0
102cd918:	e58d5000 	str	r5, [sp]
	enddata = curdata + mylen;

	if (enddata - curdata < 2)
102cd91c:	da000004 	ble	102cd934 <MQTTDeserialize_ack+0x80>
		goto exit;
	*packetid = readInt(&curdata);
102cd920:	e59f3020 	ldr	r3, [pc, #32]	; 102cd948 <MQTTDeserialize_ack+0x94>
102cd924:	e1a0000d 	mov	r0, sp
102cd928:	e12fff33 	blx	r3

	rc = 1;
102cd92c:	e3a03001 	mov	r3, #1
	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
	enddata = curdata + mylen;

	if (enddata - curdata < 2)
		goto exit;
	*packetid = readInt(&curdata);
102cd930:	e1c800b0 	strh	r0, [r8]

	rc = 1;
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
102cd934:	e1a00003 	mov	r0, r3
102cd938:	e28dd008 	add	sp, sp, #8
102cd93c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102cd940:	102cdad0 	.word	0x102cdad0
102cd944:	102cda9c 	.word	0x102cda9c
102cd948:	102cdab4 	.word	0x102cdab4

102cd94c <bufchar>:

int bufchar(unsigned char* c, int count)
{
	int i;

	for (i = 0; i < count; ++i)
102cd94c:	e3510000 	cmp	r1, #0


static unsigned char* bufptr;

int bufchar(unsigned char* c, int count)
{
102cd950:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
102cd954:	e1a0c000 	mov	ip, r0
	int i;

	for (i = 0; i < count; ++i)
102cd958:	da000007 	ble	102cd97c <bufchar+0x30>
102cd95c:	e59f0024 	ldr	r0, [pc, #36]	; 102cd988 <bufchar+0x3c>
102cd960:	e5903000 	ldr	r3, [r0]
}


static unsigned char* bufptr;

int bufchar(unsigned char* c, int count)
102cd964:	e0834001 	add	r4, r3, r1
{
	int i;

	for (i = 0; i < count; ++i)
		*c = *bufptr++;
102cd968:	e4d32001 	ldrb	r2, [r3], #1
102cd96c:	e5cc2000 	strb	r2, [ip]

int bufchar(unsigned char* c, int count)
{
	int i;

	for (i = 0; i < count; ++i)
102cd970:	e1530004 	cmp	r3, r4
102cd974:	1afffffb 	bne	102cd968 <bufchar+0x1c>
102cd978:	e5803000 	str	r3, [r0]
		*c = *bufptr++;
	return count;
}
102cd97c:	e1a00001 	mov	r0, r1
102cd980:	e8bd0010 	ldmfd	sp!, {r4}
102cd984:	e12fff1e 	bx	lr
102cd988:	f03d5728 	.word	0xf03d5728

102cd98c <MQTTPacket_encode>:

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
		length /= 128;
102cd98c:	e3510000 	cmp	r1, #0
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cd990:	e1a02fc1 	asr	r2, r1, #31
		length /= 128;
102cd994:	e281307f 	add	r3, r1, #127	; 0x7f
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cd998:	e1a02ca2 	lsr	r2, r2, #25
		length /= 128;
102cd99c:	a1a03001 	movge	r3, r1
102cd9a0:	e1a033c3 	asr	r3, r3, #7
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cd9a4:	e0811002 	add	r1, r1, r2
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cd9a8:	e3530000 	cmp	r3, #0
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cd9ac:	e201107f 	and	r1, r1, #127	; 0x7f
 * @param buf the buffer into which the encoded data is written
 * @param length the length to be encoded
 * @return the number of bytes written to buffer
 */
int MQTTPacket_encode(unsigned char* buf, int length)
{
102cd9b0:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cd9b4:	e0621001 	rsb	r1, r2, r1
 * @param buf the buffer into which the encoded data is written
 * @param length the length to be encoded
 * @return the number of bytes written to buffer
 */
int MQTTPacket_encode(unsigned char* buf, int length)
{
102cd9b8:	e1a04000 	mov	r4, r0
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cd9bc:	d3a02000 	movle	r2, #0
102cd9c0:	d3a00001 	movle	r0, #1
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cd9c4:	da000007 	ble	102cd9e8 <MQTTPacket_encode+0x5c>
102cd9c8:	e3a02000 	mov	r2, #0
			d |= 0x80;
102cd9cc:	e381c080 	orr	ip, r1, #128	; 0x80
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cd9d0:	e203107f 	and	r1, r3, #127	; 0x7f
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cd9d4:	e1b033c3 	asrs	r3, r3, #7
			d |= 0x80;
102cd9d8:	e7c4c002 	strb	ip, [r4, r2]
		buf[rc++] = d;
102cd9dc:	e2822001 	add	r2, r2, #1
	do
	{
		char d = length % 128;
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cd9e0:	1afffff9 	bne	102cd9cc <MQTTPacket_encode+0x40>
102cd9e4:	e2820001 	add	r0, r2, #1
			d |= 0x80;
		buf[rc++] = d;
102cd9e8:	e7c41002 	strb	r1, [r4, r2]
	} while (length > 0);
	FUNC_EXIT_RC(rc);
	return rc;
}
102cd9ec:	e8bd0010 	ldmfd	sp!, {r4}
102cd9f0:	e12fff1e 	bx	lr

102cd9f4 <MQTTPacket_decode>:
 * @param getcharfn pointer to function to read the next character from the data source
 * @param value the decoded length returned
 * @return the number of bytes read from the socket
 */
int MQTTPacket_decode(int (*getcharfn)(unsigned char*, int), int* value)
{
102cd9f4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	*value = 0;
	do
	{
		int rc = MQTTPACKET_READ_ERROR;

		if (++len > MAX_NO_OF_REMAINING_LENGTH_BYTES)
102cd9f8:	e3a04001 	mov	r4, #1
	int multiplier = 1;
	int len = 0;
#define MAX_NO_OF_REMAINING_LENGTH_BYTES 4

	FUNC_ENTRY;
	*value = 0;
102cd9fc:	e3a03000 	mov	r3, #0
 * @param getcharfn pointer to function to read the next character from the data source
 * @param value the decoded length returned
 * @return the number of bytes read from the socket
 */
int MQTTPacket_decode(int (*getcharfn)(unsigned char*, int), int* value)
{
102cda00:	e24dd00c 	sub	sp, sp, #12
102cda04:	e1a06001 	mov	r6, r1
102cda08:	e1a07000 	mov	r7, r0
	unsigned char c;
	int multiplier = 1;
102cda0c:	e1a05004 	mov	r5, r4
	int len = 0;
#define MAX_NO_OF_REMAINING_LENGTH_BYTES 4

	FUNC_ENTRY;
	*value = 0;
102cda10:	e5813000 	str	r3, [r1]
		if (++len > MAX_NO_OF_REMAINING_LENGTH_BYTES)
		{
			rc = MQTTPACKET_READ_ERROR;	/* bad data */
			goto exit;
		}
		rc = (*getcharfn)(&c, 1);
102cda14:	e28d0007 	add	r0, sp, #7
102cda18:	e3a01001 	mov	r1, #1
102cda1c:	e12fff37 	blx	r7
		if (rc != 1)
102cda20:	e3500001 	cmp	r0, #1
102cda24:	1a00000a 	bne	102cda54 <MQTTPacket_decode+0x60>
			goto exit;
		*value += (c & 127) * multiplier;
102cda28:	e5dd3007 	ldrb	r3, [sp, #7]
102cda2c:	e5962000 	ldr	r2, [r6]
102cda30:	e203107f 	and	r1, r3, #127	; 0x7f
102cda34:	e0222195 	mla	r2, r5, r1, r2
		multiplier *= 128;
	} while ((c & 128) != 0);
102cda38:	e3130080 	tst	r3, #128	; 0x80
			goto exit;
		}
		rc = (*getcharfn)(&c, 1);
		if (rc != 1)
			goto exit;
		*value += (c & 127) * multiplier;
102cda3c:	e5862000 	str	r2, [r6]
		multiplier *= 128;
102cda40:	e1a05385 	lsl	r5, r5, #7
	} while ((c & 128) != 0);
102cda44:	0a000002 	beq	102cda54 <MQTTPacket_decode+0x60>
	*value = 0;
	do
	{
		int rc = MQTTPACKET_READ_ERROR;

		if (++len > MAX_NO_OF_REMAINING_LENGTH_BYTES)
102cda48:	e2844001 	add	r4, r4, #1
102cda4c:	e3540005 	cmp	r4, #5
102cda50:	1affffef 	bne	102cda14 <MQTTPacket_decode+0x20>
		multiplier *= 128;
	} while ((c & 128) != 0);
exit:
	FUNC_EXIT_RC(len);
	return len;
}
102cda54:	e1a00004 	mov	r0, r4
102cda58:	e28dd00c 	add	sp, sp, #12
102cda5c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

102cda60 <MQTTPacket_len>:


int MQTTPacket_len(int rem_len)
{
	rem_len += 1; /* header byte */
102cda60:	e2803001 	add	r3, r0, #1

	/* now remaining_length field */
	if (rem_len < 128)
102cda64:	e353007f 	cmp	r3, #127	; 0x7f
102cda68:	da000008 	ble	102cda90 <MQTTPacket_len+0x30>
		rem_len += 1;
	else if (rem_len < 16384)
102cda6c:	e3530901 	cmp	r3, #16384	; 0x4000
102cda70:	ba000004 	blt	102cda88 <MQTTPacket_len+0x28>
		rem_len += 2;
	else if (rem_len < 2097151)
102cda74:	e59f201c 	ldr	r2, [pc, #28]	; 102cda98 <MQTTPacket_len+0x38>
102cda78:	e1530002 	cmp	r3, r2
		rem_len += 3;
102cda7c:	d2800004 	addle	r0, r0, #4
	else
		rem_len += 4;
102cda80:	c2800005 	addgt	r0, r0, #5
	return rem_len;
}
102cda84:	e12fff1e 	bx	lr

	/* now remaining_length field */
	if (rem_len < 128)
		rem_len += 1;
	else if (rem_len < 16384)
		rem_len += 2;
102cda88:	e2800003 	add	r0, r0, #3
102cda8c:	e12fff1e 	bx	lr
{
	rem_len += 1; /* header byte */

	/* now remaining_length field */
	if (rem_len < 128)
		rem_len += 1;
102cda90:	e2800002 	add	r0, r0, #2
102cda94:	e12fff1e 	bx	lr
102cda98:	001ffffe 	.word	0x001ffffe

102cda9c <MQTTPacket_decodeBuf>:
}


int MQTTPacket_decodeBuf(unsigned char* buf, int* value)
{
	bufptr = buf;
102cda9c:	e59f3008 	ldr	r3, [pc, #8]	; 102cdaac <MQTTPacket_decodeBuf+0x10>
102cdaa0:	e5830000 	str	r0, [r3]
	return MQTTPacket_decode(bufchar, value);
102cdaa4:	e59f0004 	ldr	r0, [pc, #4]	; 102cdab0 <MQTTPacket_decodeBuf+0x14>
102cdaa8:	eaffffd1 	b	102cd9f4 <MQTTPacket_decode>
102cdaac:	f03d5728 	.word	0xf03d5728
102cdab0:	102cd94c 	.word	0x102cd94c

102cdab4 <readInt>:
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the integer value calculated
 */
int readInt(unsigned char** pptr)
{
	unsigned char* ptr = *pptr;
102cdab4:	e5903000 	ldr	r3, [r0]
	int len = 256*(*ptr) + (*(ptr+1));
102cdab8:	e5d31000 	ldrb	r1, [r3]
102cdabc:	e5d32001 	ldrb	r2, [r3, #1]
	*pptr += 2;
102cdac0:	e2833002 	add	r3, r3, #2
102cdac4:	e5803000 	str	r3, [r0]
	return len;
}
102cdac8:	e0820401 	add	r0, r2, r1, lsl #8
102cdacc:	e12fff1e 	bx	lr

102cdad0 <readChar>:
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the character read
 */
char readChar(unsigned char** pptr)
{
	char c = **pptr;
102cdad0:	e5903000 	ldr	r3, [r0]
 * Reads one character from the input buffer.
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the character read
 */
char readChar(unsigned char** pptr)
{
102cdad4:	e1a02000 	mov	r2, r0
	char c = **pptr;
102cdad8:	e4d30001 	ldrb	r0, [r3], #1
	(*pptr)++;
102cdadc:	e5823000 	str	r3, [r2]
	return c;
}
102cdae0:	e12fff1e 	bx	lr

102cdae4 <writeChar>:
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param c the character to write
 */
void writeChar(unsigned char** pptr, char c)
{
	**pptr = c;
102cdae4:	e5903000 	ldr	r3, [r0]
102cdae8:	e5c31000 	strb	r1, [r3]
	(*pptr)++;
102cdaec:	e5903000 	ldr	r3, [r0]
102cdaf0:	e2833001 	add	r3, r3, #1
102cdaf4:	e5803000 	str	r3, [r0]
102cdaf8:	e12fff1e 	bx	lr

102cdafc <writeInt>:
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
102cdafc:	e3510000 	cmp	r1, #0
102cdb00:	e5903000 	ldr	r3, [r0]
102cdb04:	e28120ff 	add	r2, r1, #255	; 0xff
102cdb08:	a1a02001 	movge	r2, r1
102cdb0c:	e1a02442 	asr	r2, r2, #8
102cdb10:	e5c32000 	strb	r2, [r3]
	(*pptr)++;
102cdb14:	e5903000 	ldr	r3, [r0]
102cdb18:	e2832001 	add	r2, r3, #1
102cdb1c:	e5802000 	str	r2, [r0]
	**pptr = (unsigned char)(anInt % 256);
102cdb20:	e5c31001 	strb	r1, [r3, #1]
	(*pptr)++;
102cdb24:	e5903000 	ldr	r3, [r0]
102cdb28:	e2833001 	add	r3, r3, #1
102cdb2c:	e5803000 	str	r3, [r0]
102cdb30:	e12fff1e 	bx	lr

102cdb34 <writeCString>:
 * Writes a "UTF" string to an output buffer.  Converts C string to length-delimited.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param string the C string to write
 */
void writeCString(unsigned char** pptr, const char* string)
{
102cdb34:	e92d4070 	push	{r4, r5, r6, lr}
	int len = strlen(string);
102cdb38:	e59f3064 	ldr	r3, [pc, #100]	; 102cdba4 <writeCString+0x70>
 * Writes a "UTF" string to an output buffer.  Converts C string to length-delimited.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param string the C string to write
 */
void writeCString(unsigned char** pptr, const char* string)
{
102cdb3c:	e1a04000 	mov	r4, r0
	int len = strlen(string);
102cdb40:	e1a00001 	mov	r0, r1
 * Writes a "UTF" string to an output buffer.  Converts C string to length-delimited.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param string the C string to write
 */
void writeCString(unsigned char** pptr, const char* string)
{
102cdb44:	e1a06001 	mov	r6, r1
	int len = strlen(string);
102cdb48:	e12fff33 	blx	r3
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
102cdb4c:	e5943000 	ldr	r3, [r4]
 */
void writeCString(unsigned char** pptr, const char* string)
{
	int len = strlen(string);
	writeInt(pptr, len);
	memcpy(*pptr, string, len);
102cdb50:	e1a01006 	mov	r1, r6
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
102cdb54:	e3500000 	cmp	r0, #0
102cdb58:	e28020ff 	add	r2, r0, #255	; 0xff
102cdb5c:	a1a02000 	movge	r2, r0
102cdb60:	e1a02442 	asr	r2, r2, #8
102cdb64:	e5c32000 	strb	r2, [r3]
	(*pptr)++;
102cdb68:	e5943000 	ldr	r3, [r4]
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param string the C string to write
 */
void writeCString(unsigned char** pptr, const char* string)
{
	int len = strlen(string);
102cdb6c:	e1a05000 	mov	r5, r0
 * @param anInt the integer to write
 */
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
	(*pptr)++;
102cdb70:	e2832001 	add	r2, r3, #1
102cdb74:	e5842000 	str	r2, [r4]
	**pptr = (unsigned char)(anInt % 256);
102cdb78:	e5c30001 	strb	r0, [r3, #1]
	(*pptr)++;
102cdb7c:	e5940000 	ldr	r0, [r4]
 */
void writeCString(unsigned char** pptr, const char* string)
{
	int len = strlen(string);
	writeInt(pptr, len);
	memcpy(*pptr, string, len);
102cdb80:	e1a02005 	mov	r2, r5
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
	(*pptr)++;
	**pptr = (unsigned char)(anInt % 256);
	(*pptr)++;
102cdb84:	e2800001 	add	r0, r0, #1
 */
void writeCString(unsigned char** pptr, const char* string)
{
	int len = strlen(string);
	writeInt(pptr, len);
	memcpy(*pptr, string, len);
102cdb88:	e59f3018 	ldr	r3, [pc, #24]	; 102cdba8 <writeCString+0x74>
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
	(*pptr)++;
	**pptr = (unsigned char)(anInt % 256);
	(*pptr)++;
102cdb8c:	e5840000 	str	r0, [r4]
 */
void writeCString(unsigned char** pptr, const char* string)
{
	int len = strlen(string);
	writeInt(pptr, len);
	memcpy(*pptr, string, len);
102cdb90:	e12fff33 	blx	r3
	*pptr += len;
102cdb94:	e5943000 	ldr	r3, [r4]
102cdb98:	e0835005 	add	r5, r3, r5
102cdb9c:	e5845000 	str	r5, [r4]
102cdba0:	e8bd8070 	pop	{r4, r5, r6, pc}
102cdba4:	102dff65 	.word	0x102dff65
102cdba8:	102df8c9 	.word	0x102df8c9

102cdbac <getLenStringLen>:
}


int getLenStringLen(char* ptr)
{
	int len = 256*((unsigned char)(*ptr)) + (unsigned char)(*(ptr+1));
102cdbac:	e5d02000 	ldrb	r2, [r0]
102cdbb0:	e5d00001 	ldrb	r0, [r0, #1]
	return len;
}
102cdbb4:	e0800402 	add	r0, r0, r2, lsl #8
102cdbb8:	e12fff1e 	bx	lr

102cdbbc <writeMQTTString>:


void writeMQTTString(unsigned char** pptr, MQTTString mqttstring)
{
102cdbbc:	e92d4030 	push	{r4, r5, lr}
102cdbc0:	e24dd014 	sub	sp, sp, #20
102cdbc4:	e28dc010 	add	ip, sp, #16
102cdbc8:	e90c000e 	stmdb	ip, {r1, r2, r3}
102cdbcc:	e59d5008 	ldr	r5, [sp, #8]
102cdbd0:	e1a04000 	mov	r4, r0
	if (mqttstring.lenstring.len > 0)
102cdbd4:	e3550000 	cmp	r5, #0
102cdbd8:	e59d1004 	ldr	r1, [sp, #4]
102cdbdc:	ca00000f 	bgt	102cdc20 <writeMQTTString+0x64>
	{
		writeInt(pptr, mqttstring.lenstring.len);
		memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
		*pptr += mqttstring.lenstring.len;
	}
	else if (mqttstring.cstring)
102cdbe0:	e3510000 	cmp	r1, #0
102cdbe4:	0a000002 	beq	102cdbf4 <writeMQTTString+0x38>
		writeCString(pptr, mqttstring.cstring);
	else
		writeInt(pptr, 0);
}
102cdbe8:	e28dd014 	add	sp, sp, #20
102cdbec:	e8bd4030 	pop	{r4, r5, lr}
		writeInt(pptr, mqttstring.lenstring.len);
		memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
		*pptr += mqttstring.lenstring.len;
	}
	else if (mqttstring.cstring)
		writeCString(pptr, mqttstring.cstring);
102cdbf0:	eaffffcf 	b	102cdb34 <writeCString>
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
102cdbf4:	e5903000 	ldr	r3, [r0]
102cdbf8:	e5c31000 	strb	r1, [r3]
	(*pptr)++;
102cdbfc:	e5903000 	ldr	r3, [r0]
102cdc00:	e2832001 	add	r2, r3, #1
102cdc04:	e5802000 	str	r2, [r0]
	**pptr = (unsigned char)(anInt % 256);
102cdc08:	e5c31001 	strb	r1, [r3, #1]
	(*pptr)++;
102cdc0c:	e5903000 	ldr	r3, [r0]
102cdc10:	e2833001 	add	r3, r3, #1
102cdc14:	e5803000 	str	r3, [r0]
	}
	else if (mqttstring.cstring)
		writeCString(pptr, mqttstring.cstring);
	else
		writeInt(pptr, 0);
}
102cdc18:	e28dd014 	add	sp, sp, #20
102cdc1c:	e8bd8030 	pop	{r4, r5, pc}
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
102cdc20:	e5903000 	ldr	r3, [r0]
102cdc24:	e1a02445 	asr	r2, r5, #8
102cdc28:	e5c32000 	strb	r2, [r3]
	(*pptr)++;
102cdc2c:	e5903000 	ldr	r3, [r0]
void writeMQTTString(unsigned char** pptr, MQTTString mqttstring)
{
	if (mqttstring.lenstring.len > 0)
	{
		writeInt(pptr, mqttstring.lenstring.len);
		memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
102cdc30:	e59d100c 	ldr	r1, [sp, #12]
 * @param anInt the integer to write
 */
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
	(*pptr)++;
102cdc34:	e2832001 	add	r2, r3, #1
102cdc38:	e5802000 	str	r2, [r0]
	**pptr = (unsigned char)(anInt % 256);
102cdc3c:	e5c35001 	strb	r5, [r3, #1]
	(*pptr)++;
102cdc40:	e5900000 	ldr	r0, [r0]
void writeMQTTString(unsigned char** pptr, MQTTString mqttstring)
{
	if (mqttstring.lenstring.len > 0)
	{
		writeInt(pptr, mqttstring.lenstring.len);
		memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
102cdc44:	e1a02005 	mov	r2, r5
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
	(*pptr)++;
	**pptr = (unsigned char)(anInt % 256);
	(*pptr)++;
102cdc48:	e2800001 	add	r0, r0, #1
void writeMQTTString(unsigned char** pptr, MQTTString mqttstring)
{
	if (mqttstring.lenstring.len > 0)
	{
		writeInt(pptr, mqttstring.lenstring.len);
		memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
102cdc4c:	e59f3014 	ldr	r3, [pc, #20]	; 102cdc68 <writeMQTTString+0xac>
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
	(*pptr)++;
	**pptr = (unsigned char)(anInt % 256);
	(*pptr)++;
102cdc50:	e5840000 	str	r0, [r4]
void writeMQTTString(unsigned char** pptr, MQTTString mqttstring)
{
	if (mqttstring.lenstring.len > 0)
	{
		writeInt(pptr, mqttstring.lenstring.len);
		memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
102cdc54:	e12fff33 	blx	r3
		*pptr += mqttstring.lenstring.len;
102cdc58:	e5943000 	ldr	r3, [r4]
102cdc5c:	e0835005 	add	r5, r3, r5
102cdc60:	e5845000 	str	r5, [r4]
102cdc64:	eaffffeb 	b	102cdc18 <writeMQTTString+0x5c>
102cdc68:	102df8c9 	.word	0x102df8c9

102cdc6c <readMQTTLenString>:
{
	int rc = 0;

	FUNC_ENTRY;
	/* the first two bytes are the length of the string */
	if (enddata - (*pptr) > 1) /* enough length to read the integer? */
102cdc6c:	e5913000 	ldr	r3, [r1]
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param enddata pointer to the end of the data: do not read beyond
 * @return 1 if successful, 0 if not
 */
int readMQTTLenString(MQTTString* mqttstring, unsigned char** pptr, unsigned char* enddata)
{
102cdc70:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
	int rc = 0;

	FUNC_ENTRY;
	/* the first two bytes are the length of the string */
	if (enddata - (*pptr) > 1) /* enough length to read the integer? */
102cdc74:	e063c002 	rsb	ip, r3, r2
102cdc78:	e35c0001 	cmp	ip, #1
102cdc7c:	da00000e 	ble	102cdcbc <readMQTTLenString+0x50>
 * @return the integer value calculated
 */
int readInt(unsigned char** pptr)
{
	unsigned char* ptr = *pptr;
	int len = 256*(*ptr) + (*(ptr+1));
102cdc80:	e5d34000 	ldrb	r4, [r3]
102cdc84:	e5d3c001 	ldrb	ip, [r3, #1]
	*pptr += 2;
102cdc88:	e2833002 	add	r3, r3, #2
 * @return the integer value calculated
 */
int readInt(unsigned char** pptr)
{
	unsigned char* ptr = *pptr;
	int len = 256*(*ptr) + (*(ptr+1));
102cdc8c:	e08cc404 	add	ip, ip, r4, lsl #8
	FUNC_ENTRY;
	/* the first two bytes are the length of the string */
	if (enddata - (*pptr) > 1) /* enough length to read the integer? */
	{
		mqttstring->lenstring.len = readInt(pptr); /* increments pptr to point past length */
		if (&(*pptr)[mqttstring->lenstring.len] <= enddata)
102cdc90:	e083400c 	add	r4, r3, ip
102cdc94:	e1520004 	cmp	r2, r4
 */
int readInt(unsigned char** pptr)
{
	unsigned char* ptr = *pptr;
	int len = 256*(*ptr) + (*(ptr+1));
	*pptr += 2;
102cdc98:	e5813000 	str	r3, [r1]

	FUNC_ENTRY;
	/* the first two bytes are the length of the string */
	if (enddata - (*pptr) > 1) /* enough length to read the integer? */
	{
		mqttstring->lenstring.len = readInt(pptr); /* increments pptr to point past length */
102cdc9c:	e580c004 	str	ip, [r0, #4]
		if (&(*pptr)[mqttstring->lenstring.len] <= enddata)
102cdca0:	3a000005 	bcc	102cdcbc <readMQTTLenString+0x50>
		{
			mqttstring->lenstring.data = (char*)*pptr;
102cdca4:	e5803008 	str	r3, [r0, #8]
			*pptr += mqttstring->lenstring.len;
102cdca8:	e5913000 	ldr	r3, [r1]
			rc = 1;
102cdcac:	e3a02001 	mov	r2, #1
	{
		mqttstring->lenstring.len = readInt(pptr); /* increments pptr to point past length */
		if (&(*pptr)[mqttstring->lenstring.len] <= enddata)
		{
			mqttstring->lenstring.data = (char*)*pptr;
			*pptr += mqttstring->lenstring.len;
102cdcb0:	e083c00c 	add	ip, r3, ip
102cdcb4:	e581c000 	str	ip, [r1]
102cdcb8:	ea000000 	b	102cdcc0 <readMQTTLenString+0x54>
 * @param enddata pointer to the end of the data: do not read beyond
 * @return 1 if successful, 0 if not
 */
int readMQTTLenString(MQTTString* mqttstring, unsigned char** pptr, unsigned char* enddata)
{
	int rc = 0;
102cdcbc:	e3a02000 	mov	r2, #0
			mqttstring->lenstring.data = (char*)*pptr;
			*pptr += mqttstring->lenstring.len;
			rc = 1;
		}
	}
	mqttstring->cstring = NULL;
102cdcc0:	e3a03000 	mov	r3, #0
102cdcc4:	e5803000 	str	r3, [r0]
	FUNC_EXIT_RC(rc);
	return rc;
}
102cdcc8:	e1a00002 	mov	r0, r2
102cdccc:	e8bd0010 	ldmfd	sp!, {r4}
102cdcd0:	e12fff1e 	bx	lr

102cdcd4 <MQTTstrlen>:
 * Return the length of the MQTTstring - C string if there is one, otherwise the length delimited string
 * @param mqttstring the string to return the length of
 * @return the length of the string
 */
int MQTTstrlen(MQTTString mqttstring)
{
102cdcd4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102cdcd8:	e24dd014 	sub	sp, sp, #20
102cdcdc:	e28d3010 	add	r3, sp, #16
102cdce0:	e9030007 	stmdb	r3, {r0, r1, r2}
102cdce4:	e59d0004 	ldr	r0, [sp, #4]
	int rc = 0;

	if (mqttstring.cstring)
102cdce8:	e3500000 	cmp	r0, #0
102cdcec:	0a000003 	beq	102cdd00 <MQTTstrlen+0x2c>
		rc = strlen(mqttstring.cstring);
102cdcf0:	e59f3010 	ldr	r3, [pc, #16]	; 102cdd08 <MQTTstrlen+0x34>
102cdcf4:	e12fff33 	blx	r3
	else
		rc = mqttstring.lenstring.len;
	return rc;
}
102cdcf8:	e28dd014 	add	sp, sp, #20
102cdcfc:	e8bd8000 	ldmfd	sp!, {pc}
	int rc = 0;

	if (mqttstring.cstring)
		rc = strlen(mqttstring.cstring);
	else
		rc = mqttstring.lenstring.len;
102cdd00:	e59d0008 	ldr	r0, [sp, #8]
102cdd04:	eafffffb 	b	102cdcf8 <MQTTstrlen+0x24>
102cdd08:	102dff65 	.word	0x102dff65

102cdd0c <MQTTPacket_equals>:
 * @param a the MQTTString to compare
 * @param bptr the C string to compare
 * @return boolean - equal or not
 */
int MQTTPacket_equals(MQTTString* a, char* bptr)
{
102cdd0c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int alen = 0,
		blen = 0;
	char *aptr;
	
	if (a->cstring)
102cdd10:	e5904000 	ldr	r4, [r0]
 * @param a the MQTTString to compare
 * @param bptr the C string to compare
 * @return boolean - equal or not
 */
int MQTTPacket_equals(MQTTString* a, char* bptr)
{
102cdd14:	e1a06001 	mov	r6, r1
	int alen = 0,
		blen = 0;
	char *aptr;
	
	if (a->cstring)
102cdd18:	e3540000 	cmp	r4, #0
102cdd1c:	0a000011 	beq	102cdd68 <MQTTPacket_equals+0x5c>
	{
		aptr = a->cstring;
		alen = strlen(a->cstring);
102cdd20:	e1a00004 	mov	r0, r4
102cdd24:	e59f504c 	ldr	r5, [pc, #76]	; 102cdd78 <MQTTPacket_equals+0x6c>
102cdd28:	e12fff35 	blx	r5
102cdd2c:	e1a07000 	mov	r7, r0
	else
	{
		aptr = a->lenstring.data;
		alen = a->lenstring.len;
	}
	blen = strlen(bptr);
102cdd30:	e1a00006 	mov	r0, r6
102cdd34:	e12fff35 	blx	r5
	
	return (alen == blen) && (strncmp(aptr, bptr, alen) == 0);
102cdd38:	e1570000 	cmp	r7, r0
102cdd3c:	0a000001 	beq	102cdd48 <MQTTPacket_equals+0x3c>
102cdd40:	e3a00000 	mov	r0, #0
}
102cdd44:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		aptr = a->lenstring.data;
		alen = a->lenstring.len;
	}
	blen = strlen(bptr);
	
	return (alen == blen) && (strncmp(aptr, bptr, alen) == 0);
102cdd48:	e1a00004 	mov	r0, r4
102cdd4c:	e1a01006 	mov	r1, r6
102cdd50:	e1a02007 	mov	r2, r7
102cdd54:	e59f3020 	ldr	r3, [pc, #32]	; 102cdd7c <MQTTPacket_equals+0x70>
102cdd58:	e12fff33 	blx	r3
102cdd5c:	e2700001 	rsbs	r0, r0, #1
102cdd60:	33a00000 	movcc	r0, #0
102cdd64:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		aptr = a->cstring;
		alen = strlen(a->cstring);
	}
	else
	{
		aptr = a->lenstring.data;
102cdd68:	e5904008 	ldr	r4, [r0, #8]
		alen = a->lenstring.len;
102cdd6c:	e5907004 	ldr	r7, [r0, #4]
102cdd70:	e59f5000 	ldr	r5, [pc]	; 102cdd78 <MQTTPacket_equals+0x6c>
102cdd74:	eaffffed 	b	102cdd30 <MQTTPacket_equals+0x24>
102cdd78:	102dff65 	.word	0x102dff65
102cdd7c:	102dff75 	.word	0x102dff75

102cdd80 <MQTTPacket_read>:
 * @param getfn pointer to a function which will read any number of bytes from the needed source
 * @return integer MQTT packet type, or -1 on error
 * @note  the whole message must fit into the caller's buffer
 */
int MQTTPacket_read(unsigned char* buf, int buflen, int (*getfn)(unsigned char*, int))
{
102cdd80:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
102cdd84:	e1a08001 	mov	r8, r1
102cdd88:	e24dd00c 	sub	sp, sp, #12
	int rc = -1;
	MQTTHeader header = {0};
	int len = 0;
	int rem_len = 0;
102cdd8c:	e3a06000 	mov	r6, #0

	/* 1. read the header byte.  This has the packet type in it */
	if ((*getfn)(buf, 1) != 1)
102cdd90:	e3a01001 	mov	r1, #1
 * @param getfn pointer to a function which will read any number of bytes from the needed source
 * @return integer MQTT packet type, or -1 on error
 * @note  the whole message must fit into the caller's buffer
 */
int MQTTPacket_read(unsigned char* buf, int buflen, int (*getfn)(unsigned char*, int))
{
102cdd94:	e1a0a002 	mov	sl, r2
102cdd98:	e1a07000 	mov	r7, r0
	int rc = -1;
	MQTTHeader header = {0};
	int len = 0;
	int rem_len = 0;
102cdd9c:	e58d6004 	str	r6, [sp, #4]

	/* 1. read the header byte.  This has the packet type in it */
	if ((*getfn)(buf, 1) != 1)
102cdda0:	e12fff32 	blx	r2
102cdda4:	e3500001 	cmp	r0, #1
102cdda8:	1a000027 	bne	102cde4c <MQTTPacket_read+0xcc>
		return rc;

	len = 1;
	/* 2. read the remaining length.  This is variable in itself */
	MQTTPacket_decode(getfn, &rem_len);
102cddac:	e28d1004 	add	r1, sp, #4
102cddb0:	e1a0000a 	mov	r0, sl
102cddb4:	ebffff0e 	bl	102cd9f4 <MQTTPacket_decode>
	len += MQTTPacket_encode(buf + 1, rem_len); /* put the original remaining length back into the buffer */
102cddb8:	e59d5004 	ldr	r5, [sp, #4]
102cddbc:	e2872001 	add	r2, r7, #1

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
		length /= 128;
102cddc0:	e3550000 	cmp	r5, #0
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cddc4:	e1a01fc5 	asr	r1, r5, #31
		length /= 128;
102cddc8:	e285307f 	add	r3, r5, #127	; 0x7f
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cddcc:	e1a01ca1 	lsr	r1, r1, #25
		length /= 128;
102cddd0:	a1a03005 	movge	r3, r5
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cddd4:	e0854001 	add	r4, r5, r1
		length /= 128;
102cddd8:	e1a033c3 	asr	r3, r3, #7
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cdddc:	e204407f 	and	r4, r4, #127	; 0x7f
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cdde0:	e3530000 	cmp	r3, #0
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cdde4:	e0614004 	rsb	r4, r1, r4
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cdde8:	da000019 	ble	102cde54 <MQTTPacket_read+0xd4>
102cddec:	e1a05007 	mov	r5, r7
 * @param length the length to be encoded
 * @return the number of bytes written to buffer
 */
int MQTTPacket_encode(unsigned char* buf, int length)
{
	int rc = 0;
102cddf0:	e1a0c006 	mov	ip, r6
	{
		char d = length % 128;
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
			d |= 0x80;
102cddf4:	e3846080 	orr	r6, r4, #128	; 0x80
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cddf8:	e203407f 	and	r4, r3, #127	; 0x7f
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cddfc:	e1b033c3 	asrs	r3, r3, #7
			d |= 0x80;
102cde00:	e5e56001 	strb	r6, [r5, #1]!
		buf[rc++] = d;
102cde04:	e28cc001 	add	ip, ip, #1
	do
	{
		char d = length % 128;
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cde08:	1afffff9 	bne	102cddf4 <MQTTPacket_read+0x74>
102cde0c:	e59d5004 	ldr	r5, [sp, #4]
102cde10:	e28c0002 	add	r0, ip, #2
	/* 2. read the remaining length.  This is variable in itself */
	MQTTPacket_decode(getfn, &rem_len);
	len += MQTTPacket_encode(buf + 1, rem_len); /* put the original remaining length back into the buffer */

	/* 3. read the rest of the buffer using a callback to supply the rest of the data */
	if((rem_len + len) > buflen)
102cde14:	e0853000 	add	r3, r5, r0
102cde18:	e1530008 	cmp	r3, r8
		char d = length % 128;
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
			d |= 0x80;
		buf[rc++] = d;
102cde1c:	e7c2400c 	strb	r4, [r2, ip]
	/* 2. read the remaining length.  This is variable in itself */
	MQTTPacket_decode(getfn, &rem_len);
	len += MQTTPacket_encode(buf + 1, rem_len); /* put the original remaining length back into the buffer */

	/* 3. read the rest of the buffer using a callback to supply the rest of the data */
	if((rem_len + len) > buflen)
102cde20:	ca000009 	bgt	102cde4c <MQTTPacket_read+0xcc>
		return rc;
	if ((*getfn)(buf + len, rem_len) != rem_len)
102cde24:	e0870000 	add	r0, r7, r0
102cde28:	e1a01005 	mov	r1, r5
102cde2c:	e12fff3a 	blx	sl
102cde30:	e59d3004 	ldr	r3, [sp, #4]
102cde34:	e1500003 	cmp	r0, r3
102cde38:	1a000003 	bne	102cde4c <MQTTPacket_read+0xcc>
		return rc;

	header.byte = buf[0];
102cde3c:	e5d70000 	ldrb	r0, [r7]
	rc = header.bits.type;
102cde40:	e1a00220 	lsr	r0, r0, #4

	return rc;
}
102cde44:	e28dd00c 	add	sp, sp, #12
102cde48:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
	int len = 0;
	int rem_len = 0;

	/* 1. read the header byte.  This has the packet type in it */
	if ((*getfn)(buf, 1) != 1)
		return rc;
102cde4c:	e3e00000 	mvn	r0, #0
102cde50:	eafffffb 	b	102cde44 <MQTTPacket_read+0xc4>
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cde54:	e1a0c006 	mov	ip, r6
102cde58:	e3a00002 	mov	r0, #2
102cde5c:	eaffffec 	b	102cde14 <MQTTPacket_read+0x94>

102cde60 <MQTTPacket_readnb>:
 * @param trp pointer to a transport structure holding what is needed to solve getting data from it
 * @return integer MQTT packet type, 0 for call again, or -1 on error
 * @note  the whole message must fit into the caller's buffer
 */
int MQTTPacket_readnb(unsigned char* buf, int buflen, MQTTTransport *trp)
{
102cde60:	e92d4070 	push	{r4, r5, r6, lr}
102cde64:	e1a04002 	mov	r4, r2
	int rc = -1, frc;
	MQTTHeader header = {0};

	switch(trp->state){
102cde68:	e5d22014 	ldrb	r2, [r2, #20]
 * @param trp pointer to a transport structure holding what is needed to solve getting data from it
 * @return integer MQTT packet type, 0 for call again, or -1 on error
 * @note  the whole message must fit into the caller's buffer
 */
int MQTTPacket_readnb(unsigned char* buf, int buflen, MQTTTransport *trp)
{
102cde6c:	e24dd008 	sub	sp, sp, #8
	int rc = -1, frc;
	MQTTHeader header = {0};

	switch(trp->state){
102cde70:	e3520001 	cmp	r2, #1
 * @param trp pointer to a transport structure holding what is needed to solve getting data from it
 * @return integer MQTT packet type, 0 for call again, or -1 on error
 * @note  the whole message must fit into the caller's buffer
 */
int MQTTPacket_readnb(unsigned char* buf, int buflen, MQTTTransport *trp)
{
102cde74:	e1a05000 	mov	r5, r0
	int rc = -1, frc;
	MQTTHeader header = {0};

	switch(trp->state){
102cde78:	0a000014 	beq	102cded0 <MQTTPacket_readnb+0x70>
102cde7c:	3a000006 	bcc	102cde9c <MQTTPacket_readnb+0x3c>
102cde80:	e3520002 	cmp	r2, #2
102cde84:	0a00004a 	beq	102cdfb4 <MQTTPacket_readnb+0x154>
 * @return integer MQTT packet type, 0 for call again, or -1 on error
 * @note  the whole message must fit into the caller's buffer
 */
int MQTTPacket_readnb(unsigned char* buf, int buflen, MQTTTransport *trp)
{
	int rc = -1, frc;
102cde88:	e3e00000 	mvn	r0, #0
		header.byte = buf[0];
		rc = header.bits.type;
	break;
	}

	trp->state = 0;
102cde8c:	e3a03000 	mov	r3, #0
102cde90:	e5c43014 	strb	r3, [r4, #20]
	return rc;
}
102cde94:	e28dd008 	add	sp, sp, #8
102cde98:	e8bd8070 	pop	{r4, r5, r6, pc}
		trp->state = 0;
		/*FALLTHROUGH*/
	break;
	case 0:
		/* read the header byte.  This has the packet type in it */
		if ((frc=(*trp->getfn)(trp->sck, buf, 1)) == -1)
102cde9c:	e5943000 	ldr	r3, [r4]
102cdea0:	e5940004 	ldr	r0, [r4, #4]
102cdea4:	e1a01005 	mov	r1, r5
102cdea8:	e3a02001 	mov	r2, #1
102cdeac:	e12fff33 	blx	r3
102cdeb0:	e3700001 	cmn	r0, #1
102cdeb4:	0afffff3 	beq	102cde88 <MQTTPacket_readnb+0x28>
			break;
		if (frc == 0)
102cdeb8:	e3500000 	cmp	r0, #0
102cdebc:	0a000050 	beq	102ce004 <MQTTPacket_readnb+0x1a4>
			return 0;
		trp->len = 0;
102cdec0:	e3a03000 	mov	r3, #0
102cdec4:	e5843010 	str	r3, [r4, #16]
 * @return integer MQTT packet type, 0 for call again, or -1 on error
 * @note  the whole message must fit into the caller's buffer
 */
int MQTTPacket_readnb(unsigned char* buf, int buflen, MQTTTransport *trp)
{
	int rc = -1, frc;
102cdec8:	e3e00000 	mvn	r0, #0
			return 0;
		trp->len = 0;
		++trp->state;
		/*FALLTHROUGH*/
		/* read the remaining length.  This is variable in itself */
	break;
102cdecc:	eaffffee 	b	102cde8c <MQTTPacket_readnb+0x2c>
{
	unsigned char c;
	int rc = MQTTPACKET_READ_ERROR;

	FUNC_ENTRY;
	if(trp->len == 0){		/* initialize on first call */
102cded0:	e5943010 	ldr	r3, [r4, #16]
102cded4:	e3530000 	cmp	r3, #0
		trp->multiplier = 1;
102cded8:	05842008 	streq	r2, [r4, #8]
		trp->rem_len = 0;
102cdedc:	0584300c 	streq	r3, [r4, #12]
	}
	do {
		int frc;
		if (++(trp->len) > MAX_NO_OF_REMAINING_LENGTH_BYTES)
			goto exit;
		if ((frc=(*trp->getfn)(trp->sck, &c, 1)) == -1)
102cdee0:	e3a02001 	mov	r2, #1
		trp->multiplier = 1;
		trp->rem_len = 0;
	}
	do {
		int frc;
		if (++(trp->len) > MAX_NO_OF_REMAINING_LENGTH_BYTES)
102cdee4:	e0833002 	add	r3, r3, r2
102cdee8:	e3530004 	cmp	r3, #4
			goto exit;
		if ((frc=(*trp->getfn)(trp->sck, &c, 1)) == -1)
102cdeec:	e28d1007 	add	r1, sp, #7
		trp->multiplier = 1;
		trp->rem_len = 0;
	}
	do {
		int frc;
		if (++(trp->len) > MAX_NO_OF_REMAINING_LENGTH_BYTES)
102cdef0:	e5843010 	str	r3, [r4, #16]
102cdef4:	caffffe3 	bgt	102cde88 <MQTTPacket_readnb+0x28>
			goto exit;
		if ((frc=(*trp->getfn)(trp->sck, &c, 1)) == -1)
102cdef8:	e5943000 	ldr	r3, [r4]
102cdefc:	e5940004 	ldr	r0, [r4, #4]
102cdf00:	e12fff33 	blx	r3
102cdf04:	e3700001 	cmn	r0, #1
102cdf08:	0affffde 	beq	102cde88 <MQTTPacket_readnb+0x28>
			goto exit;
		if (frc == 0){
102cdf0c:	e3500000 	cmp	r0, #0
102cdf10:	0affffdf 	beq	102cde94 <MQTTPacket_readnb+0x34>
			rc = 0;
			goto exit;
		}
		trp->rem_len += (c & 127) * trp->multiplier;
102cdf14:	e5dd3007 	ldrb	r3, [sp, #7]
102cdf18:	e5942008 	ldr	r2, [r4, #8]
102cdf1c:	e594100c 	ldr	r1, [r4, #12]
102cdf20:	e203c07f 	and	ip, r3, #127	; 0x7f
102cdf24:	e02c1c92 	mla	ip, r2, ip, r1
		trp->multiplier *= 128;
	} while ((c & 128) != 0);
102cdf28:	e3130080 	tst	r3, #128	; 0x80
		if (frc == 0){
			rc = 0;
			goto exit;
		}
		trp->rem_len += (c & 127) * trp->multiplier;
		trp->multiplier *= 128;
102cdf2c:	e1a02382 	lsl	r2, r2, #7
			goto exit;
		if (frc == 0){
			rc = 0;
			goto exit;
		}
		trp->rem_len += (c & 127) * trp->multiplier;
102cdf30:	e584c00c 	str	ip, [r4, #12]
		trp->multiplier *= 128;
102cdf34:	e5842008 	str	r2, [r4, #8]
102cdf38:	e5943010 	ldr	r3, [r4, #16]
	} while ((c & 128) != 0);
102cdf3c:	1affffe7 	bne	102cdee0 <MQTTPacket_readnb+0x80>
		++trp->state;
		/*FALLTHROUGH*/
		/* read the remaining length.  This is variable in itself */
	break;
	case 1:
		if((frc=MQTTPacket_decodenb(trp)) == MQTTPACKET_READ_ERROR)
102cdf40:	e3730001 	cmn	r3, #1
102cdf44:	0affffcf 	beq	102cde88 <MQTTPacket_readnb+0x28>
			break;
		if(frc == 0)
102cdf48:	e3530000 	cmp	r3, #0
102cdf4c:	0a00002c 	beq	102ce004 <MQTTPacket_readnb+0x1a4>

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
		length /= 128;
102cdf50:	e35c0000 	cmp	ip, #0
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cdf54:	e1a02fcc 	asr	r2, ip, #31
102cdf58:	e1a02ca2 	lsr	r2, r2, #25
		length /= 128;
102cdf5c:	e28c307f 	add	r3, ip, #127	; 0x7f
102cdf60:	a1a0300c 	movge	r3, ip
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cdf64:	e08c1002 	add	r1, ip, r2
		length /= 128;
102cdf68:	e1a033c3 	asr	r3, r3, #7
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cdf6c:	e201107f 	and	r1, r1, #127	; 0x7f
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cdf70:	e3530000 	cmp	r3, #0
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cdf74:	e0621001 	rsb	r1, r2, r1
	case 1:
		if((frc=MQTTPacket_decodenb(trp)) == MQTTPACKET_READ_ERROR)
			break;
		if(frc == 0)
			return 0;
		trp->len = 1 + MQTTPacket_encode(buf + 1, trp->rem_len); /* put the original remaining length back into the buffer */
102cdf78:	e2856001 	add	r6, r5, #1
 * @param length the length to be encoded
 * @return the number of bytes written to buffer
 */
int MQTTPacket_encode(unsigned char* buf, int length)
{
	int rc = 0;
102cdf7c:	e3a02000 	mov	r2, #0

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cdf80:	d3a03002 	movle	r3, #2
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cdf84:	da000006 	ble	102cdfa4 <MQTTPacket_readnb+0x144>
			d |= 0x80;
102cdf88:	e3810080 	orr	r0, r1, #128	; 0x80
	int rc = 0;

	FUNC_ENTRY;
	do
	{
		char d = length % 128;
102cdf8c:	e203107f 	and	r1, r3, #127	; 0x7f
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cdf90:	e1b033c3 	asrs	r3, r3, #7
			d |= 0x80;
102cdf94:	e5e50001 	strb	r0, [r5, #1]!
		buf[rc++] = d;
102cdf98:	e2822001 	add	r2, r2, #1
	do
	{
		char d = length % 128;
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if (length > 0)
102cdf9c:	1afffff9 	bne	102cdf88 <MQTTPacket_readnb+0x128>
102cdfa0:	e2823002 	add	r3, r2, #2
			d |= 0x80;
		buf[rc++] = d;
102cdfa4:	e7c61002 	strb	r1, [r6, r2]
 * @return integer MQTT packet type, 0 for call again, or -1 on error
 * @note  the whole message must fit into the caller's buffer
 */
int MQTTPacket_readnb(unsigned char* buf, int buflen, MQTTTransport *trp)
{
	int rc = -1, frc;
102cdfa8:	e3e00000 	mvn	r0, #0
	case 1:
		if((frc=MQTTPacket_decodenb(trp)) == MQTTPACKET_READ_ERROR)
			break;
		if(frc == 0)
			return 0;
		trp->len = 1 + MQTTPacket_encode(buf + 1, trp->rem_len); /* put the original remaining length back into the buffer */
102cdfac:	e5843010 	str	r3, [r4, #16]
102cdfb0:	eaffffb5 	b	102cde8c <MQTTPacket_readnb+0x2c>
		++trp->state;
		/*FALLTHROUGH*/
	break;
	case 2:
		/* read the rest of the buffer using a callback to supply the rest of the data */
		if ((frc=(*trp->getfn)(trp->sck, buf + trp->len, trp->rem_len)) == -1)
102cdfb4:	e5941010 	ldr	r1, [r4, #16]
102cdfb8:	e5943000 	ldr	r3, [r4]
102cdfbc:	e5940004 	ldr	r0, [r4, #4]
102cdfc0:	e0851001 	add	r1, r5, r1
102cdfc4:	e594200c 	ldr	r2, [r4, #12]
102cdfc8:	e12fff33 	blx	r3
102cdfcc:	e3700001 	cmn	r0, #1
102cdfd0:	0affffac 	beq	102cde88 <MQTTPacket_readnb+0x28>
			break;
		if (frc == 0)
102cdfd4:	e3500000 	cmp	r0, #0
102cdfd8:	0a000009 	beq	102ce004 <MQTTPacket_readnb+0x1a4>
			return 0;
		trp->rem_len -= frc;
102cdfdc:	e594300c 	ldr	r3, [r4, #12]
		trp->len += frc;
102cdfe0:	e5942010 	ldr	r2, [r4, #16]
		/* read the rest of the buffer using a callback to supply the rest of the data */
		if ((frc=(*trp->getfn)(trp->sck, buf + trp->len, trp->rem_len)) == -1)
			break;
		if (frc == 0)
			return 0;
		trp->rem_len -= frc;
102cdfe4:	e0603003 	rsb	r3, r0, r3
		trp->len += frc;
		if(trp->rem_len)
102cdfe8:	e3530000 	cmp	r3, #0
		if ((frc=(*trp->getfn)(trp->sck, buf + trp->len, trp->rem_len)) == -1)
			break;
		if (frc == 0)
			return 0;
		trp->rem_len -= frc;
		trp->len += frc;
102cdfec:	e0820000 	add	r0, r2, r0
		/* read the rest of the buffer using a callback to supply the rest of the data */
		if ((frc=(*trp->getfn)(trp->sck, buf + trp->len, trp->rem_len)) == -1)
			break;
		if (frc == 0)
			return 0;
		trp->rem_len -= frc;
102cdff0:	e584300c 	str	r3, [r4, #12]
		trp->len += frc;
102cdff4:	e5840010 	str	r0, [r4, #16]
		if(trp->rem_len)
			return 0;

		header.byte = buf[0];
102cdff8:	05d50000 	ldrbeq	r0, [r5]
		rc = header.bits.type;
102cdffc:	01a00220 	lsreq	r0, r0, #4
	break;
102ce000:	0affffa1 	beq	102cde8c <MQTTPacket_readnb+0x2c>
	case 0:
		/* read the header byte.  This has the packet type in it */
		if ((frc=(*trp->getfn)(trp->sck, buf, 1)) == -1)
			break;
		if (frc == 0)
			return 0;
102ce004:	e3a00000 	mov	r0, #0
102ce008:	eaffffa1 	b	102cde94 <MQTTPacket_readnb+0x34>

102ce00c <MQTTSerialize_publishLength>:
  * @param topicName the topic name to be used in the publish  
  * @param payloadlen the length of the payload to be sent
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_publishLength(int qos, MQTTString topicName, int payloadlen)
{
102ce00c:	e92d4010 	push	{r4, lr}
102ce010:	e24dd010 	sub	sp, sp, #16
102ce014:	e28dc004 	add	ip, sp, #4
102ce018:	e88c000e 	stm	ip, {r1, r2, r3}
102ce01c:	e1a04000 	mov	r4, r0
	int len = 0;

	len += 2 + MQTTstrlen(topicName) + payloadlen;
102ce020:	e59f3020 	ldr	r3, [pc, #32]	; 102ce048 <MQTTSerialize_publishLength+0x3c>
102ce024:	e89c0007 	ldm	ip, {r0, r1, r2}
102ce028:	e12fff33 	blx	r3
102ce02c:	e59d3018 	ldr	r3, [sp, #24]
	if (qos > 0)
102ce030:	e3540000 	cmp	r4, #0
  */
int MQTTSerialize_publishLength(int qos, MQTTString topicName, int payloadlen)
{
	int len = 0;

	len += 2 + MQTTstrlen(topicName) + payloadlen;
102ce034:	e2800002 	add	r0, r0, #2
102ce038:	e0800003 	add	r0, r0, r3
	if (qos > 0)
		len += 2; /* packetid */
102ce03c:	c2800002 	addgt	r0, r0, #2
	return len;
}
102ce040:	e28dd010 	add	sp, sp, #16
102ce044:	e8bd8010 	pop	{r4, pc}
102ce048:	102cdcd4 	.word	0x102cdcd4

102ce04c <MQTTSerialize_publish>:
  * @param payloadlen integer - the length of the MQTT payload
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_publish(unsigned char* buf, int buflen, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,
		MQTTString topicName, unsigned char* payload, int payloadlen)
{
102ce04c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
102ce050:	e24dd010 	sub	sp, sp, #16
102ce054:	e1a06003 	mov	r6, r3
102ce058:	e59d5048 	ldr	r5, [sp, #72]	; 0x48
	unsigned char *ptr = buf;
	MQTTHeader header = {0};
	int rem_len = 0;
	int rc = 0;

	if (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)
102ce05c:	e28d4038 	add	r4, sp, #56	; 0x38
  * @param payloadlen integer - the length of the MQTT payload
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_publish(unsigned char* buf, int buflen, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,
		MQTTString topicName, unsigned char* payload, int payloadlen)
{
102ce060:	e1a07000 	mov	r7, r0
102ce064:	e1a08001 	mov	r8, r1
	unsigned char *ptr = buf;
	MQTTHeader header = {0};
	int rem_len = 0;
	int rc = 0;

	if (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)
102ce068:	e58d5000 	str	r5, [sp]
  * @param payloadlen integer - the length of the MQTT payload
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_publish(unsigned char* buf, int buflen, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,
		MQTTString topicName, unsigned char* payload, int payloadlen)
{
102ce06c:	e1a09002 	mov	r9, r2
	unsigned char *ptr = buf;
	MQTTHeader header = {0};
	int rem_len = 0;
	int rc = 0;

	if (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)
102ce070:	e1a00006 	mov	r0, r6
102ce074:	e894000e 	ldm	r4, {r1, r2, r3}
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_publish(unsigned char* buf, int buflen, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,
		MQTTString topicName, unsigned char* payload, int payloadlen)
{
	unsigned char *ptr = buf;
102ce078:	e58d700c 	str	r7, [sp, #12]
	MQTTHeader header = {0};
	int rem_len = 0;
	int rc = 0;

	if (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)
102ce07c:	ebffffe2 	bl	102ce00c <MQTTSerialize_publishLength>
102ce080:	e59f30b0 	ldr	r3, [pc, #176]	; 102ce138 <MQTTSerialize_publish+0xec>
102ce084:	e1a0a000 	mov	sl, r0
102ce088:	e12fff33 	blx	r3
102ce08c:	e1500008 	cmp	r0, r8
102ce090:	ca000026 	bgt	102ce130 <MQTTSerialize_publish+0xe4>
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		return rc;
	}

	header.bits.type = PUBLISH;
	header.bits.dup = dup;
102ce094:	e2099001 	and	r9, r9, #1
	header.bits.qos = qos;
102ce098:	e3590000 	cmp	r9, #0
	header.bits.retain = retained;
102ce09c:	e5dd1030 	ldrb	r1, [sp, #48]	; 0x30
		return rc;
	}

	header.bits.type = PUBLISH;
	header.bits.dup = dup;
	header.bits.qos = qos;
102ce0a0:	13a09038 	movne	r9, #56	; 0x38
102ce0a4:	03a09030 	moveq	r9, #48	; 0x30
102ce0a8:	e2063003 	and	r3, r6, #3
	header.bits.retain = retained;
102ce0ac:	e1899083 	orr	r9, r9, r3, lsl #1
102ce0b0:	e2011001 	and	r1, r1, #1
	writeChar(&ptr, header.byte); /* write header */
102ce0b4:	e28d000c 	add	r0, sp, #12
102ce0b8:	e1811009 	orr	r1, r1, r9
102ce0bc:	e59f3078 	ldr	r3, [pc, #120]	; 102ce13c <MQTTSerialize_publish+0xf0>
102ce0c0:	e12fff33 	blx	r3

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
102ce0c4:	e59d800c 	ldr	r8, [sp, #12]
102ce0c8:	e1a0100a 	mov	r1, sl
102ce0cc:	e1a00008 	mov	r0, r8
102ce0d0:	e59f3068 	ldr	r3, [pc, #104]	; 102ce140 <MQTTSerialize_publish+0xf4>
102ce0d4:	e12fff33 	blx	r3

	writeMQTTString(&ptr, topicName);
102ce0d8:	e894000e 	ldm	r4, {r1, r2, r3}
102ce0dc:	e59fc060 	ldr	ip, [pc, #96]	; 102ce144 <MQTTSerialize_publish+0xf8>
	header.bits.dup = dup;
	header.bits.qos = qos;
	header.bits.retain = retained;
	writeChar(&ptr, header.byte); /* write header */

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
102ce0e0:	e0888000 	add	r8, r8, r0

	writeMQTTString(&ptr, topicName);
102ce0e4:	e28d000c 	add	r0, sp, #12
	header.bits.dup = dup;
	header.bits.qos = qos;
	header.bits.retain = retained;
	writeChar(&ptr, header.byte); /* write header */

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
102ce0e8:	e58d800c 	str	r8, [sp, #12]

	writeMQTTString(&ptr, topicName);
102ce0ec:	e12fff3c 	blx	ip

	if (qos > 0)
102ce0f0:	e3560000 	cmp	r6, #0
102ce0f4:	da000003 	ble	102ce108 <MQTTSerialize_publish+0xbc>
		writeInt(&ptr, packetid);
102ce0f8:	e28d000c 	add	r0, sp, #12
102ce0fc:	e1dd13b4 	ldrh	r1, [sp, #52]	; 0x34
102ce100:	e59f3040 	ldr	r3, [pc, #64]	; 102ce148 <MQTTSerialize_publish+0xfc>
102ce104:	e12fff33 	blx	r3

	memcpy(ptr, payload, payloadlen);
102ce108:	e1a02005 	mov	r2, r5
102ce10c:	e59d000c 	ldr	r0, [sp, #12]
102ce110:	e59d1044 	ldr	r1, [sp, #68]	; 0x44
102ce114:	e59f3030 	ldr	r3, [pc, #48]	; 102ce14c <MQTTSerialize_publish+0x100>
102ce118:	e12fff33 	blx	r3
	ptr += payloadlen;
102ce11c:	e59d000c 	ldr	r0, [sp, #12]
102ce120:	e0805005 	add	r5, r0, r5

	rc = ptr - buf;
102ce124:	e0670005 	rsb	r0, r7, r5

	return rc;
}
102ce128:	e28dd010 	add	sp, sp, #16
102ce12c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
	int rc = 0;

	if (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		return rc;
102ce130:	e3e00001 	mvn	r0, #1
102ce134:	eafffffb 	b	102ce128 <MQTTSerialize_publish+0xdc>
102ce138:	102cda60 	.word	0x102cda60
102ce13c:	102cdae4 	.word	0x102cdae4
102ce140:	102cd98c 	.word	0x102cd98c
102ce144:	102cdbbc 	.word	0x102cdbbc
102ce148:	102cdafc 	.word	0x102cdafc
102ce14c:	102df8c9 	.word	0x102df8c9

102ce150 <MQTTSerialize_ack>:
  * @param dup the MQTT dup flag
  * @param packetid the MQTT packet identifier
  * @return serialized length, or error if 0
  */
int MQTTSerialize_ack(unsigned char* buf, int buflen, unsigned char packettype, unsigned char dup, unsigned short packetid)
{
102ce150:	e92d4030 	push	{r4, r5, lr}
	MQTTHeader header = {0};
	int rc = 0;
	unsigned char *ptr = buf;

	FUNC_ENTRY;
	if (buflen < 4)
102ce154:	e3510003 	cmp	r1, #3
  * @param dup the MQTT dup flag
  * @param packetid the MQTT packet identifier
  * @return serialized length, or error if 0
  */
int MQTTSerialize_ack(unsigned char* buf, int buflen, unsigned char packettype, unsigned char dup, unsigned short packetid)
{
102ce158:	e24dd00c 	sub	sp, sp, #12
102ce15c:	e1a04000 	mov	r4, r0
	MQTTHeader header = {0};
	int rc = 0;
	unsigned char *ptr = buf;
102ce160:	e58d0004 	str	r0, [sp, #4]

	FUNC_ENTRY;
	if (buflen < 4)
102ce164:	da000019 	ble	102ce1d0 <MQTTSerialize_ack+0x80>
		FUNC_EXIT_RC(rc);
		return rc;
	}
	header.bits.type = packettype;
	header.bits.dup = dup;
	header.bits.qos = (packettype == PUBREL) ? 1 : 0;
102ce168:	e2520006 	subs	r0, r2, #6
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		FUNC_EXIT_RC(rc);
		return rc;
	}
	header.bits.type = packettype;
	header.bits.dup = dup;
102ce16c:	e2033001 	and	r3, r3, #1
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		FUNC_EXIT_RC(rc);
		return rc;
	}
	header.bits.type = packettype;
102ce170:	e202100f 	and	r1, r2, #15
	header.bits.dup = dup;
102ce174:	e1a03183 	lsl	r3, r3, #3
	header.bits.qos = (packettype == PUBREL) ? 1 : 0;
102ce178:	e2702000 	rsbs	r2, r0, #0
102ce17c:	e0b22000 	adcs	r2, r2, r0
102ce180:	e1831201 	orr	r1, r3, r1, lsl #4
	writeChar(&ptr, header.byte); /* write header */
102ce184:	e1811082 	orr	r1, r1, r2, lsl #1
102ce188:	e28d0004 	add	r0, sp, #4
102ce18c:	e59f3044 	ldr	r3, [pc, #68]	; 102ce1d8 <MQTTSerialize_ack+0x88>
102ce190:	e12fff33 	blx	r3

	ptr += MQTTPacket_encode(ptr, 2); /* write remaining length */
102ce194:	e59d5004 	ldr	r5, [sp, #4]
102ce198:	e3a01002 	mov	r1, #2
102ce19c:	e1a00005 	mov	r0, r5
102ce1a0:	e59f3034 	ldr	r3, [pc, #52]	; 102ce1dc <MQTTSerialize_ack+0x8c>
102ce1a4:	e12fff33 	blx	r3
	writeInt(&ptr, packetid);
102ce1a8:	e1dd11b8 	ldrh	r1, [sp, #24]
102ce1ac:	e59f302c 	ldr	r3, [pc, #44]	; 102ce1e0 <MQTTSerialize_ack+0x90>
	header.bits.type = packettype;
	header.bits.dup = dup;
	header.bits.qos = (packettype == PUBREL) ? 1 : 0;
	writeChar(&ptr, header.byte); /* write header */

	ptr += MQTTPacket_encode(ptr, 2); /* write remaining length */
102ce1b0:	e0855000 	add	r5, r5, r0
	writeInt(&ptr, packetid);
102ce1b4:	e28d0004 	add	r0, sp, #4
	header.bits.type = packettype;
	header.bits.dup = dup;
	header.bits.qos = (packettype == PUBREL) ? 1 : 0;
	writeChar(&ptr, header.byte); /* write header */

	ptr += MQTTPacket_encode(ptr, 2); /* write remaining length */
102ce1b8:	e58d5004 	str	r5, [sp, #4]
	writeInt(&ptr, packetid);
102ce1bc:	e12fff33 	blx	r3
	rc = ptr - buf;
102ce1c0:	e59d0004 	ldr	r0, [sp, #4]
102ce1c4:	e0640000 	rsb	r0, r4, r0
	return rc;
}
102ce1c8:	e28dd00c 	add	sp, sp, #12
102ce1cc:	e8bd8030 	pop	{r4, r5, pc}
	FUNC_ENTRY;
	if (buflen < 4)
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		FUNC_EXIT_RC(rc);
		return rc;
102ce1d0:	e3e00001 	mvn	r0, #1
102ce1d4:	eafffffb 	b	102ce1c8 <MQTTSerialize_ack+0x78>
102ce1d8:	102cdae4 	.word	0x102cdae4
102ce1dc:	102cd98c 	.word	0x102cd98c
102ce1e0:	102cdafc 	.word	0x102cdafc

102ce1e4 <MQTTSerialize_puback>:
  * @param buflen the length in bytes of the supplied buffer
  * @param packetid integer - the MQTT packet identifier
  * @return serialized length, or error if 0
  */
int MQTTSerialize_puback(unsigned char* buf, int buflen, unsigned short packetid)
{
102ce1e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102ce1e8:	e24dd00c 	sub	sp, sp, #12
	return MQTTSerialize_ack(buf, buflen, PUBACK, 0, packetid);
102ce1ec:	e58d2000 	str	r2, [sp]
102ce1f0:	e3a03000 	mov	r3, #0
102ce1f4:	e3a02004 	mov	r2, #4
102ce1f8:	ebffffd4 	bl	102ce150 <MQTTSerialize_ack>
}
102ce1fc:	e28dd00c 	add	sp, sp, #12
102ce200:	e8bd8000 	ldmfd	sp!, {pc}

102ce204 <MQTTSerialize_pubrel>:
  * @param dup integer - the MQTT dup flag
  * @param packetid integer - the MQTT packet identifier
  * @return serialized length, or error if 0
  */
int MQTTSerialize_pubrel(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid)
{
102ce204:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102ce208:	e1a0c002 	mov	ip, r2
102ce20c:	e24dd00c 	sub	sp, sp, #12
	return MQTTSerialize_ack(buf, buflen, PUBREL, dup, packetid);
102ce210:	e58d3000 	str	r3, [sp]
102ce214:	e3a02006 	mov	r2, #6
102ce218:	e1a0300c 	mov	r3, ip
102ce21c:	ebffffcb 	bl	102ce150 <MQTTSerialize_ack>
}
102ce220:	e28dd00c 	add	sp, sp, #12
102ce224:	e8bd8000 	ldmfd	sp!, {pc}

102ce228 <MQTTSerialize_pubcomp>:
  * @param buflen the length in bytes of the supplied buffer
  * @param packetid integer - the MQTT packet identifier
  * @return serialized length, or error if 0
  */
int MQTTSerialize_pubcomp(unsigned char* buf, int buflen, unsigned short packetid)
{
102ce228:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102ce22c:	e24dd00c 	sub	sp, sp, #12
	return MQTTSerialize_ack(buf, buflen, PUBCOMP, 0, packetid);
102ce230:	e58d2000 	str	r2, [sp]
102ce234:	e3a03000 	mov	r3, #0
102ce238:	e3a02007 	mov	r2, #7
102ce23c:	ebffffc3 	bl	102ce150 <MQTTSerialize_ack>
}
102ce240:	e28dd00c 	add	sp, sp, #12
102ce244:	e8bd8000 	ldmfd	sp!, {pc}

102ce248 <MQTTSerialize_subscribeLength>:
  * @param count the number of topic filter strings in topicFilters
  * @param topicFilters the array of topic filter strings to be used in the publish
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])
{
102ce248:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	int i;
	int len = 2; /* packetid */

	for (i = 0; i < count; ++i)
102ce24c:	e2507000 	subs	r7, r0, #0
102ce250:	da00000d 	ble	102ce28c <MQTTSerialize_subscribeLength+0x44>
102ce254:	e59f8038 	ldr	r8, [pc, #56]	; 102ce294 <MQTTSerialize_subscribeLength+0x4c>
102ce258:	e1a04001 	mov	r4, r1
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])
{
	int i;
	int len = 2; /* packetid */
102ce25c:	e3a06002 	mov	r6, #2

	for (i = 0; i < count; ++i)
102ce260:	e3a05000 	mov	r5, #0
		len += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */
102ce264:	e8940007 	ldm	r4, {r0, r1, r2}
102ce268:	e12fff38 	blx	r8
int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])
{
	int i;
	int len = 2; /* packetid */

	for (i = 0; i < count; ++i)
102ce26c:	e2855001 	add	r5, r5, #1
102ce270:	e1550007 	cmp	r5, r7
102ce274:	e284400c 	add	r4, r4, #12
		len += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */
102ce278:	e2800003 	add	r0, r0, #3
102ce27c:	e0866000 	add	r6, r6, r0
int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])
{
	int i;
	int len = 2; /* packetid */

	for (i = 0; i < count; ++i)
102ce280:	1afffff7 	bne	102ce264 <MQTTSerialize_subscribeLength+0x1c>
		len += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */
	return len;
}
102ce284:	e1a00006 	mov	r0, r6
102ce288:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])
{
	int i;
	int len = 2; /* packetid */
102ce28c:	e3a06002 	mov	r6, #2
102ce290:	eafffffb 	b	102ce284 <MQTTSerialize_subscribeLength+0x3c>
102ce294:	102cdcd4 	.word	0x102cdcd4

102ce298 <MQTTSerialize_subscribe>:
  * @param requestedQoSs - array of requested QoS
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_subscribe(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid, int count,
		MQTTString topicFilters[], int requestedQoSs[])
{
102ce298:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
102ce29c:	e24dd008 	sub	sp, sp, #8
102ce2a0:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
102ce2a4:	e59d402c 	ldr	r4, [sp, #44]	; 0x2c
102ce2a8:	e1a09000 	mov	r9, r0
102ce2ac:	e1a05001 	mov	r5, r1
	int rem_len = 0;
	int rc = 0;
	int i = 0;

	FUNC_ENTRY;
	if (MQTTPacket_len(rem_len = MQTTSerialize_subscribeLength(count, topicFilters)) > buflen)
102ce2b0:	e1a00007 	mov	r0, r7
102ce2b4:	e1a01004 	mov	r1, r4
  * @param requestedQoSs - array of requested QoS
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_subscribe(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid, int count,
		MQTTString topicFilters[], int requestedQoSs[])
{
102ce2b8:	e1a08002 	mov	r8, r2
102ce2bc:	e1a06003 	mov	r6, r3
	unsigned char *ptr = buf;
102ce2c0:	e58d9004 	str	r9, [sp, #4]
	int rem_len = 0;
	int rc = 0;
	int i = 0;

	FUNC_ENTRY;
	if (MQTTPacket_len(rem_len = MQTTSerialize_subscribeLength(count, topicFilters)) > buflen)
102ce2c4:	ebffffdf 	bl	102ce248 <MQTTSerialize_subscribeLength>
102ce2c8:	e59f30b4 	ldr	r3, [pc, #180]	; 102ce384 <MQTTSerialize_subscribe+0xec>
102ce2cc:	e1a0a000 	mov	sl, r0
102ce2d0:	e12fff33 	blx	r3
102ce2d4:	e1500005 	cmp	r0, r5
102ce2d8:	ca000027 	bgt	102ce37c <MQTTSerialize_subscribe+0xe4>
		goto exit;
	}

	header.byte = 0;
	header.bits.type = SUBSCRIBE;
	header.bits.dup = dup;
102ce2dc:	e2088001 	and	r8, r8, #1
	header.bits.qos = 1;
102ce2e0:	e3580000 	cmp	r8, #0
102ce2e4:	13a01088 	movne	r1, #136	; 0x88
102ce2e8:	03a01080 	moveq	r1, #128	; 0x80
	writeChar(&ptr, header.byte); /* write header */
102ce2ec:	e28d0004 	add	r0, sp, #4
102ce2f0:	e3811002 	orr	r1, r1, #2
102ce2f4:	e59f808c 	ldr	r8, [pc, #140]	; 102ce388 <MQTTSerialize_subscribe+0xf0>
102ce2f8:	e12fff38 	blx	r8

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
102ce2fc:	e59d5004 	ldr	r5, [sp, #4]
102ce300:	e1a0100a 	mov	r1, sl
102ce304:	e1a00005 	mov	r0, r5
102ce308:	e59f307c 	ldr	r3, [pc, #124]	; 102ce38c <MQTTSerialize_subscribe+0xf4>
102ce30c:	e12fff33 	blx	r3

	writeInt(&ptr, packetid);
102ce310:	e1a01006 	mov	r1, r6
102ce314:	e59f3074 	ldr	r3, [pc, #116]	; 102ce390 <MQTTSerialize_subscribe+0xf8>
	header.bits.type = SUBSCRIBE;
	header.bits.dup = dup;
	header.bits.qos = 1;
	writeChar(&ptr, header.byte); /* write header */

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
102ce318:	e0855000 	add	r5, r5, r0

	writeInt(&ptr, packetid);
102ce31c:	e28d0004 	add	r0, sp, #4
	header.bits.type = SUBSCRIBE;
	header.bits.dup = dup;
	header.bits.qos = 1;
	writeChar(&ptr, header.byte); /* write header */

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
102ce320:	e58d5004 	str	r5, [sp, #4]

	writeInt(&ptr, packetid);
102ce324:	e12fff33 	blx	r3

	for (i = 0; i < count; ++i)
102ce328:	e3570000 	cmp	r7, #0
102ce32c:	da00000e 	ble	102ce36c <MQTTSerialize_subscribe+0xd4>
  * @param count - number of members in the topicFilters and reqQos arrays
  * @param topicFilters - array of topic filter names
  * @param requestedQoSs - array of requested QoS
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_subscribe(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid, int count,
102ce330:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
102ce334:	e59fa058 	ldr	sl, [pc, #88]	; 102ce394 <MQTTSerialize_subscribe+0xfc>
102ce338:	e2466004 	sub	r6, r6, #4

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;

	writeInt(&ptr, packetid);

	for (i = 0; i < count; ++i)
102ce33c:	e3a05000 	mov	r5, #0
	{
		writeMQTTString(&ptr, topicFilters[i]);
102ce340:	e894000e 	ldm	r4, {r1, r2, r3}
102ce344:	e28d0004 	add	r0, sp, #4
102ce348:	e12fff3a 	blx	sl
		writeChar(&ptr, requestedQoSs[i]);
102ce34c:	e5b61004 	ldr	r1, [r6, #4]!
102ce350:	e28d0004 	add	r0, sp, #4
102ce354:	e20110ff 	and	r1, r1, #255	; 0xff

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;

	writeInt(&ptr, packetid);

	for (i = 0; i < count; ++i)
102ce358:	e2855001 	add	r5, r5, #1
	{
		writeMQTTString(&ptr, topicFilters[i]);
		writeChar(&ptr, requestedQoSs[i]);
102ce35c:	e12fff38 	blx	r8

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;

	writeInt(&ptr, packetid);

	for (i = 0; i < count; ++i)
102ce360:	e1550007 	cmp	r5, r7
102ce364:	e284400c 	add	r4, r4, #12
102ce368:	1afffff4 	bne	102ce340 <MQTTSerialize_subscribe+0xa8>
	{
		writeMQTTString(&ptr, topicFilters[i]);
		writeChar(&ptr, requestedQoSs[i]);
	}

	rc = ptr - buf;
102ce36c:	e59d0004 	ldr	r0, [sp, #4]
102ce370:	e0690000 	rsb	r0, r9, r0
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
102ce374:	e28dd008 	add	sp, sp, #8
102ce378:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
	int i = 0;

	FUNC_ENTRY;
	if (MQTTPacket_len(rem_len = MQTTSerialize_subscribeLength(count, topicFilters)) > buflen)
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
102ce37c:	e3e00001 	mvn	r0, #1
102ce380:	eafffffb 	b	102ce374 <MQTTSerialize_subscribe+0xdc>
102ce384:	102cda60 	.word	0x102cda60
102ce388:	102cdae4 	.word	0x102cdae4
102ce38c:	102cd98c 	.word	0x102cd98c
102ce390:	102cdafc 	.word	0x102cdafc
102ce394:	102cdbbc 	.word	0x102cdbbc

102ce398 <MQTTDeserialize_suback>:
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)
{
102ce398:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102ce39c:	e24dd00c 	sub	sp, sp, #12
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
102ce3a0:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
102ce3a4:	e28d4008 	add	r4, sp, #8
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)
{
102ce3a8:	e1a0b000 	mov	fp, r0
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
102ce3ac:	e59f60c8 	ldr	r6, [pc, #200]	; 102ce47c <MQTTDeserialize_suback+0xe4>
102ce3b0:	e1a0000d 	mov	r0, sp
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)
{
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
102ce3b4:	e524c008 	str	ip, [r4, #-8]!
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)
{
102ce3b8:	e1a0a001 	mov	sl, r1
102ce3bc:	e1a08002 	mov	r8, r2
102ce3c0:	e1a07003 	mov	r7, r3
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
102ce3c4:	e12fff36 	blx	r6
102ce3c8:	e20000ff 	and	r0, r0, #255	; 0xff
	if (header.bits.type != SUBACK)
102ce3cc:	e1a00220 	lsr	r0, r0, #4
102ce3d0:	e3500009 	cmp	r0, #9
int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)
{
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
	unsigned char* enddata = NULL;
	int rc = 0;
102ce3d4:	13a00000 	movne	r0, #0
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
	if (header.bits.type != SUBACK)
102ce3d8:	0a000001 	beq	102ce3e4 <MQTTDeserialize_suback+0x4c>

	rc = 1;
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
102ce3dc:	e28dd00c 	add	sp, sp, #12
102ce3e0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	FUNC_ENTRY;
	header.byte = readChar(&curdata);
	if (header.bits.type != SUBACK)
		goto exit;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102ce3e4:	e59d5000 	ldr	r5, [sp]
102ce3e8:	e59f3090 	ldr	r3, [pc, #144]	; 102ce480 <MQTTDeserialize_suback+0xe8>
102ce3ec:	e28d1004 	add	r1, sp, #4
102ce3f0:	e1a00005 	mov	r0, r5
102ce3f4:	e12fff33 	blx	r3
	enddata = curdata + mylen;
102ce3f8:	e59d3004 	ldr	r3, [sp, #4]
	if (enddata - curdata < 2)
102ce3fc:	e3530001 	cmp	r3, #1
	FUNC_ENTRY;
	header.byte = readChar(&curdata);
	if (header.bits.type != SUBACK)
		goto exit;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
102ce400:	e0859000 	add	r9, r5, r0
102ce404:	e58d9000 	str	r9, [sp]
	enddata = curdata + mylen;
	if (enddata - curdata < 2)
102ce408:	e0899003 	add	r9, r9, r3
102ce40c:	dafffff2 	ble	102ce3dc <MQTTDeserialize_suback+0x44>
		goto exit;

	*packetid = readInt(&curdata);
102ce410:	e59f306c 	ldr	r3, [pc, #108]	; 102ce484 <MQTTDeserialize_suback+0xec>
102ce414:	e1a0000d 	mov	r0, sp
102ce418:	e12fff33 	blx	r3

	*count = 0;
	while (curdata < enddata)
102ce41c:	e59d3000 	ldr	r3, [sp]
	if (enddata - curdata < 2)
		goto exit;

	*packetid = readInt(&curdata);

	*count = 0;
102ce420:	e3a05000 	mov	r5, #0
	while (curdata < enddata)
102ce424:	e1590003 	cmp	r9, r3
	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
	enddata = curdata + mylen;
	if (enddata - curdata < 2)
		goto exit;

	*packetid = readInt(&curdata);
102ce428:	e1cb00b0 	strh	r0, [fp]

	*count = 0;
102ce42c:	e5885000 	str	r5, [r8]
	while (curdata < enddata)
102ce430:	9a00000d 	bls	102ce46c <MQTTDeserialize_suback+0xd4>
	{
		if (*count > maxcount)
102ce434:	e35a0000 	cmp	sl, #0
102ce438:	ba00000d 	blt	102ce474 <MQTTDeserialize_suback+0xdc>
  * @param grantedQoSs returned array of integers - the granted qualities of service
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)
102ce43c:	e2477004 	sub	r7, r7, #4
102ce440:	ea000001 	b	102ce44c <MQTTDeserialize_suback+0xb4>
	*packetid = readInt(&curdata);

	*count = 0;
	while (curdata < enddata)
	{
		if (*count > maxcount)
102ce444:	e15a0005 	cmp	sl, r5
102ce448:	ba000009 	blt	102ce474 <MQTTDeserialize_suback+0xdc>
		{
			rc = -1;
			goto exit;
		}
		grantedQoSs[(*count)++] = readChar(&curdata);
102ce44c:	e1a0000d 	mov	r0, sp
102ce450:	e12fff36 	blx	r6
		goto exit;

	*packetid = readInt(&curdata);

	*count = 0;
	while (curdata < enddata)
102ce454:	e59d3000 	ldr	r3, [sp]
		if (*count > maxcount)
		{
			rc = -1;
			goto exit;
		}
		grantedQoSs[(*count)++] = readChar(&curdata);
102ce458:	e2855001 	add	r5, r5, #1
		goto exit;

	*packetid = readInt(&curdata);

	*count = 0;
	while (curdata < enddata)
102ce45c:	e1590003 	cmp	r9, r3
		if (*count > maxcount)
		{
			rc = -1;
			goto exit;
		}
		grantedQoSs[(*count)++] = readChar(&curdata);
102ce460:	e5a70004 	str	r0, [r7, #4]!
102ce464:	e5885000 	str	r5, [r8]
		goto exit;

	*packetid = readInt(&curdata);

	*count = 0;
	while (curdata < enddata)
102ce468:	8afffff5 	bhi	102ce444 <MQTTDeserialize_suback+0xac>
			goto exit;
		}
		grantedQoSs[(*count)++] = readChar(&curdata);
	}

	rc = 1;
102ce46c:	e3a00001 	mov	r0, #1
102ce470:	eaffffd9 	b	102ce3dc <MQTTDeserialize_suback+0x44>
	*count = 0;
	while (curdata < enddata)
	{
		if (*count > maxcount)
		{
			rc = -1;
102ce474:	e3e00000 	mvn	r0, #0
102ce478:	eaffffd7 	b	102ce3dc <MQTTDeserialize_suback+0x44>
102ce47c:	102cdad0 	.word	0x102cdad0
102ce480:	102cda9c 	.word	0x102cda9c
102ce484:	102cdab4 	.word	0x102cdab4

102ce488 <GetLocalTime_UTC>:
 *
 * Return:
 *		s8 : Check status Fail or PASS.
 *****************************************************************/
s8 GetLocalTime_UTC(char* time_stamp_now, char* time_stamp_string_copy)
{
102ce488:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102ce48c:	e24dd034 	sub	sp, sp, #52	; 0x34
102ce490:	e1a07000 	mov	r7, r0
	ST_Time* return_loc_time;
	ST_Time recv_loc_time;

	u64 UTC_time =0;

	return_loc_time = Ql_GetLocalTime(&recv_loc_time);
102ce494:	e59f3084 	ldr	r3, [pc, #132]	; 102ce520 <GetLocalTime_UTC+0x98>
102ce498:	e28d0014 	add	r0, sp, #20
 *
 * Return:
 *		s8 : Check status Fail or PASS.
 *****************************************************************/
s8 GetLocalTime_UTC(char* time_stamp_now, char* time_stamp_string_copy)
{
102ce49c:	e1a06001 	mov	r6, r1
	ST_Time* return_loc_time;
	ST_Time recv_loc_time;

	u64 UTC_time =0;

	return_loc_time = Ql_GetLocalTime(&recv_loc_time);
102ce4a0:	e12fff33 	blx	r3
	if(return_loc_time == NULL)
102ce4a4:	e2504000 	subs	r4, r0, #0
102ce4a8:	0a00001a 	beq	102ce518 <GetLocalTime_UTC+0x90>
#ifdef DEBUG_MQTT
		APP_DEBUG("TIME READING FAIL\r\n");
#endif
		return -1;
	}
	UTC_time= Ql_Mktime(return_loc_time);
102ce4ac:	e59f3070 	ldr	r3, [pc, #112]	; 102ce524 <GetLocalTime_UTC+0x9c>
102ce4b0:	e12fff33 	blx	r3

#ifdef DEBUG_MQTT
	APP_DEBUG("\r\n<-- SUCCESS: GetLocalTime(%d.%02d.%02d %02d:%02d:%02d timezone=%02d) -->\n\r\n", return_loc_time->year, return_loc_time->month, return_loc_time->day, return_loc_time->hour, return_loc_time->minute, return_loc_time->second, return_loc_time->timezone);
#endif
	Ql_sprintf(time_stamp_now,"%d",UTC_time);
102ce4b4:	e59f506c 	ldr	r5, [pc, #108]	; 102ce528 <GetLocalTime_UTC+0xa0>
102ce4b8:	e595c000 	ldr	ip, [r5]
#ifdef DEBUG_MQTT
		APP_DEBUG("TIME READING FAIL\r\n");
#endif
		return -1;
	}
	UTC_time= Ql_Mktime(return_loc_time);
102ce4bc:	e1a02000 	mov	r2, r0
102ce4c0:	e1a03001 	mov	r3, r1

#ifdef DEBUG_MQTT
	APP_DEBUG("\r\n<-- SUCCESS: GetLocalTime(%d.%02d.%02d %02d:%02d:%02d timezone=%02d) -->\n\r\n", return_loc_time->year, return_loc_time->month, return_loc_time->day, return_loc_time->hour, return_loc_time->minute, return_loc_time->second, return_loc_time->timezone);
#endif
	Ql_sprintf(time_stamp_now,"%d",UTC_time);
102ce4c4:	e1a00007 	mov	r0, r7
102ce4c8:	e59f105c 	ldr	r1, [pc, #92]	; 102ce52c <GetLocalTime_UTC+0xa4>
102ce4cc:	e12fff3c 	blx	ip
	Ql_sprintf(time_stamp_string_copy,"%04d-%02d-%02d %02d:%02d:%02d",return_loc_time->year, return_loc_time->month, return_loc_time->day, return_loc_time->hour, return_loc_time->minute,return_loc_time->second);
102ce4d0:	e5941008 	ldr	r1, [r4, #8]
102ce4d4:	e894000c 	ldm	r4, {r2, r3}
102ce4d8:	e58d1000 	str	r1, [sp]
102ce4dc:	e594100c 	ldr	r1, [r4, #12]
102ce4e0:	e58d1004 	str	r1, [sp, #4]
102ce4e4:	e5941010 	ldr	r1, [r4, #16]
102ce4e8:	e58d1008 	str	r1, [sp, #8]
102ce4ec:	e5941014 	ldr	r1, [r4, #20]
102ce4f0:	e58d100c 	str	r1, [sp, #12]
102ce4f4:	e595c000 	ldr	ip, [r5]
102ce4f8:	e1a00006 	mov	r0, r6
102ce4fc:	e59f102c 	ldr	r1, [pc, #44]	; 102ce530 <GetLocalTime_UTC+0xa8>
102ce500:	e12fff3c 	blx	ip
	return 0;
102ce504:	e3a00000 	mov	r0, #0
102ce508:	e1a00c00 	lsl	r0, r0, #24
}
102ce50c:	e1a00c40 	asr	r0, r0, #24
102ce510:	e28dd034 	add	sp, sp, #52	; 0x34
102ce514:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	if(return_loc_time == NULL)
	{
#ifdef DEBUG_MQTT
		APP_DEBUG("TIME READING FAIL\r\n");
#endif
		return -1;
102ce518:	e3a000ff 	mov	r0, #255	; 0xff
102ce51c:	eafffff9 	b	102ce508 <GetLocalTime_UTC+0x80>
102ce520:	102e5f4c 	.word	0x102e5f4c
102ce524:	102e5fa0 	.word	0x102e5fa0
102ce528:	f03de540 	.word	0xf03de540
102ce52c:	102edef4 	.word	0x102edef4
102ce530:	102ee960 	.word	0x102ee960

102ce534 <MQTT_Send_CONN_DISCONN_Request>:
 *
 * Return:
 *
 *****************************************************************/
s32 MQTT_Send_CONN_DISCONN_Request(u8 ssid, u8 action)
{
102ce534:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102ce538:	e24dd058 	sub	sp, sp, #88	; 0x58
	//s32 ret;
	s32 len = 0;

	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;
102ce53c:	e3a02058 	mov	r2, #88	; 0x58
 *
 * Return:
 *
 *****************************************************************/
s32 MQTT_Send_CONN_DISCONN_Request(u8 ssid, u8 action)
{
102ce540:	e1a07000 	mov	r7, r0
	//s32 ret;
	s32 len = 0;

	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;
102ce544:	e59f30d8 	ldr	r3, [pc, #216]	; 102ce624 <MQTT_Send_CONN_DISCONN_Request+0xf0>
 *
 * Return:
 *
 *****************************************************************/
s32 MQTT_Send_CONN_DISCONN_Request(u8 ssid, u8 action)
{
102ce548:	e1a08001 	mov	r8, r1
	//s32 ret;
	s32 len = 0;

	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;
102ce54c:	e1a0000d 	mov	r0, sp
102ce550:	e59f10d0 	ldr	r1, [pc, #208]	; 102ce628 <MQTT_Send_CONN_DISCONN_Request+0xf4>
102ce554:	e12fff33 	blx	r3

	char *buf_ssl_send_data = (char *)Ql_MEM_Alloc(SSL_SOC_MAX_DATA_LENGTH);
102ce558:	e59f30cc 	ldr	r3, [pc, #204]	; 102ce62c <MQTT_Send_CONN_DISCONN_Request+0xf8>
102ce55c:	e59f00cc 	ldr	r0, [pc, #204]	; 102ce630 <MQTT_Send_CONN_DISCONN_Request+0xfc>
102ce560:	e12fff33 	blx	r3

	Refresh_Communication_inprogress_Symbol(colAqua);

	g_len_send_data = 0;
102ce564:	e3a05000 	mov	r5, #0

	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;

	char *buf_ssl_send_data = (char *)Ql_MEM_Alloc(SSL_SOC_MAX_DATA_LENGTH);

	Refresh_Communication_inprogress_Symbol(colAqua);
102ce568:	e59f30c4 	ldr	r3, [pc, #196]	; 102ce634 <MQTT_Send_CONN_DISCONN_Request+0x100>

	g_len_send_data = 0;
102ce56c:	e59f60c4 	ldr	r6, [pc, #196]	; 102ce638 <MQTT_Send_CONN_DISCONN_Request+0x104>
	//s32 ret;
	s32 len = 0;

	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;

	char *buf_ssl_send_data = (char *)Ql_MEM_Alloc(SSL_SOC_MAX_DATA_LENGTH);
102ce570:	e1a04000 	mov	r4, r0

	Refresh_Communication_inprogress_Symbol(colAqua);
102ce574:	e59f00c0 	ldr	r0, [pc, #192]	; 102ce63c <MQTT_Send_CONN_DISCONN_Request+0x108>
102ce578:	e12fff33 	blx	r3

	g_len_send_data = 0;
	Ql_memset(buf_ssl_send_data, 0x0, sizeof(buf_ssl_send_data));
102ce57c:	e59f30bc 	ldr	r3, [pc, #188]	; 102ce640 <MQTT_Send_CONN_DISCONN_Request+0x10c>
102ce580:	e1a00004 	mov	r0, r4
102ce584:	e1a01005 	mov	r1, r5
102ce588:	e3a02004 	mov	r2, #4

	char *buf_ssl_send_data = (char *)Ql_MEM_Alloc(SSL_SOC_MAX_DATA_LENGTH);

	Refresh_Communication_inprogress_Symbol(colAqua);

	g_len_send_data = 0;
102ce58c:	e5865000 	str	r5, [r6]
	Ql_memset(buf_ssl_send_data, 0x0, sizeof(buf_ssl_send_data));
102ce590:	e12fff33 	blx	r3

	data.keepAliveInterval = 0;
	data.cleansession = 1;
102ce594:	e3a03001 	mov	r3, #1

	switch(ssid)
102ce598:	e1570005 	cmp	r7, r5
	Refresh_Communication_inprogress_Symbol(colAqua);

	g_len_send_data = 0;
	Ql_memset(buf_ssl_send_data, 0x0, sizeof(buf_ssl_send_data));

	data.keepAliveInterval = 0;
102ce59c:	e1cd51b8 	strh	r5, [sp, #24]
	data.cleansession = 1;
102ce5a0:	e5cd301a 	strb	r3, [sp, #26]

	switch(ssid)
102ce5a4:	1a000006 	bne	102ce5c4 <MQTT_Send_CONN_DISCONN_Request+0x90>
	{
	case SSID_HOST_AZURE:
		data.will.qos = 1;
		data.clientID.cstring = DEVICE_CLIENT_ID;
102ce5a8:	e2861004 	add	r1, r6, #4
		data.username.cstring = DEVICE_USER_ID;
102ce5ac:	e2862020 	add	r2, r6, #32
		data.password.cstring = DEVICE_SAS_TOKEN;
102ce5b0:	e2866084 	add	r6, r6, #132	; 0x84
	data.cleansession = 1;

	switch(ssid)
	{
	case SSID_HOST_AZURE:
		data.will.qos = 1;
102ce5b4:	e5cd303d 	strb	r3, [sp, #61]	; 0x3d
		data.clientID.cstring = DEVICE_CLIENT_ID;
102ce5b8:	e58d100c 	str	r1, [sp, #12]
		data.username.cstring = DEVICE_USER_ID;
102ce5bc:	e58d2040 	str	r2, [sp, #64]	; 0x40
		data.password.cstring = DEVICE_SAS_TOKEN;
102ce5c0:	e58d604c 	str	r6, [sp, #76]	; 0x4c
		break;
	}
	if(action == MQTT_ON)
102ce5c4:	e3580001 	cmp	r8, #1
	{
		len = MQTTSerialize_connect((unsigned char *)buf_ssl_send_data, buflen, &data);
102ce5c8:	e1a00004 	mov	r0, r4
		data.clientID.cstring = DEVICE_CLIENT_ID;
		data.username.cstring = DEVICE_USER_ID;
		data.password.cstring = DEVICE_SAS_TOKEN;
		break;
	}
	if(action == MQTT_ON)
102ce5cc:	0a00000d 	beq	102ce608 <MQTT_Send_CONN_DISCONN_Request+0xd4>
	{
		len = MQTTSerialize_connect((unsigned char *)buf_ssl_send_data, buflen, &data);
	}
	else
	{
		len = MQTTSerialize_disconnect((unsigned char*) buf_ssl_send_data, 0);
102ce5d0:	e3a01000 	mov	r1, #0
102ce5d4:	e59f3068 	ldr	r3, [pc, #104]	; 102ce644 <MQTT_Send_CONN_DISCONN_Request+0x110>
102ce5d8:	e12fff33 	blx	r3
102ce5dc:	e1a02000 	mov	r2, r0
	}

	RIL_SSL_QSSLSEND(ssid,(u8 *)buf_ssl_send_data,len);
102ce5e0:	e1a01004 	mov	r1, r4
102ce5e4:	e1a00007 	mov	r0, r7
102ce5e8:	e59f3058 	ldr	r3, [pc, #88]	; 102ce648 <MQTT_Send_CONN_DISCONN_Request+0x114>
102ce5ec:	e12fff33 	blx	r3

	Ql_MEM_Free(buf_ssl_send_data);
102ce5f0:	e1a00004 	mov	r0, r4
102ce5f4:	e59f3050 	ldr	r3, [pc, #80]	; 102ce64c <MQTT_Send_CONN_DISCONN_Request+0x118>
102ce5f8:	e12fff33 	blx	r3
	buf_ssl_send_data = NULL;

	return 0;
}
102ce5fc:	e3a00000 	mov	r0, #0
102ce600:	e28dd058 	add	sp, sp, #88	; 0x58
102ce604:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		data.password.cstring = DEVICE_SAS_TOKEN;
		break;
	}
	if(action == MQTT_ON)
	{
		len = MQTTSerialize_connect((unsigned char *)buf_ssl_send_data, buflen, &data);
102ce608:	e59f3040 	ldr	r3, [pc, #64]	; 102ce650 <MQTT_Send_CONN_DISCONN_Request+0x11c>
102ce60c:	e1a0200d 	mov	r2, sp
102ce610:	e5931000 	ldr	r1, [r3]
102ce614:	e59f3038 	ldr	r3, [pc, #56]	; 102ce654 <MQTT_Send_CONN_DISCONN_Request+0x120>
102ce618:	e12fff33 	blx	r3
102ce61c:	e1a02000 	mov	r2, r0
102ce620:	eaffffee 	b	102ce5e0 <MQTT_Send_CONN_DISCONN_Request+0xac>
102ce624:	102df8c9 	.word	0x102df8c9
102ce628:	102e6f7c 	.word	0x102e6f7c
102ce62c:	102e4840 	.word	0x102e4840
102ce630:	000005b4 	.word	0x000005b4
102ce634:	102d9bf4 	.word	0x102d9bf4
102ce638:	f03d572c 	.word	0xf03d572c
102ce63c:	000007ff 	.word	0x000007ff
102ce640:	102e58f4 	.word	0x102e58f4
102ce644:	102cd79c 	.word	0x102cd79c
102ce648:	102dc47c 	.word	0x102dc47c
102ce64c:	102e48b8 	.word	0x102e48b8
102ce650:	f03d203c 	.word	0xf03d203c
102ce654:	102cd47c 	.word	0x102cd47c

102ce658 <MQTT_Send_SUB_Request>:
 *		u8 param_subtopic : Number which topic is to be subscribe.
 * Return	 Status
 *
 *****************************************************************/
s32 MQTT_Send_SUB_Request(u8 ssid, u8 param_subtopic)
{
102ce658:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	s32 msgid = 1;
	s32 req_qos = 0;
102ce65c:	e3a04000 	mov	r4, #0
 *		u8 param_subtopic : Number which topic is to be subscribe.
 * Return	 Status
 *
 *****************************************************************/
s32 MQTT_Send_SUB_Request(u8 ssid, u8 param_subtopic)
{
102ce660:	e24dd088 	sub	sp, sp, #136	; 0x88
	s32 msgid = 1;
	s32 req_qos = 0;
	s32 len = 0;

	char topic_subscibe[100]= {0};
102ce664:	e59f3190 	ldr	r3, [pc, #400]	; 102ce7fc <MQTT_Send_SUB_Request+0x1a4>
 *		u8 param_subtopic : Number which topic is to be subscribe.
 * Return	 Status
 *
 *****************************************************************/
s32 MQTT_Send_SUB_Request(u8 ssid, u8 param_subtopic)
{
102ce668:	e1a07001 	mov	r7, r1
	s32 msgid = 1;
	s32 req_qos = 0;
	s32 len = 0;

	char topic_subscibe[100]= {0};
102ce66c:	e3a02064 	mov	r2, #100	; 0x64
102ce670:	e1a01004 	mov	r1, r4
 *		u8 param_subtopic : Number which topic is to be subscribe.
 * Return	 Status
 *
 *****************************************************************/
s32 MQTT_Send_SUB_Request(u8 ssid, u8 param_subtopic)
{
102ce674:	e1a08000 	mov	r8, r0
	s32 msgid = 1;
	s32 req_qos = 0;
	s32 len = 0;

	char topic_subscibe[100]= {0};
102ce678:	e28d0024 	add	r0, sp, #36	; 0x24
	Ql_memset(topic_subscibe, 0x0, sizeof(topic_subscibe));
102ce67c:	e59f617c 	ldr	r6, [pc, #380]	; 102ce800 <MQTT_Send_SUB_Request+0x1a8>
 *
 *****************************************************************/
s32 MQTT_Send_SUB_Request(u8 ssid, u8 param_subtopic)
{
	s32 msgid = 1;
	s32 req_qos = 0;
102ce680:	e58d4014 	str	r4, [sp, #20]
	s32 len = 0;

	char topic_subscibe[100]= {0};
102ce684:	e12fff33 	blx	r3
	Ql_memset(topic_subscibe, 0x0, sizeof(topic_subscibe));
102ce688:	e1a01004 	mov	r1, r4
102ce68c:	e3a02064 	mov	r2, #100	; 0x64
102ce690:	e28d0024 	add	r0, sp, #36	; 0x24
102ce694:	e12fff36 	blx	r6

	MQTTString topicString = MQTTString_initializer;
	char *buf_ssl_send_data = (char *)Ql_MEM_Alloc(SSL_SOC_MAX_DATA_LENGTH);
102ce698:	e59f3164 	ldr	r3, [pc, #356]	; 102ce804 <MQTT_Send_SUB_Request+0x1ac>
102ce69c:	e59f0164 	ldr	r0, [pc, #356]	; 102ce808 <MQTT_Send_SUB_Request+0x1b0>
	s32 len = 0;

	char topic_subscibe[100]= {0};
	Ql_memset(topic_subscibe, 0x0, sizeof(topic_subscibe));

	MQTTString topicString = MQTTString_initializer;
102ce6a0:	e58d4018 	str	r4, [sp, #24]
102ce6a4:	e58d401c 	str	r4, [sp, #28]
102ce6a8:	e58d4020 	str	r4, [sp, #32]
	char *buf_ssl_send_data = (char *)Ql_MEM_Alloc(SSL_SOC_MAX_DATA_LENGTH);
102ce6ac:	e12fff33 	blx	r3
	Ql_memset(buf_ssl_send_data, 0x0, sizeof(buf_ssl_send_data));
102ce6b0:	e1a01004 	mov	r1, r4
102ce6b4:	e3a02004 	mov	r2, #4

	char topic_subscibe[100]= {0};
	Ql_memset(topic_subscibe, 0x0, sizeof(topic_subscibe));

	MQTTString topicString = MQTTString_initializer;
	char *buf_ssl_send_data = (char *)Ql_MEM_Alloc(SSL_SOC_MAX_DATA_LENGTH);
102ce6b8:	e1a05000 	mov	r5, r0
	Ql_memset(buf_ssl_send_data, 0x0, sizeof(buf_ssl_send_data));
102ce6bc:	e12fff36 	blx	r6


	switch(param_subtopic)
102ce6c0:	e3570001 	cmp	r7, #1
102ce6c4:	0a00003d 	beq	102ce7c0 <MQTT_Send_SUB_Request+0x168>
102ce6c8:	3a000027 	bcc	102ce76c <MQTT_Send_SUB_Request+0x114>
102ce6cc:	e3570002 	cmp	r7, #2
102ce6d0:	13a03001 	movne	r3, #1
102ce6d4:	1a00000d 	bne	102ce710 <MQTT_Send_SUB_Request+0xb8>
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_ON_SYMBOL);
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
		msgid = 1;
		break;
	case SUB_DEVICE_TWIN_DESIRED_TOPIC: // Subscribe for Device twin desired parameter change notification
		Ql_sprintf(topic_subscibe,"$iothub/twin/PATCH/properties/desired/#");
102ce6d8:	e59f312c 	ldr	r3, [pc, #300]	; 102ce80c <MQTT_Send_SUB_Request+0x1b4>
102ce6dc:	e59f112c 	ldr	r1, [pc, #300]	; 102ce810 <MQTT_Send_SUB_Request+0x1b8>
102ce6e0:	e5933000 	ldr	r3, [r3]
102ce6e4:	e28d0024 	add	r0, sp, #36	; 0x24
102ce6e8:	e12fff33 	blx	r3
		topicString.cstring = topic_subscibe;
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
102ce6ec:	e3a00003 	mov	r0, #3
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
		msgid = 1;
		break;
	case SUB_DEVICE_TWIN_DESIRED_TOPIC: // Subscribe for Device twin desired parameter change notification
		Ql_sprintf(topic_subscibe,"$iothub/twin/PATCH/properties/desired/#");
		topicString.cstring = topic_subscibe;
102ce6f0:	e28dc024 	add	ip, sp, #36	; 0x24
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
102ce6f4:	e1a03000 	mov	r3, r0
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
		msgid = 1;
		break;
	case SUB_DEVICE_TWIN_DESIRED_TOPIC: // Subscribe for Device twin desired parameter change notification
		Ql_sprintf(topic_subscibe,"$iothub/twin/PATCH/properties/desired/#");
		topicString.cstring = topic_subscibe;
102ce6f8:	e58dc018 	str	ip, [sp, #24]
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
102ce6fc:	e59f1110 	ldr	r1, [pc, #272]	; 102ce814 <MQTT_Send_SUB_Request+0x1bc>
102ce700:	e1a02007 	mov	r2, r7
102ce704:	e59fc10c 	ldr	ip, [pc, #268]	; 102ce818 <MQTT_Send_SUB_Request+0x1c0>
102ce708:	e12fff3c 	blx	ip
		msgid = 2;
		break;
102ce70c:	e1a03007 	mov	r3, r7
		break;
	}
#ifdef DEBUG_MQTT
	APP_DEBUG("\r\n<-- SUBSCRIBED TOPIC : %s-->\r\n", topic_subscibe);
#endif
	len = MQTTSerialize_subscribe((unsigned char *)buf_ssl_send_data, buflen, 0, msgid, 1, &topicString, &req_qos);
102ce710:	e59f2104 	ldr	r2, [pc, #260]	; 102ce81c <MQTT_Send_SUB_Request+0x1c4>
102ce714:	e59fc104 	ldr	ip, [pc, #260]	; 102ce820 <MQTT_Send_SUB_Request+0x1c8>
102ce718:	e5921000 	ldr	r1, [r2]
102ce71c:	e3a02001 	mov	r2, #1
102ce720:	e58d2000 	str	r2, [sp]
102ce724:	e28d2018 	add	r2, sp, #24
102ce728:	e58d2004 	str	r2, [sp, #4]
102ce72c:	e28d2014 	add	r2, sp, #20
102ce730:	e58d2008 	str	r2, [sp, #8]
102ce734:	e1a00005 	mov	r0, r5
102ce738:	e3a02000 	mov	r2, #0
102ce73c:	e12fff3c 	blx	ip

	RIL_SSL_QSSLSEND(ssid,(u8 *)buf_ssl_send_data,len);
102ce740:	e1a01005 	mov	r1, r5
102ce744:	e59f30d8 	ldr	r3, [pc, #216]	; 102ce824 <MQTT_Send_SUB_Request+0x1cc>
		break;
	}
#ifdef DEBUG_MQTT
	APP_DEBUG("\r\n<-- SUBSCRIBED TOPIC : %s-->\r\n", topic_subscibe);
#endif
	len = MQTTSerialize_subscribe((unsigned char *)buf_ssl_send_data, buflen, 0, msgid, 1, &topicString, &req_qos);
102ce748:	e1a02000 	mov	r2, r0

	RIL_SSL_QSSLSEND(ssid,(u8 *)buf_ssl_send_data,len);
102ce74c:	e1a00008 	mov	r0, r8
102ce750:	e12fff33 	blx	r3
	Ql_MEM_Free(buf_ssl_send_data);
102ce754:	e1a00005 	mov	r0, r5
102ce758:	e59f30c8 	ldr	r3, [pc, #200]	; 102ce828 <MQTT_Send_SUB_Request+0x1d0>
102ce75c:	e12fff33 	blx	r3
	buf_ssl_send_data = NULL;
	return 0;
}
102ce760:	e3a00000 	mov	r0, #0
102ce764:	e28dd088 	add	sp, sp, #136	; 0x88
102ce768:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}


	switch(param_subtopic)
	{
	case SUB_IOTHUB_TOPIC_ALL: // Subscribe for all messages from IoT Hub for devices
		Ql_sprintf(topic_subscibe,"devices/%s/messages/devicebound/#",DEVICE_CLIENT_ID);
102ce76c:	e59f3098 	ldr	r3, [pc, #152]	; 102ce80c <MQTT_Send_SUB_Request+0x1b4>
102ce770:	e59f10b4 	ldr	r1, [pc, #180]	; 102ce82c <MQTT_Send_SUB_Request+0x1d4>
102ce774:	e59f20b4 	ldr	r2, [pc, #180]	; 102ce830 <MQTT_Send_SUB_Request+0x1d8>
102ce778:	e5933000 	ldr	r3, [r3]
102ce77c:	e28d0024 	add	r0, sp, #36	; 0x24
102ce780:	e12fff33 	blx	r3
		topicString.cstring = topic_subscibe;
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_ON_SYMBOL);
102ce784:	e59f408c 	ldr	r4, [pc, #140]	; 102ce818 <MQTT_Send_SUB_Request+0x1c0>

	switch(param_subtopic)
	{
	case SUB_IOTHUB_TOPIC_ALL: // Subscribe for all messages from IoT Hub for devices
		Ql_sprintf(topic_subscibe,"devices/%s/messages/devicebound/#",DEVICE_CLIENT_ID);
		topicString.cstring = topic_subscibe;
102ce788:	e28dc024 	add	ip, sp, #36	; 0x24
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_ON_SYMBOL);
102ce78c:	e59f1080 	ldr	r1, [pc, #128]	; 102ce814 <MQTT_Send_SUB_Request+0x1bc>
102ce790:	e3a02002 	mov	r2, #2
102ce794:	e3a03001 	mov	r3, #1
102ce798:	e3a00003 	mov	r0, #3

	switch(param_subtopic)
	{
	case SUB_IOTHUB_TOPIC_ALL: // Subscribe for all messages from IoT Hub for devices
		Ql_sprintf(topic_subscibe,"devices/%s/messages/devicebound/#",DEVICE_CLIENT_ID);
		topicString.cstring = topic_subscibe;
102ce79c:	e58dc018 	str	ip, [sp, #24]
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_ON_SYMBOL);
102ce7a0:	e12fff34 	blx	r4
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
102ce7a4:	e3a00003 	mov	r0, #3
102ce7a8:	e1a03000 	mov	r3, r0
102ce7ac:	e59f1060 	ldr	r1, [pc, #96]	; 102ce814 <MQTT_Send_SUB_Request+0x1bc>
102ce7b0:	e3a02002 	mov	r2, #2
102ce7b4:	e12fff34 	blx	r4
		msgid = 1;
		break;
102ce7b8:	e3a03001 	mov	r3, #1
102ce7bc:	eaffffd3 	b	102ce710 <MQTT_Send_SUB_Request+0xb8>
		topicString.cstring = topic_subscibe;
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
		msgid = 2;
		break;
	case SUB_DEVICETWIN_TOPIC: // Subscribe for device twin topic
		Ql_sprintf(topic_subscibe,"$iothub/twin/res/#");
102ce7c0:	e59f3044 	ldr	r3, [pc, #68]	; 102ce80c <MQTT_Send_SUB_Request+0x1b4>
102ce7c4:	e59f1068 	ldr	r1, [pc, #104]	; 102ce834 <MQTT_Send_SUB_Request+0x1dc>
102ce7c8:	e5933000 	ldr	r3, [r3]
102ce7cc:	e28d0024 	add	r0, sp, #36	; 0x24
102ce7d0:	e12fff33 	blx	r3
		topicString.cstring = topic_subscibe;
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
102ce7d4:	e3a00003 	mov	r0, #3
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
		msgid = 2;
		break;
	case SUB_DEVICETWIN_TOPIC: // Subscribe for device twin topic
		Ql_sprintf(topic_subscibe,"$iothub/twin/res/#");
		topicString.cstring = topic_subscibe;
102ce7d8:	e28dc024 	add	ip, sp, #36	; 0x24
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
102ce7dc:	e1a03000 	mov	r3, r0
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
		msgid = 2;
		break;
	case SUB_DEVICETWIN_TOPIC: // Subscribe for device twin topic
		Ql_sprintf(topic_subscibe,"$iothub/twin/res/#");
		topicString.cstring = topic_subscibe;
102ce7e0:	e58dc018 	str	ip, [sp, #24]
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
102ce7e4:	e59f1028 	ldr	r1, [pc, #40]	; 102ce814 <MQTT_Send_SUB_Request+0x1bc>
102ce7e8:	e3a02002 	mov	r2, #2
102ce7ec:	e59fc024 	ldr	ip, [pc, #36]	; 102ce818 <MQTT_Send_SUB_Request+0x1c0>
102ce7f0:	e12fff3c 	blx	ip
		msgid = 3;
		break;
102ce7f4:	e3a03003 	mov	r3, #3
102ce7f8:	eaffffc4 	b	102ce710 <MQTT_Send_SUB_Request+0xb8>
102ce7fc:	102df9d5 	.word	0x102df9d5
102ce800:	102e58f4 	.word	0x102e58f4
102ce804:	102e4840 	.word	0x102e4840
102ce808:	000005b4 	.word	0x000005b4
102ce80c:	f03de540 	.word	0xf03de540
102ce810:	102ee9a4 	.word	0x102ee9a4
102ce814:	000010c8 	.word	0x000010c8
102ce818:	102e5cb4 	.word	0x102e5cb4
102ce81c:	f03d203c 	.word	0xf03d203c
102ce820:	102ce298 	.word	0x102ce298
102ce824:	102dc47c 	.word	0x102dc47c
102ce828:	102e48b8 	.word	0x102e48b8
102ce82c:	102ee980 	.word	0x102ee980
102ce830:	f03d5730 	.word	0xf03d5730
102ce834:	102ee9cc 	.word	0x102ee9cc

102ce838 <MQTT_Send_Publish>:
 *
 * Return:
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
102ce838:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	bool LOG_MESSAGES_AVAILABLE = FALSE;
	s32  filehandleData = -1;
	unsigned char invalid_payload = 0,valid_payload=0;
	s32 ret=PASS,i=0;
	char msg_id[18];
	char string_temp[10] = {0};
102ce83c:	e3a07000 	mov	r7, #0
 *
 * Return:
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
102ce840:	e24dd0c4 	sub	sp, sp, #196	; 0xc4
	s32 rc = 0;
	char *Topic_String = NULL;
	cJSON *json_root = NULL;
	cJSON *value = NULL;

	char topic_subscibe[100]= {0};
102ce844:	e59f3e68 	ldr	r3, [pc, #3688]	; 102cf6b4 <MQTT_Send_Publish+0xe7c>
 *
 * Return:
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
102ce848:	e1a0b001 	mov	fp, r1
	s32 rc = 0;
	char *Topic_String = NULL;
	cJSON *json_root = NULL;
	cJSON *value = NULL;

	char topic_subscibe[100]= {0};
102ce84c:	e3a02064 	mov	r2, #100	; 0x64
	Ql_memset(topic_subscibe, 0x0, sizeof(topic_subscibe));

	//Initiate the topic for messages from Device to cloud
	Ql_sprintf(topic_subscibe,"devices/%s/messages/events/Topic=",DEVICE_CLIENT_ID);
102ce850:	e59f4f34 	ldr	r4, [pc, #3892]	; 102cf78c <MQTT_Send_Publish+0xf54>
 *
 * Return:
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
102ce854:	e58d0038 	str	r0, [sp, #56]	; 0x38
	s32 rc = 0;
	char *Topic_String = NULL;
	cJSON *json_root = NULL;
	cJSON *value = NULL;

	char topic_subscibe[100]= {0};
102ce858:	e1a01007 	mov	r1, r7
102ce85c:	e28d005c 	add	r0, sp, #92	; 0x5c
	Ql_memset(topic_subscibe, 0x0, sizeof(topic_subscibe));
102ce860:	e59f6f28 	ldr	r6, [pc, #3880]	; 102cf790 <MQTT_Send_Publish+0xf58>
	bool LOG_MESSAGES_AVAILABLE = FALSE;
	s32  filehandleData = -1;
	unsigned char invalid_payload = 0,valid_payload=0;
	s32 ret=PASS,i=0;
	char msg_id[18];
	char string_temp[10] = {0};
102ce864:	e58d7044 	str	r7, [sp, #68]	; 0x44
102ce868:	e58d7048 	str	r7, [sp, #72]	; 0x48
102ce86c:	e1cd74bc 	strh	r7, [sp, #76]	; 0x4c
	s32 rc = 0;
	char *Topic_String = NULL;
	cJSON *json_root = NULL;
	cJSON *value = NULL;

	char topic_subscibe[100]= {0};
102ce870:	e12fff33 	blx	r3
	Ql_memset(topic_subscibe, 0x0, sizeof(topic_subscibe));
102ce874:	e1a01007 	mov	r1, r7
102ce878:	e3a02064 	mov	r2, #100	; 0x64
102ce87c:	e28d005c 	add	r0, sp, #92	; 0x5c
102ce880:	e12fff36 	blx	r6

	//Initiate the topic for messages from Device to cloud
	Ql_sprintf(topic_subscibe,"devices/%s/messages/events/Topic=",DEVICE_CLIENT_ID);
102ce884:	e5943000 	ldr	r3, [r4]
102ce888:	e59f2e28 	ldr	r2, [pc, #3624]	; 102cf6b8 <MQTT_Send_Publish+0xe80>
102ce88c:	e59f1e28 	ldr	r1, [pc, #3624]	; 102cf6bc <MQTT_Send_Publish+0xe84>
102ce890:	e28d005c 	add	r0, sp, #92	; 0x5c
102ce894:	e12fff33 	blx	r3

	//get Time stamp in UTC

	GetLocalTime_UTC(time_stamp, local_time);
102ce898:	e59f0e20 	ldr	r0, [pc, #3616]	; 102cf6c0 <MQTT_Send_Publish+0xe88>
		msg_id[i] = IMEI[i-1];
	}
	msg_id[17] = '\0';

#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--****");
102ce89c:	e59f5ee4 	ldr	r5, [pc, #3812]	; 102cf788 <MQTT_Send_Publish+0xf50>
	//Initiate the topic for messages from Device to cloud
	Ql_sprintf(topic_subscibe,"devices/%s/messages/events/Topic=",DEVICE_CLIENT_ID);

	//get Time stamp in UTC

	GetLocalTime_UTC(time_stamp, local_time);
102ce8a0:	e2801014 	add	r1, r0, #20
102ce8a4:	ebfffef7 	bl	102ce488 <GetLocalTime_UTC>
		msg_id[i] = IMEI[i-1];
	}
	msg_id[17] = '\0';

#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--****");
102ce8a8:	e3a02c02 	mov	r2, #512	; 0x200
102ce8ac:	e1a01007 	mov	r1, r7
102ce8b0:	e59f0eec 	ldr	r0, [pc, #3820]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
	int payloadlen ;
	int len = 0;
	int buflen=0;
	char *buf_ssl = NULL;

	MQTTString topicString = MQTTString_initializer;
102ce8b4:	e58d7050 	str	r7, [sp, #80]	; 0x50
102ce8b8:	e58d7054 	str	r7, [sp, #84]	; 0x54
102ce8bc:	e58d7058 	str	r7, [sp, #88]	; 0x58
		msg_id[i] = IMEI[i-1];
	}
	msg_id[17] = '\0';

#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--****");
102ce8c0:	e12fff36 	blx	r6
102ce8c4:	e59f1df8 	ldr	r1, [pc, #3576]	; 102cf6c4 <MQTT_Send_Publish+0xe8c>
102ce8c8:	e5943000 	ldr	r3, [r4]
102ce8cc:	e59f0ed0 	ldr	r0, [pc, #3792]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ce8d0:	e12fff33 	blx	r3
102ce8d4:	e59f0ec8 	ldr	r0, [pc, #3784]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ce8d8:	e12fff35 	blx	r5
102ce8dc:	e59f3f98 	ldr	r3, [pc, #3992]	; 102cf87c <MQTT_Send_Publish+0x1044>
102ce8e0:	e59f1ebc 	ldr	r1, [pc, #3772]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ce8e4:	e1a02000 	mov	r2, r0
102ce8e8:	e3a0000a 	mov	r0, #10
102ce8ec:	e12fff33 	blx	r3
#endif
	switch(MSG_TYPE)
102ce8f0:	e24b3001 	sub	r3, fp, #1
102ce8f4:	e3530040 	cmp	r3, #64	; 0x40
102ce8f8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
102ce8fc:	ea00009e 	b	102ceb7c <MQTT_Send_Publish+0x344>
102ce900:	102cec54 	.word	0x102cec54
102ce904:	102ced4c 	.word	0x102ced4c
102ce908:	102ced4c 	.word	0x102ced4c
102ce90c:	102cee50 	.word	0x102cee50
102ce910:	102cee50 	.word	0x102cee50
102ce914:	102cee50 	.word	0x102cee50
102ce918:	102cee50 	.word	0x102cee50
102ce91c:	102cef64 	.word	0x102cef64
102ce920:	102cef64 	.word	0x102cef64
102ce924:	102cef64 	.word	0x102cef64
102ce928:	102cef64 	.word	0x102cef64
102ce92c:	102cf0e0 	.word	0x102cf0e0
102ce930:	102cf194 	.word	0x102cf194
102ce934:	102cf248 	.word	0x102cf248
102ce938:	102cf8ec 	.word	0x102cf8ec
102ce93c:	102cf3c4 	.word	0x102cf3c4
102ce940:	102cf3c4 	.word	0x102cf3c4
102ce944:	102cef64 	.word	0x102cef64
102ce948:	102cfbe0 	.word	0x102cfbe0
102ce94c:	102cf314 	.word	0x102cf314
102ce950:	102cfc4c 	.word	0x102cfc4c
102ce954:	102cfc4c 	.word	0x102cfc4c
102ce958:	102cfc4c 	.word	0x102cfc4c
102ce95c:	102cf4ec 	.word	0x102cf4ec
102ce960:	102ceb7c 	.word	0x102ceb7c
102ce964:	102ceb7c 	.word	0x102ceb7c
102ce968:	102ceb7c 	.word	0x102ceb7c
102ce96c:	102ceb7c 	.word	0x102ceb7c
102ce970:	102ceb7c 	.word	0x102ceb7c
102ce974:	102ceb7c 	.word	0x102ceb7c
102ce978:	102ceb7c 	.word	0x102ceb7c
102ce97c:	102ceb7c 	.word	0x102ceb7c
102ce980:	102ceb7c 	.word	0x102ceb7c
102ce984:	102ceb7c 	.word	0x102ceb7c
102ce988:	102ceb7c 	.word	0x102ceb7c
102ce98c:	102ceb7c 	.word	0x102ceb7c
102ce990:	102ceb7c 	.word	0x102ceb7c
102ce994:	102ceb7c 	.word	0x102ceb7c
102ce998:	102ceb7c 	.word	0x102ceb7c
102ce99c:	102ceb7c 	.word	0x102ceb7c
102ce9a0:	102ceb7c 	.word	0x102ceb7c
102ce9a4:	102ceb7c 	.word	0x102ceb7c
102ce9a8:	102ceb7c 	.word	0x102ceb7c
102ce9ac:	102ceb7c 	.word	0x102ceb7c
102ce9b0:	102ceb7c 	.word	0x102ceb7c
102ce9b4:	102ceb7c 	.word	0x102ceb7c
102ce9b8:	102ceb7c 	.word	0x102ceb7c
102ce9bc:	102ceb7c 	.word	0x102ceb7c
102ce9c0:	102ceb7c 	.word	0x102ceb7c
102ce9c4:	102ceb7c 	.word	0x102ceb7c
102ce9c8:	102ceb7c 	.word	0x102ceb7c
102ce9cc:	102ceb7c 	.word	0x102ceb7c
102ce9d0:	102ceb7c 	.word	0x102ceb7c
102ce9d4:	102ceb7c 	.word	0x102ceb7c
102ce9d8:	102ceb7c 	.word	0x102ceb7c
102ce9dc:	102ceb7c 	.word	0x102ceb7c
102ce9e0:	102ceb7c 	.word	0x102ceb7c
102ce9e4:	102ceb7c 	.word	0x102ceb7c
102ce9e8:	102ceb7c 	.word	0x102ceb7c
102ce9ec:	102ceb7c 	.word	0x102ceb7c
102ce9f0:	102ceb7c 	.word	0x102ceb7c
102ce9f4:	102ceb7c 	.word	0x102ceb7c
102ce9f8:	102ceb7c 	.word	0x102ceb7c
102ce9fc:	102cfd94 	.word	0x102cfd94
102cea00:	102cea04 	.word	0x102cea04
	break;

	case MQTT_TWIN_REPORTED:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH TWIN REPORTED PROPERTY");
102cea04:	e59fceb8 	ldr	ip, [pc, #3768]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cea08:	e3a02c02 	mov	r2, #512	; 0x200
102cea0c:	e3a01000 	mov	r1, #0
102cea10:	e28c00b8 	add	r0, ip, #184	; 0xb8
102cea14:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cea18:	e12fff36 	blx	r6
102cea1c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102cea20:	e59f1ca0 	ldr	r1, [pc, #3232]	; 102cf6c8 <MQTT_Send_Publish+0xe90>
102cea24:	e5943000 	ldr	r3, [r4]
102cea28:	e28c00b8 	add	r0, ip, #184	; 0xb8
102cea2c:	e12fff33 	blx	r3
102cea30:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102cea34:	e28c00b8 	add	r0, ip, #184	; 0xb8
102cea38:	e12fff35 	blx	r5
102cea3c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102cea40:	e59f3e34 	ldr	r3, [pc, #3636]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cea44:	e28c10b8 	add	r1, ip, #184	; 0xb8
102cea48:	e1a02000 	mov	r2, r0
102cea4c:	e3a0000a 	mov	r0, #10
102cea50:	e12fff33 	blx	r3
#endif
		json_root = cJSON_CreateObject();
102cea54:	e59f3e3c 	ldr	r3, [pc, #3644]	; 102cf898 <MQTT_Send_Publish+0x1060>
102cea58:	e12fff33 	blx	r3

		{
			if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_GEOLOCATION)
102cea5c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102cea60:	e59c2374 	ldr	r2, [ip, #884]	; 0x374
102cea64:	e3120001 	tst	r2, #1
	case MQTT_TWIN_REPORTED:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH TWIN REPORTED PROPERTY");
#endif
		json_root = cJSON_CreateObject();
102cea68:	e1a08000 	mov	r8, r0

		{
			if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_GEOLOCATION)
102cea6c:	1a0006d7 	bne	102d05d0 <MQTT_Send_Publish+0x1d98>
				cJSON_AddStringToObject(json_root, TWIN_GEOLOCATION,RP_Geolocation);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_GEOLOCATION);
102cea70:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102cea74:	e3c23001 	bic	r3, r2, #1
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_VENDOR_CODE)
102cea78:	e3120002 	tst	r2, #2
		json_root = cJSON_CreateObject();

		{
			if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_GEOLOCATION)
				cJSON_AddStringToObject(json_root, TWIN_GEOLOCATION,RP_Geolocation);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_GEOLOCATION);
102cea7c:	e59f7e40 	ldr	r7, [pc, #3648]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cea80:	e58c3374 	str	r3, [ip, #884]	; 0x374
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_VENDOR_CODE)
102cea84:	1a0006c5 	bne	102d05a0 <MQTT_Send_Publish+0x1d68>
		{
			cJSON_AddStringToObject(json_root, TWIN_VENDOR_CODE,RP_vendorcode);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_VENDOR_CODE);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_DEVICE_TYPE)
102cea88:	e3130004 	tst	r3, #4
102cea8c:	1a0006b6 	bne	102d056c <MQTT_Send_Publish+0x1d34>
		{
			cJSON_AddStringToObject(json_root, TWIN_DEVICE_TYPE,RP_devicetype);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DEVICE_TYPE);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_DEVICE_STATUS)
102cea90:	e3130008 	tst	r3, #8
102cea94:	1a0006a7 	bne	102d0538 <MQTT_Send_Publish+0x1d00>
		{
			cJSON_AddStringToObject(json_root, TWIN_DEVICE_STATUS,RP_devicestatus);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DEVICE_STATUS);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_IOT_HUB_NAME)
102cea98:	e3130010 	tst	r3, #16
102cea9c:	1a000698 	bne	102d0504 <MQTT_Send_Publish+0x1ccc>
		{
			cJSON_AddStringToObject(json_root, TWIN_IOT_HUB_NAME,RP_IotHubName);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_IOT_HUB_NAME);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_DPS_ID_SCOPE)
102ceaa0:	e3130020 	tst	r3, #32
102ceaa4:	1a000689 	bne	102d04d0 <MQTT_Send_Publish+0x1c98>
		{
			cJSON_AddStringToObject(json_root, TWIN_DPS_ID_SCOPE,RP_DpsIdScope);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DPS_ID_SCOPE);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CNTRL_FW_INFO) // Report back FOTA related properties..
102ceaa8:	e3130040 	tst	r3, #64	; 0x40
102ceaac:	1a00066e 	bne	102d046c <MQTT_Send_Publish+0x1c34>
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_FILE_VER,RP_CntrlFirmwareVersion);
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_FILE_URL,RP_CntrlFirmwareFileURL);

			FOTA_information = 0; //Reset the flags
		}
		else if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CNTRL_FW_VER) // Report back FW version if not reported
102ceab0:	e3130080 	tst	r3, #128	; 0x80
102ceab4:	1a0007aa 	bne	102d0964 <MQTT_Send_Publish+0x212c>
		{
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_FILE_VER,RP_CntrlFirmwareVersion);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CNTRL_FW_VER);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CNTL_FW_UPDTAE_STATUS)
102ceab8:	e3130c01 	tst	r3, #256	; 0x100
102ceabc:	1a00078f 	bne	102d0900 <MQTT_Send_Publish+0x20c8>
		{
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_UPDATE_STATUS,RP_FW_Upgrade_status);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CNTL_FW_UPDTAE_STATUS);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_IMIE)
102ceac0:	e3130c02 	tst	r3, #512	; 0x200
102ceac4:	1a000780 	bne	102d08cc <MQTT_Send_Publish+0x2094>
		{
			cJSON_AddStringToObject(json_root, TWIN_IMEI,IMEI);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_IMIE);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CCID)
102ceac8:	e3130b01 	tst	r3, #1024	; 0x400
102ceacc:	1a000771 	bne	102d0898 <MQTT_Send_Publish+0x2060>
		{
			cJSON_AddStringToObject(json_root, TWIN_CCID,CCID);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CCID);
		}
		payload = cJSON_Print(json_root);
102cead0:	e59f3d24 	ldr	r3, [pc, #3364]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102cead4:	e1a00008 	mov	r0, r8
102cead8:	e12fff33 	blx	r3
102ceadc:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102ceae0:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102ceae4:	e59f3d14 	ldr	r3, [pc, #3348]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102ceae8:	e1a00007 	mov	r0, r7
102ceaec:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102ceaf0:	e1a00007 	mov	r0, r7
102ceaf4:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102ceaf8:	e59f3d04 	ldr	r3, [pc, #3332]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102ceafc:	e280a064 	add	sl, r0, #100	; 0x64
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CCID);
		}
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102ceb00:	e1a09000 	mov	r9, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102ceb04:	e1a0000a 	mov	r0, sl
102ceb08:	e12fff33 	blx	r3
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102ceb0c:	e59f3cf4 	ldr	r3, [pc, #3316]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102ceb10:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102ceb14:	e1a00008 	mov	r0, r8
102ceb18:	e12fff33 	blx	r3

		Ql_sprintf(topic_subscibe,"$iothub/twin/PATCH/properties/reported/?$rid=1");
102ceb1c:	e59f1ba8 	ldr	r1, [pc, #2984]	; 102cf6cc <MQTT_Send_Publish+0xe94>
102ceb20:	e5943000 	ldr	r3, [r4]
102ceb24:	e28d005c 	add	r0, sp, #92	; 0x5c
102ceb28:	e12fff33 	blx	r3
		topicString.cstring = topic_subscibe;
102ceb2c:	e28d30c0 	add	r3, sp, #192	; 0xc0
102ceb30:	e28d105c 	add	r1, sp, #92	; 0x5c
102ceb34:	e5231070 	str	r1, [r3, #-112]!	; 0xffffff90

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102ceb38:	e8930007 	ldm	r3, {r0, r1, r2}
102ceb3c:	e3a08000 	mov	r8, #0
102ceb40:	e28dc008 	add	ip, sp, #8
102ceb44:	e58d8000 	str	r8, [sp]
102ceb48:	e58d8004 	str	r8, [sp, #4]
102ceb4c:	e1a03008 	mov	r3, r8
102ceb50:	e88c0007 	stm	ip, {r0, r1, r2}
102ceb54:	e58d9018 	str	r9, [sp, #24]
102ceb58:	e58d7014 	str	r7, [sp, #20]
102ceb5c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
102ceb60:	e1a0100a 	mov	r1, sl
102ceb64:	e1a02008 	mov	r2, r8
102ceb68:	e59fcc70 	ldr	ip, [pc, #3184]	; 102cf7e0 <MQTT_Send_Publish+0xfa8>
102ceb6c:	e12fff3c 	blx	ip
	}
	break;
102ceb70:	e58d8034 	str	r8, [sp, #52]	; 0x34

		Ql_sprintf(topic_subscibe,"$iothub/twin/PATCH/properties/reported/?$rid=1");
		topicString.cstring = topic_subscibe;

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102ceb74:	e1a09000 	mov	r9, r0
102ceb78:	ea000156 	b	102cf0d8 <MQTT_Send_Publish+0x8a0>

	default:
		break;
	}
#ifdef DEBUG_MSG
	APP_DEBUG("*****-->\r\n");
102ceb7c:	e3a02c02 	mov	r2, #512	; 0x200
102ceb80:	e3a01000 	mov	r1, #0
102ceb84:	e59f0c18 	ldr	r0, [pc, #3096]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ceb88:	e12fff36 	blx	r6
102ceb8c:	e59f1ce4 	ldr	r1, [pc, #3300]	; 102cf878 <MQTT_Send_Publish+0x1040>
102ceb90:	e5943000 	ldr	r3, [r4]
102ceb94:	e59f0c08 	ldr	r0, [pc, #3080]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ceb98:	e12fff33 	blx	r3
102ceb9c:	e59f0c00 	ldr	r0, [pc, #3072]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ceba0:	e12fff35 	blx	r5
102ceba4:	e25b3018 	subs	r3, fp, #24
102ceba8:	e273c000 	rsbs	ip, r3, #0
102cebac:	e0bcc003 	adcs	ip, ip, r3
102cebb0:	e59f1bec 	ldr	r1, [pc, #3052]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cebb4:	e59f3cc0 	ldr	r3, [pc, #3264]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cebb8:	e58dc034 	str	ip, [sp, #52]	; 0x34
102cebbc:	e1a02000 	mov	r2, r0
102cebc0:	e3a0000a 	mov	r0, #10
102cebc4:	e12fff33 	blx	r3
#endif
	// Now message is ready to publish .. process it

	//In case of Pending message type if no pending message is there.. need ot skip out from this point.
	if((MSG_TYPE == MQTT_LOG) && (LOG_MESSAGES_AVAILABLE == FALSE))// No message to send in pending list
102cebc8:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
102cebcc:	e35c0000 	cmp	ip, #0
102cebd0:	0a000905 	beq	102d0fec <MQTT_Send_Publish+0x27b4>
102cebd4:	e59fcc98 	ldr	ip, [pc, #3224]	; 102cf874 <MQTT_Send_Publish+0x103c>
102cebd8:	e58dc028 	str	ip, [sp, #40]	; 0x28
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
	bool LOG_MESSAGES_AVAILABLE = FALSE;
	s32  filehandleData = -1;
102cebdc:	e3e0c000 	mvn	ip, #0
102cebe0:	e58dc030 	str	ip, [sp, #48]	; 0x30

	//In case of Pending message type if no pending message is there.. need ot skip out from this point.
	if((MSG_TYPE == MQTT_LOG) && (LOG_MESSAGES_AVAILABLE == FALSE))// No message to send in pending list
	{
#ifdef DEBUG_MSG
		APP_DEBUG("\n\r<--No Pending Data to Publish -->\r\n");
102cebe4:	e3a02c02 	mov	r2, #512	; 0x200
102cebe8:	e3a01000 	mov	r1, #0
102cebec:	e59f0bb0 	ldr	r0, [pc, #2992]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cebf0:	e12fff36 	blx	r6
102cebf4:	e59f1ad4 	ldr	r1, [pc, #2772]	; 102cf6d0 <MQTT_Send_Publish+0xe98>
102cebf8:	e5943000 	ldr	r3, [r4]
102cebfc:	e59f0ba0 	ldr	r0, [pc, #2976]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cec00:	e12fff33 	blx	r3
102cec04:	e59f0b98 	ldr	r0, [pc, #2968]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cec08:	e12fff35 	blx	r5
102cec0c:	e59f1b90 	ldr	r1, [pc, #2960]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cec10:	e59f3c64 	ldr	r3, [pc, #3172]	; 102cf87c <MQTT_Send_Publish+0x1044>
		Ql_MEM_Free(payload);
		payload = NULL;
		Ql_MEM_Free(buf_ssl);
		buf_ssl = NULL;
		//-------------------------------------------------------
		return rc;
102cec14:	e3a0a000 	mov	sl, #0

	//In case of Pending message type if no pending message is there.. need ot skip out from this point.
	if((MSG_TYPE == MQTT_LOG) && (LOG_MESSAGES_AVAILABLE == FALSE))// No message to send in pending list
	{
#ifdef DEBUG_MSG
		APP_DEBUG("\n\r<--No Pending Data to Publish -->\r\n");
102cec18:	e1a02000 	mov	r2, r0
102cec1c:	e3a0000a 	mov	r0, #10
102cec20:	e12fff33 	blx	r3
#endif
		//-------------------------------------------------------
		fileSys_CloseFile(filehandleData); // Close the file
102cec24:	e59f3be8 	ldr	r3, [pc, #3048]	; 102cf814 <MQTT_Send_Publish+0xfdc>
102cec28:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
102cec2c:	e12fff33 	blx	r3
		Ql_MEM_Free(payload);
102cec30:	e3a00000 	mov	r0, #0
102cec34:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
102cec38:	e12fff3c 	blx	ip
		payload = NULL;
		Ql_MEM_Free(buf_ssl);
102cec3c:	e3a00000 	mov	r0, #0
102cec40:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
102cec44:	e12fff3c 	blx	ip
	payload = NULL;
	Ql_MEM_Free(buf_ssl);
	buf_ssl = NULL;
	//-------------------------------------------------------
	return rc;
}
102cec48:	e1a0000a 	mov	r0, sl
102cec4c:	e28dd0c4 	add	sp, sp, #196	; 0xc4
102cec50:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	break;

	case MQTT_WATER_BALANCE:
	{
		Ql_sprintf((char *)flow_rate,"%d",water_flow_rate_ml_minute);
102cec54:	e59f3a78 	ldr	r3, [pc, #2680]	; 102cf6d4 <MQTT_Send_Publish+0xe9c>
102cec58:	e59f1a78 	ldr	r1, [pc, #2680]	; 102cf6d8 <MQTT_Send_Publish+0xea0>
102cec5c:	e1d320b0 	ldrh	r2, [r3]
102cec60:	e59f0b68 	ldr	r0, [pc, #2920]	; 102cf7d0 <MQTT_Send_Publish+0xf98>
102cec64:	e5943000 	ldr	r3, [r4]
102cec68:	e12fff33 	blx	r3
		Ql_sprintf((char *)TDS_Input_Data,"%d",TDS_Sensor_In_value);
102cec6c:	e59f3a68 	ldr	r3, [pc, #2664]	; 102cf6dc <MQTT_Send_Publish+0xea4>
102cec70:	e59f1a60 	ldr	r1, [pc, #2656]	; 102cf6d8 <MQTT_Send_Publish+0xea0>
102cec74:	e1d320b0 	ldrh	r2, [r3]
102cec78:	e59f0b2c 	ldr	r0, [pc, #2860]	; 102cf7ac <MQTT_Send_Publish+0xf74>
102cec7c:	e5943000 	ldr	r3, [r4]
102cec80:	e12fff33 	blx	r3
		Ql_sprintf((char *)TDS_Ouput_Data,"%d",TDS_Sensor_OUT_value);
102cec84:	e59f3a54 	ldr	r3, [pc, #2644]	; 102cf6e0 <MQTT_Send_Publish+0xea8>
102cec88:	e59f1a48 	ldr	r1, [pc, #2632]	; 102cf6d8 <MQTT_Send_Publish+0xea0>
102cec8c:	e1d320b0 	ldrh	r2, [r3]
102cec90:	e59f0b1c 	ldr	r0, [pc, #2844]	; 102cf7b4 <MQTT_Send_Publish+0xf7c>
102cec94:	e5943000 	ldr	r3, [r4]
102cec98:	e12fff33 	blx	r3
		Ql_sprintf((char *)Pump_Current,"%d",ro_pump_current_in_mA);
102cec9c:	e59f3a40 	ldr	r3, [pc, #2624]	; 102cf6e4 <MQTT_Send_Publish+0xeac>
102ceca0:	e59f1a30 	ldr	r1, [pc, #2608]	; 102cf6d8 <MQTT_Send_Publish+0xea0>
102ceca4:	e1d320b0 	ldrh	r2, [r3]
102ceca8:	e59f0b0c 	ldr	r0, [pc, #2828]	; 102cf7bc <MQTT_Send_Publish+0xf84>
102cecac:	e5943000 	ldr	r3, [r4]
102cecb0:	e12fff33 	blx	r3
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_WATER_BAL ");
102cecb4:	e3a02c02 	mov	r2, #512	; 0x200
102cecb8:	e3a01000 	mov	r1, #0
102cecbc:	e59f0ae0 	ldr	r0, [pc, #2784]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cecc0:	e12fff36 	blx	r6
102cecc4:	e59f1a1c 	ldr	r1, [pc, #2588]	; 102cf6e8 <MQTT_Send_Publish+0xeb0>
102cecc8:	e5943000 	ldr	r3, [r4]
102ceccc:	e59f0ad0 	ldr	r0, [pc, #2768]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cecd0:	e12fff33 	blx	r3
102cecd4:	e59f0ac8 	ldr	r0, [pc, #2760]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cecd8:	e12fff35 	blx	r5
#endif
		json_root = cJSON_CreateObject();
102cecdc:	e59f7bb4 	ldr	r7, [pc, #2996]	; 102cf898 <MQTT_Send_Publish+0x1060>
		Ql_sprintf((char *)flow_rate,"%d",water_flow_rate_ml_minute);
		Ql_sprintf((char *)TDS_Input_Data,"%d",TDS_Sensor_In_value);
		Ql_sprintf((char *)TDS_Ouput_Data,"%d",TDS_Sensor_OUT_value);
		Ql_sprintf((char *)Pump_Current,"%d",ro_pump_current_in_mA);
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_WATER_BAL ");
102cece0:	e59f3b94 	ldr	r3, [pc, #2964]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cece4:	e59f1ab8 	ldr	r1, [pc, #2744]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cece8:	e1a02000 	mov	r2, r0
102cecec:	e3a0000a 	mov	r0, #10
102cecf0:	e12fff33 	blx	r3
#endif
		json_root = cJSON_CreateObject();
102cecf4:	e12fff37 	blx	r7
102cecf8:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cecfc:	e12fff37 	blx	r7
102ced00:	e59f1b94 	ldr	r1, [pc, #2964]	; 102cf89c <MQTT_Send_Publish+0x1064>
102ced04:	e59f7bd8 	ldr	r7, [pc, #3032]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102ced08:	e1a08000 	mov	r8, r0
102ced0c:	e1a02008 	mov	r2, r8
102ced10:	e1a0000a 	mov	r0, sl
102ced14:	e12fff37 	blx	r7
102ced18:	e59f39cc 	ldr	r3, [pc, #2508]	; 102cf6ec <MQTT_Send_Publish+0xeb4>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102ced1c:	e59f0ba4 	ldr	r0, [pc, #2980]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());


		for(i=0;i<5;i++)
102ced20:	e3a02000 	mov	r2, #0
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
102ced24:	e7d31002 	ldrb	r1, [r3, r2]
102ced28:	e3510020 	cmp	r1, #32
102ced2c:	0a000442 	beq	102cfe3c <MQTT_Send_Publish+0x1604>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102ced30:	e7c21000 	strb	r1, [r2, r0]
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());


		for(i=0;i<5;i++)
102ced34:	e2822001 	add	r2, r2, #1
102ced38:	e3520005 	cmp	r2, #5
102ced3c:	1afffff8 	bne	102ced24 <MQTT_Send_Publish+0x4ec>
102ced40:	e59fcb7c 	ldr	ip, [pc, #2940]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102ced44:	e58dc024 	str	ip, [sp, #36]	; 0x24
102ced48:	ea000440 	b	102cfe50 <MQTT_Send_Publish+0x1618>
	{
	case MQTT_POWER_ON:
	case MQTT_POWER_OFF:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_POWER_");
102ced4c:	e3a02c02 	mov	r2, #512	; 0x200
102ced50:	e3a01000 	mov	r1, #0
102ced54:	e59f0a48 	ldr	r0, [pc, #2632]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ced58:	e12fff36 	blx	r6
102ced5c:	e59f198c 	ldr	r1, [pc, #2444]	; 102cf6f0 <MQTT_Send_Publish+0xeb8>
102ced60:	e5943000 	ldr	r3, [r4]
102ced64:	e59f0a38 	ldr	r0, [pc, #2616]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ced68:	e12fff33 	blx	r3
102ced6c:	e59f0a30 	ldr	r0, [pc, #2608]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ced70:	e12fff35 	blx	r5
102ced74:	e59f1a28 	ldr	r1, [pc, #2600]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ced78:	e59f3afc 	ldr	r3, [pc, #2812]	; 102cf87c <MQTT_Send_Publish+0x1044>
102ced7c:	e59faa08 	ldr	sl, [pc, #2568]	; 102cf78c <MQTT_Send_Publish+0xf54>
102ced80:	e59f7a00 	ldr	r7, [pc, #2560]	; 102cf788 <MQTT_Send_Publish+0xf50>
102ced84:	e59f8af0 	ldr	r8, [pc, #2800]	; 102cf87c <MQTT_Send_Publish+0x1044>
102ced88:	e1a02000 	mov	r2, r0
102ced8c:	e3a0000a 	mov	r0, #10
102ced90:	e12fff33 	blx	r3
		if( MSG_TYPE == MQTT_POWER_ON)
102ced94:	e35b0002 	cmp	fp, #2
		{
			APP_DEBUG("ON ");
102ced98:	e3a02c02 	mov	r2, #512	; 0x200
102ced9c:	e3a01000 	mov	r1, #0
102ceda0:	e59f09fc 	ldr	r0, [pc, #2556]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
	{
	case MQTT_POWER_ON:
	case MQTT_POWER_OFF:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_POWER_");
102ceda4:	e59f39e4 	ldr	r3, [pc, #2532]	; 102cf790 <MQTT_Send_Publish+0xf58>
		if( MSG_TYPE == MQTT_POWER_ON)
102ceda8:	0a00074f 	beq	102d0aec <MQTT_Send_Publish+0x22b4>
		{
			APP_DEBUG("ON ");
		}
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			APP_DEBUG("OFF ");
102cedac:	e12fff33 	blx	r3
102cedb0:	e59a3000 	ldr	r3, [sl]
102cedb4:	e59f1938 	ldr	r1, [pc, #2360]	; 102cf6f4 <MQTT_Send_Publish+0xebc>
102cedb8:	e59f09e4 	ldr	r0, [pc, #2532]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cedbc:	e12fff33 	blx	r3
102cedc0:	e59f09dc 	ldr	r0, [pc, #2524]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cedc4:	e12fff37 	blx	r7
102cedc8:	e59f19d4 	ldr	r1, [pc, #2516]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
		}
#endif
		json_root = cJSON_CreateObject();
102cedcc:	e59f7ac4 	ldr	r7, [pc, #2756]	; 102cf898 <MQTT_Send_Publish+0x1060>
		{
			APP_DEBUG("ON ");
		}
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			APP_DEBUG("OFF ");
102cedd0:	e1a02000 	mov	r2, r0
102cedd4:	e3a0000a 	mov	r0, #10
102cedd8:	e12fff38 	blx	r8
		}
#endif
		json_root = cJSON_CreateObject();
102ceddc:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_PWR,"1");
		}
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_PWR,"0");
102cede0:	e59f8af4 	ldr	r8, [pc, #2804]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			APP_DEBUG("OFF ");
		}
#endif
		json_root = cJSON_CreateObject();
102cede4:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cede8:	e12fff37 	blx	r7
102cedec:	e59f1aa8 	ldr	r1, [pc, #2728]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cedf0:	e59f7aec 	ldr	r7, [pc, #2796]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cedf4:	e1a09000 	mov	r9, r0
102cedf8:	e1a02009 	mov	r2, r9
102cedfc:	e1a0000a 	mov	r0, sl
102cee00:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_PWR,"1");
		}
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_PWR,"0");
102cee04:	e59f08ec 	ldr	r0, [pc, #2284]	; 102cf6f8 <MQTT_Send_Publish+0xec0>
102cee08:	e12fff38 	blx	r8
102cee0c:	e59f18e8 	ldr	r1, [pc, #2280]	; 102cf6fc <MQTT_Send_Publish+0xec4>
102cee10:	e1a02000 	mov	r2, r0
102cee14:	e1a00009 	mov	r0, r9
102cee18:	e12fff37 	blx	r7
102cee1c:	e59f38c8 	ldr	r3, [pc, #2248]	; 102cf6ec <MQTT_Send_Publish+0xeb4>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cee20:	e59f0aa0 	ldr	r0, [pc, #2720]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
 *
 * Return:
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
102cee24:	e3a02000 	mov	r2, #0
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_PWR,"0");
		}

		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
102cee28:	e7d31002 	ldrb	r1, [r3, r2]
102cee2c:	e3510020 	cmp	r1, #32
102cee30:	0a00065d 	beq	102d07ac <MQTT_Send_Publish+0x1f74>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cee34:	e7c21000 	strb	r1, [r2, r0]
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_PWR,"0");
		}

		for(i=0;i<5;i++)
102cee38:	e2822001 	add	r2, r2, #1
102cee3c:	e3520005 	cmp	r2, #5
102cee40:	1afffff8 	bne	102cee28 <MQTT_Send_Publish+0x5f0>
102cee44:	e59fca78 	ldr	ip, [pc, #2680]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cee48:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cee4c:	ea00065b 	b	102d07c0 <MQTT_Send_Publish+0x1f88>
	case MQTT_CONNECTIVITY_LOW:
	case MQTT_BAL_ZERO:
	case MQTT_BAL_LOW:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
102cee50:	e3a02c02 	mov	r2, #512	; 0x200
102cee54:	e3a01000 	mov	r1, #0
102cee58:	e59f0944 	ldr	r0, [pc, #2372]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cee5c:	e12fff36 	blx	r6
102cee60:	e59f1898 	ldr	r1, [pc, #2200]	; 102cf700 <MQTT_Send_Publish+0xec8>
102cee64:	e5943000 	ldr	r3, [r4]
102cee68:	e59f0934 	ldr	r0, [pc, #2356]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cee6c:	e12fff33 	blx	r3
102cee70:	e59f092c 	ldr	r0, [pc, #2348]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cee74:	e12fff35 	blx	r5
102cee78:	e59f1924 	ldr	r1, [pc, #2340]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cee7c:	e59f39f8 	ldr	r3, [pc, #2552]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cee80:	e59fa904 	ldr	sl, [pc, #2308]	; 102cf78c <MQTT_Send_Publish+0xf54>
102cee84:	e59f78fc 	ldr	r7, [pc, #2300]	; 102cf788 <MQTT_Send_Publish+0xf50>
102cee88:	e59f89ec 	ldr	r8, [pc, #2540]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cee8c:	e1a02000 	mov	r2, r0
102cee90:	e3a0000a 	mov	r0, #10
102cee94:	e12fff33 	blx	r3
		if( MSG_TYPE == MQTT_CONNECTIVITY_ON)
102cee98:	e35b0004 	cmp	fp, #4
		{
			APP_DEBUG("CONNECTIVITY_ON ");
102cee9c:	e3a02c02 	mov	r2, #512	; 0x200
102ceea0:	e3a01000 	mov	r1, #0
102ceea4:	e59f08f8 	ldr	r0, [pc, #2296]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
	case MQTT_CONNECTIVITY_LOW:
	case MQTT_BAL_ZERO:
	case MQTT_BAL_LOW:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
102ceea8:	e59f38e0 	ldr	r3, [pc, #2272]	; 102cf790 <MQTT_Send_Publish+0xf58>
		if( MSG_TYPE == MQTT_CONNECTIVITY_ON)
102ceeac:	0a0006f1 	beq	102d0a78 <MQTT_Send_Publish+0x2240>
		{
			APP_DEBUG("CONNECTIVITY_ON ");
		}
		else if( MSG_TYPE == MQTT_CONNECTIVITY_LOW)
102ceeb0:	e35b0005 	cmp	fp, #5
102ceeb4:	0a0005e2 	beq	102d0644 <MQTT_Send_Publish+0x1e0c>
		{
			APP_DEBUG("CONNECTIVITY_LOW ");
		}
		else if( MSG_TYPE == MQTT_BAL_ZERO)
102ceeb8:	e35b0006 	cmp	fp, #6
102ceebc:	0a000739 	beq	102d0ba8 <MQTT_Send_Publish+0x2370>
		{
			APP_DEBUG("BAL_ZERO ");
		}
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
102ceec0:	e12fff33 	blx	r3
102ceec4:	e59a3000 	ldr	r3, [sl]
102ceec8:	e59f1834 	ldr	r1, [pc, #2100]	; 102cf704 <MQTT_Send_Publish+0xecc>
102ceecc:	e59f08d0 	ldr	r0, [pc, #2256]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ceed0:	e12fff33 	blx	r3
102ceed4:	e59f08c8 	ldr	r0, [pc, #2248]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102ceed8:	e12fff37 	blx	r7
102ceedc:	e59f18c0 	ldr	r1, [pc, #2240]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
		}
#endif
		json_root = cJSON_CreateObject();
102ceee0:	e59f79b0 	ldr	r7, [pc, #2480]	; 102cf898 <MQTT_Send_Publish+0x1060>
		{
			APP_DEBUG("BAL_ZERO ");
		}
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
102ceee4:	e1a02000 	mov	r2, r0
102ceee8:	e3a0000a 	mov	r0, #10
102ceeec:	e12fff38 	blx	r8
		}
#endif
		json_root = cJSON_CreateObject();
102ceef0:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_ZBAL,"1");
		}
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LBAL,"1");
102ceef4:	e59f89e0 	ldr	r8, [pc, #2528]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102ceef8:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102ceefc:	e12fff37 	blx	r7
102cef00:	e59f1994 	ldr	r1, [pc, #2452]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cef04:	e59f79d8 	ldr	r7, [pc, #2520]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cef08:	e1a09000 	mov	r9, r0
102cef0c:	e1a02009 	mov	r2, r9
102cef10:	e1a0000a 	mov	r0, sl
102cef14:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_ZBAL,"1");
		}
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LBAL,"1");
102cef18:	e59f0970 	ldr	r0, [pc, #2416]	; 102cf890 <MQTT_Send_Publish+0x1058>
102cef1c:	e12fff38 	blx	r8
102cef20:	e59f17e0 	ldr	r1, [pc, #2016]	; 102cf708 <MQTT_Send_Publish+0xed0>
102cef24:	e1a02000 	mov	r2, r0
102cef28:	e1a00009 	mov	r0, r9
102cef2c:	e12fff37 	blx	r7
102cef30:	e59f37b4 	ldr	r3, [pc, #1972]	; 102cf6ec <MQTT_Send_Publish+0xeb4>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cef34:	e59f098c 	ldr	r0, [pc, #2444]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
 *
 * Return:
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
102cef38:	e3a02000 	mov	r2, #0
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LBAL,"1");
		}

		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
102cef3c:	e7d31002 	ldrb	r1, [r3, r2]
102cef40:	e3510020 	cmp	r1, #32
102cef44:	0a00063b 	beq	102d0838 <MQTT_Send_Publish+0x2000>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cef48:	e7c21000 	strb	r1, [r2, r0]
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LBAL,"1");
		}

		for(i=0;i<5;i++)
102cef4c:	e2822001 	add	r2, r2, #1
102cef50:	e3520005 	cmp	r2, #5
102cef54:	1afffff8 	bne	102cef3c <MQTT_Send_Publish+0x704>
102cef58:	e59fc964 	ldr	ip, [pc, #2404]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cef5c:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cef60:	ea000639 	b	102d084c <MQTT_Send_Publish+0x2014>
	case MQTT_EM_ERROR_E5:
	case MQTT_TAMPER:
	case MQTT_LANGUAGE_ACK:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
102cef64:	e59fc958 	ldr	ip, [pc, #2392]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cef68:	e3a02c02 	mov	r2, #512	; 0x200
102cef6c:	e3a01000 	mov	r1, #0
102cef70:	e28c00b8 	add	r0, ip, #184	; 0xb8
102cef74:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cef78:	e12fff36 	blx	r6
102cef7c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102cef80:	e59f1778 	ldr	r1, [pc, #1912]	; 102cf700 <MQTT_Send_Publish+0xec8>
102cef84:	e5943000 	ldr	r3, [r4]
102cef88:	e28c00b8 	add	r0, ip, #184	; 0xb8
102cef8c:	e12fff33 	blx	r3
102cef90:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102cef94:	e59f87f0 	ldr	r8, [pc, #2032]	; 102cf78c <MQTT_Send_Publish+0xf54>
102cef98:	e28c00b8 	add	r0, ip, #184	; 0xb8
102cef9c:	e12fff35 	blx	r5
102cefa0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102cefa4:	e59f38d0 	ldr	r3, [pc, #2256]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cefa8:	e28c10b8 	add	r1, ip, #184	; 0xb8
102cefac:	e59f77d4 	ldr	r7, [pc, #2004]	; 102cf788 <MQTT_Send_Publish+0xf50>
102cefb0:	e59fa8c4 	ldr	sl, [pc, #2244]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cefb4:	e1a02000 	mov	r2, r0
102cefb8:	e3a0000a 	mov	r0, #10
102cefbc:	e12fff33 	blx	r3
		if( MSG_TYPE == MQTT_EM_ERROR)
102cefc0:	e35b0008 	cmp	fp, #8
	case MQTT_EM_ERROR_E5:
	case MQTT_TAMPER:
	case MQTT_LANGUAGE_ACK:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
102cefc4:	e59f37c4 	ldr	r3, [pc, #1988]	; 102cf790 <MQTT_Send_Publish+0xf58>
		if( MSG_TYPE == MQTT_EM_ERROR)
102cefc8:	0a00068a 	beq	102d09f8 <MQTT_Send_Publish+0x21c0>
		{
			APP_DEBUG("EM_ERROR ");
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E1)
102cefcc:	e35b0009 	cmp	fp, #9
102cefd0:	0a0005d0 	beq	102d0718 <MQTT_Send_Publish+0x1ee0>
		{
			APP_DEBUG("EM_ERROR_E1 ");
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E5)
102cefd4:	e35b000a 	cmp	fp, #10
102cefd8:	0a00070f 	beq	102d0c1c <MQTT_Send_Publish+0x23e4>
		{
			APP_DEBUG("EM_ERROR_E5 ");
		}
		else if( MSG_TYPE == MQTT_TAMPER)
102cefdc:	e35b000b 	cmp	fp, #11
102cefe0:	0a000732 	beq	102d0cb0 <MQTT_Send_Publish+0x2478>
		{
			APP_DEBUG("TAMPER ");
		}
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
102cefe4:	e35b0012 	cmp	fp, #18
102cefe8:	0a000778 	beq	102d0dd0 <MQTT_Send_Publish+0x2598>
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102cefec:	e59f78a4 	ldr	r7, [pc, #2212]	; 102cf898 <MQTT_Send_Publish+0x1060>
102ceff0:	e12fff37 	blx	r7
102ceff4:	e59f88e0 	ldr	r8, [pc, #2272]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102ceff8:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102ceffc:	e12fff37 	blx	r7
102cf000:	e59f1894 	ldr	r1, [pc, #2196]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cf004:	e59f78d8 	ldr	r7, [pc, #2264]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cf008:	e1a09000 	mov	r9, r0
102cf00c:	e1a02009 	mov	r2, r9
102cf010:	e1a0000a 	mov	r0, sl
102cf014:	e12fff37 	blx	r7
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			Ql_sprintf(string_temp, "%d",language_index);
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LANGUAGE_ACK,string_temp);
		}
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);
102cf018:	e59f07d4 	ldr	r0, [pc, #2004]	; 102cf7f4 <MQTT_Send_Publish+0xfbc>
102cf01c:	e12fff38 	blx	r8
102cf020:	e59f17d0 	ldr	r1, [pc, #2000]	; 102cf7f8 <MQTT_Send_Publish+0xfc0>
102cf024:	e1a02000 	mov	r2, r0
102cf028:	e1a00009 	mov	r0, r9
102cf02c:	e12fff37 	blx	r7

		payload = cJSON_Print(json_root);
102cf030:	e59f37c4 	ldr	r3, [pc, #1988]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102cf034:	e1a0000a 	mov	r0, sl
102cf038:	e12fff33 	blx	r3
102cf03c:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102cf040:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102cf044:	e59f37b4 	ldr	r3, [pc, #1972]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102cf048:	e1a00007 	mov	r0, r7
102cf04c:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102cf050:	e1a00007 	mov	r0, r7
102cf054:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cf058:	e59f37a4 	ldr	r3, [pc, #1956]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102cf05c:	e2809064 	add	r9, r0, #100	; 0x64
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);

		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102cf060:	e1a08000 	mov	r8, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cf064:	e1a00009 	mov	r0, r9
102cf068:	e12fff33 	blx	r3
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102cf06c:	e59f3794 	ldr	r3, [pc, #1940]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cf070:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102cf074:	e1a0000a 	mov	r0, sl
102cf078:	e12fff33 	blx	r3

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
102cf07c:	e59f1764 	ldr	r1, [pc, #1892]	; 102cf7e8 <MQTT_Send_Publish+0xfb0>
102cf080:	e59f3754 	ldr	r3, [pc, #1876]	; 102cf7dc <MQTT_Send_Publish+0xfa4>
102cf084:	e28d005c 	add	r0, sp, #92	; 0x5c
102cf088:	e12fff33 	blx	r3
		topicString.cstring = topic_subscibe;
102cf08c:	e28d30c0 	add	r3, sp, #192	; 0xc0
102cf090:	e28d105c 	add	r1, sp, #92	; 0x5c
102cf094:	e5231070 	str	r1, [r3, #-112]!	; 0xffffff90

		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cf098:	e8930007 	ldm	r3, {r0, r1, r2}
102cf09c:	e3a0a000 	mov	sl, #0
102cf0a0:	e28dc008 	add	ip, sp, #8
102cf0a4:	e58da000 	str	sl, [sp]
102cf0a8:	e58da004 	str	sl, [sp, #4]
102cf0ac:	e1a0300a 	mov	r3, sl
102cf0b0:	e88c0007 	stm	ip, {r0, r1, r2}
102cf0b4:	e1a01009 	mov	r1, r9
102cf0b8:	e58d7014 	str	r7, [sp, #20]
102cf0bc:	e58d8018 	str	r8, [sp, #24]
102cf0c0:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
102cf0c4:	e1a0200a 	mov	r2, sl
102cf0c8:	e59fc710 	ldr	ip, [pc, #1808]	; 102cf7e0 <MQTT_Send_Publish+0xfa8>
102cf0cc:	e12fff3c 	blx	ip
	}
	break;
102cf0d0:	e58da034 	str	sl, [sp, #52]	; 0x34
		cJSON_Delete(json_root);

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
		topicString.cstring = topic_subscibe;

		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cf0d4:	e1a09000 	mov	r9, r0
		topicString.cstring = topic_subscibe;

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
	}
	break;
102cf0d8:	e3a0c011 	mov	ip, #17
102cf0dc:	ea0003b7 	b	102cffc0 <MQTT_Send_Publish+0x1788>
	break;

	case MQTT_RC_OK:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_RC_OK ");
102cf0e0:	e3a02c02 	mov	r2, #512	; 0x200
102cf0e4:	e3a01000 	mov	r1, #0
102cf0e8:	e59f06b4 	ldr	r0, [pc, #1716]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf0ec:	e12fff36 	blx	r6
102cf0f0:	e59f1614 	ldr	r1, [pc, #1556]	; 102cf70c <MQTT_Send_Publish+0xed4>
102cf0f4:	e5943000 	ldr	r3, [r4]
102cf0f8:	e59f06a4 	ldr	r0, [pc, #1700]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf0fc:	e12fff33 	blx	r3
102cf100:	e59f069c 	ldr	r0, [pc, #1692]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf104:	e12fff35 	blx	r5
#endif
		json_root = cJSON_CreateObject();
102cf108:	e59f7788 	ldr	r7, [pc, #1928]	; 102cf898 <MQTT_Send_Publish+0x1060>
	break;

	case MQTT_RC_OK:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_RC_OK ");
102cf10c:	e59f3768 	ldr	r3, [pc, #1896]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf110:	e59f168c 	ldr	r1, [pc, #1676]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_OK,"1");
102cf114:	e59f87c0 	ldr	r8, [pc, #1984]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
	break;

	case MQTT_RC_OK:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_RC_OK ");
102cf118:	e1a02000 	mov	r2, r0
102cf11c:	e3a0000a 	mov	r0, #10
102cf120:	e12fff33 	blx	r3
#endif
		json_root = cJSON_CreateObject();
102cf124:	e12fff37 	blx	r7
102cf128:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cf12c:	e12fff37 	blx	r7
102cf130:	e59f1764 	ldr	r1, [pc, #1892]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cf134:	e59f77a8 	ldr	r7, [pc, #1960]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cf138:	e1a09000 	mov	r9, r0
102cf13c:	e1a02009 	mov	r2, r9
102cf140:	e1a0000a 	mov	r0, sl
102cf144:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_OK,"1");
102cf148:	e59f0740 	ldr	r0, [pc, #1856]	; 102cf890 <MQTT_Send_Publish+0x1058>
102cf14c:	e12fff38 	blx	r8
102cf150:	e59f15b8 	ldr	r1, [pc, #1464]	; 102cf710 <MQTT_Send_Publish+0xed8>
102cf154:	e1a02000 	mov	r2, r0
102cf158:	e1a00009 	mov	r0, r9
102cf15c:	e12fff37 	blx	r7
102cf160:	e59f3584 	ldr	r3, [pc, #1412]	; 102cf6ec <MQTT_Send_Publish+0xeb4>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cf164:	e59f075c 	ldr	r0, [pc, #1884]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
		APP_DEBUG(" PUBLISH MQTT_RC_OK ");
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_OK,"1");
		for(i=0;i<5;i++)
102cf168:	e3a02000 	mov	r2, #0
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
102cf16c:	e7d31002 	ldrb	r1, [r3, r2]
102cf170:	e3510020 	cmp	r1, #32
102cf174:	0a000397 	beq	102cffd8 <MQTT_Send_Publish+0x17a0>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cf178:	e7c21000 	strb	r1, [r2, r0]
		APP_DEBUG(" PUBLISH MQTT_RC_OK ");
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_OK,"1");
		for(i=0;i<5;i++)
102cf17c:	e2822001 	add	r2, r2, #1
102cf180:	e3520005 	cmp	r2, #5
102cf184:	1afffff8 	bne	102cf16c <MQTT_Send_Publish+0x934>
102cf188:	e59fc734 	ldr	ip, [pc, #1844]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cf18c:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cf190:	ea000395 	b	102cffec <MQTT_Send_Publish+0x17b4>
	break;

	case MQTT_RC_FAIL:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_RC_FAIL ");
102cf194:	e3a02c02 	mov	r2, #512	; 0x200
102cf198:	e3a01000 	mov	r1, #0
102cf19c:	e59f0600 	ldr	r0, [pc, #1536]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf1a0:	e12fff36 	blx	r6
102cf1a4:	e59f1568 	ldr	r1, [pc, #1384]	; 102cf714 <MQTT_Send_Publish+0xedc>
102cf1a8:	e5943000 	ldr	r3, [r4]
102cf1ac:	e59f05f0 	ldr	r0, [pc, #1520]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf1b0:	e12fff33 	blx	r3
102cf1b4:	e59f05e8 	ldr	r0, [pc, #1512]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf1b8:	e12fff35 	blx	r5
#endif
		json_root = cJSON_CreateObject();
102cf1bc:	e59f76d4 	ldr	r7, [pc, #1748]	; 102cf898 <MQTT_Send_Publish+0x1060>
	break;

	case MQTT_RC_FAIL:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_RC_FAIL ");
102cf1c0:	e59f36b4 	ldr	r3, [pc, #1716]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf1c4:	e59f15d8 	ldr	r1, [pc, #1496]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_FAIL,"1");
102cf1c8:	e59f870c 	ldr	r8, [pc, #1804]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
	break;

	case MQTT_RC_FAIL:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_RC_FAIL ");
102cf1cc:	e1a02000 	mov	r2, r0
102cf1d0:	e3a0000a 	mov	r0, #10
102cf1d4:	e12fff33 	blx	r3
#endif
		json_root = cJSON_CreateObject();
102cf1d8:	e12fff37 	blx	r7
102cf1dc:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cf1e0:	e12fff37 	blx	r7
102cf1e4:	e59f16b0 	ldr	r1, [pc, #1712]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cf1e8:	e59f76f4 	ldr	r7, [pc, #1780]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cf1ec:	e1a09000 	mov	r9, r0
102cf1f0:	e1a02009 	mov	r2, r9
102cf1f4:	e1a0000a 	mov	r0, sl
102cf1f8:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_FAIL,"1");
102cf1fc:	e59f068c 	ldr	r0, [pc, #1676]	; 102cf890 <MQTT_Send_Publish+0x1058>
102cf200:	e12fff38 	blx	r8
102cf204:	e59f150c 	ldr	r1, [pc, #1292]	; 102cf718 <MQTT_Send_Publish+0xee0>
102cf208:	e1a02000 	mov	r2, r0
102cf20c:	e1a00009 	mov	r0, r9
102cf210:	e12fff37 	blx	r7
102cf214:	e59f34d0 	ldr	r3, [pc, #1232]	; 102cf6ec <MQTT_Send_Publish+0xeb4>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cf218:	e59f06a8 	ldr	r0, [pc, #1704]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
		APP_DEBUG(" PUBLISH MQTT_RC_FAIL ");
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_FAIL,"1");
		for(i=0;i<5;i++)
102cf21c:	e3a02000 	mov	r2, #0
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
102cf220:	e7d31002 	ldrb	r1, [r3, r2]
102cf224:	e3510020 	cmp	r1, #32
102cf228:	0a00039d 	beq	102d00a4 <MQTT_Send_Publish+0x186c>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cf22c:	e7c21000 	strb	r1, [r2, r0]
		APP_DEBUG(" PUBLISH MQTT_RC_FAIL ");
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_FAIL,"1");
		for(i=0;i<5;i++)
102cf230:	e2822001 	add	r2, r2, #1
102cf234:	e3520005 	cmp	r2, #5
102cf238:	1afffff8 	bne	102cf220 <MQTT_Send_Publish+0x9e8>
102cf23c:	e59fc680 	ldr	ip, [pc, #1664]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cf240:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cf244:	ea00039b 	b	102d00b8 <MQTT_Send_Publish+0x1880>
	break;

	case MQTT_PURIFICATION_EVENT:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_PURIFICATION_EVENT ");
102cf248:	e3a02c02 	mov	r2, #512	; 0x200
102cf24c:	e3a01000 	mov	r1, #0
102cf250:	e59f054c 	ldr	r0, [pc, #1356]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf254:	e12fff36 	blx	r6
102cf258:	e59f14bc 	ldr	r1, [pc, #1212]	; 102cf71c <MQTT_Send_Publish+0xee4>
102cf25c:	e5943000 	ldr	r3, [r4]
102cf260:	e59f053c 	ldr	r0, [pc, #1340]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf264:	e12fff33 	blx	r3
102cf268:	e59f0534 	ldr	r0, [pc, #1332]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf26c:	e12fff35 	blx	r5
#endif
		json_root = cJSON_CreateObject();
102cf270:	e59f7620 	ldr	r7, [pc, #1568]	; 102cf898 <MQTT_Send_Publish+0x1060>
	break;

	case MQTT_PURIFICATION_EVENT:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_PURIFICATION_EVENT ");
102cf274:	e59f3600 	ldr	r3, [pc, #1536]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf278:	e59f1524 	ldr	r1, [pc, #1316]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PST_TS,Purification_Start_local_time);
102cf27c:	e59f8658 	ldr	r8, [pc, #1624]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
	break;

	case MQTT_PURIFICATION_EVENT:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_PURIFICATION_EVENT ");
102cf280:	e1a02000 	mov	r2, r0
102cf284:	e3a0000a 	mov	r0, #10
102cf288:	e12fff33 	blx	r3
#endif
		json_root = cJSON_CreateObject();
102cf28c:	e12fff37 	blx	r7
102cf290:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cf294:	e12fff37 	blx	r7
102cf298:	e59f15fc 	ldr	r1, [pc, #1532]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cf29c:	e59f7640 	ldr	r7, [pc, #1600]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cf2a0:	e1a09000 	mov	r9, r0
102cf2a4:	e1a02009 	mov	r2, r9
102cf2a8:	e1a0000a 	mov	r0, sl
102cf2ac:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PST_TS,Purification_Start_local_time);
102cf2b0:	e59f0468 	ldr	r0, [pc, #1128]	; 102cf720 <MQTT_Send_Publish+0xee8>
102cf2b4:	e12fff38 	blx	r8
102cf2b8:	e59f1464 	ldr	r1, [pc, #1124]	; 102cf724 <MQTT_Send_Publish+0xeec>
102cf2bc:	e1a02000 	mov	r2, r0
102cf2c0:	e1a00009 	mov	r0, r9
102cf2c4:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PSTP_TS,Purification_Stop_local_time);
102cf2c8:	e59f0458 	ldr	r0, [pc, #1112]	; 102cf728 <MQTT_Send_Publish+0xef0>
102cf2cc:	e12fff38 	blx	r8
102cf2d0:	e59f1454 	ldr	r1, [pc, #1108]	; 102cf72c <MQTT_Send_Publish+0xef4>
102cf2d4:	e1a02000 	mov	r2, r0
102cf2d8:	e1a00009 	mov	r0, r9
102cf2dc:	e12fff37 	blx	r7
102cf2e0:	e59f1448 	ldr	r1, [pc, #1096]	; 102cf730 <MQTT_Send_Publish+0xef8>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = Water_dispensed_volume[i];
102cf2e4:	e59f05dc 	ldr	r0, [pc, #1500]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PST_TS,Purification_Start_local_time);
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PSTP_TS,Purification_Stop_local_time);
		for(i=0;i<5;i++)
102cf2e8:	e3a03000 	mov	r3, #0
		{
			if(Water_dispensed_volume[i] == ' ')// Check for a space to find end of Water data string
102cf2ec:	e7d12003 	ldrb	r2, [r1, r3]
102cf2f0:	e3520020 	cmp	r2, #32
102cf2f4:	0a0003c7 	beq	102d0218 <MQTT_Send_Publish+0x19e0>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = Water_dispensed_volume[i];
102cf2f8:	e7c32000 	strb	r2, [r3, r0]
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PST_TS,Purification_Start_local_time);
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PSTP_TS,Purification_Stop_local_time);
		for(i=0;i<5;i++)
102cf2fc:	e2833001 	add	r3, r3, #1
102cf300:	e3530005 	cmp	r3, #5
102cf304:	1afffff8 	bne	102cf2ec <MQTT_Send_Publish+0xab4>
102cf308:	e59fc5b4 	ldr	ip, [pc, #1460]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cf30c:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cf310:	ea0003c5 	b	102d022c <MQTT_Send_Publish+0x19f4>
	}
	break;

	case MQTT_HEART_BEAT_MESSAGE:
	{
		Ql_sprintf((char *)flow_rate,"%d",water_flow_rate_ml_minute);
102cf314:	e59f33b8 	ldr	r3, [pc, #952]	; 102cf6d4 <MQTT_Send_Publish+0xe9c>
102cf318:	e59f13b8 	ldr	r1, [pc, #952]	; 102cf6d8 <MQTT_Send_Publish+0xea0>
102cf31c:	e1d320b0 	ldrh	r2, [r3]
102cf320:	e59f04a8 	ldr	r0, [pc, #1192]	; 102cf7d0 <MQTT_Send_Publish+0xf98>
102cf324:	e5943000 	ldr	r3, [r4]
102cf328:	e12fff33 	blx	r3
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH HEART BEAT MESSAGE ");
102cf32c:	e3a02c02 	mov	r2, #512	; 0x200
102cf330:	e3a01000 	mov	r1, #0
102cf334:	e59f0468 	ldr	r0, [pc, #1128]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf338:	e12fff36 	blx	r6
102cf33c:	e59f13f0 	ldr	r1, [pc, #1008]	; 102cf734 <MQTT_Send_Publish+0xefc>
102cf340:	e5943000 	ldr	r3, [r4]
102cf344:	e59f0458 	ldr	r0, [pc, #1112]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf348:	e12fff33 	blx	r3
102cf34c:	e59f0450 	ldr	r0, [pc, #1104]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf350:	e12fff35 	blx	r5
#endif
		json_root = cJSON_CreateObject();
102cf354:	e59f753c 	ldr	r7, [pc, #1340]	; 102cf898 <MQTT_Send_Publish+0x1060>

	case MQTT_HEART_BEAT_MESSAGE:
	{
		Ql_sprintf((char *)flow_rate,"%d",water_flow_rate_ml_minute);
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH HEART BEAT MESSAGE ");
102cf358:	e59f351c 	ldr	r3, [pc, #1308]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf35c:	e59f1440 	ldr	r1, [pc, #1088]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf360:	e1a02000 	mov	r2, r0
102cf364:	e3a0000a 	mov	r0, #10
102cf368:	e12fff33 	blx	r3
#endif
		json_root = cJSON_CreateObject();
102cf36c:	e12fff37 	blx	r7
102cf370:	e1a08000 	mov	r8, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cf374:	e12fff37 	blx	r7
102cf378:	e59f151c 	ldr	r1, [pc, #1308]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cf37c:	e59f7560 	ldr	r7, [pc, #1376]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cf380:	e1a0a000 	mov	sl, r0
102cf384:	e1a0200a 	mov	r2, sl
102cf388:	e1a00008 	mov	r0, r8
102cf38c:	e12fff37 	blx	r7
102cf390:	e59f3354 	ldr	r3, [pc, #852]	; 102cf6ec <MQTT_Send_Publish+0xeb4>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cf394:	e59f052c 	ldr	r0, [pc, #1324]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
		APP_DEBUG(" PUBLISH HEART BEAT MESSAGE ");
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());

		for(i=0;i<5;i++)
102cf398:	e3a02000 	mov	r2, #0
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
102cf39c:	e7d31002 	ldrb	r1, [r3, r2]
102cf3a0:	e3510020 	cmp	r1, #32
102cf3a4:	0a000357 	beq	102d0108 <MQTT_Send_Publish+0x18d0>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cf3a8:	e7c21000 	strb	r1, [r2, r0]
		APP_DEBUG(" PUBLISH HEART BEAT MESSAGE ");
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());

		for(i=0;i<5;i++)
102cf3ac:	e2822001 	add	r2, r2, #1
102cf3b0:	e3520005 	cmp	r2, #5
102cf3b4:	1afffff8 	bne	102cf39c <MQTT_Send_Publish+0xb64>
102cf3b8:	e59fc504 	ldr	ip, [pc, #1284]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cf3bc:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cf3c0:	ea000355 	b	102d011c <MQTT_Send_Publish+0x18e4>

	case MQTT_LOCK_ACK:
	case MQTT_UNLOCK_ACK:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
102cf3c4:	e3a02c02 	mov	r2, #512	; 0x200
102cf3c8:	e3a01000 	mov	r1, #0
102cf3cc:	e59f03d0 	ldr	r0, [pc, #976]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf3d0:	e12fff36 	blx	r6
102cf3d4:	e59f1324 	ldr	r1, [pc, #804]	; 102cf700 <MQTT_Send_Publish+0xec8>
102cf3d8:	e5943000 	ldr	r3, [r4]
102cf3dc:	e59f03c0 	ldr	r0, [pc, #960]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf3e0:	e12fff33 	blx	r3
102cf3e4:	e59f03b8 	ldr	r0, [pc, #952]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf3e8:	e12fff35 	blx	r5
102cf3ec:	e59f13b0 	ldr	r1, [pc, #944]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf3f0:	e59f3484 	ldr	r3, [pc, #1156]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf3f4:	e59fa390 	ldr	sl, [pc, #912]	; 102cf78c <MQTT_Send_Publish+0xf54>
102cf3f8:	e59f7388 	ldr	r7, [pc, #904]	; 102cf788 <MQTT_Send_Publish+0xf50>
102cf3fc:	e59f8478 	ldr	r8, [pc, #1144]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf400:	e1a02000 	mov	r2, r0
102cf404:	e3a0000a 	mov	r0, #10
102cf408:	e12fff33 	blx	r3
		if( MSG_TYPE == MQTT_LOCK_ACK)
102cf40c:	e35b0010 	cmp	fp, #16
		{
			APP_DEBUG("LOCK_ACK ");
102cf410:	e3a02c02 	mov	r2, #512	; 0x200
102cf414:	e3a01000 	mov	r1, #0
102cf418:	e59f0384 	ldr	r0, [pc, #900]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>

	case MQTT_LOCK_ACK:
	case MQTT_UNLOCK_ACK:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
102cf41c:	e59f336c 	ldr	r3, [pc, #876]	; 102cf790 <MQTT_Send_Publish+0xf58>
		if( MSG_TYPE == MQTT_LOCK_ACK)
102cf420:	0a0005c9 	beq	102d0b4c <MQTT_Send_Publish+0x2314>
		{
			APP_DEBUG("LOCK_ACK ");
		}
		else if( MSG_TYPE == MQTT_UNLOCK_ACK)
		{
			APP_DEBUG("UNLOCK_ACK ");
102cf424:	e12fff33 	blx	r3
102cf428:	e59a3000 	ldr	r3, [sl]
102cf42c:	e59f1304 	ldr	r1, [pc, #772]	; 102cf738 <MQTT_Send_Publish+0xf00>
102cf430:	e59f036c 	ldr	r0, [pc, #876]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf434:	e12fff33 	blx	r3
102cf438:	e59f0364 	ldr	r0, [pc, #868]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf43c:	e12fff37 	blx	r7
102cf440:	e59f135c 	ldr	r1, [pc, #860]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
		}
#endif
		json_root = cJSON_CreateObject();
102cf444:	e59f744c 	ldr	r7, [pc, #1100]	; 102cf898 <MQTT_Send_Publish+0x1060>
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());

		cJSON_AddStringToObject(value,((MSG_TYPE == MQTT_LOCK_ACK) ? MQTT_PAYLOAD_LOCK_ACK : MQTT_PAYLOAD_UNLOCK_ACK), ((Ql_strcmp(lock_unlock_ack, "0") == 0) ? "1" : "0"));
102cf448:	e59f92ec 	ldr	r9, [pc, #748]	; 102cf73c <MQTT_Send_Publish+0xf04>
		{
			APP_DEBUG("LOCK_ACK ");
		}
		else if( MSG_TYPE == MQTT_UNLOCK_ACK)
		{
			APP_DEBUG("UNLOCK_ACK ");
102cf44c:	e1a02000 	mov	r2, r0
102cf450:	e3a0000a 	mov	r0, #10
102cf454:	e12fff38 	blx	r8
		}
#endif
		json_root = cJSON_CreateObject();
102cf458:	e12fff37 	blx	r7
102cf45c:	e58d0028 	str	r0, [sp, #40]	; 0x28
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cf460:	e12fff37 	blx	r7
102cf464:	e59f1430 	ldr	r1, [pc, #1072]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cf468:	e59f7474 	ldr	r7, [pc, #1140]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cf46c:	e1a0a000 	mov	sl, r0
102cf470:	e1a0200a 	mov	r2, sl
102cf474:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
102cf478:	e12fff37 	blx	r7

		cJSON_AddStringToObject(value,((MSG_TYPE == MQTT_LOCK_ACK) ? MQTT_PAYLOAD_LOCK_ACK : MQTT_PAYLOAD_UNLOCK_ACK), ((Ql_strcmp(lock_unlock_ack, "0") == 0) ? "1" : "0"));
102cf47c:	e59f1274 	ldr	r1, [pc, #628]	; 102cf6f8 <MQTT_Send_Publish+0xec0>
102cf480:	e59f32b8 	ldr	r3, [pc, #696]	; 102cf740 <MQTT_Send_Publish+0xf08>
102cf484:	e59f0360 	ldr	r0, [pc, #864]	; 102cf7ec <MQTT_Send_Publish+0xfb4>
102cf488:	e12fff33 	blx	r3
102cf48c:	e59f33fc 	ldr	r3, [pc, #1020]	; 102cf890 <MQTT_Send_Publish+0x1058>
102cf490:	e59f2260 	ldr	r2, [pc, #608]	; 102cf6f8 <MQTT_Send_Publish+0xec0>
102cf494:	e59f8440 	ldr	r8, [pc, #1088]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102cf498:	e3500000 	cmp	r0, #0
102cf49c:	11a00002 	movne	r0, r2
102cf4a0:	01a00003 	moveq	r0, r3
102cf4a4:	e12fff38 	blx	r8
102cf4a8:	e1a01009 	mov	r1, r9
102cf4ac:	e1a02000 	mov	r2, r0
102cf4b0:	e1a0000a 	mov	r0, sl
102cf4b4:	e12fff37 	blx	r7
102cf4b8:	e59f322c 	ldr	r3, [pc, #556]	; 102cf6ec <MQTT_Send_Publish+0xeb4>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cf4bc:	e59f0404 	ldr	r0, [pc, #1028]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());

		cJSON_AddStringToObject(value,((MSG_TYPE == MQTT_LOCK_ACK) ? MQTT_PAYLOAD_LOCK_ACK : MQTT_PAYLOAD_UNLOCK_ACK), ((Ql_strcmp(lock_unlock_ack, "0") == 0) ? "1" : "0"));

		for(i=0;i<5;i++)
102cf4c0:	e3a02000 	mov	r2, #0
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
102cf4c4:	e7d31002 	ldrb	r1, [r3, r2]
102cf4c8:	e3510020 	cmp	r1, #32
102cf4cc:	0a000378 	beq	102d02b4 <MQTT_Send_Publish+0x1a7c>
			{
				Water_data_Publish_without_unit[i] = '\0';
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
102cf4d0:	e7c21000 	strb	r1, [r2, r0]
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());

		cJSON_AddStringToObject(value,((MSG_TYPE == MQTT_LOCK_ACK) ? MQTT_PAYLOAD_LOCK_ACK : MQTT_PAYLOAD_UNLOCK_ACK), ((Ql_strcmp(lock_unlock_ack, "0") == 0) ? "1" : "0"));

		for(i=0;i<5;i++)
102cf4d4:	e2822001 	add	r2, r2, #1
102cf4d8:	e3520005 	cmp	r2, #5
102cf4dc:	1afffff8 	bne	102cf4c4 <MQTT_Send_Publish+0xc8c>
102cf4e0:	e59fc3dc 	ldr	ip, [pc, #988]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cf4e4:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cf4e8:	ea000376 	b	102d02c8 <MQTT_Send_Publish+0x1a90>
	break;

	case MQTT_LOG:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH PENDIGN LOG ");
102cf4ec:	e3a02c02 	mov	r2, #512	; 0x200
102cf4f0:	e3a01000 	mov	r1, #0
102cf4f4:	e59f02a8 	ldr	r0, [pc, #680]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf4f8:	e12fff36 	blx	r6
102cf4fc:	e59f1240 	ldr	r1, [pc, #576]	; 102cf744 <MQTT_Send_Publish+0xf0c>
102cf500:	e5943000 	ldr	r3, [r4]
102cf504:	e59f0298 	ldr	r0, [pc, #664]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf508:	e12fff33 	blx	r3
102cf50c:	e59f0290 	ldr	r0, [pc, #656]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf510:	e12fff35 	blx	r5
102cf514:	e59f1288 	ldr	r1, [pc, #648]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf518:	e59f335c 	ldr	r3, [pc, #860]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf51c:	e1a02000 	mov	r2, r0
102cf520:	e3a0000a 	mov	r0, #10
102cf524:	e12fff33 	blx	r3
#endif
		// Open the log file that stored unpublished MQTT messages or pending messgaes
		filehandleData = fileSys_OpenOrCreateFile((u8*)file_data);
102cf528:	e59f3218 	ldr	r3, [pc, #536]	; 102cf748 <MQTT_Send_Publish+0xf10>
102cf52c:	e5930000 	ldr	r0, [r3]
102cf530:	e59f3214 	ldr	r3, [pc, #532]	; 102cf74c <MQTT_Send_Publish+0xf14>
102cf534:	e12fff33 	blx	r3

		if(filehandleData >= QL_RET_OK)
102cf538:	e3500000 	cmp	r0, #0
102cf53c:	e58d0030 	str	r0, [sp, #48]	; 0x30
102cf540:	ba00042d 	blt	102d05fc <MQTT_Send_Publish+0x1dc4>
102cf544:	e59fc328 	ldr	ip, [pc, #808]	; 102cf874 <MQTT_Send_Publish+0x103c>
102cf548:	e3a0802f 	mov	r8, #47	; 0x2f
102cf54c:	e58dc028 	str	ip, [sp, #40]	; 0x28
102cf550:	e59fa2ac 	ldr	sl, [pc, #684]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102cf554:	e3a0c000 	mov	ip, #0
102cf558:	e59f91f0 	ldr	r9, [pc, #496]	; 102cf750 <MQTT_Send_Publish+0xf18>
102cf55c:	e1a07008 	mov	r7, r8
102cf560:	e1a0800c 	mov	r8, ip
102cf564:	e58dc03c 	str	ip, [sp, #60]	; 0x3c
102cf568:	e58db024 	str	fp, [sp, #36]	; 0x24
		{
			for(i = 0; (invalid_payload+valid_payload)<MAX_PAYLOADS+1 ; i++) // Scan for all payloads in the file one by one
			{
				if(i>MAX_PAYLOADS)
102cf56c:	e358002e 	cmp	r8, #46	; 0x2e
102cf570:	e3a020c8 	mov	r2, #200	; 0xc8
102cf574:	e0010892 	mul	r1, r2, r8
102cf578:	c3a08000 	movgt	r8, #0
					i=0;
102cf57c:	c1a01008 	movgt	r1, r8
				ret = Ql_FS_Seek(filehandleData, i*PAYLOAD_LENGTH , QL_FS_FILE_BEGIN); // Point to the start of required message in the file
102cf580:	e3a02000 	mov	r2, #0
102cf584:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
102cf588:	e12fff39 	blx	r9
				{
#ifdef DEBUG_MQTT
					APP_DEBUG("\r\n<--Error : Ql_FS_Seek ret : %d-->\r\n",ret);
#endif
				}
				payload = (char*)Ql_MEM_Alloc(PAYLOAD_LENGTH);
102cf58c:	e3a000c8 	mov	r0, #200	; 0xc8
102cf590:	e12fff3a 	blx	sl
				Ql_memset(payload, 0x0,PAYLOAD_LENGTH );
102cf594:	e3a020c8 	mov	r2, #200	; 0xc8
102cf598:	e3a01000 	mov	r1, #0
				{
#ifdef DEBUG_MQTT
					APP_DEBUG("\r\n<--Error : Ql_FS_Seek ret : %d-->\r\n",ret);
#endif
				}
				payload = (char*)Ql_MEM_Alloc(PAYLOAD_LENGTH);
102cf59c:	e1a0b000 	mov	fp, r0
				Ql_memset(payload, 0x0,PAYLOAD_LENGTH );
102cf5a0:	e12fff36 	blx	r6
				ret = Ql_FS_Read(filehandleData,(u8*)payload,PAYLOAD_LENGTH, &readedlen); // Read the payload from the file
102cf5a4:	e59f31a8 	ldr	r3, [pc, #424]	; 102cf754 <MQTT_Send_Publish+0xf1c>
102cf5a8:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
102cf5ac:	e1a0100b 	mov	r1, fp
102cf5b0:	e3a020c8 	mov	r2, #200	; 0xc8
102cf5b4:	e59fc19c 	ldr	ip, [pc, #412]	; 102cf758 <MQTT_Send_Publish+0xf20>
102cf5b8:	e12fff3c 	blx	ip
#ifdef DEBUG_MQTT
					APP_DEBUG("\r\n<--nError : Ql_FS_Read ret : %d-->\r\n",ret);
#endif
				}

				if(payload[0] != '{') //A payload is invalid if it start with character other than '{'
102cf5bc:	e5db3000 	ldrb	r3, [fp]
				{
					invalid_payload++;

					Ql_MEM_Free(payload);
102cf5c0:	e1a0000b 	mov	r0, fp
#ifdef DEBUG_MQTT
					APP_DEBUG("\r\n<--nError : Ql_FS_Read ret : %d-->\r\n",ret);
#endif
				}

				if(payload[0] != '{') //A payload is invalid if it start with character other than '{'
102cf5c4:	e353007b 	cmp	r3, #123	; 0x7b
102cf5c8:	1a0004a5 	bne	102d0864 <MQTT_Send_Publish+0x202c>
102cf5cc:	e1a0700b 	mov	r7, fp
102cf5d0:	e58d803c 	str	r8, [sp, #60]	; 0x3c
102cf5d4:	e59db024 	ldr	fp, [sp, #36]	; 0x24
				}
				else if(payload[0] == '{') // A valid palyload will always start with character '{'
				{
					valid_payload++;

					payloadlen = Ql_strlen(payload); // Find out the payload length
102cf5d8:	e12fff35 	blx	r5

					buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cf5dc:	e59f3220 	ldr	r3, [pc, #544]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102cf5e0:	e280a064 	add	sl, r0, #100	; 0x64
				}
				else if(payload[0] == '{') // A valid palyload will always start with character '{'
				{
					valid_payload++;

					payloadlen = Ql_strlen(payload); // Find out the payload length
102cf5e4:	e1a09000 	mov	r9, r0

					buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cf5e8:	e1a0000a 	mov	r0, sl
102cf5ec:	e12fff33 	blx	r3
					buflen= payloadlen+100;

					// Check the topic of payload message ..it is one out of DATA or EVENT or ACK to topic_subscibe
					if(payload[2]=='D')
102cf5f0:	e5d73002 	ldrb	r3, [r7, #2]
102cf5f4:	e3530044 	cmp	r3, #68	; 0x44
				{
					valid_payload++;

					payloadlen = Ql_strlen(payload); // Find out the payload length

					buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cf5f8:	e58d002c 	str	r0, [sp, #44]	; 0x2c
					buflen= payloadlen+100;

					// Check the topic of payload message ..it is one out of DATA or EVENT or ACK to topic_subscibe
					if(payload[2]=='D')
102cf5fc:	0a000661 	beq	102d0f88 <MQTT_Send_Publish+0x2750>
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_DATA);
					}
					else if(payload[2]=='E')
102cf600:	e3530045 	cmp	r3, #69	; 0x45
102cf604:	0a00065a 	beq	102d0f74 <MQTT_Send_Publish+0x273c>
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
					}
					else if(payload[2] == 'A')
102cf608:	e3530041 	cmp	r3, #65	; 0x41
102cf60c:	0a00066a 	beq	102d0fbc <MQTT_Send_Publish+0x2784>
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_ACK);
					}
					topicString.cstring = topic_subscibe;
102cf610:	e28d30c0 	add	r3, sp, #192	; 0xc0
102cf614:	e28d105c 	add	r1, sp, #92	; 0x5c
102cf618:	e5231070 	str	r1, [r3, #-112]!	; 0xffffff90
					payload[2]='d';   //replace payload[2] with "d" to published to cloud
					len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cf61c:	e8930007 	ldm	r3, {r0, r1, r2}
102cf620:	e3a08000 	mov	r8, #0
102cf624:	e28dc008 	add	ip, sp, #8
					else if(payload[2] == 'A')
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_ACK);
					}
					topicString.cstring = topic_subscibe;
					payload[2]='d';   //replace payload[2] with "d" to published to cloud
102cf628:	e3a03064 	mov	r3, #100	; 0x64
102cf62c:	e5c73002 	strb	r3, [r7, #2]
					len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cf630:	e1a03008 	mov	r3, r8
102cf634:	e58d8000 	str	r8, [sp]
102cf638:	e58d8004 	str	r8, [sp, #4]
102cf63c:	e88c0007 	stm	ip, {r0, r1, r2}
102cf640:	e59fc198 	ldr	ip, [pc, #408]	; 102cf7e0 <MQTT_Send_Publish+0xfa8>
102cf644:	e1a0100a 	mov	r1, sl
102cf648:	e1a02008 	mov	r2, r8
102cf64c:	e58d9018 	str	r9, [sp, #24]
102cf650:	e58d7014 	str	r7, [sp, #20]
102cf654:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
102cf658:	e12fff3c 	blx	ip

					LOG_MESSAGES_AVAILABLE = TRUE;
#ifdef DEBUG_MSG
					APP_DEBUG(" [%d] ", i);
102cf65c:	e1a01008 	mov	r1, r8
102cf660:	e3a02c02 	mov	r2, #512	; 0x200
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_ACK);
					}
					topicString.cstring = topic_subscibe;
					payload[2]='d';   //replace payload[2] with "d" to published to cloud
					len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cf664:	e1a09000 	mov	r9, r0

					LOG_MESSAGES_AVAILABLE = TRUE;
#ifdef DEBUG_MSG
					APP_DEBUG(" [%d] ", i);
102cf668:	e59f0134 	ldr	r0, [pc, #308]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf66c:	e12fff36 	blx	r6
102cf670:	e59f10e4 	ldr	r1, [pc, #228]	; 102cf75c <MQTT_Send_Publish+0xf24>
102cf674:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
102cf678:	e5943000 	ldr	r3, [r4]
102cf67c:	e59f0120 	ldr	r0, [pc, #288]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf680:	e12fff33 	blx	r3
102cf684:	e59f0118 	ldr	r0, [pc, #280]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf688:	e12fff35 	blx	r5
102cf68c:	e59f1110 	ldr	r1, [pc, #272]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf690:	e59f31e4 	ldr	r3, [pc, #484]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf694:	e1a02000 	mov	r2, r0
102cf698:	e3a0000a 	mov	r0, #10
102cf69c:	e12fff33 	blx	r3
102cf6a0:	e3a0c001 	mov	ip, #1
102cf6a4:	e58dc034 	str	ip, [sp, #52]	; 0x34
102cf6a8:	e59fc214 	ldr	ip, [pc, #532]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cf6ac:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cf6b0:	ea0000f7 	b	102cfa94 <MQTT_Send_Publish+0x125c>
102cf6b4:	102df9d5 	.word	0x102df9d5
102cf6b8:	f03d5730 	.word	0xf03d5730
102cf6bc:	102ee9e4 	.word	0x102ee9e4
102cf6c0:	f03d57b4 	.word	0xf03d57b4
102cf6c4:	102eea08 	.word	0x102eea08
102cf6c8:	102eec3c 	.word	0x102eec3c
102cf6cc:	102eed18 	.word	0x102eed18
102cf6d0:	102eed48 	.word	0x102eed48
102cf6d4:	f03da522 	.word	0xf03da522
102cf6d8:	102edef4 	.word	0x102edef4
102cf6dc:	f03da52c 	.word	0xf03da52c
102cf6e0:	f03da528 	.word	0xf03da528
102cf6e4:	f03da53a 	.word	0xf03da53a
102cf6e8:	102eeaa0 	.word	0x102eeaa0
102cf6ec:	f03da518 	.word	0xf03da518
102cf6f0:	102eea20 	.word	0x102eea20
102cf6f4:	102eea38 	.word	0x102eea38
102cf6f8:	102efd90 	.word	0x102efd90
102cf6fc:	102e6fec 	.word	0x102e6fec
102cf700:	102eea50 	.word	0x102eea50
102cf704:	102eea94 	.word	0x102eea94
102cf708:	102e703c 	.word	0x102e703c
102cf70c:	102eeb00 	.word	0x102eeb00
102cf710:	102e709c 	.word	0x102e709c
102cf714:	102eeb18 	.word	0x102eeb18
102cf718:	102e70a4 	.word	0x102e70a4
102cf71c:	102eeb34 	.word	0x102eeb34
102cf720:	f03da564 	.word	0xf03da564
102cf724:	102e70b8 	.word	0x102e70b8
102cf728:	f03da548 	.word	0xf03da548
102cf72c:	102e70c0 	.word	0x102e70c0
102cf730:	f03da580 	.word	0xf03da580
102cf734:	102eeba0 	.word	0x102eeba0
102cf738:	102eeb7c 	.word	0x102eeb7c
102cf73c:	102e6fe0 	.word	0x102e6fe0
102cf740:	102e581c 	.word	0x102e581c
102cf744:	102eebe4 	.word	0x102eebe4
102cf748:	f03d20a4 	.word	0xf03d20a4
102cf74c:	102d2e00 	.word	0x102d2e00
102cf750:	102e41a8 	.word	0x102e41a8
102cf754:	f03db8f8 	.word	0xf03db8f8
102cf758:	102e40b8 	.word	0x102e40b8
102cf75c:	102eebfc 	.word	0x102eebfc
102cf760:	102eeb58 	.word	0x102eeb58
102cf764:	f03da824 	.word	0xf03da824
102cf768:	102e70cc 	.word	0x102e70cc
102cf76c:	f03da830 	.word	0xf03da830
102cf770:	102e70d0 	.word	0x102e70d0
102cf774:	102eed70 	.word	0x102eed70
102cf778:	f03da5f0 	.word	0xf03da5f0
102cf77c:	102eeb88 	.word	0x102eeb88
102cf780:	102cd7a4 	.word	0x102cd7a4
102cf784:	102eebc0 	.word	0x102eebc0
102cf788:	102e57a4 	.word	0x102e57a4
102cf78c:	f03de540 	.word	0xf03de540
102cf790:	102e58f4 	.word	0x102e58f4
102cf794:	102eebd4 	.word	0x102eebd4
102cf798:	102eebe0 	.word	0x102eebe0
102cf79c:	102e70d4 	.word	0x102e70d4
102cf7a0:	102eec04 	.word	0x102eec04
102cf7a4:	f03d57e4 	.word	0xf03d57e4
102cf7a8:	102eec20 	.word	0x102eec20
102cf7ac:	f03d5a30 	.word	0xf03d5a30
102cf7b0:	102e7050 	.word	0x102e7050
102cf7b4:	f03d5a3c 	.word	0xf03d5a3c
102cf7b8:	102e7058 	.word	0x102e7058
102cf7bc:	f03d5a48 	.word	0xf03d5a48
102cf7c0:	102e7060 	.word	0x102e7060
102cf7c4:	102eeb30 	.word	0x102eeb30
102cf7c8:	f03d5a64 	.word	0xf03d5a64
102cf7cc:	f03d5a80 	.word	0xf03d5a80
102cf7d0:	f03d5a24 	.word	0xf03d5a24
102cf7d4:	102e7044 	.word	0x102e7044
102cf7d8:	f03d2050 	.word	0xf03d2050
102cf7dc:	102e5724 	.word	0x102e5724
102cf7e0:	102ce04c 	.word	0x102ce04c
102cf7e4:	102e70c8 	.word	0x102e70c8
102cf7e8:	f03d2040 	.word	0xf03d2040
102cf7ec:	f03d5a9c 	.word	0xf03d5a9c
102cf7f0:	102e70ac 	.word	0x102e70ac
102cf7f4:	f03d57c8 	.word	0xf03d57c8
102cf7f8:	102e7020 	.word	0x102e7020
102cf7fc:	102d775c 	.word	0x102d775c
102cf800:	102d80cc 	.word	0x102d80cc
102cf804:	102e4840 	.word	0x102e4840
102cf808:	102d6f68 	.word	0x102d6f68
102cf80c:	f03d2060 	.word	0xf03d2060
102cf810:	102dcb4c 	.word	0x102dcb4c
102cf814:	102d2f9c 	.word	0x102d2f9c
102cf818:	102dced0 	.word	0x102dced0
102cf81c:	000010c8 	.word	0x000010c8
102cf820:	102e5cb4 	.word	0x102e5cb4
102cf824:	f03d5bac 	.word	0xf03d5bac
102cf828:	102e55fc 	.word	0x102e55fc
102cf82c:	f03d5acc 	.word	0xf03d5acc
102cf830:	102eeca8 	.word	0x102eeca8
102cf834:	f03d5b00 	.word	0xf03d5b00
102cf838:	102eecc0 	.word	0x102eecc0
102cf83c:	f03d5b0c 	.word	0xf03d5b0c
102cf840:	102eecd8 	.word	0x102eecd8
102cf844:	f03d5ac0 	.word	0xf03d5ac0
102cf848:	102eec9c 	.word	0x102eec9c
102cf84c:	f03d5aa4 	.word	0xf03d5aa4
102cf850:	102eec90 	.word	0x102eec90
102cf854:	f03d2090 	.word	0xf03d2090
102cf858:	102eec80 	.word	0x102eec80
102cf85c:	f03d2084 	.word	0xf03d2084
102cf860:	102eec74 	.word	0x102eec74
102cf864:	f03d2078 	.word	0xf03d2078
102cf868:	102eec68 	.word	0x102eec68
102cf86c:	f03d2070 	.word	0xf03d2070
102cf870:	102eec5c 	.word	0x102eec5c
102cf874:	102e48b8 	.word	0x102e48b8
102cf878:	102eea14 	.word	0x102eea14
102cf87c:	102e6230 	.word	0x102e6230
102cf880:	102eea74 	.word	0x102eea74
102cf884:	102e702c 	.word	0x102e702c
102cf888:	102eeb6c 	.word	0x102eeb6c
102cf88c:	f03d57e4 	.word	0xf03d57e4
102cf890:	102ee9e0 	.word	0x102ee9e0
102cf894:	102eeac8 	.word	0x102eeac8
102cf898:	102d7da8 	.word	0x102d7da8
102cf89c:	102ef9b8 	.word	0x102ef9b8
102cf8a0:	102e7070 	.word	0x102e7070
102cf8a4:	102eea40 	.word	0x102eea40
102cf8a8:	102e6ff4 	.word	0x102e6ff4
102cf8ac:	102eea44 	.word	0x102eea44
102cf8b0:	102e7004 	.word	0x102e7004
102cf8b4:	f03d59ec 	.word	0xf03d59ec
102cf8b8:	102e7010 	.word	0x102e7010
102cf8bc:	f03d5a08 	.word	0xf03d5a08
102cf8c0:	102e7018 	.word	0x102e7018
102cf8c4:	f03d572c 	.word	0xf03d572c
102cf8c8:	f03d59e4 	.word	0xf03d59e4
102cf8cc:	102e6ff0 	.word	0x102e6ff0
102cf8d0:	f03da598 	.word	0xf03da598
102cf8d4:	f03da908 	.word	0xf03da908
102cf8d8:	102eed10 	.word	0x102eed10
102cf8dc:	102d7cf8 	.word	0x102d7cf8
102cf8e0:	f03da924 	.word	0xf03da924
102cf8e4:	102d79d8 	.word	0x102d79d8
102cf8e8:	102eed08 	.word	0x102eed08
	break;

	case MQTT_LOCATION:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_LOCATION ");
102cf8ec:	e3a02c02 	mov	r2, #512	; 0x200
102cf8f0:	e3a01000 	mov	r1, #0
102cf8f4:	e51f0158 	ldr	r0, [pc, #-344]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf8f8:	e12fff36 	blx	r6
102cf8fc:	e51f11a4 	ldr	r1, [pc, #-420]	; 102cf760 <MQTT_Send_Publish+0xf28>
102cf900:	e5943000 	ldr	r3, [r4]
102cf904:	e51f0168 	ldr	r0, [pc, #-360]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf908:	e12fff33 	blx	r3
102cf90c:	e51f0170 	ldr	r0, [pc, #-368]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cf910:	e12fff35 	blx	r5
#endif
		json_root = cJSON_CreateObject();
102cf914:	e51f7084 	ldr	r7, [pc, #-132]	; 102cf898 <MQTT_Send_Publish+0x1060>
	break;

	case MQTT_LOCATION:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_LOCATION ");
102cf918:	e51f30a4 	ldr	r3, [pc, #-164]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cf91c:	e51f1180 	ldr	r1, [pc, #-384]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_LAT,latitude_);
102cf920:	e51f904c 	ldr	r9, [pc, #-76]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
	break;

	case MQTT_LOCATION:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_LOCATION ");
102cf924:	e1a02000 	mov	r2, r0
102cf928:	e3a0000a 	mov	r0, #10
102cf92c:	e12fff33 	blx	r3
#endif
		json_root = cJSON_CreateObject();
102cf930:	e12fff37 	blx	r7
102cf934:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cf938:	e12fff37 	blx	r7
102cf93c:	e51f7060 	ldr	r7, [pc, #-96]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cf940:	e51f10ac 	ldr	r1, [pc, #-172]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cf944:	e1a08000 	mov	r8, r0
102cf948:	e1a02008 	mov	r2, r8
102cf94c:	e1a0000a 	mov	r0, sl
102cf950:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_LAT,latitude_);
102cf954:	e51f01f8 	ldr	r0, [pc, #-504]	; 102cf764 <MQTT_Send_Publish+0xf2c>
102cf958:	e12fff39 	blx	r9
102cf95c:	e51f11fc 	ldr	r1, [pc, #-508]	; 102cf768 <MQTT_Send_Publish+0xf30>
102cf960:	e1a02000 	mov	r2, r0
102cf964:	e1a00008 	mov	r0, r8
102cf968:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_LON,longitude_);
102cf96c:	e51f0208 	ldr	r0, [pc, #-520]	; 102cf76c <MQTT_Send_Publish+0xf34>
102cf970:	e12fff39 	blx	r9
102cf974:	e51f120c 	ldr	r1, [pc, #-524]	; 102cf770 <MQTT_Send_Publish+0xf38>
102cf978:	e1a02000 	mov	r2, r0
102cf97c:	e1a00008 	mov	r0, r8
102cf980:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_ID,Received_RCID);
102cf984:	e51f00d8 	ldr	r0, [pc, #-216]	; 102cf8b4 <MQTT_Send_Publish+0x107c>
102cf988:	e12fff39 	blx	r9
102cf98c:	e51f10dc 	ldr	r1, [pc, #-220]	; 102cf8b8 <MQTT_Send_Publish+0x1080>
102cf990:	e1a02000 	mov	r2, r0
102cf994:	e1a00008 	mov	r0, r8
102cf998:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_TS,Received_RCTS);
102cf99c:	e51f00e8 	ldr	r0, [pc, #-232]	; 102cf8bc <MQTT_Send_Publish+0x1084>
102cf9a0:	e12fff39 	blx	r9
102cf9a4:	e51f10ec 	ldr	r1, [pc, #-236]	; 102cf8c0 <MQTT_Send_Publish+0x1088>
102cf9a8:	e1a02000 	mov	r2, r0
102cf9ac:	e1a00008 	mov	r0, r8
102cf9b0:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);
102cf9b4:	e51f01c8 	ldr	r0, [pc, #-456]	; 102cf7f4 <MQTT_Send_Publish+0xfbc>
102cf9b8:	e12fff39 	blx	r9
102cf9bc:	e51f11cc 	ldr	r1, [pc, #-460]	; 102cf7f8 <MQTT_Send_Publish+0xfc0>
102cf9c0:	e1a02000 	mov	r2, r0
102cf9c4:	e1a00008 	mov	r0, r8
102cf9c8:	e12fff37 	blx	r7


		payload = cJSON_Print(json_root);
102cf9cc:	e51f31d8 	ldr	r3, [pc, #-472]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102cf9d0:	e1a0000a 	mov	r0, sl
102cf9d4:	e12fff33 	blx	r3
102cf9d8:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102cf9dc:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102cf9e0:	e51f31e8 	ldr	r3, [pc, #-488]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102cf9e4:	e1a00007 	mov	r0, r7
102cf9e8:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102cf9ec:	e1a00007 	mov	r0, r7
102cf9f0:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cf9f4:	e51f31f8 	ldr	r3, [pc, #-504]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102cf9f8:	e2808064 	add	r8, r0, #100	; 0x64


		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102cf9fc:	e1a09000 	mov	r9, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cfa00:	e1a00008 	mov	r0, r8
102cfa04:	e12fff33 	blx	r3
		buflen = payloadlen+100;
		cJSON_Delete(json_root);
102cfa08:	e51f3208 	ldr	r3, [pc, #-520]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cfa0c:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen = payloadlen+100;
		cJSON_Delete(json_root);
102cfa10:	e1a0000a 	mov	r0, sl
102cfa14:	e12fff33 	blx	r3

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_DATA);
102cfa18:	e51f1248 	ldr	r1, [pc, #-584]	; 102cf7d8 <MQTT_Send_Publish+0xfa0>
102cfa1c:	e28d005c 	add	r0, sp, #92	; 0x5c

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
		buflen= payloadlen+100;
		cJSON_Delete(json_root);

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
102cfa20:	e51f324c 	ldr	r3, [pc, #-588]	; 102cf7dc <MQTT_Send_Publish+0xfa4>
102cfa24:	e12fff33 	blx	r3
		topicString.cstring = topic_subscibe;
102cfa28:	e28d30c0 	add	r3, sp, #192	; 0xc0
102cfa2c:	e28dc05c 	add	ip, sp, #92	; 0x5c
102cfa30:	e523c070 	str	ip, [r3, #-112]!	; 0xffffff90

		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cfa34:	e8930007 	ldm	r3, {r0, r1, r2}
102cfa38:	e3a0a000 	mov	sl, #0
102cfa3c:	e28dc008 	add	ip, sp, #8
102cfa40:	e58da000 	str	sl, [sp]
102cfa44:	e58da004 	str	sl, [sp, #4]
102cfa48:	e1a0300a 	mov	r3, sl
102cfa4c:	e88c0007 	stm	ip, {r0, r1, r2}
102cfa50:	e58d9018 	str	r9, [sp, #24]
102cfa54:	e58d7014 	str	r7, [sp, #20]
102cfa58:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
102cfa5c:	e1a01008 	mov	r1, r8
102cfa60:	e1a0200a 	mov	r2, sl
102cfa64:	e51fc28c 	ldr	ip, [pc, #-652]	; 102cf7e0 <MQTT_Send_Publish+0xfa8>
102cfa68:	e12fff3c 	blx	ip
	}
	break;
102cfa6c:	e58da034 	str	sl, [sp, #52]	; 0x34
		cJSON_Delete(json_root);

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
		topicString.cstring = topic_subscibe;

		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cfa70:	e1a09000 	mov	r9, r0
		topicString.cstring = topic_subscibe;

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, NULL, 0);
	}
	break;
102cfa74:	e3a0c011 	mov	ip, #17
102cfa78:	e58dc03c 	str	ip, [sp, #60]	; 0x3c
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
	bool LOG_MESSAGES_AVAILABLE = FALSE;
	s32  filehandleData = -1;
102cfa7c:	e3e0c000 	mvn	ip, #0
102cfa80:	e58dc030 	str	ip, [sp, #48]	; 0x30
102cfa84:	e51fc1c8 	ldr	ip, [pc, #-456]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cfa88:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cfa8c:	e51fc220 	ldr	ip, [pc, #-544]	; 102cf874 <MQTT_Send_Publish+0x103c>
102cfa90:	e58dc028 	str	ip, [sp, #40]	; 0x28

	default:
		break;
	}
#ifdef DEBUG_MSG
	APP_DEBUG("*****-->\r\n");
102cfa94:	e3a02c02 	mov	r2, #512	; 0x200
102cfa98:	e3a01000 	mov	r1, #0
102cfa9c:	e51f0300 	ldr	r0, [pc, #-768]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfaa0:	e12fff36 	blx	r6
102cfaa4:	e51f1234 	ldr	r1, [pc, #-564]	; 102cf878 <MQTT_Send_Publish+0x1040>
102cfaa8:	e5943000 	ldr	r3, [r4]
102cfaac:	e51f0310 	ldr	r0, [pc, #-784]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfab0:	e12fff33 	blx	r3
102cfab4:	e51f0318 	ldr	r0, [pc, #-792]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfab8:	e12fff35 	blx	r5
102cfabc:	e51f1320 	ldr	r1, [pc, #-800]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfac0:	e51fc24c 	ldr	ip, [pc, #-588]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cfac4:	e1a02000 	mov	r2, r0
102cfac8:	e3a0000a 	mov	r0, #10
102cfacc:	e12fff3c 	blx	ip
		return rc;
	}

	//There is a definite message to transmit..
#ifdef DEBUG_MSG
	APP_DEBUG("<--Message Paylod : %s -->\r\n",payload);
102cfad0:	e3a01000 	mov	r1, #0
102cfad4:	e3a02c02 	mov	r2, #512	; 0x200
102cfad8:	e51f033c 	ldr	r0, [pc, #-828]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfadc:	e12fff36 	blx	r6
102cfae0:	e51f1374 	ldr	r1, [pc, #-884]	; 102cf774 <MQTT_Send_Publish+0xf3c>
102cfae4:	e1a02007 	mov	r2, r7
102cfae8:	e5943000 	ldr	r3, [r4]
102cfaec:	e51f0350 	ldr	r0, [pc, #-848]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfaf0:	e12fff33 	blx	r3
102cfaf4:	e51f0358 	ldr	r0, [pc, #-856]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfaf8:	e12fff35 	blx	r5
#endif
	//Check the gprs and socket connection status and autoprovisioning status
	//if its ok then send data over tcp ip
	//also check return of data send

	if((FLAG.SSL_CONNECTION_STATE == TRUE) &&  (FLAG.GPRS_ACTIVE == TRUE) && (FLAG.AUTOPROVISIONING_COMPLETE == TRUE))
102cfafc:	e51f838c 	ldr	r8, [pc, #-908]	; 102cf778 <MQTT_Send_Publish+0xf40>
		return rc;
	}

	//There is a definite message to transmit..
#ifdef DEBUG_MSG
	APP_DEBUG("<--Message Paylod : %s -->\r\n",payload);
102cfb00:	e51f328c 	ldr	r3, [pc, #-652]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cfb04:	e51f1368 	ldr	r1, [pc, #-872]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfb08:	e1a02000 	mov	r2, r0
102cfb0c:	e3a0000a 	mov	r0, #10
102cfb10:	e12fff33 	blx	r3
#endif
	//Check the gprs and socket connection status and autoprovisioning status
	//if its ok then send data over tcp ip
	//also check return of data send

	if((FLAG.SSL_CONNECTION_STATE == TRUE) &&  (FLAG.GPRS_ACTIVE == TRUE) && (FLAG.AUTOPROVISIONING_COMPLETE == TRUE))
102cfb14:	e5d83010 	ldrb	r3, [r8, #16]
102cfb18:	e3530001 	cmp	r3, #1
102cfb1c:	1a000002 	bne	102cfb2c <MQTT_Send_Publish+0x12f4>
102cfb20:	e5d83000 	ldrb	r3, [r8]
102cfb24:	e3530001 	cmp	r3, #1
102cfb28:	0a000222 	beq	102d03b8 <MQTT_Send_Publish+0x1b80>
			FLAG.CON_MSG_PUBLISH_PENDING = TRUE; // At next successful connection it is required to publish the connection ON record so enable this flag
		}
	}
	else
	{
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102cfb2c:	e3a02002 	mov	r2, #2
102cfb30:	e3a00003 	mov	r0, #3
102cfb34:	e51f1320 	ldr	r1, [pc, #-800]	; 102cf81c <MQTT_Send_Publish+0xfe4>
102cfb38:	e1a03002 	mov	r3, r2
102cfb3c:	e51f9324 	ldr	r9, [pc, #-804]	; 102cf820 <MQTT_Send_Publish+0xfe8>
102cfb40:	e12fff39 	blx	r9

		//Message failed to publish will be storeed in the log
		if((MSG_TYPE != MQTT_PING_REQUEST_AZURE) // Do not store PING message
102cfb44:	e35b0018 	cmp	fp, #24
102cfb48:	135b0013 	cmpne	fp, #19
102cfb4c:	0a000007 	beq	102cfb70 <MQTT_Send_Publish+0x1338>
				&& (MSG_TYPE != MQTT_LOG) // Do not store log record
				&& (MSG_TYPE != MQTT_HEART_BEAT_MESSAGE) //Do not store regular heart beat events
				&& (MSG_TYPE != MQTT_TWIN_PROPERTIES)//Do not Store Device Twin related events
102cfb50:	e35b0040 	cmp	fp, #64	; 0x40
102cfb54:	135b0014 	cmpne	fp, #20
102cfb58:	0a000004 	beq	102cfb70 <MQTT_Send_Publish+0x1338>
				&& (MSG_TYPE != MQTT_TWIN_REPORTED)//Do not Store Device Twin reported related events
102cfb5c:	e35b0041 	cmp	fp, #65	; 0x41
102cfb60:	0a000002 	beq	102cfb70 <MQTT_Send_Publish+0x1338>
				&& (FLAG.SSL_X509_CERTPRESENT == TRUE)) // Do not write log messages in case of device not configured with certificates
102cfb64:	e5d83015 	ldrb	r3, [r8, #21]
102cfb68:	e3530001 	cmp	r3, #1
102cfb6c:	0a000370 	beq	102d0934 <MQTT_Send_Publish+0x20fc>
					}
				}
			}
			Write_And_Store_Pending_MQTT_Log_Messages(payload);
		}
		Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_GET_GPRS_STRENGTH,0);
102cfb70:	e3a00000 	mov	r0, #0
102cfb74:	e51f1360 	ldr	r1, [pc, #-864]	; 102cf81c <MQTT_Send_Publish+0xfe4>
102cfb78:	e3a02004 	mov	r2, #4
102cfb7c:	e1a03000 	mov	r3, r0
102cfb80:	e12fff39 	blx	r9
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_ANTENNA_SYMBOL);
102cfb84:	e3a02002 	mov	r2, #2
102cfb88:	e3a03000 	mov	r3, #0
102cfb8c:	e3a00003 	mov	r0, #3
102cfb90:	e51f137c 	ldr	r1, [pc, #-892]	; 102cf81c <MQTT_Send_Publish+0xfe4>
102cfb94:	e12fff39 	blx	r9
		FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = TRUE; // Enable this flag to re-attempt the GPRS reconnect
		FLAG.MQTT_CONNECTION_STATUS = FALSE; // Mark the connection not available flag
102cfb98:	e3a02000 	mov	r2, #0
			}
			Write_And_Store_Pending_MQTT_Log_Messages(payload);
		}
		Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_GET_GPRS_STRENGTH,0);
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_ANTENNA_SYMBOL);
		FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = TRUE; // Enable this flag to re-attempt the GPRS reconnect
102cfb9c:	e3a03001 	mov	r3, #1
	s32  filehandleData = -1;
	unsigned char invalid_payload = 0,valid_payload=0;
	s32 ret=PASS,i=0;
	char msg_id[18];
	char string_temp[10] = {0};
	s32 rc = 0;
102cfba0:	e1a0a002 	mov	sl, r2
			}
			Write_And_Store_Pending_MQTT_Log_Messages(payload);
		}
		Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_GET_GPRS_STRENGTH,0);
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_ANTENNA_SYMBOL);
		FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = TRUE; // Enable this flag to re-attempt the GPRS reconnect
102cfba4:	e5c8300c 	strb	r3, [r8, #12]
		FLAG.MQTT_CONNECTION_STATUS = FALSE; // Mark the connection not available flag
102cfba8:	e5c8200d 	strb	r2, [r8, #13]
		FLAG.CON_MSG_PUBLISH_PENDING = TRUE; // At next successful connection it is required to publish the connection ON record so enable this flag
102cfbac:	e5c83004 	strb	r3, [r8, #4]
	}
	if(MSG_TYPE == MQTT_POWER_OFF)
102cfbb0:	e35b0003 	cmp	fp, #3
102cfbb4:	0a0001f8 	beq	102d039c <MQTT_Send_Publish+0x1b64>
		FLAG.POWER_OFF_MSG_PROCESSED = TRUE;
	//-------------------------------------------------------
	if(MSG_TYPE == MQTT_LOG)
102cfbb8:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
102cfbbc:	e35c0000 	cmp	ip, #0
102cfbc0:	1a0001f8 	bne	102d03a8 <MQTT_Send_Publish+0x1b70>
		fileSys_CloseFile(filehandleData); // Close the file
	Ql_MEM_Free(payload);
102cfbc4:	e1a00007 	mov	r0, r7
102cfbc8:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
102cfbcc:	e12fff3c 	blx	ip
	payload = NULL;
	Ql_MEM_Free(buf_ssl);
102cfbd0:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
102cfbd4:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
102cfbd8:	e12fff3c 	blx	ip
102cfbdc:	eafffc19 	b	102cec48 <MQTT_Send_Publish+0x410>
	break;

	case MQTT_PING_REQUEST_AZURE:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PING - AZURE_IOTHUB ");
102cfbe0:	e3a02c02 	mov	r2, #512	; 0x200
102cfbe4:	e3a01000 	mov	r1, #0
102cfbe8:	e51f044c 	ldr	r0, [pc, #-1100]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfbec:	e12fff36 	blx	r6
102cfbf0:	e51f147c 	ldr	r1, [pc, #-1148]	; 102cf77c <MQTT_Send_Publish+0xf44>
102cfbf4:	e5943000 	ldr	r3, [r4]
102cfbf8:	e51f045c 	ldr	r0, [pc, #-1116]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfbfc:	e12fff33 	blx	r3
102cfc00:	e51f0464 	ldr	r0, [pc, #-1124]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfc04:	e12fff35 	blx	r5
102cfc08:	e51f146c 	ldr	r1, [pc, #-1132]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfc0c:	e51f3398 	ldr	r3, [pc, #-920]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cfc10:	e1a02000 	mov	r2, r0
102cfc14:	e3a0000a 	mov	r0, #10
102cfc18:	e12fff33 	blx	r3
#endif
		buf_ssl = (char *)Ql_MEM_Alloc(100);
102cfc1c:	e51f3420 	ldr	r3, [pc, #-1056]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102cfc20:	e3a00064 	mov	r0, #100	; 0x64
102cfc24:	e12fff33 	blx	r3
		buflen = 100;
		len = MQTTSerialize_pingreq((unsigned char *)buf_ssl,buflen);
	}
	break;
102cfc28:	e3a0c000 	mov	ip, #0
#ifdef DEBUG_MSG
		APP_DEBUG(" PING - AZURE_IOTHUB ");
#endif
		buf_ssl = (char *)Ql_MEM_Alloc(100);
		buflen = 100;
		len = MQTTSerialize_pingreq((unsigned char *)buf_ssl,buflen);
102cfc2c:	e3a01064 	mov	r1, #100	; 0x64
102cfc30:	e51f34b8 	ldr	r3, [pc, #-1208]	; 102cf780 <MQTT_Send_Publish+0xf48>
	}
	break;
102cfc34:	e58dc034 	str	ip, [sp, #52]	; 0x34
	case MQTT_PING_REQUEST_AZURE:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PING - AZURE_IOTHUB ");
#endif
		buf_ssl = (char *)Ql_MEM_Alloc(100);
102cfc38:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen = 100;
		len = MQTTSerialize_pingreq((unsigned char *)buf_ssl,buflen);
102cfc3c:	e12fff33 	blx	r3
		Ql_sprintf(topic_subscibe,"$iothub/twin/GET/?$rid=0");

		topicString.cstring = topic_subscibe;

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, NULL, 0);
102cfc40:	e1a09000 	mov	r9, r0

	//get Time stamp in UTC

	GetLocalTime_UTC(time_stamp, local_time);

	char* payload=NULL;
102cfc44:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
102cfc48:	eaffff89 	b	102cfa74 <MQTT_Send_Publish+0x123c>
	case MQTT_HEATING_OFF:
	case MQTT_HEATING_ON:
	case MQTT_HEATING_COMPLETE:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH HEATING ");
102cfc4c:	e3a02c02 	mov	r2, #512	; 0x200
102cfc50:	e3a01000 	mov	r1, #0
102cfc54:	e51f04b8 	ldr	r0, [pc, #-1208]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfc58:	e12fff36 	blx	r6
102cfc5c:	e51f14e0 	ldr	r1, [pc, #-1248]	; 102cf784 <MQTT_Send_Publish+0xf4c>
102cfc60:	e5943000 	ldr	r3, [r4]
102cfc64:	e51f04c8 	ldr	r0, [pc, #-1224]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfc68:	e12fff33 	blx	r3
102cfc6c:	e51f04d0 	ldr	r0, [pc, #-1232]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfc70:	e12fff35 	blx	r5
102cfc74:	e51f14d8 	ldr	r1, [pc, #-1240]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfc78:	e51f3404 	ldr	r3, [pc, #-1028]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cfc7c:	e51fa4f8 	ldr	sl, [pc, #-1272]	; 102cf78c <MQTT_Send_Publish+0xf54>
102cfc80:	e51f7500 	ldr	r7, [pc, #-1280]	; 102cf788 <MQTT_Send_Publish+0xf50>
102cfc84:	e51f8410 	ldr	r8, [pc, #-1040]	; 102cf87c <MQTT_Send_Publish+0x1044>
102cfc88:	e1a02000 	mov	r2, r0
102cfc8c:	e3a0000a 	mov	r0, #10
102cfc90:	e12fff33 	blx	r3
		if( MSG_TYPE == MQTT_HEATING_OFF)
102cfc94:	e35b0015 	cmp	fp, #21
		{
			APP_DEBUG("OFF ");
102cfc98:	e3a02c02 	mov	r2, #512	; 0x200
102cfc9c:	e3a01000 	mov	r1, #0
102cfca0:	e51f0504 	ldr	r0, [pc, #-1284]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
	case MQTT_HEATING_OFF:
	case MQTT_HEATING_ON:
	case MQTT_HEATING_COMPLETE:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH HEATING ");
102cfca4:	e51f351c 	ldr	r3, [pc, #-1308]	; 102cf790 <MQTT_Send_Publish+0xf58>
		if( MSG_TYPE == MQTT_HEATING_OFF)
102cfca8:	0a00033a 	beq	102d0998 <MQTT_Send_Publish+0x2160>
		{
			APP_DEBUG("OFF ");
		}
		else if( MSG_TYPE == MQTT_HEATING_ON)
102cfcac:	e35b0016 	cmp	fp, #22
102cfcb0:	0a000280 	beq	102d06b8 <MQTT_Send_Publish+0x1e80>
		{
			APP_DEBUG("ON ");
		}
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
102cfcb4:	e12fff33 	blx	r3
102cfcb8:	e59a3000 	ldr	r3, [sl]
102cfcbc:	e51f1530 	ldr	r1, [pc, #-1328]	; 102cf794 <MQTT_Send_Publish+0xf5c>
102cfcc0:	e51f0524 	ldr	r0, [pc, #-1316]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfcc4:	e12fff33 	blx	r3
102cfcc8:	e51f052c 	ldr	r0, [pc, #-1324]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfccc:	e12fff37 	blx	r7
102cfcd0:	e51f1534 	ldr	r1, [pc, #-1332]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
		}
#endif
		json_root = cJSON_CreateObject();
102cfcd4:	e51f7444 	ldr	r7, [pc, #-1092]	; 102cf898 <MQTT_Send_Publish+0x1060>
		{
			APP_DEBUG("ON ");
		}
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
102cfcd8:	e1a02000 	mov	r2, r0
102cfcdc:	e3a0000a 	mov	r0, #10
102cfce0:	e12fff38 	blx	r8
		}
#endif
		json_root = cJSON_CreateObject();
102cfce4:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"1");
		}
		if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"2");
102cfce8:	e51f8414 	ldr	r8, [pc, #-1044]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
		}
#endif
		json_root = cJSON_CreateObject();
102cfcec:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102cfcf0:	e12fff37 	blx	r7
102cfcf4:	e51f1460 	ldr	r1, [pc, #-1120]	; 102cf89c <MQTT_Send_Publish+0x1064>
102cfcf8:	e51f741c 	ldr	r7, [pc, #-1052]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102cfcfc:	e1a09000 	mov	r9, r0
102cfd00:	e1a02009 	mov	r2, r9
102cfd04:	e1a0000a 	mov	r0, sl
102cfd08:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"1");
		}
		if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"2");
102cfd0c:	e51f057c 	ldr	r0, [pc, #-1404]	; 102cf798 <MQTT_Send_Publish+0xf60>
102cfd10:	e12fff38 	blx	r8
102cfd14:	e51f1580 	ldr	r1, [pc, #-1408]	; 102cf79c <MQTT_Send_Publish+0xf64>
102cfd18:	e1a02000 	mov	r2, r0
102cfd1c:	e1a00009 	mov	r0, r9
102cfd20:	e12fff37 	blx	r7
		}
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);
102cfd24:	e51f0538 	ldr	r0, [pc, #-1336]	; 102cf7f4 <MQTT_Send_Publish+0xfbc>
102cfd28:	e12fff38 	blx	r8
102cfd2c:	e51f153c 	ldr	r1, [pc, #-1340]	; 102cf7f8 <MQTT_Send_Publish+0xfc0>
102cfd30:	e1a02000 	mov	r2, r0
102cfd34:	e1a00009 	mov	r0, r9
102cfd38:	e12fff37 	blx	r7

		payload = cJSON_Print(json_root);
102cfd3c:	e51f3548 	ldr	r3, [pc, #-1352]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102cfd40:	e1a0000a 	mov	r0, sl
102cfd44:	e12fff33 	blx	r3
102cfd48:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102cfd4c:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102cfd50:	e51f3558 	ldr	r3, [pc, #-1368]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102cfd54:	e1a00007 	mov	r0, r7
102cfd58:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102cfd5c:	e1a00007 	mov	r0, r7
102cfd60:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cfd64:	e51f3568 	ldr	r3, [pc, #-1384]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102cfd68:	e2808064 	add	r8, r0, #100	; 0x64
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);

		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102cfd6c:	e1a09000 	mov	r9, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cfd70:	e1a00008 	mov	r0, r8
102cfd74:	e12fff33 	blx	r3
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102cfd78:	e51f3578 	ldr	r3, [pc, #-1400]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cfd7c:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102cfd80:	e1a0000a 	mov	r0, sl
102cfd84:	e12fff33 	blx	r3

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
102cfd88:	e28d005c 	add	r0, sp, #92	; 0x5c
102cfd8c:	e51f15ac 	ldr	r1, [pc, #-1452]	; 102cf7e8 <MQTT_Send_Publish+0xfb0>
102cfd90:	eaffff22 	b	102cfa20 <MQTT_Send_Publish+0x11e8>
	break;

	case MQTT_TWIN_PROPERTIES:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH TWIN PROPERTY GET ");
102cfd94:	e3a02c02 	mov	r2, #512	; 0x200
102cfd98:	e3a01000 	mov	r1, #0
102cfd9c:	e51f0600 	ldr	r0, [pc, #-1536]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfda0:	e12fff36 	blx	r6
102cfda4:	e5943000 	ldr	r3, [r4]
102cfda8:	e51f1610 	ldr	r1, [pc, #-1552]	; 102cf7a0 <MQTT_Send_Publish+0xf68>
102cfdac:	e51f0610 	ldr	r0, [pc, #-1552]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfdb0:	e12fff33 	blx	r3
102cfdb4:	e51f0618 	ldr	r0, [pc, #-1560]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfdb8:	e12fff35 	blx	r5
102cfdbc:	e51f1620 	ldr	r1, [pc, #-1568]	; 102cf7a4 <MQTT_Send_Publish+0xf6c>
102cfdc0:	e51f354c 	ldr	r3, [pc, #-1356]	; 102cf87c <MQTT_Send_Publish+0x1044>
		Ql_sprintf(topic_subscibe,"$iothub/twin/GET/?$rid=0");

		topicString.cstring = topic_subscibe;

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, NULL, 0);
102cfdc4:	e3a0a000 	mov	sl, #0
	break;

	case MQTT_TWIN_PROPERTIES:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH TWIN PROPERTY GET ");
102cfdc8:	e1a02000 	mov	r2, r0
102cfdcc:	e3a0000a 	mov	r0, #10
102cfdd0:	e12fff33 	blx	r3
#endif
		buf_ssl = (char *)Ql_MEM_Alloc(100);
102cfdd4:	e51f35d8 	ldr	r3, [pc, #-1496]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102cfdd8:	e3a00064 	mov	r0, #100	; 0x64
102cfddc:	e12fff33 	blx	r3
		buflen= 100;

		Ql_sprintf(topic_subscibe,"$iothub/twin/GET/?$rid=0");
102cfde0:	e5943000 	ldr	r3, [r4]
102cfde4:	e51f1644 	ldr	r1, [pc, #-1604]	; 102cf7a8 <MQTT_Send_Publish+0xf70>
	case MQTT_TWIN_PROPERTIES:
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH TWIN PROPERTY GET ");
#endif
		buf_ssl = (char *)Ql_MEM_Alloc(100);
102cfde8:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen= 100;

		Ql_sprintf(topic_subscibe,"$iothub/twin/GET/?$rid=0");
102cfdec:	e28d005c 	add	r0, sp, #92	; 0x5c
102cfdf0:	e12fff33 	blx	r3

		topicString.cstring = topic_subscibe;
102cfdf4:	e28d30c0 	add	r3, sp, #192	; 0xc0
102cfdf8:	e28dc05c 	add	ip, sp, #92	; 0x5c
102cfdfc:	e523c070 	str	ip, [r3, #-112]!	; 0xffffff90

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, NULL, 0);
102cfe00:	e8930007 	ldm	r3, {r0, r1, r2}
102cfe04:	e28dc008 	add	ip, sp, #8
102cfe08:	e58da000 	str	sl, [sp]
102cfe0c:	e58da004 	str	sl, [sp, #4]
102cfe10:	e1a0300a 	mov	r3, sl
102cfe14:	e88c0007 	stm	ip, {r0, r1, r2}
102cfe18:	e58da014 	str	sl, [sp, #20]
102cfe1c:	e58da018 	str	sl, [sp, #24]
102cfe20:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
102cfe24:	e3a01064 	mov	r1, #100	; 0x64
102cfe28:	e1a0200a 	mov	r2, sl
	}
	break;
102cfe2c:	e58da034 	str	sl, [sp, #52]	; 0x34
		Ql_sprintf(topic_subscibe,"$iothub/twin/GET/?$rid=0");

		topicString.cstring = topic_subscibe;

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, NULL, 0);
102cfe30:	e51fc658 	ldr	ip, [pc, #-1624]	; 102cf7e0 <MQTT_Send_Publish+0xfa8>
102cfe34:	e12fff3c 	blx	ip
102cfe38:	eaffff80 	b	102cfc40 <MQTT_Send_Publish+0x1408>

		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
			{
				Water_data_Publish_without_unit[i] = '\0';
102cfe3c:	e51fc580 	ldr	ip, [pc, #-1408]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cfe40:	e3a03000 	mov	r3, #0
102cfe44:	e08c2002 	add	r2, ip, r2
102cfe48:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cfe4c:	e5c232b8 	strb	r3, [r2, #696]	; 0x2b8
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}

		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
102cfe50:	e51f957c 	ldr	r9, [pc, #-1404]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102cfe54:	e51f0594 	ldr	r0, [pc, #-1428]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
102cfe58:	e12fff39 	blx	r9
102cfe5c:	e51f1598 	ldr	r1, [pc, #-1432]	; 102cf8cc <MQTT_Send_Publish+0x1094>
102cfe60:	e1a02000 	mov	r2, r0
102cfe64:	e1a00008 	mov	r0, r8
102cfe68:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_FLOW_RATE,flow_rate);
102cfe6c:	e51f06a4 	ldr	r0, [pc, #-1700]	; 102cf7d0 <MQTT_Send_Publish+0xf98>
102cfe70:	e12fff39 	blx	r9
102cfe74:	e51f16a8 	ldr	r1, [pc, #-1704]	; 102cf7d4 <MQTT_Send_Publish+0xf9c>
102cfe78:	e1a02000 	mov	r2, r0
102cfe7c:	e1a00008 	mov	r0, r8
102cfe80:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TDS_IN,TDS_Input_Data);
102cfe84:	e51f06e0 	ldr	r0, [pc, #-1760]	; 102cf7ac <MQTT_Send_Publish+0xf74>
102cfe88:	e12fff39 	blx	r9
102cfe8c:	e51f16e4 	ldr	r1, [pc, #-1764]	; 102cf7b0 <MQTT_Send_Publish+0xf78>
102cfe90:	e1a02000 	mov	r2, r0
102cfe94:	e1a00008 	mov	r0, r8
102cfe98:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TDS_OUT,TDS_Ouput_Data);
102cfe9c:	e51f06f0 	ldr	r0, [pc, #-1776]	; 102cf7b4 <MQTT_Send_Publish+0xf7c>
102cfea0:	e12fff39 	blx	r9
102cfea4:	e51f16f4 	ldr	r1, [pc, #-1780]	; 102cf7b8 <MQTT_Send_Publish+0xf80>
102cfea8:	e1a02000 	mov	r2, r0
102cfeac:	e1a00008 	mov	r0, r8
102cfeb0:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PUMP_CURRENT,Pump_Current);
102cfeb4:	e51f0700 	ldr	r0, [pc, #-1792]	; 102cf7bc <MQTT_Send_Publish+0xf84>
102cfeb8:	e12fff39 	blx	r9
102cfebc:	e51f1704 	ldr	r1, [pc, #-1796]	; 102cf7c0 <MQTT_Send_Publish+0xf88>
102cfec0:	e1a02000 	mov	r2, r0
102cfec4:	e1a00008 	mov	r0, r8
102cfec8:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_ID,Received_RCID);
102cfecc:	e51f0620 	ldr	r0, [pc, #-1568]	; 102cf8b4 <MQTT_Send_Publish+0x107c>
102cfed0:	e12fff39 	blx	r9
102cfed4:	e51f1624 	ldr	r1, [pc, #-1572]	; 102cf8b8 <MQTT_Send_Publish+0x1080>
102cfed8:	e1a02000 	mov	r2, r0
102cfedc:	e1a00008 	mov	r0, r8
102cfee0:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_TS,Received_RCTS);
102cfee4:	e51f0630 	ldr	r0, [pc, #-1584]	; 102cf8bc <MQTT_Send_Publish+0x1084>
102cfee8:	e12fff39 	blx	r9
102cfeec:	e51f1634 	ldr	r1, [pc, #-1588]	; 102cf8c0 <MQTT_Send_Publish+0x1088>
102cfef0:	e1a02000 	mov	r2, r0
102cfef4:	e1a00008 	mov	r0, r8
102cfef8:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);
102cfefc:	e51f0710 	ldr	r0, [pc, #-1808]	; 102cf7f4 <MQTT_Send_Publish+0xfbc>
102cff00:	e12fff39 	blx	r9
102cff04:	e51f1714 	ldr	r1, [pc, #-1812]	; 102cf7f8 <MQTT_Send_Publish+0xfc0>
102cff08:	e1a02000 	mov	r2, r0
102cff0c:	e1a00008 	mov	r0, r8
102cff10:	e12fff37 	blx	r7

		payload = cJSON_Print(json_root);
102cff14:	e51f3720 	ldr	r3, [pc, #-1824]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102cff18:	e1a0000a 	mov	r0, sl
102cff1c:	e12fff33 	blx	r3
102cff20:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102cff24:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102cff28:	e51f3730 	ldr	r3, [pc, #-1840]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102cff2c:	e1a00007 	mov	r0, r7
102cff30:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102cff34:	e1a00007 	mov	r0, r7
102cff38:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cff3c:	e51f3740 	ldr	r3, [pc, #-1856]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102cff40:	e2809064 	add	r9, r0, #100	; 0x64
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);

		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102cff44:	e1a08000 	mov	r8, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cff48:	e1a00009 	mov	r0, r9
102cff4c:	e12fff33 	blx	r3
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102cff50:	e51f3750 	ldr	r3, [pc, #-1872]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102cff54:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102cff58:	e1a0000a 	mov	r0, sl
102cff5c:	e12fff33 	blx	r3

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_DATA);
102cff60:	e51f1790 	ldr	r1, [pc, #-1936]	; 102cf7d8 <MQTT_Send_Publish+0xfa0>
102cff64:	e28d005c 	add	r0, sp, #92	; 0x5c

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
		buflen= payloadlen+100;
		cJSON_Delete(json_root);

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
102cff68:	e51f3794 	ldr	r3, [pc, #-1940]	; 102cf7dc <MQTT_Send_Publish+0xfa4>
102cff6c:	e12fff33 	blx	r3
		topicString.cstring = topic_subscibe;
102cff70:	e28d30c0 	add	r3, sp, #192	; 0xc0
102cff74:	e28d105c 	add	r1, sp, #92	; 0x5c
102cff78:	e5231070 	str	r1, [r3, #-112]!	; 0xffffff90

		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cff7c:	e8930007 	ldm	r3, {r0, r1, r2}
102cff80:	e3a0a000 	mov	sl, #0
102cff84:	e28dc008 	add	ip, sp, #8
102cff88:	e58da000 	str	sl, [sp]
102cff8c:	e58da004 	str	sl, [sp, #4]
102cff90:	e1a0300a 	mov	r3, sl
102cff94:	e88c0007 	stm	ip, {r0, r1, r2}
102cff98:	e1a01009 	mov	r1, r9
102cff9c:	e51fc7c4 	ldr	ip, [pc, #-1988]	; 102cf7e0 <MQTT_Send_Publish+0xfa8>
102cffa0:	e58d7014 	str	r7, [sp, #20]
102cffa4:	e58d8018 	str	r8, [sp, #24]
102cffa8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
102cffac:	e1a0200a 	mov	r2, sl
102cffb0:	e12fff3c 	blx	ip
	}
	break;
102cffb4:	e3a0c005 	mov	ip, #5
102cffb8:	e58da034 	str	sl, [sp, #52]	; 0x34
		cJSON_Delete(json_root);

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
		topicString.cstring = topic_subscibe;

		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102cffbc:	e1a09000 	mov	r9, r0
		topicString.cstring = topic_subscibe;

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
	}
	break;
102cffc0:	e58dc03c 	str	ip, [sp, #60]	; 0x3c
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
	bool LOG_MESSAGES_AVAILABLE = FALSE;
	s32  filehandleData = -1;
102cffc4:	e3e0c000 	mvn	ip, #0
102cffc8:	e58dc030 	str	ip, [sp, #48]	; 0x30
102cffcc:	e51fc760 	ldr	ip, [pc, #-1888]	; 102cf874 <MQTT_Send_Publish+0x103c>
102cffd0:	e58dc028 	str	ip, [sp, #40]	; 0x28
		topicString.cstring = topic_subscibe;

		// Send an empty packet to receive the full list of desired / reported parameter Data set
		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
	}
	break;
102cffd4:	eafffeae 	b	102cfa94 <MQTT_Send_Publish+0x125c>
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_OK,"1");
		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
			{
				Water_data_Publish_without_unit[i] = '\0';
102cffd8:	e51fc71c 	ldr	ip, [pc, #-1820]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102cffdc:	e3a03000 	mov	r3, #0
102cffe0:	e08c2002 	add	r2, ip, r2
102cffe4:	e58dc024 	str	ip, [sp, #36]	; 0x24
102cffe8:	e5c232b8 	strb	r3, [r2, #696]	; 0x2b8
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}

		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
102cffec:	e51f072c 	ldr	r0, [pc, #-1836]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
102cfff0:	e12fff38 	blx	r8
102cfff4:	e51f1730 	ldr	r1, [pc, #-1840]	; 102cf8cc <MQTT_Send_Publish+0x1094>
102cfff8:	e1a02000 	mov	r2, r0
102cfffc:	e1a00009 	mov	r0, r9
102d0000:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_ID,Received_RCID);
102d0004:	e51f0758 	ldr	r0, [pc, #-1880]	; 102cf8b4 <MQTT_Send_Publish+0x107c>
102d0008:	e12fff38 	blx	r8
102d000c:	e51f175c 	ldr	r1, [pc, #-1884]	; 102cf8b8 <MQTT_Send_Publish+0x1080>
102d0010:	e1a02000 	mov	r2, r0
102d0014:	e1a00009 	mov	r0, r9
102d0018:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_TS,Received_RCTS);
102d001c:	e51f0768 	ldr	r0, [pc, #-1896]	; 102cf8bc <MQTT_Send_Publish+0x1084>
		}

		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RES_CODE,"4");
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_ID,RCID);   //RCID value is received recharge
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_TS,RCTS);   ////RCID value is received recharge TS
102d0020:	e12fff38 	blx	r8
102d0024:	e51f176c 	ldr	r1, [pc, #-1900]	; 102cf8c0 <MQTT_Send_Publish+0x1088>
102d0028:	e1a02000 	mov	r2, r0
102d002c:	e1a00009 	mov	r0, r9
102d0030:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);
102d0034:	e51f0848 	ldr	r0, [pc, #-2120]	; 102cf7f4 <MQTT_Send_Publish+0xfbc>
102d0038:	e12fff38 	blx	r8
102d003c:	e51f184c 	ldr	r1, [pc, #-2124]	; 102cf7f8 <MQTT_Send_Publish+0xfc0>
102d0040:	e1a02000 	mov	r2, r0
102d0044:	e1a00009 	mov	r0, r9
102d0048:	e12fff37 	blx	r7

		payload = cJSON_Print(json_root);
102d004c:	e51f3858 	ldr	r3, [pc, #-2136]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102d0050:	e1a0000a 	mov	r0, sl
102d0054:	e12fff33 	blx	r3
102d0058:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102d005c:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102d0060:	e51f3868 	ldr	r3, [pc, #-2152]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102d0064:	e1a00007 	mov	r0, r7
102d0068:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102d006c:	e1a00007 	mov	r0, r7
102d0070:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d0074:	e51f3878 	ldr	r3, [pc, #-2168]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102d0078:	e2809064 	add	r9, r0, #100	; 0x64
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);

		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102d007c:	e1a08000 	mov	r8, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d0080:	e1a00009 	mov	r0, r9
102d0084:	e12fff33 	blx	r3
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102d0088:	e51f3888 	ldr	r3, [pc, #-2184]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d008c:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102d0090:	e1a0000a 	mov	r0, sl
102d0094:	e12fff33 	blx	r3

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_ACK);
102d0098:	e28d005c 	add	r0, sp, #92	; 0x5c
102d009c:	e51f1898 	ldr	r1, [pc, #-2200]	; 102cf80c <MQTT_Send_Publish+0xfd4>
102d00a0:	eaffffb0 	b	102cff68 <MQTT_Send_Publish+0x1730>
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_FAIL,"1");
		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
			{
				Water_data_Publish_without_unit[i] = '\0';
102d00a4:	e51fc7e8 	ldr	ip, [pc, #-2024]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102d00a8:	e3a03000 	mov	r3, #0
102d00ac:	e08c2002 	add	r2, ip, r2
102d00b0:	e58dc024 	str	ip, [sp, #36]	; 0x24
102d00b4:	e5c232b8 	strb	r3, [r2, #696]	; 0x2b8
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}

		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
102d00b8:	e51f07f8 	ldr	r0, [pc, #-2040]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
102d00bc:	e12fff38 	blx	r8
102d00c0:	e51f17fc 	ldr	r1, [pc, #-2044]	; 102cf8cc <MQTT_Send_Publish+0x1094>
102d00c4:	e1a02000 	mov	r2, r0
102d00c8:	e1a00009 	mov	r0, r9
102d00cc:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RES_CODE,"4");
102d00d0:	e51f0914 	ldr	r0, [pc, #-2324]	; 102cf7c4 <MQTT_Send_Publish+0xf8c>
102d00d4:	e12fff38 	blx	r8
102d00d8:	e51f18f0 	ldr	r1, [pc, #-2288]	; 102cf7f0 <MQTT_Send_Publish+0xfb8>
102d00dc:	e1a02000 	mov	r2, r0
102d00e0:	e1a00009 	mov	r0, r9
102d00e4:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_ID,RCID);   //RCID value is received recharge
102d00e8:	e51f0928 	ldr	r0, [pc, #-2344]	; 102cf7c8 <MQTT_Send_Publish+0xf90>
102d00ec:	e12fff38 	blx	r8
102d00f0:	e51f1840 	ldr	r1, [pc, #-2112]	; 102cf8b8 <MQTT_Send_Publish+0x1080>
102d00f4:	e1a02000 	mov	r2, r0
102d00f8:	e1a00009 	mov	r0, r9
102d00fc:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_TS,RCTS);   ////RCID value is received recharge TS
102d0100:	e51f093c 	ldr	r0, [pc, #-2364]	; 102cf7cc <MQTT_Send_Publish+0xf94>
102d0104:	eaffffc5 	b	102d0020 <MQTT_Send_Publish+0x17e8>

		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
			{
				Water_data_Publish_without_unit[i] = '\0';
102d0108:	e51fc84c 	ldr	ip, [pc, #-2124]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102d010c:	e3a03000 	mov	r3, #0
102d0110:	e08c2002 	add	r2, ip, r2
102d0114:	e58dc024 	str	ip, [sp, #36]	; 0x24
102d0118:	e5c232b8 	strb	r3, [r2, #696]	; 0x2b8
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}

		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
102d011c:	e51f9848 	ldr	r9, [pc, #-2120]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d0120:	e51f0860 	ldr	r0, [pc, #-2144]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
102d0124:	e12fff39 	blx	r9
102d0128:	e51f1864 	ldr	r1, [pc, #-2148]	; 102cf8cc <MQTT_Send_Publish+0x1094>
102d012c:	e1a02000 	mov	r2, r0
102d0130:	e1a0000a 	mov	r0, sl
102d0134:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_FLOW_RATE,flow_rate);
102d0138:	e51f0970 	ldr	r0, [pc, #-2416]	; 102cf7d0 <MQTT_Send_Publish+0xf98>
102d013c:	e12fff39 	blx	r9
102d0140:	e51f1974 	ldr	r1, [pc, #-2420]	; 102cf7d4 <MQTT_Send_Publish+0xf9c>
102d0144:	e1a02000 	mov	r2, r0
102d0148:	e1a0000a 	mov	r0, sl
102d014c:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);
102d0150:	e51f0964 	ldr	r0, [pc, #-2404]	; 102cf7f4 <MQTT_Send_Publish+0xfbc>
102d0154:	e12fff39 	blx	r9
102d0158:	e51f1968 	ldr	r1, [pc, #-2408]	; 102cf7f8 <MQTT_Send_Publish+0xfc0>
102d015c:	e1a02000 	mov	r2, r0
102d0160:	e1a0000a 	mov	r0, sl
102d0164:	e12fff37 	blx	r7

		payload = cJSON_Print(json_root);
102d0168:	e51f3974 	ldr	r3, [pc, #-2420]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102d016c:	e1a00008 	mov	r0, r8
102d0170:	e12fff33 	blx	r3
102d0174:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102d0178:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102d017c:	e51f3984 	ldr	r3, [pc, #-2436]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102d0180:	e1a00007 	mov	r0, r7
102d0184:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102d0188:	e1a00007 	mov	r0, r7
102d018c:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d0190:	e51f3994 	ldr	r3, [pc, #-2452]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102d0194:	e280a064 	add	sl, r0, #100	; 0x64
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);

		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102d0198:	e1a09000 	mov	r9, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d019c:	e1a0000a 	mov	r0, sl
102d01a0:	e12fff33 	blx	r3
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102d01a4:	e51f39a4 	ldr	r3, [pc, #-2468]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d01a8:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102d01ac:	e1a00008 	mov	r0, r8
102d01b0:	e12fff33 	blx	r3

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_DATA);
102d01b4:	e51f19e4 	ldr	r1, [pc, #-2532]	; 102cf7d8 <MQTT_Send_Publish+0xfa0>
102d01b8:	e28d005c 	add	r0, sp, #92	; 0x5c
102d01bc:	e51f39e8 	ldr	r3, [pc, #-2536]	; 102cf7dc <MQTT_Send_Publish+0xfa4>
102d01c0:	e12fff33 	blx	r3
		topicString.cstring = topic_subscibe;
102d01c4:	e28d30c0 	add	r3, sp, #192	; 0xc0
102d01c8:	e28d105c 	add	r1, sp, #92	; 0x5c
102d01cc:	e5231070 	str	r1, [r3, #-112]!	; 0xffffff90

		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102d01d0:	e8930007 	ldm	r3, {r0, r1, r2}
102d01d4:	e3a08000 	mov	r8, #0
102d01d8:	e28dc008 	add	ip, sp, #8
102d01dc:	e58d8000 	str	r8, [sp]
102d01e0:	e58d8004 	str	r8, [sp, #4]
102d01e4:	e1a03008 	mov	r3, r8
102d01e8:	e88c0007 	stm	ip, {r0, r1, r2}
102d01ec:	e58d9018 	str	r9, [sp, #24]
102d01f0:	e51fca18 	ldr	ip, [pc, #-2584]	; 102cf7e0 <MQTT_Send_Publish+0xfa8>
102d01f4:	e58d7014 	str	r7, [sp, #20]
102d01f8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
102d01fc:	e1a0100a 	mov	r1, sl
102d0200:	e1a02008 	mov	r2, r8
102d0204:	e12fff3c 	blx	ip
	}
	break;
102d0208:	e58d8034 	str	r8, [sp, #52]	; 0x34
102d020c:	e3a0c005 	mov	ip, #5
		cJSON_Delete(json_root);

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_DATA);
		topicString.cstring = topic_subscibe;

		len = MQTTSerialize_publish((unsigned char *)buf_ssl, buflen, 0, 0, 0, 0, topicString, (unsigned char*)payload, payloadlen);
102d0210:	e1a09000 	mov	r9, r0
102d0214:	eaffff69 	b	102cffc0 <MQTT_Send_Publish+0x1788>
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_PSTP_TS,Purification_Stop_local_time);
		for(i=0;i<5;i++)
		{
			if(Water_dispensed_volume[i] == ' ')// Check for a space to find end of Water data string
			{
				Water_data_Publish_without_unit[i] = '\0';
102d0218:	e51fc95c 	ldr	ip, [pc, #-2396]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102d021c:	e3a02000 	mov	r2, #0
102d0220:	e08c3003 	add	r3, ip, r3
102d0224:	e58dc024 	str	ip, [sp, #36]	; 0x24
102d0228:	e5c322b8 	strb	r2, [r3, #696]	; 0x2b8
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = Water_dispensed_volume[i];
		}
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_VOLUME,Water_data_Publish_without_unit);
102d022c:	e51f096c 	ldr	r0, [pc, #-2412]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
102d0230:	e12fff38 	blx	r8
102d0234:	e51f1a58 	ldr	r1, [pc, #-2648]	; 102cf7e4 <MQTT_Send_Publish+0xfac>
102d0238:	e1a02000 	mov	r2, r0
102d023c:	e1a00009 	mov	r0, r9
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_ID,Received_RCID);
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_TS,Received_RCTS);
102d0240:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);
102d0244:	e51f0a58 	ldr	r0, [pc, #-2648]	; 102cf7f4 <MQTT_Send_Publish+0xfbc>
102d0248:	e12fff38 	blx	r8
102d024c:	e51f1a5c 	ldr	r1, [pc, #-2652]	; 102cf7f8 <MQTT_Send_Publish+0xfc0>
102d0250:	e1a02000 	mov	r2, r0
102d0254:	e1a00009 	mov	r0, r9
102d0258:	e12fff37 	blx	r7

		payload = cJSON_Print(json_root);
102d025c:	e51f3a68 	ldr	r3, [pc, #-2664]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102d0260:	e1a0000a 	mov	r0, sl
102d0264:	e12fff33 	blx	r3
102d0268:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102d026c:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102d0270:	e51f3a78 	ldr	r3, [pc, #-2680]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102d0274:	e1a00007 	mov	r0, r7
102d0278:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102d027c:	e1a00007 	mov	r0, r7
102d0280:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d0284:	e51f3a88 	ldr	r3, [pc, #-2696]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102d0288:	e2809064 	add	r9, r0, #100	; 0x64
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);

		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102d028c:	e1a08000 	mov	r8, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d0290:	e1a00009 	mov	r0, r9
102d0294:	e12fff33 	blx	r3
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102d0298:	e51f3a98 	ldr	r3, [pc, #-2712]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d029c:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen= payloadlen+100;
		cJSON_Delete(json_root);
102d02a0:	e1a0000a 	mov	r0, sl
102d02a4:	e12fff33 	blx	r3

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
102d02a8:	e28d005c 	add	r0, sp, #92	; 0x5c
102d02ac:	e51f1acc 	ldr	r1, [pc, #-2764]	; 102cf7e8 <MQTT_Send_Publish+0xfb0>
102d02b0:	eaffff2c 	b	102cff68 <MQTT_Send_Publish+0x1730>

		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
			{
				Water_data_Publish_without_unit[i] = '\0';
102d02b4:	e51fc9f8 	ldr	ip, [pc, #-2552]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102d02b8:	e3a03000 	mov	r3, #0
102d02bc:	e08c2002 	add	r2, ip, r2
102d02c0:	e58dc024 	str	ip, [sp, #36]	; 0x24
102d02c4:	e5c232b8 	strb	r3, [r2, #696]	; 0x2b8
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}

		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
102d02c8:	e51f0a08 	ldr	r0, [pc, #-2568]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
102d02cc:	e12fff38 	blx	r8
102d02d0:	e51f1a0c 	ldr	r1, [pc, #-2572]	; 102cf8cc <MQTT_Send_Publish+0x1094>
102d02d4:	e1a02000 	mov	r2, r0
102d02d8:	e1a0000a 	mov	r0, sl
102d02dc:	e12fff37 	blx	r7

		cJSON_AddStringToObject(value,MQTT_PAYLOAD_RES_CODE,lock_unlock_ack);
102d02e0:	e51f0afc 	ldr	r0, [pc, #-2812]	; 102cf7ec <MQTT_Send_Publish+0xfb4>
102d02e4:	e12fff38 	blx	r8
102d02e8:	e51f1b00 	ldr	r1, [pc, #-2816]	; 102cf7f0 <MQTT_Send_Publish+0xfb8>
102d02ec:	e1a02000 	mov	r2, r0
102d02f0:	e1a0000a 	mov	r0, sl
102d02f4:	e12fff37 	blx	r7

		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);
102d02f8:	e51f0b0c 	ldr	r0, [pc, #-2828]	; 102cf7f4 <MQTT_Send_Publish+0xfbc>
102d02fc:	e12fff38 	blx	r8
102d0300:	e51f1b10 	ldr	r1, [pc, #-2832]	; 102cf7f8 <MQTT_Send_Publish+0xfc0>
102d0304:	e1a02000 	mov	r2, r0
102d0308:	e1a0000a 	mov	r0, sl
102d030c:	e12fff37 	blx	r7

		payload = cJSON_Print(json_root);
102d0310:	e51f3b1c 	ldr	r3, [pc, #-2844]	; 102cf7fc <MQTT_Send_Publish+0xfc4>
102d0314:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
102d0318:	e12fff33 	blx	r3
102d031c:	e1a07000 	mov	r7, r0
		payloadlen = Ql_strlen(payload);
102d0320:	e12fff35 	blx	r5
		cJSON_Minify(payload);
102d0324:	e51f3b2c 	ldr	r3, [pc, #-2860]	; 102cf800 <MQTT_Send_Publish+0xfc8>
102d0328:	e1a00007 	mov	r0, r7
102d032c:	e12fff33 	blx	r3
		payloadlen = Ql_strlen(payload);
102d0330:	e1a00007 	mov	r0, r7
102d0334:	e12fff35 	blx	r5

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d0338:	e51f3b3c 	ldr	r3, [pc, #-2876]	; 102cf804 <MQTT_Send_Publish+0xfcc>
102d033c:	e280a064 	add	sl, r0, #100	; 0x64
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_TS,local_time);

		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);
102d0340:	e1a09000 	mov	r9, r0

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d0344:	e1a0000a 	mov	r0, sl
102d0348:	e12fff33 	blx	r3
		buflen = payloadlen+100;
		cJSON_Delete(json_root);
102d034c:	e51f3b4c 	ldr	r3, [pc, #-2892]	; 102cf808 <MQTT_Send_Publish+0xfd0>
		payload = cJSON_Print(json_root);
		payloadlen = Ql_strlen(payload);
		cJSON_Minify(payload);
		payloadlen = Ql_strlen(payload);

		buf_ssl = (char *)Ql_MEM_Alloc(payloadlen+100);
102d0350:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		buflen = payloadlen+100;
		cJSON_Delete(json_root);
102d0354:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
102d0358:	e12fff33 	blx	r3

		Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_ACK);
102d035c:	e28d005c 	add	r0, sp, #92	; 0x5c
102d0360:	e51f1b5c 	ldr	r1, [pc, #-2908]	; 102cf80c <MQTT_Send_Publish+0xfd4>
102d0364:	eaffff94 	b	102d01bc <MQTT_Send_Publish+0x1984>
				APP_DEBUG("<-- [SUCCESS] data Send-AZURE_IOTHUB -->\r\n");
#endif

			if(MSG_TYPE == MQTT_POWER_OFF) // MQTT disconnect before power OFF / recycle
			{
				MQTT_Send_CONN_DISCONN_Request(SSID_HOST_AZURE, MQTT_OFF);
102d0368:	e3a00000 	mov	r0, #0
102d036c:	e1a01000 	mov	r1, r0
102d0370:	ebfff86f 	bl	102ce534 <MQTT_Send_CONN_DISCONN_Request>
				FLAG.MQTT_CONNECTION_STATUS = FALSE;
102d0374:	e3a04000 	mov	r4, #0
				GPRS_Deactivate();
102d0378:	e51f3b70 	ldr	r3, [pc, #-2928]	; 102cf810 <MQTT_Send_Publish+0xfd8>
#endif

			if(MSG_TYPE == MQTT_POWER_OFF) // MQTT disconnect before power OFF / recycle
			{
				MQTT_Send_CONN_DISCONN_Request(SSID_HOST_AZURE, MQTT_OFF);
				FLAG.MQTT_CONNECTION_STATUS = FALSE;
102d037c:	e5c8400d 	strb	r4, [r8, #13]
				GPRS_Deactivate();
102d0380:	e12fff33 	blx	r3
				FLAG.GPRS_ACTIVE = FALSE;
				Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102d0384:	e3a02002 	mov	r2, #2
102d0388:	e1a0000b 	mov	r0, fp
102d038c:	e51f1b78 	ldr	r1, [pc, #-2936]	; 102cf81c <MQTT_Send_Publish+0xfe4>
102d0390:	e1a03002 	mov	r3, r2
			if(MSG_TYPE == MQTT_POWER_OFF) // MQTT disconnect before power OFF / recycle
			{
				MQTT_Send_CONN_DISCONN_Request(SSID_HOST_AZURE, MQTT_OFF);
				FLAG.MQTT_CONNECTION_STATUS = FALSE;
				GPRS_Deactivate();
				FLAG.GPRS_ACTIVE = FALSE;
102d0394:	e5c84000 	strb	r4, [r8]
				Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102d0398:	e12fff39 	blx	r9
		FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = TRUE; // Enable this flag to re-attempt the GPRS reconnect
		FLAG.MQTT_CONNECTION_STATUS = FALSE; // Mark the connection not available flag
		FLAG.CON_MSG_PUBLISH_PENDING = TRUE; // At next successful connection it is required to publish the connection ON record so enable this flag
	}
	if(MSG_TYPE == MQTT_POWER_OFF)
		FLAG.POWER_OFF_MSG_PROCESSED = TRUE;
102d039c:	e3a03001 	mov	r3, #1
102d03a0:	e5c8301f 	strb	r3, [r8, #31]
102d03a4:	eafffe06 	b	102cfbc4 <MQTT_Send_Publish+0x138c>
	//-------------------------------------------------------
	if(MSG_TYPE == MQTT_LOG)
		fileSys_CloseFile(filehandleData); // Close the file
102d03a8:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
102d03ac:	e51f3ba0 	ldr	r3, [pc, #-2976]	; 102cf814 <MQTT_Send_Publish+0xfdc>
102d03b0:	e12fff33 	blx	r3
102d03b4:	eafffe02 	b	102cfbc4 <MQTT_Send_Publish+0x138c>
#endif
	//Check the gprs and socket connection status and autoprovisioning status
	//if its ok then send data over tcp ip
	//also check return of data send

	if((FLAG.SSL_CONNECTION_STATE == TRUE) &&  (FLAG.GPRS_ACTIVE == TRUE) && (FLAG.AUTOPROVISIONING_COMPLETE == TRUE))
102d03b8:	e5d83017 	ldrb	r3, [r8, #23]
102d03bc:	e3530001 	cmp	r3, #1
102d03c0:	1afffdd9 	bne	102cfb2c <MQTT_Send_Publish+0x12f4>
	{
		rc = SSL_Send_Data(ssid, buf_ssl , len); // There is a reconnect attempt at the start in this function if found not connected
102d03c4:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
102d03c8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
102d03cc:	e1a02009 	mov	r2, r9
102d03d0:	e51f3bc0 	ldr	r3, [pc, #-3008]	; 102cf818 <MQTT_Send_Publish+0xfe0>
102d03d4:	e12fff33 	blx	r3

		if(rc == RIL_ATRSP_SUCCESS)
102d03d8:	e250a000 	subs	sl, r0, #0
102d03dc:	1a000258 	bne	102d0d44 <MQTT_Send_Publish+0x250c>
		{
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);
102d03e0:	e3a00003 	mov	r0, #3
102d03e4:	e51f1bd0 	ldr	r1, [pc, #-3024]	; 102cf81c <MQTT_Send_Publish+0xfe4>
102d03e8:	e3a02002 	mov	r2, #2
102d03ec:	e1a03000 	mov	r3, r0
102d03f0:	e51f9bd8 	ldr	r9, [pc, #-3032]	; 102cf820 <MQTT_Send_Publish+0xfe8>
102d03f4:	e12fff39 	blx	r9

			Ql_strcpy(last_connectedtime,local_time);  //store local time to connecttime variable
102d03f8:	e51f0bdc 	ldr	r0, [pc, #-3036]	; 102cf824 <MQTT_Send_Publish+0xfec>
102d03fc:	e51f3bdc 	ldr	r3, [pc, #-3036]	; 102cf828 <MQTT_Send_Publish+0xff0>
102d0400:	e2401ff9 	sub	r1, r0, #996	; 0x3e4
102d0404:	e12fff33 	blx	r3

			if((FLAG.DIGNOSTIC_MODE == TRUE) && (!(FLAG.SUSPEND_IPC_COMMUNICATION)))//To avoid the LCD to display last connected time if device is in FW upgrading state with diagnostic mode ON.
102d0408:	e5d8300a 	ldrb	r3, [r8, #10]
102d040c:	e3530001 	cmp	r3, #1
102d0410:	0a0002ab 	beq	102d0ec4 <MQTT_Send_Publish+0x268c>
			{
				Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_DIAG_LAST_CONNECT_TIME); // Update last connected time in diagnostic screen
			}
			FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = FALSE; // DO not attempt a re-connect to GPRS as there is already connection in place

			if(MSG_TYPE == MQTT_LOG)// Invalidate the recent log record published successfully
102d0414:	e59dc034 	ldr	ip, [sp, #52]	; 0x34

			if((FLAG.DIGNOSTIC_MODE == TRUE) && (!(FLAG.SUSPEND_IPC_COMMUNICATION)))//To avoid the LCD to display last connected time if device is in FW upgrading state with diagnostic mode ON.
			{
				Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_DIAG_LAST_CONNECT_TIME); // Update last connected time in diagnostic screen
			}
			FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = FALSE; // DO not attempt a re-connect to GPRS as there is already connection in place
102d0418:	e3a01000 	mov	r1, #0

			if(MSG_TYPE == MQTT_LOG)// Invalidate the recent log record published successfully
102d041c:	e35c0000 	cmp	ip, #0

			if((FLAG.DIGNOSTIC_MODE == TRUE) && (!(FLAG.SUSPEND_IPC_COMMUNICATION)))//To avoid the LCD to display last connected time if device is in FW upgrading state with diagnostic mode ON.
			{
				Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_DIAG_LAST_CONNECT_TIME); // Update last connected time in diagnostic screen
			}
			FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = FALSE; // DO not attempt a re-connect to GPRS as there is already connection in place
102d0420:	e5c8100c 	strb	r1, [r8, #12]

			if(MSG_TYPE == MQTT_LOG)// Invalidate the recent log record published successfully
102d0424:	1a0002bf 	bne	102d0f28 <MQTT_Send_Publish+0x26f0>
				ret = Ql_FS_Write(filehandleData, (u8 *)payload, 1 , (u32 *)&writeedlen);
				Ql_MEM_Free(payload);
				payload = NULL;
			}
#ifdef DEBUG_MSG
			if(ssid == SSID_HOST_AZURE)
102d0428:	e59dc038 	ldr	ip, [sp, #56]	; 0x38
102d042c:	e35c0000 	cmp	ip, #0
102d0430:	0a0002ac 	beq	102d0ee8 <MQTT_Send_Publish+0x26b0>
				APP_DEBUG("<-- [SUCCESS] data Send-AZURE_IOTHUB -->\r\n");
#endif

			if(MSG_TYPE == MQTT_POWER_OFF) // MQTT disconnect before power OFF / recycle
102d0434:	e35b0003 	cmp	fp, #3
102d0438:	0affffca 	beq	102d0368 <MQTT_Send_Publish+0x1b30>
				GPRS_Deactivate();
				FLAG.GPRS_ACTIVE = FALSE;
				Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
			}

			if((MSG_TYPE == MQTT_TWIN_REPORTED) && (Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CNTRL_FW_INFO))// Prepare for FOTA download once twin reported back
102d043c:	e35b0041 	cmp	fp, #65	; 0x41
102d0440:	1afffddc 	bne	102cfbb8 <MQTT_Send_Publish+0x1380>
102d0444:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0448:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d044c:	e3130040 	tst	r3, #64	; 0x40
102d0450:	0afffddb 	beq	102cfbc4 <MQTT_Send_Publish+0x138c>
			{
				FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD = TRUE;
102d0454:	e3a02001 	mov	r2, #1
102d0458:	e5c82024 	strb	r2, [r8, #36]	; 0x24
				Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CNTRL_FW_INFO);
102d045c:	e51f2ba0 	ldr	r2, [pc, #-2976]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102d0460:	e3c33040 	bic	r3, r3, #64	; 0x40
102d0464:	e5823374 	str	r3, [r2, #884]	; 0x374
102d0468:	eafffdd5 	b	102cfbc4 <MQTT_Send_Publish+0x138c>
			cJSON_AddStringToObject(json_root, TWIN_DPS_ID_SCOPE,RP_DpsIdScope);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DPS_ID_SCOPE);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CNTRL_FW_INFO) // Report back FOTA related properties..
		{
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_FILE_NAME,RP_CntrlFirmwareFileName);
102d046c:	e51fab98 	ldr	sl, [pc, #-2968]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d0470:	e51f0c4c 	ldr	r0, [pc, #-3148]	; 102cf82c <MQTT_Send_Publish+0xff4>
102d0474:	e12fff3a 	blx	sl
102d0478:	e51f7b9c 	ldr	r7, [pc, #-2972]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d047c:	e51f1c54 	ldr	r1, [pc, #-3156]	; 102cf830 <MQTT_Send_Publish+0xff8>
102d0480:	e1a02000 	mov	r2, r0
102d0484:	e1a00008 	mov	r0, r8
102d0488:	e12fff37 	blx	r7
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_FILE_VER,RP_CntrlFirmwareVersion);
102d048c:	e51f0c60 	ldr	r0, [pc, #-3168]	; 102cf834 <MQTT_Send_Publish+0xffc>
102d0490:	e12fff3a 	blx	sl
102d0494:	e51f1c64 	ldr	r1, [pc, #-3172]	; 102cf838 <MQTT_Send_Publish+0x1000>
102d0498:	e1a02000 	mov	r2, r0
102d049c:	e1a00008 	mov	r0, r8
102d04a0:	e12fff37 	blx	r7
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_FILE_URL,RP_CntrlFirmwareFileURL);
102d04a4:	e51f0c70 	ldr	r0, [pc, #-3184]	; 102cf83c <MQTT_Send_Publish+0x1004>
102d04a8:	e12fff3a 	blx	sl
102d04ac:	e51f1c74 	ldr	r1, [pc, #-3188]	; 102cf840 <MQTT_Send_Publish+0x1008>
102d04b0:	e1a02000 	mov	r2, r0
102d04b4:	e1a00008 	mov	r0, r8
102d04b8:	e12fff37 	blx	r7

			FOTA_information = 0; //Reset the flags
102d04bc:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d04c0:	e3a03000 	mov	r3, #0
102d04c4:	e5cc3476 	strb	r3, [ip, #1142]	; 0x476
102d04c8:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d04cc:	eafff979 	b	102ceab8 <MQTT_Send_Publish+0x280>
			cJSON_AddStringToObject(json_root, TWIN_IOT_HUB_NAME,RP_IotHubName);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_IOT_HUB_NAME);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_DPS_ID_SCOPE)
		{
			cJSON_AddStringToObject(json_root, TWIN_DPS_ID_SCOPE,RP_DpsIdScope);
102d04d0:	e51f3bfc 	ldr	r3, [pc, #-3068]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d04d4:	e51f0c98 	ldr	r0, [pc, #-3224]	; 102cf844 <MQTT_Send_Publish+0x100c>
102d04d8:	e12fff33 	blx	r3
102d04dc:	e51f3c00 	ldr	r3, [pc, #-3072]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d04e0:	e51f1ca0 	ldr	r1, [pc, #-3232]	; 102cf848 <MQTT_Send_Publish+0x1010>
102d04e4:	e1a02000 	mov	r2, r0
102d04e8:	e1a00008 	mov	r0, r8
102d04ec:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DPS_ID_SCOPE);
102d04f0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d04f4:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d04f8:	e3c33020 	bic	r3, r3, #32
102d04fc:	e58c3374 	str	r3, [ip, #884]	; 0x374
102d0500:	eafff968 	b	102ceaa8 <MQTT_Send_Publish+0x270>
			cJSON_AddStringToObject(json_root, TWIN_DEVICE_STATUS,RP_devicestatus);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DEVICE_STATUS);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_IOT_HUB_NAME)
		{
			cJSON_AddStringToObject(json_root, TWIN_IOT_HUB_NAME,RP_IotHubName);
102d0504:	e51f3c30 	ldr	r3, [pc, #-3120]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d0508:	e51f0cc4 	ldr	r0, [pc, #-3268]	; 102cf84c <MQTT_Send_Publish+0x1014>
102d050c:	e12fff33 	blx	r3
102d0510:	e51f3c34 	ldr	r3, [pc, #-3124]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d0514:	e51f1ccc 	ldr	r1, [pc, #-3276]	; 102cf850 <MQTT_Send_Publish+0x1018>
102d0518:	e1a02000 	mov	r2, r0
102d051c:	e1a00008 	mov	r0, r8
102d0520:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_IOT_HUB_NAME);
102d0524:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0528:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d052c:	e3c33010 	bic	r3, r3, #16
102d0530:	e58c3374 	str	r3, [ip, #884]	; 0x374
102d0534:	eafff959 	b	102ceaa0 <MQTT_Send_Publish+0x268>
			cJSON_AddStringToObject(json_root, TWIN_DEVICE_TYPE,RP_devicetype);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DEVICE_TYPE);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_DEVICE_STATUS)
		{
			cJSON_AddStringToObject(json_root, TWIN_DEVICE_STATUS,RP_devicestatus);
102d0538:	e51f3c64 	ldr	r3, [pc, #-3172]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d053c:	e51f0cf0 	ldr	r0, [pc, #-3312]	; 102cf854 <MQTT_Send_Publish+0x101c>
102d0540:	e12fff33 	blx	r3
102d0544:	e51f3c68 	ldr	r3, [pc, #-3176]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d0548:	e51f1cf8 	ldr	r1, [pc, #-3320]	; 102cf858 <MQTT_Send_Publish+0x1020>
102d054c:	e1a02000 	mov	r2, r0
102d0550:	e1a00008 	mov	r0, r8
102d0554:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DEVICE_STATUS);
102d0558:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d055c:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d0560:	e3c33008 	bic	r3, r3, #8
102d0564:	e58c3374 	str	r3, [ip, #884]	; 0x374
102d0568:	eafff94a 	b	102cea98 <MQTT_Send_Publish+0x260>
			cJSON_AddStringToObject(json_root, TWIN_VENDOR_CODE,RP_vendorcode);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_VENDOR_CODE);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_DEVICE_TYPE)
		{
			cJSON_AddStringToObject(json_root, TWIN_DEVICE_TYPE,RP_devicetype);
102d056c:	e51f3c98 	ldr	r3, [pc, #-3224]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d0570:	e51f0d1c 	ldr	r0, [pc, #-3356]	; 102cf85c <MQTT_Send_Publish+0x1024>
102d0574:	e12fff33 	blx	r3
102d0578:	e51f3c9c 	ldr	r3, [pc, #-3228]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d057c:	e51f1d24 	ldr	r1, [pc, #-3364]	; 102cf860 <MQTT_Send_Publish+0x1028>
102d0580:	e1a02000 	mov	r2, r0
102d0584:	e1a00008 	mov	r0, r8
102d0588:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_DEVICE_TYPE);
102d058c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0590:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d0594:	e3c33004 	bic	r3, r3, #4
102d0598:	e58c3374 	str	r3, [ip, #884]	; 0x374
102d059c:	eafff93b 	b	102cea90 <MQTT_Send_Publish+0x258>
				cJSON_AddStringToObject(json_root, TWIN_GEOLOCATION,RP_Geolocation);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_GEOLOCATION);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_VENDOR_CODE)
		{
			cJSON_AddStringToObject(json_root, TWIN_VENDOR_CODE,RP_vendorcode);
102d05a0:	e51f3ccc 	ldr	r3, [pc, #-3276]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d05a4:	e51f0d48 	ldr	r0, [pc, #-3400]	; 102cf864 <MQTT_Send_Publish+0x102c>
102d05a8:	e12fff33 	blx	r3
102d05ac:	e51f3cd0 	ldr	r3, [pc, #-3280]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d05b0:	e51f1d50 	ldr	r1, [pc, #-3408]	; 102cf868 <MQTT_Send_Publish+0x1030>
102d05b4:	e1a02000 	mov	r2, r0
102d05b8:	e1a00008 	mov	r0, r8
102d05bc:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_VENDOR_CODE);
102d05c0:	e5973374 	ldr	r3, [r7, #884]	; 0x374
102d05c4:	e3c33002 	bic	r3, r3, #2
102d05c8:	e5873374 	str	r3, [r7, #884]	; 0x374
102d05cc:	eafff92d 	b	102cea88 <MQTT_Send_Publish+0x250>
#endif
		json_root = cJSON_CreateObject();

		{
			if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_GEOLOCATION)
				cJSON_AddStringToObject(json_root, TWIN_GEOLOCATION,RP_Geolocation);
102d05d0:	e51f3cfc 	ldr	r3, [pc, #-3324]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d05d4:	e51f0d70 	ldr	r0, [pc, #-3440]	; 102cf86c <MQTT_Send_Publish+0x1034>
102d05d8:	e12fff33 	blx	r3
102d05dc:	e51f1d74 	ldr	r1, [pc, #-3444]	; 102cf870 <MQTT_Send_Publish+0x1038>
102d05e0:	e51f3d04 	ldr	r3, [pc, #-3332]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d05e4:	e1a02000 	mov	r2, r0
102d05e8:	e1a00008 	mov	r0, r8
102d05ec:	e12fff33 	blx	r3
102d05f0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d05f4:	e59c2374 	ldr	r2, [ip, #884]	; 0x374
102d05f8:	eafff91c 	b	102cea70 <MQTT_Send_Publish+0x238>
102d05fc:	e51fcd90 	ldr	ip, [pc, #-3472]	; 102cf874 <MQTT_Send_Publish+0x103c>
102d0600:	e58dc028 	str	ip, [sp, #40]	; 0x28

	default:
		break;
	}
#ifdef DEBUG_MSG
	APP_DEBUG("*****-->\r\n");
102d0604:	e3a02c02 	mov	r2, #512	; 0x200
102d0608:	e3a01000 	mov	r1, #0
102d060c:	e51f0d88 	ldr	r0, [pc, #-3464]	; 102cf88c <MQTT_Send_Publish+0x1054>
102d0610:	e12fff36 	blx	r6
102d0614:	e5943000 	ldr	r3, [r4]
102d0618:	e51f1da8 	ldr	r1, [pc, #-3496]	; 102cf878 <MQTT_Send_Publish+0x1040>
102d061c:	e51f0d98 	ldr	r0, [pc, #-3480]	; 102cf88c <MQTT_Send_Publish+0x1054>
102d0620:	e12fff33 	blx	r3
102d0624:	e51f0da0 	ldr	r0, [pc, #-3488]	; 102cf88c <MQTT_Send_Publish+0x1054>
102d0628:	e12fff35 	blx	r5
102d062c:	e51f1da8 	ldr	r1, [pc, #-3496]	; 102cf88c <MQTT_Send_Publish+0x1054>
102d0630:	e51f3dbc 	ldr	r3, [pc, #-3516]	; 102cf87c <MQTT_Send_Publish+0x1044>
102d0634:	e1a02000 	mov	r2, r0
102d0638:	e3a0000a 	mov	r0, #10
102d063c:	e12fff33 	blx	r3
102d0640:	eafff967 	b	102cebe4 <MQTT_Send_Publish+0x3ac>
		{
			APP_DEBUG("CONNECTIVITY_ON ");
		}
		else if( MSG_TYPE == MQTT_CONNECTIVITY_LOW)
		{
			APP_DEBUG("CONNECTIVITY_LOW ");
102d0644:	e12fff33 	blx	r3
102d0648:	e59a3000 	ldr	r3, [sl]
102d064c:	e51f1dd4 	ldr	r1, [pc, #-3540]	; 102cf880 <MQTT_Send_Publish+0x1048>
102d0650:	e51f0dcc 	ldr	r0, [pc, #-3532]	; 102cf88c <MQTT_Send_Publish+0x1054>
102d0654:	e12fff33 	blx	r3
102d0658:	e51f0dd4 	ldr	r0, [pc, #-3540]	; 102cf88c <MQTT_Send_Publish+0x1054>
102d065c:	e12fff37 	blx	r7
102d0660:	e51f1ddc 	ldr	r1, [pc, #-3548]	; 102cf88c <MQTT_Send_Publish+0x1054>
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0664:	e51f7dd4 	ldr	r7, [pc, #-3540]	; 102cf898 <MQTT_Send_Publish+0x1060>
		{
			APP_DEBUG("CONNECTIVITY_ON ");
		}
		else if( MSG_TYPE == MQTT_CONNECTIVITY_LOW)
		{
			APP_DEBUG("CONNECTIVITY_LOW ");
102d0668:	e1a02000 	mov	r2, r0
102d066c:	e3a0000a 	mov	r0, #10
102d0670:	e12fff38 	blx	r8
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0674:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_CONN,"1");
		}
		else if( MSG_TYPE == MQTT_CONNECTIVITY_LOW)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_CONL,"1");
102d0678:	e51f8da4 	ldr	r8, [pc, #-3492]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d067c:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0680:	e12fff37 	blx	r7
102d0684:	e51f1df0 	ldr	r1, [pc, #-3568]	; 102cf89c <MQTT_Send_Publish+0x1064>
102d0688:	e51f7dac 	ldr	r7, [pc, #-3500]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d068c:	e1a09000 	mov	r9, r0
102d0690:	e1a02009 	mov	r2, r9
102d0694:	e1a0000a 	mov	r0, sl
102d0698:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_CONN,"1");
		}
		else if( MSG_TYPE == MQTT_CONNECTIVITY_LOW)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_CONL,"1");
102d069c:	e51f0e14 	ldr	r0, [pc, #-3604]	; 102cf890 <MQTT_Send_Publish+0x1058>
102d06a0:	e12fff38 	blx	r8
102d06a4:	e51f1e28 	ldr	r1, [pc, #-3624]	; 102cf884 <MQTT_Send_Publish+0x104c>
102d06a8:	e1a02000 	mov	r2, r0
102d06ac:	e1a00009 	mov	r0, r9
102d06b0:	e12fff37 	blx	r7
102d06b4:	eafffa1d 	b	102cef30 <MQTT_Send_Publish+0x6f8>
		{
			APP_DEBUG("OFF ");
		}
		else if( MSG_TYPE == MQTT_HEATING_ON)
		{
			APP_DEBUG("ON ");
102d06b8:	e12fff33 	blx	r3
102d06bc:	e59a3000 	ldr	r3, [sl]
102d06c0:	e51f1e40 	ldr	r1, [pc, #-3648]	; 102cf888 <MQTT_Send_Publish+0x1050>
102d06c4:	e51f0e40 	ldr	r0, [pc, #-3648]	; 102cf88c <MQTT_Send_Publish+0x1054>
102d06c8:	e12fff33 	blx	r3
102d06cc:	e51f0e48 	ldr	r0, [pc, #-3656]	; 102cf88c <MQTT_Send_Publish+0x1054>
102d06d0:	e12fff37 	blx	r7
102d06d4:	e51f1e50 	ldr	r1, [pc, #-3664]	; 102cf88c <MQTT_Send_Publish+0x1054>
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
		}
#endif
		json_root = cJSON_CreateObject();
102d06d8:	e51f7e48 	ldr	r7, [pc, #-3656]	; 102cf898 <MQTT_Send_Publish+0x1060>
		{
			APP_DEBUG("OFF ");
		}
		else if( MSG_TYPE == MQTT_HEATING_ON)
		{
			APP_DEBUG("ON ");
102d06dc:	e1a02000 	mov	r2, r0
102d06e0:	e3a0000a 	mov	r0, #10
102d06e4:	e12fff38 	blx	r8
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
		}
#endif
		json_root = cJSON_CreateObject();
102d06e8:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"0");
		}
		if( MSG_TYPE == MQTT_HEATING_ON)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"1");
102d06ec:	e51f8e18 	ldr	r8, [pc, #-3608]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
		}
#endif
		json_root = cJSON_CreateObject();
102d06f0:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d06f4:	e12fff37 	blx	r7
102d06f8:	e51f1e64 	ldr	r1, [pc, #-3684]	; 102cf89c <MQTT_Send_Publish+0x1064>
102d06fc:	e51f7e20 	ldr	r7, [pc, #-3616]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d0700:	e1a09000 	mov	r9, r0
102d0704:	e1a02009 	mov	r2, r9
102d0708:	e1a0000a 	mov	r0, sl
102d070c:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"0");
		}
		if( MSG_TYPE == MQTT_HEATING_ON)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"1");
102d0710:	e51f0e88 	ldr	r0, [pc, #-3720]	; 102cf890 <MQTT_Send_Publish+0x1058>
102d0714:	eafffd7d 	b	102cfd10 <MQTT_Send_Publish+0x14d8>
		{
			APP_DEBUG("EM_ERROR ");
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E1)
		{
			APP_DEBUG("EM_ERROR_E1 ");
102d0718:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d071c:	e3a02c02 	mov	r2, #512	; 0x200
102d0720:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0724:	e3a01000 	mov	r1, #0
102d0728:	e12fff33 	blx	r3
102d072c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0730:	e5983000 	ldr	r3, [r8]
102d0734:	e51f1ea8 	ldr	r1, [pc, #-3752]	; 102cf894 <MQTT_Send_Publish+0x105c>
102d0738:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d073c:	e12fff33 	blx	r3
102d0740:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_EMERROR,em_error);
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E1)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_EMERROR,em_error_E1);
102d0744:	e51f8e70 	ldr	r8, [pc, #-3696]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
		{
			APP_DEBUG("EM_ERROR ");
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E1)
		{
			APP_DEBUG("EM_ERROR_E1 ");
102d0748:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d074c:	e12fff37 	blx	r7
102d0750:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0754:	e51f7ec4 	ldr	r7, [pc, #-3780]	; 102cf898 <MQTT_Send_Publish+0x1060>
		{
			APP_DEBUG("EM_ERROR ");
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E1)
		{
			APP_DEBUG("EM_ERROR_E1 ");
102d0758:	e28c10b8 	add	r1, ip, #184	; 0xb8
102d075c:	e1a02000 	mov	r2, r0
102d0760:	e3a0000a 	mov	r0, #10
102d0764:	e12fff3a 	blx	sl
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0768:	e12fff37 	blx	r7
102d076c:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0770:	e12fff37 	blx	r7
102d0774:	e51f1ee0 	ldr	r1, [pc, #-3808]	; 102cf89c <MQTT_Send_Publish+0x1064>
102d0778:	e51f7e9c 	ldr	r7, [pc, #-3740]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d077c:	e1a09000 	mov	r9, r0
102d0780:	e1a02009 	mov	r2, r9
102d0784:	e1a0000a 	mov	r0, sl
102d0788:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_EMERROR,em_error);
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E1)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_EMERROR,em_error_E1);
102d078c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0790:	e28c0fcb 	add	r0, ip, #812	; 0x32c
102d0794:	e12fff38 	blx	r8
102d0798:	e51f1f00 	ldr	r1, [pc, #-3840]	; 102cf8a0 <MQTT_Send_Publish+0x1068>
102d079c:	e1a02000 	mov	r2, r0
102d07a0:	e1a00009 	mov	r0, r9
102d07a4:	e12fff37 	blx	r7
102d07a8:	eafffa1a 	b	102cf018 <MQTT_Send_Publish+0x7e0>

		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
			{
				Water_data_Publish_without_unit[i] = '\0';
102d07ac:	e51fcef0 	ldr	ip, [pc, #-3824]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102d07b0:	e3a03000 	mov	r3, #0
102d07b4:	e08c2002 	add	r2, ip, r2
102d07b8:	e58dc024 	str	ip, [sp, #36]	; 0x24
102d07bc:	e5c232b8 	strb	r3, [r2, #696]	; 0x2b8
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}

		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
102d07c0:	e51f0f00 	ldr	r0, [pc, #-3840]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
102d07c4:	e12fff38 	blx	r8
102d07c8:	e51f1f04 	ldr	r1, [pc, #-3844]	; 102cf8cc <MQTT_Send_Publish+0x1094>
102d07cc:	e1a02000 	mov	r2, r0
102d07d0:	e1a00009 	mov	r0, r9
102d07d4:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_FW_VER,FW_Version_STRING);
102d07d8:	e51f0f3c 	ldr	r0, [pc, #-3900]	; 102cf8a4 <MQTT_Send_Publish+0x106c>
102d07dc:	e12fff38 	blx	r8
102d07e0:	e51f1f40 	ldr	r1, [pc, #-3904]	; 102cf8a8 <MQTT_Send_Publish+0x1070>
102d07e4:	e1a02000 	mov	r2, r0
102d07e8:	e1a00009 	mov	r0, r9
102d07ec:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_FW_TS,__TIME__);
102d07f0:	e51f0f4c 	ldr	r0, [pc, #-3916]	; 102cf8ac <MQTT_Send_Publish+0x1074>
102d07f4:	e12fff38 	blx	r8
102d07f8:	e51f1f50 	ldr	r1, [pc, #-3920]	; 102cf8b0 <MQTT_Send_Publish+0x1078>
102d07fc:	e1a02000 	mov	r2, r0
102d0800:	e1a00009 	mov	r0, r9
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
102d0804:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_ID,Received_RCID);
102d0808:	e51f0f5c 	ldr	r0, [pc, #-3932]	; 102cf8b4 <MQTT_Send_Publish+0x107c>
102d080c:	e12fff38 	blx	r8
102d0810:	e51f1f60 	ldr	r1, [pc, #-3936]	; 102cf8b8 <MQTT_Send_Publish+0x1080>
102d0814:	e1a02000 	mov	r2, r0
102d0818:	e1a00009 	mov	r0, r9
102d081c:	e12fff37 	blx	r7
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_RC_TS,Received_RCTS);
102d0820:	e51f0f6c 	ldr	r0, [pc, #-3948]	; 102cf8bc <MQTT_Send_Publish+0x1084>
102d0824:	e12fff38 	blx	r8
102d0828:	e51f1f70 	ldr	r1, [pc, #-3952]	; 102cf8c0 <MQTT_Send_Publish+0x1088>
102d082c:	e1a02000 	mov	r2, r0
102d0830:	e1a00009 	mov	r0, r9
102d0834:	eafffe81 	b	102d0240 <MQTT_Send_Publish+0x1a08>

		for(i=0;i<5;i++)
		{
			if(water_balance_buffer[i] == ' ')// Check for a space to find end of Water data string
			{
				Water_data_Publish_without_unit[i] = '\0';
102d0838:	e51fcf7c 	ldr	ip, [pc, #-3964]	; 102cf8c4 <MQTT_Send_Publish+0x108c>
102d083c:	e3a03000 	mov	r3, #0
102d0840:	e08c2002 	add	r2, ip, r2
102d0844:	e58dc024 	str	ip, [sp, #36]	; 0x24
102d0848:	e5c232b8 	strb	r3, [r2, #696]	; 0x2b8
				i = 4;
			}
			else
				Water_data_Publish_without_unit[i] = water_balance_buffer[i];
		}
		cJSON_AddStringToObject(value, MQTT_PAYLOAD_BAL,Water_data_Publish_without_unit);
102d084c:	e51f0f8c 	ldr	r0, [pc, #-3980]	; 102cf8c8 <MQTT_Send_Publish+0x1090>
102d0850:	e12fff38 	blx	r8
102d0854:	e51f1f90 	ldr	r1, [pc, #-3984]	; 102cf8cc <MQTT_Send_Publish+0x1094>
102d0858:	e1a02000 	mov	r2, r0
102d085c:	e1a00009 	mov	r0, r9
102d0860:	eaffffe7 	b	102d0804 <MQTT_Send_Publish+0x1fcc>

				if(payload[0] != '{') //A payload is invalid if it start with character other than '{'
				{
					invalid_payload++;

					Ql_MEM_Free(payload);
102d0864:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
102d0868:	e12fff3c 	blx	ip
					payload = NULL;

					if(invalid_payload==MAX_PAYLOADS+1)
102d086c:	e3570001 	cmp	r7, #1
102d0870:	0a000003 	beq	102d0884 <MQTT_Send_Publish+0x204c>
		// Open the log file that stored unpublished MQTT messages or pending messgaes
		filehandleData = fileSys_OpenOrCreateFile((u8*)file_data);

		if(filehandleData >= QL_RET_OK)
		{
			for(i = 0; (invalid_payload+valid_payload)<MAX_PAYLOADS+1 ; i++) // Scan for all payloads in the file one by one
102d0874:	e2577001 	subs	r7, r7, #1
102d0878:	e2888001 	add	r8, r8, #1
102d087c:	1afffb3a 	bne	102cf56c <MQTT_Send_Publish+0xd34>
102d0880:	eaffff5f 	b	102d0604 <MQTT_Send_Publish+0x1dcc>
					Ql_MEM_Free(payload);
					payload = NULL;

					if(invalid_payload==MAX_PAYLOADS+1)
					{
						PUBLISH_RESPONSE_REQ_source &= (u32) (~SCHEDULE_PUBLISH_PENDING_MESSAGES); // Remove the pending log publish flag
102d0884:	e51f3fbc 	ldr	r3, [pc, #-4028]	; 102cf8d0 <MQTT_Send_Publish+0x1098>
102d0888:	e5932000 	ldr	r2, [r3]
102d088c:	e3c22040 	bic	r2, r2, #64	; 0x40
102d0890:	e5832000 	str	r2, [r3]
						break;
102d0894:	eaffff5a 	b	102d0604 <MQTT_Send_Publish+0x1dcc>
			cJSON_AddStringToObject(json_root, TWIN_IMEI,IMEI);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_IMIE);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CCID)
		{
			cJSON_AddStringToObject(json_root, TWIN_CCID,CCID);
102d0898:	e51f3fc4 	ldr	r3, [pc, #-4036]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d089c:	e51f0fd0 	ldr	r0, [pc, #-4048]	; 102cf8d4 <MQTT_Send_Publish+0x109c>
102d08a0:	e12fff33 	blx	r3
102d08a4:	e51f3fc8 	ldr	r3, [pc, #-4040]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d08a8:	e51f1fd8 	ldr	r1, [pc, #-4056]	; 102cf8d8 <MQTT_Send_Publish+0x10a0>
102d08ac:	e1a02000 	mov	r2, r0
102d08b0:	e1a00008 	mov	r0, r8
102d08b4:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CCID);
102d08b8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d08bc:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d08c0:	e3c33b01 	bic	r3, r3, #1024	; 0x400
102d08c4:	e58c3374 	str	r3, [ip, #884]	; 0x374
102d08c8:	eafff880 	b	102cead0 <MQTT_Send_Publish+0x298>
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_UPDATE_STATUS,RP_FW_Upgrade_status);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CNTL_FW_UPDTAE_STATUS);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_IMIE)
		{
			cJSON_AddStringToObject(json_root, TWIN_IMEI,IMEI);
102d08cc:	e51f3ff8 	ldr	r3, [pc, #-4088]	; 102cf8dc <MQTT_Send_Publish+0x10a4>
102d08d0:	e51f0ff8 	ldr	r0, [pc, #-4088]	; 102cf8e0 <MQTT_Send_Publish+0x10a8>
102d08d4:	e12fff33 	blx	r3
102d08d8:	e51f3ffc 	ldr	r3, [pc, #-4092]	; 102cf8e4 <MQTT_Send_Publish+0x10ac>
102d08dc:	e51f1ffc 	ldr	r1, [pc, #-4092]	; 102cf8e8 <MQTT_Send_Publish+0x10b0>
102d08e0:	e1a02000 	mov	r2, r0
102d08e4:	e1a00008 	mov	r0, r8
102d08e8:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_IMIE);
102d08ec:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d08f0:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d08f4:	e3c33c02 	bic	r3, r3, #512	; 0x200
102d08f8:	e58c3374 	str	r3, [ip, #884]	; 0x374
102d08fc:	eafff871 	b	102ceac8 <MQTT_Send_Publish+0x290>
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_FILE_VER,RP_CntrlFirmwareVersion);
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CNTRL_FW_VER);
		}
		if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CNTL_FW_UPDTAE_STATUS)
		{
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_UPDATE_STATUS,RP_FW_Upgrade_status);
102d0900:	e59f377c 	ldr	r3, [pc, #1916]	; 102d1084 <MQTT_Send_Publish+0x284c>
102d0904:	e59f077c 	ldr	r0, [pc, #1916]	; 102d1088 <MQTT_Send_Publish+0x2850>
102d0908:	e12fff33 	blx	r3
102d090c:	e59f3778 	ldr	r3, [pc, #1912]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0910:	e59f1778 	ldr	r1, [pc, #1912]	; 102d1090 <MQTT_Send_Publish+0x2858>
102d0914:	e1a02000 	mov	r2, r0
102d0918:	e1a00008 	mov	r0, r8
102d091c:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CNTL_FW_UPDTAE_STATUS);
102d0920:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0924:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d0928:	e3c33c01 	bic	r3, r3, #256	; 0x100
102d092c:	e58c3374 	str	r3, [ip, #884]	; 0x374
102d0930:	eafff862 	b	102ceac0 <MQTT_Send_Publish+0x288>
				&& (MSG_TYPE != MQTT_HEART_BEAT_MESSAGE) //Do not store regular heart beat events
				&& (MSG_TYPE != MQTT_TWIN_PROPERTIES)//Do not Store Device Twin related events
				&& (MSG_TYPE != MQTT_TWIN_REPORTED)//Do not Store Device Twin reported related events
				&& (FLAG.SSL_X509_CERTPRESENT == TRUE)) // Do not write log messages in case of device not configured with certificates
		{
			Topic_String = Ql_strstr(topic_subscibe,SECURE_GW_TOPIC_EVENT); //check GW_IoTHub-EVENT is present in topic_subscibe
102d0934:	e28d005c 	add	r0, sp, #92	; 0x5c
102d0938:	e59f1754 	ldr	r1, [pc, #1876]	; 102d1094 <MQTT_Send_Publish+0x285c>
102d093c:	e59f4754 	ldr	r4, [pc, #1876]	; 102d1098 <MQTT_Send_Publish+0x2860>
102d0940:	e12fff34 	blx	r4
			if(Topic_String != NULL)
102d0944:	e3500000 	cmp	r0, #0
102d0948:	0a000193 	beq	102d0f9c <MQTT_Send_Publish+0x2764>
			{
				payload[2]='E';  // replace "d" with "E" to identify log message is event
102d094c:	e3a03045 	mov	r3, #69	; 0x45
102d0950:	e5c73002 	strb	r3, [r7, #2]
					{
						payload[2]='A';  // replace "d" with "A" to identify log message is ack
					}
				}
			}
			Write_And_Store_Pending_MQTT_Log_Messages(payload);
102d0954:	e1a00007 	mov	r0, r7
102d0958:	e59f373c 	ldr	r3, [pc, #1852]	; 102d109c <MQTT_Send_Publish+0x2864>
102d095c:	e12fff33 	blx	r3
102d0960:	eafffc82 	b	102cfb70 <MQTT_Send_Publish+0x1338>

			FOTA_information = 0; //Reset the flags
		}
		else if(Process_TWIN_PROPERTY_CHANGE & REPORT_TWIN_CNTRL_FW_VER) // Report back FW version if not reported
		{
			cJSON_AddStringToObject(json_root, TWIN_CNTRL_FW_FILE_VER,RP_CntrlFirmwareVersion);
102d0964:	e59f3718 	ldr	r3, [pc, #1816]	; 102d1084 <MQTT_Send_Publish+0x284c>
102d0968:	e59f0730 	ldr	r0, [pc, #1840]	; 102d10a0 <MQTT_Send_Publish+0x2868>
102d096c:	e12fff33 	blx	r3
102d0970:	e59f3714 	ldr	r3, [pc, #1812]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0974:	e59f1728 	ldr	r1, [pc, #1832]	; 102d10a4 <MQTT_Send_Publish+0x286c>
102d0978:	e1a02000 	mov	r2, r0
102d097c:	e1a00008 	mov	r0, r8
102d0980:	e12fff33 	blx	r3
			Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CNTRL_FW_VER);
102d0984:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0988:	e59c3374 	ldr	r3, [ip, #884]	; 0x374
102d098c:	e3c33080 	bic	r3, r3, #128	; 0x80
102d0990:	e58c3374 	str	r3, [ip, #884]	; 0x374
102d0994:	eafff847 	b	102ceab8 <MQTT_Send_Publish+0x280>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH HEATING ");
		if( MSG_TYPE == MQTT_HEATING_OFF)
		{
			APP_DEBUG("OFF ");
102d0998:	e12fff33 	blx	r3
102d099c:	e59a3000 	ldr	r3, [sl]
102d09a0:	e59f1700 	ldr	r1, [pc, #1792]	; 102d10a8 <MQTT_Send_Publish+0x2870>
102d09a4:	e59f0700 	ldr	r0, [pc, #1792]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d09a8:	e12fff33 	blx	r3
102d09ac:	e59f06f8 	ldr	r0, [pc, #1784]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d09b0:	e12fff37 	blx	r7
102d09b4:	e59f16f0 	ldr	r1, [pc, #1776]	; 102d10ac <MQTT_Send_Publish+0x2874>
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
		}
#endif
		json_root = cJSON_CreateObject();
102d09b8:	e59f76f0 	ldr	r7, [pc, #1776]	; 102d10b0 <MQTT_Send_Publish+0x2878>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH HEATING ");
		if( MSG_TYPE == MQTT_HEATING_OFF)
		{
			APP_DEBUG("OFF ");
102d09bc:	e1a02000 	mov	r2, r0
102d09c0:	e3a0000a 	mov	r0, #10
102d09c4:	e12fff38 	blx	r8
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
		}
#endif
		json_root = cJSON_CreateObject();
102d09c8:	e12fff37 	blx	r7
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		if( MSG_TYPE == MQTT_HEATING_OFF)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"0");
102d09cc:	e59f86b0 	ldr	r8, [pc, #1712]	; 102d1084 <MQTT_Send_Publish+0x284c>
		else if( MSG_TYPE == MQTT_HEATING_COMPLETE)
		{
			APP_DEBUG("COMPLETE ");
		}
#endif
		json_root = cJSON_CreateObject();
102d09d0:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d09d4:	e12fff37 	blx	r7
102d09d8:	e59f16d4 	ldr	r1, [pc, #1748]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d09dc:	e59f76a8 	ldr	r7, [pc, #1704]	; 102d108c <MQTT_Send_Publish+0x2854>
102d09e0:	e1a09000 	mov	r9, r0
102d09e4:	e1a02009 	mov	r2, r9
102d09e8:	e1a0000a 	mov	r0, sl
102d09ec:	e12fff37 	blx	r7
		if( MSG_TYPE == MQTT_HEATING_OFF)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_HEATER,"0");
102d09f0:	e59f06c0 	ldr	r0, [pc, #1728]	; 102d10b8 <MQTT_Send_Publish+0x2880>
102d09f4:	eafffcc5 	b	102cfd10 <MQTT_Send_Publish+0x14d8>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
		if( MSG_TYPE == MQTT_EM_ERROR)
		{
			APP_DEBUG("EM_ERROR ");
102d09f8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d09fc:	e3a02c02 	mov	r2, #512	; 0x200
102d0a00:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0a04:	e3a01000 	mov	r1, #0
102d0a08:	e12fff33 	blx	r3
102d0a0c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0a10:	e5983000 	ldr	r3, [r8]
102d0a14:	e59f16a0 	ldr	r1, [pc, #1696]	; 102d10bc <MQTT_Send_Publish+0x2884>
102d0a18:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0a1c:	e12fff33 	blx	r3
102d0a20:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
#endif
		json_root = cJSON_CreateObject();
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		if( MSG_TYPE == MQTT_EM_ERROR)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_EMERROR,em_error);
102d0a24:	e59f8658 	ldr	r8, [pc, #1624]	; 102d1084 <MQTT_Send_Publish+0x284c>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
		if( MSG_TYPE == MQTT_EM_ERROR)
		{
			APP_DEBUG("EM_ERROR ");
102d0a28:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0a2c:	e12fff37 	blx	r7
102d0a30:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0a34:	e59f7674 	ldr	r7, [pc, #1652]	; 102d10b0 <MQTT_Send_Publish+0x2878>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
		if( MSG_TYPE == MQTT_EM_ERROR)
		{
			APP_DEBUG("EM_ERROR ");
102d0a38:	e28c10b8 	add	r1, ip, #184	; 0xb8
102d0a3c:	e1a02000 	mov	r2, r0
102d0a40:	e3a0000a 	mov	r0, #10
102d0a44:	e12fff3a 	blx	sl
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0a48:	e12fff37 	blx	r7
102d0a4c:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0a50:	e12fff37 	blx	r7
102d0a54:	e59f1658 	ldr	r1, [pc, #1624]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d0a58:	e59f762c 	ldr	r7, [pc, #1580]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0a5c:	e1a09000 	mov	r9, r0
102d0a60:	e1a02009 	mov	r2, r9
102d0a64:	e1a0000a 	mov	r0, sl
102d0a68:	e12fff37 	blx	r7
		if( MSG_TYPE == MQTT_EM_ERROR)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_EMERROR,em_error);
102d0a6c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0a70:	e28c0fca 	add	r0, ip, #808	; 0x328
102d0a74:	eaffff46 	b	102d0794 <MQTT_Send_Publish+0x1f5c>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
		if( MSG_TYPE == MQTT_CONNECTIVITY_ON)
		{
			APP_DEBUG("CONNECTIVITY_ON ");
102d0a78:	e12fff33 	blx	r3
102d0a7c:	e59a3000 	ldr	r3, [sl]
102d0a80:	e59f1638 	ldr	r1, [pc, #1592]	; 102d10c0 <MQTT_Send_Publish+0x2888>
102d0a84:	e59f0620 	ldr	r0, [pc, #1568]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0a88:	e12fff33 	blx	r3
102d0a8c:	e59f0618 	ldr	r0, [pc, #1560]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0a90:	e12fff37 	blx	r7
102d0a94:	e59f1610 	ldr	r1, [pc, #1552]	; 102d10ac <MQTT_Send_Publish+0x2874>
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0a98:	e59f7610 	ldr	r7, [pc, #1552]	; 102d10b0 <MQTT_Send_Publish+0x2878>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
		if( MSG_TYPE == MQTT_CONNECTIVITY_ON)
		{
			APP_DEBUG("CONNECTIVITY_ON ");
102d0a9c:	e1a02000 	mov	r2, r0
102d0aa0:	e3a0000a 	mov	r0, #10
102d0aa4:	e12fff38 	blx	r8
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0aa8:	e12fff37 	blx	r7
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		if( MSG_TYPE == MQTT_CONNECTIVITY_ON)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_CONN,"1");
102d0aac:	e59f85d0 	ldr	r8, [pc, #1488]	; 102d1084 <MQTT_Send_Publish+0x284c>
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0ab0:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0ab4:	e12fff37 	blx	r7
102d0ab8:	e59f15f4 	ldr	r1, [pc, #1524]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d0abc:	e59f75c8 	ldr	r7, [pc, #1480]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0ac0:	e1a09000 	mov	r9, r0
102d0ac4:	e1a02009 	mov	r2, r9
102d0ac8:	e1a0000a 	mov	r0, sl
102d0acc:	e12fff37 	blx	r7
		if( MSG_TYPE == MQTT_CONNECTIVITY_ON)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_CONN,"1");
102d0ad0:	e59f05ec 	ldr	r0, [pc, #1516]	; 102d10c4 <MQTT_Send_Publish+0x288c>
102d0ad4:	e12fff38 	blx	r8
102d0ad8:	e59f15e8 	ldr	r1, [pc, #1512]	; 102d10c8 <MQTT_Send_Publish+0x2890>
102d0adc:	e1a02000 	mov	r2, r0
102d0ae0:	e1a00009 	mov	r0, r9
102d0ae4:	e12fff37 	blx	r7
102d0ae8:	eafff910 	b	102cef30 <MQTT_Send_Publish+0x6f8>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_POWER_");
		if( MSG_TYPE == MQTT_POWER_ON)
		{
			APP_DEBUG("ON ");
102d0aec:	e12fff33 	blx	r3
102d0af0:	e59a3000 	ldr	r3, [sl]
102d0af4:	e59f15d0 	ldr	r1, [pc, #1488]	; 102d10cc <MQTT_Send_Publish+0x2894>
102d0af8:	e59f05ac 	ldr	r0, [pc, #1452]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0afc:	e12fff33 	blx	r3
102d0b00:	e59f05a4 	ldr	r0, [pc, #1444]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0b04:	e12fff37 	blx	r7
102d0b08:	e59f159c 	ldr	r1, [pc, #1436]	; 102d10ac <MQTT_Send_Publish+0x2874>
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			APP_DEBUG("OFF ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0b0c:	e59f759c 	ldr	r7, [pc, #1436]	; 102d10b0 <MQTT_Send_Publish+0x2878>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_POWER_");
		if( MSG_TYPE == MQTT_POWER_ON)
		{
			APP_DEBUG("ON ");
102d0b10:	e1a02000 	mov	r2, r0
102d0b14:	e3a0000a 	mov	r0, #10
102d0b18:	e12fff38 	blx	r8
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			APP_DEBUG("OFF ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0b1c:	e12fff37 	blx	r7
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
		if( MSG_TYPE == MQTT_POWER_ON)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_PWR,"1");
102d0b20:	e59f855c 	ldr	r8, [pc, #1372]	; 102d1084 <MQTT_Send_Publish+0x284c>
		else if( MSG_TYPE == MQTT_POWER_OFF)
		{
			APP_DEBUG("OFF ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0b24:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0b28:	e12fff37 	blx	r7
102d0b2c:	e59f1580 	ldr	r1, [pc, #1408]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d0b30:	e59f7554 	ldr	r7, [pc, #1364]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0b34:	e1a09000 	mov	r9, r0
102d0b38:	e1a02009 	mov	r2, r9
102d0b3c:	e1a0000a 	mov	r0, sl
102d0b40:	e12fff37 	blx	r7
		if( MSG_TYPE == MQTT_POWER_ON)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_PWR,"1");
102d0b44:	e59f0578 	ldr	r0, [pc, #1400]	; 102d10c4 <MQTT_Send_Publish+0x288c>
102d0b48:	eafff8ae 	b	102cee08 <MQTT_Send_Publish+0x5d0>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
		if( MSG_TYPE == MQTT_LOCK_ACK)
		{
			APP_DEBUG("LOCK_ACK ");
102d0b4c:	e12fff33 	blx	r3
102d0b50:	e59a3000 	ldr	r3, [sl]
102d0b54:	e59f1574 	ldr	r1, [pc, #1396]	; 102d10d0 <MQTT_Send_Publish+0x2898>
102d0b58:	e59f054c 	ldr	r0, [pc, #1356]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0b5c:	e12fff33 	blx	r3
102d0b60:	e59f0544 	ldr	r0, [pc, #1348]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0b64:	e12fff37 	blx	r7
102d0b68:	e59f153c 	ldr	r1, [pc, #1340]	; 102d10ac <MQTT_Send_Publish+0x2874>
		else if( MSG_TYPE == MQTT_UNLOCK_ACK)
		{
			APP_DEBUG("UNLOCK_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0b6c:	e59f753c 	ldr	r7, [pc, #1340]	; 102d10b0 <MQTT_Send_Publish+0x2878>
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());

		cJSON_AddStringToObject(value,((MSG_TYPE == MQTT_LOCK_ACK) ? MQTT_PAYLOAD_LOCK_ACK : MQTT_PAYLOAD_UNLOCK_ACK), ((Ql_strcmp(lock_unlock_ack, "0") == 0) ? "1" : "0"));
102d0b70:	e59f955c 	ldr	r9, [pc, #1372]	; 102d10d4 <MQTT_Send_Publish+0x289c>
	{
#ifdef DEBUG_MSG
		APP_DEBUG(" PUBLISH MQTT_");
		if( MSG_TYPE == MQTT_LOCK_ACK)
		{
			APP_DEBUG("LOCK_ACK ");
102d0b74:	e1a02000 	mov	r2, r0
102d0b78:	e3a0000a 	mov	r0, #10
102d0b7c:	e12fff38 	blx	r8
		else if( MSG_TYPE == MQTT_UNLOCK_ACK)
		{
			APP_DEBUG("UNLOCK_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0b80:	e12fff37 	blx	r7
102d0b84:	e58d0028 	str	r0, [sp, #40]	; 0x28
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0b88:	e12fff37 	blx	r7
102d0b8c:	e59f1520 	ldr	r1, [pc, #1312]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d0b90:	e59f74f4 	ldr	r7, [pc, #1268]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0b94:	e1a0a000 	mov	sl, r0
102d0b98:	e1a0200a 	mov	r2, sl
102d0b9c:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
102d0ba0:	e12fff37 	blx	r7
102d0ba4:	eafffa34 	b	102cf47c <MQTT_Send_Publish+0xc44>
		{
			APP_DEBUG("CONNECTIVITY_LOW ");
		}
		else if( MSG_TYPE == MQTT_BAL_ZERO)
		{
			APP_DEBUG("BAL_ZERO ");
102d0ba8:	e12fff33 	blx	r3
102d0bac:	e59a3000 	ldr	r3, [sl]
102d0bb0:	e59f1520 	ldr	r1, [pc, #1312]	; 102d10d8 <MQTT_Send_Publish+0x28a0>
102d0bb4:	e59f04f0 	ldr	r0, [pc, #1264]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0bb8:	e12fff33 	blx	r3
102d0bbc:	e59f04e8 	ldr	r0, [pc, #1256]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0bc0:	e12fff37 	blx	r7
102d0bc4:	e59f14e0 	ldr	r1, [pc, #1248]	; 102d10ac <MQTT_Send_Publish+0x2874>
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0bc8:	e59f74e0 	ldr	r7, [pc, #1248]	; 102d10b0 <MQTT_Send_Publish+0x2878>
		{
			APP_DEBUG("CONNECTIVITY_LOW ");
		}
		else if( MSG_TYPE == MQTT_BAL_ZERO)
		{
			APP_DEBUG("BAL_ZERO ");
102d0bcc:	e1a02000 	mov	r2, r0
102d0bd0:	e3a0000a 	mov	r0, #10
102d0bd4:	e12fff38 	blx	r8
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0bd8:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_CONL,"1");
		}
		else if( MSG_TYPE == MQTT_BAL_ZERO)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_ZBAL,"1");
102d0bdc:	e59f84a0 	ldr	r8, [pc, #1184]	; 102d1084 <MQTT_Send_Publish+0x284c>
		else if( MSG_TYPE == MQTT_BAL_LOW)
		{
			APP_DEBUG("BAL_LOW ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0be0:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0be4:	e12fff37 	blx	r7
102d0be8:	e59f14c4 	ldr	r1, [pc, #1220]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d0bec:	e59f7498 	ldr	r7, [pc, #1176]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0bf0:	e1a09000 	mov	r9, r0
102d0bf4:	e1a02009 	mov	r2, r9
102d0bf8:	e1a0000a 	mov	r0, sl
102d0bfc:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_CONL,"1");
		}
		else if( MSG_TYPE == MQTT_BAL_ZERO)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_ZBAL,"1");
102d0c00:	e59f04bc 	ldr	r0, [pc, #1212]	; 102d10c4 <MQTT_Send_Publish+0x288c>
102d0c04:	e12fff38 	blx	r8
102d0c08:	e59f14cc 	ldr	r1, [pc, #1228]	; 102d10dc <MQTT_Send_Publish+0x28a4>
102d0c0c:	e1a02000 	mov	r2, r0
102d0c10:	e1a00009 	mov	r0, r9
102d0c14:	e12fff37 	blx	r7
102d0c18:	eafff8c4 	b	102cef30 <MQTT_Send_Publish+0x6f8>
		{
			APP_DEBUG("EM_ERROR_E1 ");
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E5)
		{
			APP_DEBUG("EM_ERROR_E5 ");
102d0c1c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0c20:	e3a02c02 	mov	r2, #512	; 0x200
102d0c24:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0c28:	e3a01000 	mov	r1, #0
102d0c2c:	e12fff33 	blx	r3
102d0c30:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0c34:	e5983000 	ldr	r3, [r8]
102d0c38:	e59f14a0 	ldr	r1, [pc, #1184]	; 102d10e0 <MQTT_Send_Publish+0x28a8>
102d0c3c:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0c40:	e12fff33 	blx	r3
102d0c44:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_EMERROR,em_error_E1);
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E5)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LOW_FLOW,em_error_E5);
102d0c48:	e59f8434 	ldr	r8, [pc, #1076]	; 102d1084 <MQTT_Send_Publish+0x284c>
		{
			APP_DEBUG("EM_ERROR_E1 ");
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E5)
		{
			APP_DEBUG("EM_ERROR_E5 ");
102d0c4c:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0c50:	e12fff37 	blx	r7
102d0c54:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0c58:	e59f7450 	ldr	r7, [pc, #1104]	; 102d10b0 <MQTT_Send_Publish+0x2878>
		{
			APP_DEBUG("EM_ERROR_E1 ");
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E5)
		{
			APP_DEBUG("EM_ERROR_E5 ");
102d0c5c:	e28c10b8 	add	r1, ip, #184	; 0xb8
102d0c60:	e1a02000 	mov	r2, r0
102d0c64:	e1a0000b 	mov	r0, fp
102d0c68:	e12fff3a 	blx	sl
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0c6c:	e12fff37 	blx	r7
102d0c70:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0c74:	e12fff37 	blx	r7
102d0c78:	e59f1434 	ldr	r1, [pc, #1076]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d0c7c:	e59f7408 	ldr	r7, [pc, #1032]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0c80:	e1a09000 	mov	r9, r0
102d0c84:	e1a02009 	mov	r2, r9
102d0c88:	e1a0000a 	mov	r0, sl
102d0c8c:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_EMERROR,em_error_E1);
		}
		else if( MSG_TYPE == MQTT_EM_ERROR_E5)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LOW_FLOW,em_error_E5);
102d0c90:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0c94:	e28c0e33 	add	r0, ip, #816	; 0x330
102d0c98:	e12fff38 	blx	r8
102d0c9c:	e59f1440 	ldr	r1, [pc, #1088]	; 102d10e4 <MQTT_Send_Publish+0x28ac>
102d0ca0:	e1a02000 	mov	r2, r0
102d0ca4:	e1a00009 	mov	r0, r9
102d0ca8:	e12fff37 	blx	r7
102d0cac:	eafff8d9 	b	102cf018 <MQTT_Send_Publish+0x7e0>
		{
			APP_DEBUG("EM_ERROR_E5 ");
		}
		else if( MSG_TYPE == MQTT_TAMPER)
		{
			APP_DEBUG("TAMPER ");
102d0cb0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0cb4:	e3a02c02 	mov	r2, #512	; 0x200
102d0cb8:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0cbc:	e3a01000 	mov	r1, #0
102d0cc0:	e12fff33 	blx	r3
102d0cc4:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0cc8:	e5983000 	ldr	r3, [r8]
102d0ccc:	e59f1414 	ldr	r1, [pc, #1044]	; 102d10e8 <MQTT_Send_Publish+0x28b0>
102d0cd0:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0cd4:	e12fff33 	blx	r3
102d0cd8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LOW_FLOW,em_error_E5);
		}
		else if( MSG_TYPE == MQTT_TAMPER)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_TAMPER,tamper);
102d0cdc:	e59f83a0 	ldr	r8, [pc, #928]	; 102d1084 <MQTT_Send_Publish+0x284c>
		{
			APP_DEBUG("EM_ERROR_E5 ");
		}
		else if( MSG_TYPE == MQTT_TAMPER)
		{
			APP_DEBUG("TAMPER ");
102d0ce0:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0ce4:	e12fff37 	blx	r7
102d0ce8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0cec:	e59f73bc 	ldr	r7, [pc, #956]	; 102d10b0 <MQTT_Send_Publish+0x2878>
		{
			APP_DEBUG("EM_ERROR_E5 ");
		}
		else if( MSG_TYPE == MQTT_TAMPER)
		{
			APP_DEBUG("TAMPER ");
102d0cf0:	e28c10b8 	add	r1, ip, #184	; 0xb8
102d0cf4:	e1a02000 	mov	r2, r0
102d0cf8:	e3a0000a 	mov	r0, #10
102d0cfc:	e12fff3a 	blx	sl
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
		}
#endif
		json_root = cJSON_CreateObject();
102d0d00:	e12fff37 	blx	r7
102d0d04:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0d08:	e12fff37 	blx	r7
102d0d0c:	e59f13a0 	ldr	r1, [pc, #928]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d0d10:	e59f7374 	ldr	r7, [pc, #884]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0d14:	e1a09000 	mov	r9, r0
102d0d18:	e1a02009 	mov	r2, r9
102d0d1c:	e1a0000a 	mov	r0, sl
102d0d20:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LOW_FLOW,em_error_E5);
		}
		else if( MSG_TYPE == MQTT_TAMPER)
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_TAMPER,tamper);
102d0d24:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0d28:	e28c0fcd 	add	r0, ip, #820	; 0x334
102d0d2c:	e12fff38 	blx	r8
102d0d30:	e59f13b4 	ldr	r1, [pc, #948]	; 102d10ec <MQTT_Send_Publish+0x28b4>
102d0d34:	e1a02000 	mov	r2, r0
102d0d38:	e1a00009 	mov	r0, r9
102d0d3c:	e12fff37 	blx	r7
102d0d40:	eafff8b4 	b	102cf018 <MQTT_Send_Publish+0x7e0>
				Process_TWIN_PROPERTY_CHANGE &= (u32) (~REPORT_TWIN_CNTRL_FW_INFO);
			}
		}
		else
		{
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102d0d44:	e3a02002 	mov	r2, #2
102d0d48:	e3a00003 	mov	r0, #3
102d0d4c:	e59f139c 	ldr	r1, [pc, #924]	; 102d10f0 <MQTT_Send_Publish+0x28b8>
102d0d50:	e1a03002 	mov	r3, r2
102d0d54:	e59f9398 	ldr	r9, [pc, #920]	; 102d10f4 <MQTT_Send_Publish+0x28bc>
102d0d58:	e12fff39 	blx	r9
#ifdef DEBUG_MSG
			if(ssid == SSID_HOST_AZURE)
102d0d5c:	e59dc038 	ldr	ip, [sp, #56]	; 0x38
102d0d60:	e35c0000 	cmp	ip, #0
102d0d64:	0a000043 	beq	102d0e78 <MQTT_Send_Publish+0x2640>
				APP_DEBUG("<-- [FAIL] data Send-AZURE_IOTHUB -->\r\n");
#endif
			//Message failed to publish will be storeed in the log
			if((MSG_TYPE != MQTT_PING_REQUEST_AZURE) // Do not store PING message
102d0d68:	e35b0018 	cmp	fp, #24
102d0d6c:	135b0013 	cmpne	fp, #19
102d0d70:	0a000007 	beq	102d0d94 <MQTT_Send_Publish+0x255c>
					&& (MSG_TYPE != MQTT_LOG) // Do not store log record
					&& (MSG_TYPE != MQTT_HEART_BEAT_MESSAGE) //Do not store regular heart beat events
					&& (MSG_TYPE != MQTT_TWIN_PROPERTIES)//Do not Store Device Twin related events
102d0d74:	e35b0040 	cmp	fp, #64	; 0x40
102d0d78:	135b0014 	cmpne	fp, #20
102d0d7c:	0a000004 	beq	102d0d94 <MQTT_Send_Publish+0x255c>
					&& (MSG_TYPE != MQTT_TWIN_REPORTED)//Do not Store Device Twin reported related events
102d0d80:	e35b0041 	cmp	fp, #65	; 0x41
102d0d84:	0a000002 	beq	102d0d94 <MQTT_Send_Publish+0x255c>
					&& (FLAG.SSL_X509_CERTPRESENT == TRUE)) // Do not write log messages in case of device not configured with certificates
102d0d88:	e5d83015 	ldrb	r3, [r8, #21]
102d0d8c:	e3530001 	cmp	r3, #1
102d0d90:	0a0000a1 	beq	102d101c <MQTT_Send_Publish+0x27e4>
					}
				}
				Write_And_Store_Pending_MQTT_Log_Messages(payload);
			}

			Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_GET_GPRS_STRENGTH,0);
102d0d94:	e3a00000 	mov	r0, #0
102d0d98:	e59f1350 	ldr	r1, [pc, #848]	; 102d10f0 <MQTT_Send_Publish+0x28b8>
102d0d9c:	e3a02004 	mov	r2, #4
102d0da0:	e1a03000 	mov	r3, r0
102d0da4:	e12fff39 	blx	r9
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_ANTENNA_SYMBOL);
102d0da8:	e3a03000 	mov	r3, #0
102d0dac:	e3a00003 	mov	r0, #3
102d0db0:	e59f1338 	ldr	r1, [pc, #824]	; 102d10f0 <MQTT_Send_Publish+0x28b8>
102d0db4:	e3a02002 	mov	r2, #2
102d0db8:	e12fff39 	blx	r9
			FLAG.MQTT_CONNECTION_STATUS = FALSE; // Mark the connection not available flag
102d0dbc:	e3a03000 	mov	r3, #0
102d0dc0:	e5c8300d 	strb	r3, [r8, #13]
			FLAG.CON_MSG_PUBLISH_PENDING = TRUE; // At next successful connection it is required to publish the connection ON record so enable this flag
102d0dc4:	e3a03001 	mov	r3, #1
102d0dc8:	e5c83004 	strb	r3, [r8, #4]
102d0dcc:	eafffb77 	b	102cfbb0 <MQTT_Send_Publish+0x1378>
		{
			APP_DEBUG("TAMPER ");
		}
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
102d0dd0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0dd4:	e3a02c02 	mov	r2, #512	; 0x200
102d0dd8:	e3a01000 	mov	r1, #0
102d0ddc:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0de0:	e12fff33 	blx	r3
102d0de4:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0de8:	e5983000 	ldr	r3, [r8]
102d0dec:	e59f1304 	ldr	r1, [pc, #772]	; 102d10f8 <MQTT_Send_Publish+0x28c0>
102d0df0:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0df4:	e12fff33 	blx	r3
102d0df8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
102d0dfc:	e28c00b8 	add	r0, ip, #184	; 0xb8
102d0e00:	e12fff37 	blx	r7
102d0e04:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
		}
#endif
		json_root = cJSON_CreateObject();
102d0e08:	e59f72a0 	ldr	r7, [pc, #672]	; 102d10b0 <MQTT_Send_Publish+0x2878>
		{
			APP_DEBUG("TAMPER ");
		}
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			APP_DEBUG("LANGUAGE_ACK ");
102d0e0c:	e28c10b8 	add	r1, ip, #184	; 0xb8
102d0e10:	e1a02000 	mov	r2, r0
102d0e14:	e3a0000a 	mov	r0, #10
102d0e18:	e12fff3a 	blx	sl
		}
#endif
		json_root = cJSON_CreateObject();
102d0e1c:	e12fff37 	blx	r7
102d0e20:	e1a0a000 	mov	sl, r0
		cJSON_AddItemToObject(json_root, "d", value = cJSON_CreateObject());
102d0e24:	e12fff37 	blx	r7
102d0e28:	e59f1284 	ldr	r1, [pc, #644]	; 102d10b4 <MQTT_Send_Publish+0x287c>
102d0e2c:	e59f7258 	ldr	r7, [pc, #600]	; 102d108c <MQTT_Send_Publish+0x2854>
102d0e30:	e1a09000 	mov	r9, r0
102d0e34:	e1a02009 	mov	r2, r9
102d0e38:	e1a0000a 	mov	r0, sl
102d0e3c:	e12fff37 	blx	r7
		{
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_TAMPER,tamper);
		}
		else if( MSG_TYPE == MQTT_LANGUAGE_ACK)
		{
			Ql_sprintf(string_temp, "%d",language_index);
102d0e40:	e59f32b4 	ldr	r3, [pc, #692]	; 102d10fc <MQTT_Send_Publish+0x28c4>
102d0e44:	e59f12b4 	ldr	r1, [pc, #692]	; 102d1100 <MQTT_Send_Publish+0x28c8>
102d0e48:	e5932000 	ldr	r2, [r3]
102d0e4c:	e28d0044 	add	r0, sp, #68	; 0x44
102d0e50:	e5983000 	ldr	r3, [r8]
102d0e54:	e12fff33 	blx	r3
			cJSON_AddStringToObject(value, MQTT_PAYLOAD_LANGUAGE_ACK,string_temp);
102d0e58:	e59f8224 	ldr	r8, [pc, #548]	; 102d1084 <MQTT_Send_Publish+0x284c>
102d0e5c:	e28d0044 	add	r0, sp, #68	; 0x44
102d0e60:	e12fff38 	blx	r8
102d0e64:	e59f1298 	ldr	r1, [pc, #664]	; 102d1104 <MQTT_Send_Publish+0x28cc>
102d0e68:	e1a02000 	mov	r2, r0
102d0e6c:	e1a00009 	mov	r0, r9
102d0e70:	e12fff37 	blx	r7
102d0e74:	eafff867 	b	102cf018 <MQTT_Send_Publish+0x7e0>
		else
		{
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
#ifdef DEBUG_MSG
			if(ssid == SSID_HOST_AZURE)
				APP_DEBUG("<-- [FAIL] data Send-AZURE_IOTHUB -->\r\n");
102d0e78:	e1a0100c 	mov	r1, ip
102d0e7c:	e3a02c02 	mov	r2, #512	; 0x200
102d0e80:	e59f3280 	ldr	r3, [pc, #640]	; 102d1108 <MQTT_Send_Publish+0x28d0>
102d0e84:	e59f0220 	ldr	r0, [pc, #544]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0e88:	e12fff33 	blx	r3
102d0e8c:	e59f3278 	ldr	r3, [pc, #632]	; 102d110c <MQTT_Send_Publish+0x28d4>
102d0e90:	e59f1278 	ldr	r1, [pc, #632]	; 102d1110 <MQTT_Send_Publish+0x28d8>
102d0e94:	e5933000 	ldr	r3, [r3]
102d0e98:	e59f020c 	ldr	r0, [pc, #524]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0e9c:	e12fff33 	blx	r3
102d0ea0:	e59f326c 	ldr	r3, [pc, #620]	; 102d1114 <MQTT_Send_Publish+0x28dc>
102d0ea4:	e59f0200 	ldr	r0, [pc, #512]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0ea8:	e12fff33 	blx	r3
102d0eac:	e59f11f8 	ldr	r1, [pc, #504]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0eb0:	e59f3260 	ldr	r3, [pc, #608]	; 102d1118 <MQTT_Send_Publish+0x28e0>
102d0eb4:	e1a02000 	mov	r2, r0
102d0eb8:	e3a0000a 	mov	r0, #10
102d0ebc:	e12fff33 	blx	r3
102d0ec0:	eaffffa8 	b	102d0d68 <MQTT_Send_Publish+0x2530>
		{
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL);

			Ql_strcpy(last_connectedtime,local_time);  //store local time to connecttime variable

			if((FLAG.DIGNOSTIC_MODE == TRUE) && (!(FLAG.SUSPEND_IPC_COMMUNICATION)))//To avoid the LCD to display last connected time if device is in FW upgrading state with diagnostic mode ON.
102d0ec4:	e5d8301d 	ldrb	r3, [r8, #29]
102d0ec8:	e3530000 	cmp	r3, #0
102d0ecc:	1afffd50 	bne	102d0414 <MQTT_Send_Publish+0x1bdc>
			{
				Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_DIAG_LAST_CONNECT_TIME); // Update last connected time in diagnostic screen
102d0ed0:	e59f1218 	ldr	r1, [pc, #536]	; 102d10f0 <MQTT_Send_Publish+0x28b8>
102d0ed4:	e3a02002 	mov	r2, #2
102d0ed8:	e3a0301c 	mov	r3, #28
102d0edc:	e3a00003 	mov	r0, #3
102d0ee0:	e12fff39 	blx	r9
102d0ee4:	eafffd4a 	b	102d0414 <MQTT_Send_Publish+0x1bdc>
				Ql_MEM_Free(payload);
				payload = NULL;
			}
#ifdef DEBUG_MSG
			if(ssid == SSID_HOST_AZURE)
				APP_DEBUG("<-- [SUCCESS] data Send-AZURE_IOTHUB -->\r\n");
102d0ee8:	e1a0100c 	mov	r1, ip
102d0eec:	e3a02c02 	mov	r2, #512	; 0x200
102d0ef0:	e59f01b4 	ldr	r0, [pc, #436]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0ef4:	e12fff36 	blx	r6
102d0ef8:	e5943000 	ldr	r3, [r4]
102d0efc:	e59f1218 	ldr	r1, [pc, #536]	; 102d111c <MQTT_Send_Publish+0x28e4>
102d0f00:	e59f01a4 	ldr	r0, [pc, #420]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0f04:	e12fff33 	blx	r3
102d0f08:	e59f019c 	ldr	r0, [pc, #412]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0f0c:	e12fff35 	blx	r5
102d0f10:	e59f1194 	ldr	r1, [pc, #404]	; 102d10ac <MQTT_Send_Publish+0x2874>
102d0f14:	e59f31fc 	ldr	r3, [pc, #508]	; 102d1118 <MQTT_Send_Publish+0x28e0>
102d0f18:	e1a02000 	mov	r2, r0
102d0f1c:	e3a0000a 	mov	r0, #10
102d0f20:	e12fff33 	blx	r3
102d0f24:	eafffd42 	b	102d0434 <MQTT_Send_Publish+0x1bfc>
			FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = FALSE; // DO not attempt a re-connect to GPRS as there is already connection in place

			if(MSG_TYPE == MQTT_LOG)// Invalidate the recent log record published successfully
			{
				payload[0]=NULL; // Mark the payload as invalid
				ret = Ql_FS_Seek(filehandleData, i*PAYLOAD_LENGTH , QL_FS_FILE_BEGIN);
102d0f28:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
			}
			FLAG.SCHEDULE_GPRS_RECONNECT_ATTEMPT = FALSE; // DO not attempt a re-connect to GPRS as there is already connection in place

			if(MSG_TYPE == MQTT_LOG)// Invalidate the recent log record published successfully
			{
				payload[0]=NULL; // Mark the payload as invalid
102d0f2c:	e5c71000 	strb	r1, [r7]
				ret = Ql_FS_Seek(filehandleData, i*PAYLOAD_LENGTH , QL_FS_FILE_BEGIN);
102d0f30:	e3a010c8 	mov	r1, #200	; 0xc8
102d0f34:	e001019c 	mul	r1, ip, r1
102d0f38:	e3a02000 	mov	r2, #0
102d0f3c:	e59f31dc 	ldr	r3, [pc, #476]	; 102d1120 <MQTT_Send_Publish+0x28e8>
102d0f40:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
102d0f44:	e12fff33 	blx	r3
				ret = Ql_FS_Write(filehandleData, (u8 *)payload, 1 , (u32 *)&writeedlen);
102d0f48:	e1a01007 	mov	r1, r7
102d0f4c:	e3a02001 	mov	r2, #1
102d0f50:	e59f31cc 	ldr	r3, [pc, #460]	; 102d1124 <MQTT_Send_Publish+0x28ec>
102d0f54:	e59fc1cc 	ldr	ip, [pc, #460]	; 102d1128 <MQTT_Send_Publish+0x28f0>
102d0f58:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
102d0f5c:	e12fff3c 	blx	ip
				Ql_MEM_Free(payload);
102d0f60:	e1a00007 	mov	r0, r7
102d0f64:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
102d0f68:	e12fff3c 	blx	ip
				payload = NULL;
102d0f6c:	e3a07000 	mov	r7, #0
102d0f70:	eafffd2c 	b	102d0428 <MQTT_Send_Publish+0x1bf0>
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_DATA);
					}
					else if(payload[2]=='E')
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
102d0f74:	e28d005c 	add	r0, sp, #92	; 0x5c
102d0f78:	e59f1114 	ldr	r1, [pc, #276]	; 102d1094 <MQTT_Send_Publish+0x285c>
102d0f7c:	e59f31a8 	ldr	r3, [pc, #424]	; 102d112c <MQTT_Send_Publish+0x28f4>
102d0f80:	e12fff33 	blx	r3
102d0f84:	eafff9a1 	b	102cf610 <MQTT_Send_Publish+0xdd8>
					buflen= payloadlen+100;

					// Check the topic of payload message ..it is one out of DATA or EVENT or ACK to topic_subscibe
					if(payload[2]=='D')
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_DATA);
102d0f88:	e28d005c 	add	r0, sp, #92	; 0x5c
102d0f8c:	e59f119c 	ldr	r1, [pc, #412]	; 102d1130 <MQTT_Send_Publish+0x28f8>
102d0f90:	e59f3194 	ldr	r3, [pc, #404]	; 102d112c <MQTT_Send_Publish+0x28f4>
102d0f94:	e12fff33 	blx	r3
102d0f98:	eafff99c 	b	102cf610 <MQTT_Send_Publish+0xdd8>
			{
				payload[2]='E';  // replace "d" with "E" to identify log message is event
			}
			else
			{
				Topic_String = Ql_strstr(topic_subscibe,SECURE_GW_TOPIC_DATA); //check GW_IoTHub-DATA is present in topic_subscibe
102d0f9c:	e28d005c 	add	r0, sp, #92	; 0x5c
102d0fa0:	e59f1188 	ldr	r1, [pc, #392]	; 102d1130 <MQTT_Send_Publish+0x28f8>
102d0fa4:	e12fff34 	blx	r4
				if(Topic_String != NULL)
102d0fa8:	e3500000 	cmp	r0, #0
102d0fac:	0a000007 	beq	102d0fd0 <MQTT_Send_Publish+0x2798>
				{
					payload[2]='D';  // replace "d" with "D" to identify log message is data
102d0fb0:	e3a03044 	mov	r3, #68	; 0x44
102d0fb4:	e5c73002 	strb	r3, [r7, #2]
102d0fb8:	eafffe65 	b	102d0954 <MQTT_Send_Publish+0x211c>
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_EVENT);
					}
					else if(payload[2] == 'A')
					{
						Ql_strcat(topic_subscibe,SECURE_GW_TOPIC_ACK);
102d0fbc:	e28d005c 	add	r0, sp, #92	; 0x5c
102d0fc0:	e59f116c 	ldr	r1, [pc, #364]	; 102d1134 <MQTT_Send_Publish+0x28fc>
102d0fc4:	e59f3160 	ldr	r3, [pc, #352]	; 102d112c <MQTT_Send_Publish+0x28f4>
102d0fc8:	e12fff33 	blx	r3
102d0fcc:	eafff98f 	b	102cf610 <MQTT_Send_Publish+0xdd8>
				{
					payload[2]='D';  // replace "d" with "D" to identify log message is data
				}
				else
				{
					Topic_String = Ql_strstr(topic_subscibe,SECURE_GW_TOPIC_ACK); //check GW_IoTHub-ACK is present in topic_subscibe
102d0fd0:	e28d005c 	add	r0, sp, #92	; 0x5c
102d0fd4:	e59f1158 	ldr	r1, [pc, #344]	; 102d1134 <MQTT_Send_Publish+0x28fc>
102d0fd8:	e12fff34 	blx	r4
					if(Topic_String != NULL)
102d0fdc:	e3500000 	cmp	r0, #0
					{
						payload[2]='A';  // replace "d" with "A" to identify log message is ack
102d0fe0:	13a03041 	movne	r3, #65	; 0x41
102d0fe4:	15c73002 	strbne	r3, [r7, #2]
102d0fe8:	eafffe59 	b	102d0954 <MQTT_Send_Publish+0x211c>

	char* payload=NULL;
	int payloadlen ;
	int len = 0;
	int buflen=0;
	char *buf_ssl = NULL;
102d0fec:	e58dc02c 	str	ip, [sp, #44]	; 0x2c

	GetLocalTime_UTC(time_stamp, local_time);

	char* payload=NULL;
	int payloadlen ;
	int len = 0;
102d0ff0:	e1a0900c 	mov	r9, ip

	//get Time stamp in UTC

	GetLocalTime_UTC(time_stamp, local_time);

	char* payload=NULL;
102d0ff4:	e1a0700c 	mov	r7, ip
	APP_DEBUG("*****-->\r\n");
#endif
	// Now message is ready to publish .. process it

	//In case of Pending message type if no pending message is there.. need ot skip out from this point.
	if((MSG_TYPE == MQTT_LOG) && (LOG_MESSAGES_AVAILABLE == FALSE))// No message to send in pending list
102d0ff8:	e3a0c011 	mov	ip, #17
102d0ffc:	e58dc03c 	str	ip, [sp, #60]	; 0x3c
 *	 int : status Fail or PASS.
 *****************************************************************/
int MQTT_Send_Publish(u8 ssid, u16 MSG_TYPE)
{
	bool LOG_MESSAGES_AVAILABLE = FALSE;
	s32  filehandleData = -1;
102d1000:	e3e0c000 	mvn	ip, #0
102d1004:	e58dc030 	str	ip, [sp, #48]	; 0x30
102d1008:	e59fc128 	ldr	ip, [pc, #296]	; 102d1138 <MQTT_Send_Publish+0x2900>
102d100c:	e58dc024 	str	ip, [sp, #36]	; 0x24
102d1010:	e59fc124 	ldr	ip, [pc, #292]	; 102d113c <MQTT_Send_Publish+0x2904>
102d1014:	e58dc028 	str	ip, [sp, #40]	; 0x28
102d1018:	eafffaac 	b	102cfad0 <MQTT_Send_Publish+0x1298>
					&& (MSG_TYPE != MQTT_HEART_BEAT_MESSAGE) //Do not store regular heart beat events
					&& (MSG_TYPE != MQTT_TWIN_PROPERTIES)//Do not Store Device Twin related events
					&& (MSG_TYPE != MQTT_TWIN_REPORTED)//Do not Store Device Twin reported related events
					&& (FLAG.SSL_X509_CERTPRESENT == TRUE)) // Do not write log messages in case of device not configured with certificates
			{
				Topic_String = Ql_strstr(topic_subscibe,SECURE_GW_TOPIC_EVENT); //check GW_IoTHub-EVENT is present in topic_subscibe
102d101c:	e28d005c 	add	r0, sp, #92	; 0x5c
102d1020:	e59f106c 	ldr	r1, [pc, #108]	; 102d1094 <MQTT_Send_Publish+0x285c>
102d1024:	e59f406c 	ldr	r4, [pc, #108]	; 102d1098 <MQTT_Send_Publish+0x2860>
102d1028:	e12fff34 	blx	r4
				if(Topic_String != NULL)
102d102c:	e3500000 	cmp	r0, #0
102d1030:	0a000005 	beq	102d104c <MQTT_Send_Publish+0x2814>
				{
					payload[2]='E';  // replace "d" with "E" to identify log message is event
102d1034:	e3a03045 	mov	r3, #69	; 0x45
102d1038:	e5c73002 	strb	r3, [r7, #2]
						{
							payload[2]='A';  // replace "d" with "A" to identify log message is ack
						}
					}
				}
				Write_And_Store_Pending_MQTT_Log_Messages(payload);
102d103c:	e1a00007 	mov	r0, r7
102d1040:	e59f3054 	ldr	r3, [pc, #84]	; 102d109c <MQTT_Send_Publish+0x2864>
102d1044:	e12fff33 	blx	r3
102d1048:	eaffff51 	b	102d0d94 <MQTT_Send_Publish+0x255c>
				{
					payload[2]='E';  // replace "d" with "E" to identify log message is event
				}
				else
				{
					Topic_String = Ql_strstr(topic_subscibe,SECURE_GW_TOPIC_DATA); //check GW_IoTHub-DATA is present in topic_subscibe
102d104c:	e28d005c 	add	r0, sp, #92	; 0x5c
102d1050:	e59f10d8 	ldr	r1, [pc, #216]	; 102d1130 <MQTT_Send_Publish+0x28f8>
102d1054:	e12fff34 	blx	r4
					if(Topic_String != NULL)
102d1058:	e3500000 	cmp	r0, #0
					{
						payload[2]='D';  // replace "d" with "E" to identify log message is data
102d105c:	13a03044 	movne	r3, #68	; 0x44
102d1060:	15c73002 	strbne	r3, [r7, #2]
102d1064:	1afffff4 	bne	102d103c <MQTT_Send_Publish+0x2804>
					}
					else
					{
						Topic_String = Ql_strstr(topic_subscibe,SECURE_GW_TOPIC_ACK); //check GW_IoTHub-ACK is present in topic_subscibe
102d1068:	e28d005c 	add	r0, sp, #92	; 0x5c
102d106c:	e59f10c0 	ldr	r1, [pc, #192]	; 102d1134 <MQTT_Send_Publish+0x28fc>
102d1070:	e12fff34 	blx	r4
						if(Topic_String != NULL)
102d1074:	e3500000 	cmp	r0, #0
						{
							payload[2]='A';  // replace "d" with "A" to identify log message is ack
102d1078:	13a03041 	movne	r3, #65	; 0x41
102d107c:	15c73002 	strbne	r3, [r7, #2]
102d1080:	eaffffed 	b	102d103c <MQTT_Send_Publish+0x2804>
102d1084:	102d7cf8 	.word	0x102d7cf8
102d1088:	f03d5ba4 	.word	0xf03d5ba4
102d108c:	102d79d8 	.word	0x102d79d8
102d1090:	102eecec 	.word	0x102eecec
102d1094:	f03d2040 	.word	0xf03d2040
102d1098:	102e5a04 	.word	0x102e5a04
102d109c:	102d412c 	.word	0x102d412c
102d10a0:	f03d5b00 	.word	0xf03d5b00
102d10a4:	102eecc0 	.word	0x102eecc0
102d10a8:	102eea38 	.word	0x102eea38
102d10ac:	f03d57e4 	.word	0xf03d57e4
102d10b0:	102d7da8 	.word	0x102d7da8
102d10b4:	102ef9b8 	.word	0x102ef9b8
102d10b8:	102efd90 	.word	0x102efd90
102d10bc:	102eeabc 	.word	0x102eeabc
102d10c0:	102eea60 	.word	0x102eea60
102d10c4:	102ee9e0 	.word	0x102ee9e0
102d10c8:	102e7024 	.word	0x102e7024
102d10cc:	102eeb6c 	.word	0x102eeb6c
102d10d0:	102eeb70 	.word	0x102eeb70
102d10d4:	102e6fd4 	.word	0x102e6fd4
102d10d8:	102eea88 	.word	0x102eea88
102d10dc:	102e7034 	.word	0x102e7034
102d10e0:	102eead8 	.word	0x102eead8
102d10e4:	102e7078 	.word	0x102e7078
102d10e8:	102eeae8 	.word	0x102eeae8
102d10ec:	102e7084 	.word	0x102e7084
102d10f0:	000010c8 	.word	0x000010c8
102d10f4:	102e5cb4 	.word	0x102e5cb4
102d10f8:	102eeaf0 	.word	0x102eeaf0
102d10fc:	f03d64f8 	.word	0xf03d64f8
102d1100:	102edef4 	.word	0x102edef4
102d1104:	102e708c 	.word	0x102e708c
102d1108:	102e58f4 	.word	0x102e58f4
102d110c:	f03de540 	.word	0xf03de540
102d1110:	102eedbc 	.word	0x102eedbc
102d1114:	102e57a4 	.word	0x102e57a4
102d1118:	102e6230 	.word	0x102e6230
102d111c:	102eed90 	.word	0x102eed90
102d1120:	102e41a8 	.word	0x102e41a8
102d1124:	f03db8f0 	.word	0xf03db8f0
102d1128:	102e4130 	.word	0x102e4130
102d112c:	102e5724 	.word	0x102e5724
102d1130:	f03d2050 	.word	0xf03d2050
102d1134:	f03d2060 	.word	0xf03d2060
102d1138:	f03d572c 	.word	0xf03d572c
102d113c:	102e48b8 	.word	0x102e48b8

102d1140 <Process_Device_Twin_Properties>:
 *       : 2. If a desired Porperty is available and no corresponding reported property available - act (if required) and report back the property
 *       : 3. If a desired Porperty is available and corresponding reported property available - act and report back the property. only if there is change in property
 *       : 4. If a desired Porperty is not available and corresponding reported property available - no action required
 *****************************************************************/
s32 Process_Device_Twin_Properties(unsigned char *twin_msg)
{
102d1140:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

	u8 i=0;
	char Desired_Property_Data[150];
	char Reported_Property_Data[150];

	cJSON_InitHooks(NULL); //init function pointers to Ql_MEM_Alloc calloc realloc
102d1144:	e59f3fa4 	ldr	r3, [pc, #4004]	; 102d20f0 <Process_Device_Twin_Properties+0xfb0>
 *       : 2. If a desired Porperty is available and no corresponding reported property available - act (if required) and report back the property
 *       : 3. If a desired Porperty is available and corresponding reported property available - act and report back the property. only if there is change in property
 *       : 4. If a desired Porperty is not available and corresponding reported property available - no action required
 *****************************************************************/
s32 Process_Device_Twin_Properties(unsigned char *twin_msg)
{
102d1148:	e24ddf53 	sub	sp, sp, #332	; 0x14c
102d114c:	e1a04000 	mov	r4, r0

	u8 i=0;
	char Desired_Property_Data[150];
	char Reported_Property_Data[150];

	cJSON_InitHooks(NULL); //init function pointers to Ql_MEM_Alloc calloc realloc
102d1150:	e3a00000 	mov	r0, #0
102d1154:	e12fff33 	blx	r3
	root = cJSON_Parse(twin_msg);
102d1158:	e59f3f94 	ldr	r3, [pc, #3988]	; 102d20f4 <Process_Device_Twin_Properties+0xfb4>
102d115c:	e1a00004 	mov	r0, r4
102d1160:	e12fff33 	blx	r3
	//Check if the message is for entire property list via GET message or is a change notification
	// A change notification will have version information in root jason..
	desired_obj = cJSON_GetObjectItem(root, TWIN_VERSION);//Json object listing desired properties
102d1164:	e59f5f8c 	ldr	r5, [pc, #3980]	; 102d20f8 <Process_Device_Twin_Properties+0xfb8>
102d1168:	e59f1f8c 	ldr	r1, [pc, #3980]	; 102d20fc <Process_Device_Twin_Properties+0xfbc>
	u8 i=0;
	char Desired_Property_Data[150];
	char Reported_Property_Data[150];

	cJSON_InitHooks(NULL); //init function pointers to Ql_MEM_Alloc calloc realloc
	root = cJSON_Parse(twin_msg);
102d116c:	e58d0008 	str	r0, [sp, #8]
	//Check if the message is for entire property list via GET message or is a change notification
	// A change notification will have version information in root jason..
	desired_obj = cJSON_GetObjectItem(root, TWIN_VERSION);//Json object listing desired properties
102d1170:	e12fff35 	blx	r5
	if(desired_obj == NULL) // This is a GET response with entire set of desired and reported properties
102d1174:	e2506000 	subs	r6, r0, #0
102d1178:	0a00034a 	beq	102d1ea8 <Process_Device_Twin_Properties+0xd68>
 *****************************************************************/
s32 Process_Device_Twin_Properties(unsigned char *twin_msg)
{
	cJSON *root = NULL;
	cJSON *desired = NULL;
	cJSON *reported = NULL;
102d117c:	e3a03000 	mov	r3, #0
		}
		desired_obj = cJSON_GetObjectItem(desired, TWIN_VERSION);
	}
	else
	{
		FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = TRUE;
102d1180:	e59f9f78 	ldr	r9, [pc, #3960]	; 102d2100 <Process_Device_Twin_Properties+0xfc0>
 *****************************************************************/
s32 Process_Device_Twin_Properties(unsigned char *twin_msg)
{
	cJSON *root = NULL;
	cJSON *desired = NULL;
	cJSON *reported = NULL;
102d1184:	e58d3004 	str	r3, [sp, #4]
 *       : 4. If a desired Porperty is not available and corresponding reported property available - no action required
 *****************************************************************/
s32 Process_Device_Twin_Properties(unsigned char *twin_msg)
{
	cJSON *root = NULL;
	cJSON *desired = NULL;
102d1188:	e58d300c 	str	r3, [sp, #12]
		}
		desired_obj = cJSON_GetObjectItem(desired, TWIN_VERSION);
	}
	else
	{
		FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = TRUE;
102d118c:	e3a03001 	mov	r3, #1
102d1190:	e5c93025 	strb	r3, [r9, #37]	; 0x25
		return RET_FAIL;
	}
	else
	{
#ifdef DEBUG_MSG
		APP_DEBUG("\n\r<-- Desired Prpoerties version [%d]-->\n\r", desired_obj->valueint);
102d1194:	e59f7f68 	ldr	r7, [pc, #3944]	; 102d2104 <Process_Device_Twin_Properties+0xfc4>
102d1198:	e59f4f68 	ldr	r4, [pc, #3944]	; 102d2108 <Process_Device_Twin_Properties+0xfc8>
102d119c:	e3a01000 	mov	r1, #0
102d11a0:	e3a02c02 	mov	r2, #512	; 0x200
102d11a4:	e59f0f60 	ldr	r0, [pc, #3936]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d11a8:	e12fff34 	blx	r4
102d11ac:	e5962014 	ldr	r2, [r6, #20]
102d11b0:	e5973000 	ldr	r3, [r7]
102d11b4:	e59f1f54 	ldr	r1, [pc, #3924]	; 102d2110 <Process_Device_Twin_Properties+0xfd0>
102d11b8:	e59f0f4c 	ldr	r0, [pc, #3916]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d11bc:	e12fff33 	blx	r3
102d11c0:	e59f8f4c 	ldr	r8, [pc, #3916]	; 102d2114 <Process_Device_Twin_Properties+0xfd4>
102d11c4:	e59f0f40 	ldr	r0, [pc, #3904]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d11c8:	e12fff38 	blx	r8
102d11cc:	e59faf44 	ldr	sl, [pc, #3908]	; 102d2118 <Process_Device_Twin_Properties+0xfd8>
102d11d0:	e59f1f34 	ldr	r1, [pc, #3892]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d11d4:	e1a02000 	mov	r2, r0
102d11d8:	e3a0000a 	mov	r0, #10
102d11dc:	e12fff3a 	blx	sl
#endif
		Ql_sprintf(DP_Version_Info,"%d",desired_obj->valueint);
102d11e0:	e5973000 	ldr	r3, [r7]
102d11e4:	e5962014 	ldr	r2, [r6, #20]
102d11e8:	e59f1f2c 	ldr	r1, [pc, #3884]	; 102d211c <Process_Device_Twin_Properties+0xfdc>
102d11ec:	e59f0f2c 	ldr	r0, [pc, #3884]	; 102d2120 <Process_Device_Twin_Properties+0xfe0>
102d11f0:	e12fff33 	blx	r3

		//Process all Desired and to be reported properties one by one
		// 1. "GeoLocation" [Desired + Reported]
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d11f4:	e3a01000 	mov	r1, #0
102d11f8:	e3a02096 	mov	r2, #150	; 0x96
102d11fc:	e28d0018 	add	r0, sp, #24
102d1200:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1204:	e3a01000 	mov	r1, #0
102d1208:	e3a02096 	mov	r2, #150	; 0x96
102d120c:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1210:	e12fff34 	blx	r4

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_GEOLOCATION);
102d1214:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d1218:	e59d3008 	ldr	r3, [sp, #8]
102d121c:	e3500001 	cmp	r0, #1
102d1220:	e59d200c 	ldr	r2, [sp, #12]
102d1224:	01a02003 	moveq	r2, r3
102d1228:	e59f1ef4 	ldr	r1, [pc, #3828]	; 102d2124 <Process_Device_Twin_Properties+0xfe4>
102d122c:	e1a00002 	mov	r0, r2
102d1230:	e12fff35 	blx	r5
		if (NULL != desired_obj) // Desired property is available
102d1234:	e250b000 	subs	fp, r0, #0
102d1238:	059f6ee8 	ldreq	r6, [pc, #3816]	; 102d2128 <Process_Device_Twin_Properties+0xfe8>
102d123c:	0a000013 	beq	102d1290 <Process_Device_Twin_Properties+0x150>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_GEOLOCATION, desired_obj->valuestring);
102d1240:	e3a01000 	mov	r1, #0
102d1244:	e3a02c02 	mov	r2, #512	; 0x200
102d1248:	e59f0ebc 	ldr	r0, [pc, #3772]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d124c:	e12fff34 	blx	r4
102d1250:	e59f1ed4 	ldr	r1, [pc, #3796]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d1254:	e59f2ec8 	ldr	r2, [pc, #3784]	; 102d2124 <Process_Device_Twin_Properties+0xfe4>
102d1258:	e59b3010 	ldr	r3, [fp, #16]
102d125c:	e597c000 	ldr	ip, [r7]
102d1260:	e59f0ea4 	ldr	r0, [pc, #3748]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1264:	e12fff3c 	blx	ip
102d1268:	e59f0e9c 	ldr	r0, [pc, #3740]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d126c:	e12fff38 	blx	r8
102d1270:	e59f1e94 	ldr	r1, [pc, #3732]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d1274:	e59f6eac 	ldr	r6, [pc, #3756]	; 102d2128 <Process_Device_Twin_Properties+0xfe8>

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_GEOLOCATION);
		if (NULL != desired_obj) // Desired property is available
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_GEOLOCATION, desired_obj->valuestring);
102d1278:	e1a02000 	mov	r2, r0
102d127c:	e3a0000a 	mov	r0, #10
102d1280:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d1284:	e28d0018 	add	r0, sp, #24
102d1288:	e59b1010 	ldr	r1, [fp, #16]
102d128c:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_GEOLOCATION);
102d1290:	e59d0004 	ldr	r0, [sp, #4]
102d1294:	e59f1e88 	ldr	r1, [pc, #3720]	; 102d2124 <Process_Device_Twin_Properties+0xfe4>
102d1298:	e12fff35 	blx	r5
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_Geolocation));
102d129c:	e2503000 	subs	r3, r0, #0
102d12a0:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d12a4:	0a000383 	beq	102d20b8 <Process_Device_Twin_Properties+0xf78>
102d12a8:	e5931010 	ldr	r1, [r3, #16]
102d12ac:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d12b0:	e35b0000 	cmp	fp, #0
102d12b4:	0a0002da 	beq	102d1e24 <Process_Device_Twin_Properties+0xce4>
		{
			Ql_strcpy(RP_Geolocation, Desired_Property_Data);
102d12b8:	e28d1018 	add	r1, sp, #24
102d12bc:	e59f0e6c 	ldr	r0, [pc, #3692]	; 102d2130 <Process_Device_Twin_Properties+0xff0>
102d12c0:	e12fff36 	blx	r6
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d12c4:	e59f3e68 	ldr	r3, [pc, #3688]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d12c8:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d12cc:	e28d0018 	add	r0, sp, #24
102d12d0:	e12fff33 	blx	r3
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_GEOLOCATION;
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_Geolocation);
102d12d4:	e3a01000 	mov	r1, #0
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_Geolocation));

		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_Geolocation, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d12d8:	e3500000 	cmp	r0, #0
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_GEOLOCATION;
102d12dc:	159f2e54 	ldrne	r2, [pc, #3668]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d12e0:	059f3e50 	ldreq	r3, [pc, #3664]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d12e4:	15923374 	ldrne	r3, [r2, #884]	; 0x374
102d12e8:	158d2010 	strne	r2, [sp, #16]
102d12ec:	13833001 	orrne	r3, r3, #1
102d12f0:	15823374 	strne	r3, [r2, #884]	; 0x374
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_Geolocation);
102d12f4:	e59f0e10 	ldr	r0, [pc, #3600]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d12f8:	e3a02c02 	mov	r2, #512	; 0x200
102d12fc:	058d3010 	streq	r3, [sp, #16]
102d1300:	e12fff34 	blx	r4
102d1304:	e59f1e30 	ldr	r1, [pc, #3632]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d1308:	e59f2e20 	ldr	r2, [pc, #3616]	; 102d2130 <Process_Device_Twin_Properties+0xff0>
102d130c:	e5973000 	ldr	r3, [r7]
102d1310:	e59f0df4 	ldr	r0, [pc, #3572]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1314:	e12fff33 	blx	r3
102d1318:	e59f0dec 	ldr	r0, [pc, #3564]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d131c:	e12fff38 	blx	r8
102d1320:	e59f1de4 	ldr	r1, [pc, #3556]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1324:	e1a02000 	mov	r2, r0
102d1328:	e3a0000a 	mov	r0, #10
102d132c:	e12fff3a 	blx	sl
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_GEOLOCATION;
		}

		// 2. "VendorCode"
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1330:	e3a01000 	mov	r1, #0
102d1334:	e3a02096 	mov	r2, #150	; 0x96
102d1338:	e28d0018 	add	r0, sp, #24
102d133c:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1340:	e3a01000 	mov	r1, #0
102d1344:	e3a02096 	mov	r2, #150	; 0x96
102d1348:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d134c:	e12fff34 	blx	r4
		desired_obj = NULL;
		reported_obj = NULL;

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_VENDOR_CODE);
102d1350:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d1354:	e59d2008 	ldr	r2, [sp, #8]
102d1358:	e3500001 	cmp	r0, #1
102d135c:	e59d300c 	ldr	r3, [sp, #12]
102d1360:	01a03002 	moveq	r3, r2
102d1364:	e59f1dd4 	ldr	r1, [pc, #3540]	; 102d2140 <Process_Device_Twin_Properties+0x1000>
102d1368:	e1a00003 	mov	r0, r3
102d136c:	e12fff35 	blx	r5
		if (NULL != desired_obj)
102d1370:	e250b000 	subs	fp, r0, #0
102d1374:	0a000012 	beq	102d13c4 <Process_Device_Twin_Properties+0x284>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_VENDOR_CODE, desired_obj->valuestring);
102d1378:	e3a01000 	mov	r1, #0
102d137c:	e3a02c02 	mov	r2, #512	; 0x200
102d1380:	e59f0d84 	ldr	r0, [pc, #3460]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1384:	e12fff34 	blx	r4
102d1388:	e59f1d9c 	ldr	r1, [pc, #3484]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d138c:	e59f2dac 	ldr	r2, [pc, #3500]	; 102d2140 <Process_Device_Twin_Properties+0x1000>
102d1390:	e59b3010 	ldr	r3, [fp, #16]
102d1394:	e597c000 	ldr	ip, [r7]
102d1398:	e59f0d6c 	ldr	r0, [pc, #3436]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d139c:	e12fff3c 	blx	ip
102d13a0:	e59f0d64 	ldr	r0, [pc, #3428]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d13a4:	e12fff38 	blx	r8
102d13a8:	e59f1d5c 	ldr	r1, [pc, #3420]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d13ac:	e1a02000 	mov	r2, r0
102d13b0:	e3a0000a 	mov	r0, #10
102d13b4:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d13b8:	e28d0018 	add	r0, sp, #24
102d13bc:	e59b1010 	ldr	r1, [fp, #16]
102d13c0:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_VENDOR_CODE);
102d13c4:	e59d0004 	ldr	r0, [sp, #4]
102d13c8:	e59f1d70 	ldr	r1, [pc, #3440]	; 102d2140 <Process_Device_Twin_Properties+0x1000>
102d13cc:	e12fff35 	blx	r5

		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_vendorcode));
102d13d0:	e2503000 	subs	r3, r0, #0
102d13d4:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d13d8:	0a0002db 	beq	102d1f4c <Process_Device_Twin_Properties+0xe0c>
102d13dc:	e5931010 	ldr	r1, [r3, #16]
102d13e0:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d13e4:	e35b0000 	cmp	fp, #0
102d13e8:	0a00001a 	beq	102d1458 <Process_Device_Twin_Properties+0x318>
		{
			Ql_strcpy(RP_vendorcode, Desired_Property_Data);
102d13ec:	e28d1018 	add	r1, sp, #24
102d13f0:	e59f0d4c 	ldr	r0, [pc, #3404]	; 102d2144 <Process_Device_Twin_Properties+0x1004>
102d13f4:	e12fff36 	blx	r6
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d13f8:	e59f3d34 	ldr	r3, [pc, #3380]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d13fc:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d1400:	e28d0018 	add	r0, sp, #24
102d1404:	e12fff33 	blx	r3
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_VENDOR_CODE;
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_vendorcode);
102d1408:	e3a01000 	mov	r1, #0
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_vendorcode));

		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_vendorcode, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d140c:	e3500000 	cmp	r0, #0
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_VENDOR_CODE;
102d1410:	159d2010 	ldrne	r2, [sp, #16]
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_vendorcode);
102d1414:	e59f0cf0 	ldr	r0, [pc, #3312]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_vendorcode, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_VENDOR_CODE;
102d1418:	15923374 	ldrne	r3, [r2, #884]	; 0x374
102d141c:	13833002 	orrne	r3, r3, #2
102d1420:	15823374 	strne	r3, [r2, #884]	; 0x374
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_vendorcode);
102d1424:	e3a02c02 	mov	r2, #512	; 0x200
102d1428:	e12fff34 	blx	r4
102d142c:	e59f1d08 	ldr	r1, [pc, #3336]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d1430:	e59f2d0c 	ldr	r2, [pc, #3340]	; 102d2144 <Process_Device_Twin_Properties+0x1004>
102d1434:	e5973000 	ldr	r3, [r7]
102d1438:	e59f0ccc 	ldr	r0, [pc, #3276]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d143c:	e12fff33 	blx	r3
102d1440:	e59f0cc4 	ldr	r0, [pc, #3268]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1444:	e12fff38 	blx	r8
102d1448:	e59f1cbc 	ldr	r1, [pc, #3260]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d144c:	e1a02000 	mov	r2, r0
102d1450:	e3a0000a 	mov	r0, #10
102d1454:	e12fff3a 	blx	sl
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_VENDOR_CODE;
		}

		// 3. "DeviceType"
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1458:	e3a01000 	mov	r1, #0
102d145c:	e3a02096 	mov	r2, #150	; 0x96
102d1460:	e28d0018 	add	r0, sp, #24
102d1464:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1468:	e3a01000 	mov	r1, #0
102d146c:	e3a02096 	mov	r2, #150	; 0x96
102d1470:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1474:	e12fff34 	blx	r4
		desired_obj = NULL;
		reported_obj = NULL;

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_DEVICE_TYPE);
102d1478:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d147c:	e59d2008 	ldr	r2, [sp, #8]
102d1480:	e3500001 	cmp	r0, #1
102d1484:	e59d300c 	ldr	r3, [sp, #12]
102d1488:	01a03002 	moveq	r3, r2
102d148c:	e59f1cb4 	ldr	r1, [pc, #3252]	; 102d2148 <Process_Device_Twin_Properties+0x1008>
102d1490:	e1a00003 	mov	r0, r3
102d1494:	e12fff35 	blx	r5
		if (NULL != desired_obj)
102d1498:	e250b000 	subs	fp, r0, #0
102d149c:	0a000012 	beq	102d14ec <Process_Device_Twin_Properties+0x3ac>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_DEVICE_TYPE, desired_obj->valuestring);
102d14a0:	e3a01000 	mov	r1, #0
102d14a4:	e3a02c02 	mov	r2, #512	; 0x200
102d14a8:	e59f0c5c 	ldr	r0, [pc, #3164]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d14ac:	e12fff34 	blx	r4
102d14b0:	e59f1c74 	ldr	r1, [pc, #3188]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d14b4:	e59f2c8c 	ldr	r2, [pc, #3212]	; 102d2148 <Process_Device_Twin_Properties+0x1008>
102d14b8:	e59b3010 	ldr	r3, [fp, #16]
102d14bc:	e597c000 	ldr	ip, [r7]
102d14c0:	e59f0c44 	ldr	r0, [pc, #3140]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d14c4:	e12fff3c 	blx	ip
102d14c8:	e59f0c3c 	ldr	r0, [pc, #3132]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d14cc:	e12fff38 	blx	r8
102d14d0:	e59f1c34 	ldr	r1, [pc, #3124]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d14d4:	e1a02000 	mov	r2, r0
102d14d8:	e3a0000a 	mov	r0, #10
102d14dc:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d14e0:	e28d0018 	add	r0, sp, #24
102d14e4:	e59b1010 	ldr	r1, [fp, #16]
102d14e8:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_DEVICE_TYPE);
102d14ec:	e59d0004 	ldr	r0, [sp, #4]
102d14f0:	e59f1c50 	ldr	r1, [pc, #3152]	; 102d2148 <Process_Device_Twin_Properties+0x1008>
102d14f4:	e12fff35 	blx	r5
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_devicetype));
102d14f8:	e2503000 	subs	r3, r0, #0
102d14fc:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1500:	0a0002a7 	beq	102d1fa4 <Process_Device_Twin_Properties+0xe64>
102d1504:	e5931010 	ldr	r1, [r3, #16]
102d1508:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d150c:	e35b0000 	cmp	fp, #0
102d1510:	0a00001a 	beq	102d1580 <Process_Device_Twin_Properties+0x440>
		{
			Ql_strcpy(RP_devicetype, Desired_Property_Data);
102d1514:	e28d1018 	add	r1, sp, #24
102d1518:	e59f0c2c 	ldr	r0, [pc, #3116]	; 102d214c <Process_Device_Twin_Properties+0x100c>
102d151c:	e12fff36 	blx	r6
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1520:	e59f3c0c 	ldr	r3, [pc, #3084]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d1524:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d1528:	e28d0018 	add	r0, sp, #24
102d152c:	e12fff33 	blx	r3
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_TYPE;
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_devicetype);
102d1530:	e3a01000 	mov	r1, #0
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_devicetype));

		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_devicetype, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1534:	e3500000 	cmp	r0, #0
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_TYPE;
102d1538:	159d2010 	ldrne	r2, [sp, #16]
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_devicetype);
102d153c:	e59f0bc8 	ldr	r0, [pc, #3016]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_devicetype, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_TYPE;
102d1540:	15923374 	ldrne	r3, [r2, #884]	; 0x374
102d1544:	13833004 	orrne	r3, r3, #4
102d1548:	15823374 	strne	r3, [r2, #884]	; 0x374
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_devicetype);
102d154c:	e3a02c02 	mov	r2, #512	; 0x200
102d1550:	e12fff34 	blx	r4
102d1554:	e59f1be0 	ldr	r1, [pc, #3040]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d1558:	e59f2bec 	ldr	r2, [pc, #3052]	; 102d214c <Process_Device_Twin_Properties+0x100c>
102d155c:	e5973000 	ldr	r3, [r7]
102d1560:	e59f0ba4 	ldr	r0, [pc, #2980]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1564:	e12fff33 	blx	r3
102d1568:	e59f0b9c 	ldr	r0, [pc, #2972]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d156c:	e12fff38 	blx	r8
102d1570:	e59f1b94 	ldr	r1, [pc, #2964]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1574:	e1a02000 	mov	r2, r0
102d1578:	e3a0000a 	mov	r0, #10
102d157c:	e12fff3a 	blx	sl
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_TYPE;
		}

		// 4. "DeviceStatus"
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1580:	e3a01000 	mov	r1, #0
102d1584:	e3a02096 	mov	r2, #150	; 0x96
102d1588:	e28d0018 	add	r0, sp, #24
102d158c:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1590:	e3a01000 	mov	r1, #0
102d1594:	e3a02096 	mov	r2, #150	; 0x96
102d1598:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d159c:	e12fff34 	blx	r4
		desired_obj = NULL;
		reported_obj = NULL;

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_DEVICE_STATUS);
102d15a0:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d15a4:	e59d2008 	ldr	r2, [sp, #8]
102d15a8:	e3500001 	cmp	r0, #1
102d15ac:	e59d300c 	ldr	r3, [sp, #12]
102d15b0:	01a03002 	moveq	r3, r2
102d15b4:	e59f1b94 	ldr	r1, [pc, #2964]	; 102d2150 <Process_Device_Twin_Properties+0x1010>
102d15b8:	e1a00003 	mov	r0, r3
102d15bc:	e12fff35 	blx	r5
		if (NULL != desired_obj)
102d15c0:	e250b000 	subs	fp, r0, #0
102d15c4:	0a000012 	beq	102d1614 <Process_Device_Twin_Properties+0x4d4>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_DEVICE_STATUS, desired_obj->valuestring);
102d15c8:	e3a01000 	mov	r1, #0
102d15cc:	e3a02c02 	mov	r2, #512	; 0x200
102d15d0:	e59f0b34 	ldr	r0, [pc, #2868]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d15d4:	e12fff34 	blx	r4
102d15d8:	e59f1b4c 	ldr	r1, [pc, #2892]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d15dc:	e59f2b6c 	ldr	r2, [pc, #2924]	; 102d2150 <Process_Device_Twin_Properties+0x1010>
102d15e0:	e59b3010 	ldr	r3, [fp, #16]
102d15e4:	e597c000 	ldr	ip, [r7]
102d15e8:	e59f0b1c 	ldr	r0, [pc, #2844]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d15ec:	e12fff3c 	blx	ip
102d15f0:	e59f0b14 	ldr	r0, [pc, #2836]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d15f4:	e12fff38 	blx	r8
102d15f8:	e59f1b0c 	ldr	r1, [pc, #2828]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d15fc:	e1a02000 	mov	r2, r0
102d1600:	e3a0000a 	mov	r0, #10
102d1604:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d1608:	e28d0018 	add	r0, sp, #24
102d160c:	e59b1010 	ldr	r1, [fp, #16]
102d1610:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_DEVICE_STATUS);
102d1614:	e59d0004 	ldr	r0, [sp, #4]
102d1618:	e59f1b30 	ldr	r1, [pc, #2864]	; 102d2150 <Process_Device_Twin_Properties+0x1010>
102d161c:	e12fff35 	blx	r5
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_devicestatus));
102d1620:	e2503000 	subs	r3, r0, #0
102d1624:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1628:	0a000252 	beq	102d1f78 <Process_Device_Twin_Properties+0xe38>
102d162c:	e5931010 	ldr	r1, [r3, #16]
102d1630:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d1634:	e35b0000 	cmp	fp, #0
102d1638:	0a00001a 	beq	102d16a8 <Process_Device_Twin_Properties+0x568>
		{
			Ql_strcpy(RP_devicestatus, Desired_Property_Data);
102d163c:	e28d1018 	add	r1, sp, #24
102d1640:	e59f0b0c 	ldr	r0, [pc, #2828]	; 102d2154 <Process_Device_Twin_Properties+0x1014>
102d1644:	e12fff36 	blx	r6
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1648:	e59f3ae4 	ldr	r3, [pc, #2788]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d164c:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d1650:	e28d0018 	add	r0, sp, #24
102d1654:	e12fff33 	blx	r3
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_STATUS;
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_devicestatus);
102d1658:	e3a01000 	mov	r1, #0
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_devicestatus));

		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_devicestatus, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d165c:	e3500000 	cmp	r0, #0
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_STATUS;
102d1660:	159d2010 	ldrne	r2, [sp, #16]
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_devicestatus);
102d1664:	e59f0aa0 	ldr	r0, [pc, #2720]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_devicestatus, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_STATUS;
102d1668:	15923374 	ldrne	r3, [r2, #884]	; 0x374
102d166c:	13833008 	orrne	r3, r3, #8
102d1670:	15823374 	strne	r3, [r2, #884]	; 0x374
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_devicestatus);
102d1674:	e3a02c02 	mov	r2, #512	; 0x200
102d1678:	e12fff34 	blx	r4
102d167c:	e59f1ab8 	ldr	r1, [pc, #2744]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d1680:	e59f2acc 	ldr	r2, [pc, #2764]	; 102d2154 <Process_Device_Twin_Properties+0x1014>
102d1684:	e5973000 	ldr	r3, [r7]
102d1688:	e59f0a7c 	ldr	r0, [pc, #2684]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d168c:	e12fff33 	blx	r3
102d1690:	e59f0a74 	ldr	r0, [pc, #2676]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1694:	e12fff38 	blx	r8
102d1698:	e59f1a6c 	ldr	r1, [pc, #2668]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d169c:	e1a02000 	mov	r2, r0
102d16a0:	e3a0000a 	mov	r0, #10
102d16a4:	e12fff3a 	blx	sl
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_STATUS;
		}

		//5. IotHubName
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d16a8:	e3a01000 	mov	r1, #0
102d16ac:	e3a02096 	mov	r2, #150	; 0x96
102d16b0:	e28d0018 	add	r0, sp, #24
102d16b4:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d16b8:	e3a01000 	mov	r1, #0
102d16bc:	e3a02096 	mov	r2, #150	; 0x96
102d16c0:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d16c4:	e12fff34 	blx	r4
		desired_obj = NULL;
		reported_obj = NULL;

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_IOT_HUB_NAME);
102d16c8:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d16cc:	e59d2008 	ldr	r2, [sp, #8]
102d16d0:	e3500001 	cmp	r0, #1
102d16d4:	e59d300c 	ldr	r3, [sp, #12]
102d16d8:	01a03002 	moveq	r3, r2
102d16dc:	e59f1a74 	ldr	r1, [pc, #2676]	; 102d2158 <Process_Device_Twin_Properties+0x1018>
102d16e0:	e1a00003 	mov	r0, r3
102d16e4:	e12fff35 	blx	r5
		if (NULL != desired_obj)
102d16e8:	e250b000 	subs	fp, r0, #0
102d16ec:	0a000012 	beq	102d173c <Process_Device_Twin_Properties+0x5fc>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_IOT_HUB_NAME, desired_obj->valuestring);
102d16f0:	e3a01000 	mov	r1, #0
102d16f4:	e3a02c02 	mov	r2, #512	; 0x200
102d16f8:	e59f0a0c 	ldr	r0, [pc, #2572]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d16fc:	e12fff34 	blx	r4
102d1700:	e59f1a24 	ldr	r1, [pc, #2596]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d1704:	e59f2a4c 	ldr	r2, [pc, #2636]	; 102d2158 <Process_Device_Twin_Properties+0x1018>
102d1708:	e59b3010 	ldr	r3, [fp, #16]
102d170c:	e597c000 	ldr	ip, [r7]
102d1710:	e59f09f4 	ldr	r0, [pc, #2548]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1714:	e12fff3c 	blx	ip
102d1718:	e59f09ec 	ldr	r0, [pc, #2540]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d171c:	e12fff38 	blx	r8
102d1720:	e59f19e4 	ldr	r1, [pc, #2532]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1724:	e1a02000 	mov	r2, r0
102d1728:	e3a0000a 	mov	r0, #10
102d172c:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d1730:	e28d0018 	add	r0, sp, #24
102d1734:	e59b1010 	ldr	r1, [fp, #16]
102d1738:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_IOT_HUB_NAME);
102d173c:	e59d0004 	ldr	r0, [sp, #4]
102d1740:	e59f1a10 	ldr	r1, [pc, #2576]	; 102d2158 <Process_Device_Twin_Properties+0x1018>
102d1744:	e12fff35 	blx	r5
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_IotHubName));
102d1748:	e2503000 	subs	r3, r0, #0
102d174c:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1750:	0a00021e 	beq	102d1fd0 <Process_Device_Twin_Properties+0xe90>
102d1754:	e5931010 	ldr	r1, [r3, #16]
102d1758:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d175c:	e35b0000 	cmp	fp, #0
102d1760:	0a000018 	beq	102d17c8 <Process_Device_Twin_Properties+0x688>
		{
			Ql_strcpy(RP_IotHubName, Desired_Property_Data);
102d1764:	e59fb9cc 	ldr	fp, [pc, #2508]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d1768:	e28d1018 	add	r1, sp, #24
102d176c:	e28b0fde 	add	r0, fp, #888	; 0x378
102d1770:	e12fff36 	blx	r6
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1774:	e28d0018 	add	r0, sp, #24
102d1778:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d177c:	e59f39b0 	ldr	r3, [pc, #2480]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d1780:	e12fff33 	blx	r3
102d1784:	e3500000 	cmp	r0, #0
102d1788:	1a0001a8 	bne	102d1e30 <Process_Device_Twin_Properties+0xcf0>
				Ql_sprintf(AZURE_assigned_IoT_Hub,"%s.azure-devices.net",RP_IotHubName);
				Store_IoT_Persistent_Data(); // Store Updated assigned IoT Hub information in permanent storage
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_IOT_HUB_NAME;
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_IotHubName);
102d178c:	e3a01000 	mov	r1, #0
102d1790:	e3a02c02 	mov	r2, #512	; 0x200
102d1794:	e59f0970 	ldr	r0, [pc, #2416]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1798:	e12fff34 	blx	r4
102d179c:	e59f0968 	ldr	r0, [pc, #2408]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d17a0:	e59f1994 	ldr	r1, [pc, #2452]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d17a4:	e2802d0b 	add	r2, r0, #704	; 0x2c0
102d17a8:	e5973000 	ldr	r3, [r7]
102d17ac:	e12fff33 	blx	r3
102d17b0:	e59f0954 	ldr	r0, [pc, #2388]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d17b4:	e12fff38 	blx	r8
102d17b8:	e59f194c 	ldr	r1, [pc, #2380]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d17bc:	e1a02000 	mov	r2, r0
102d17c0:	e3a0000a 	mov	r0, #10
102d17c4:	e12fff3a 	blx	sl
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_IOT_HUB_NAME;
			}
		}

		//6. DpsIdScope
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d17c8:	e3a01000 	mov	r1, #0
102d17cc:	e3a02096 	mov	r2, #150	; 0x96
102d17d0:	e28d0018 	add	r0, sp, #24
102d17d4:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d17d8:	e3a01000 	mov	r1, #0
102d17dc:	e3a02096 	mov	r2, #150	; 0x96
102d17e0:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d17e4:	e12fff34 	blx	r4
		desired_obj = NULL;
		reported_obj = NULL;

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_DPS_ID_SCOPE);
102d17e8:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d17ec:	e59d2008 	ldr	r2, [sp, #8]
102d17f0:	e3500001 	cmp	r0, #1
102d17f4:	e59d300c 	ldr	r3, [sp, #12]
102d17f8:	01a03002 	moveq	r3, r2
102d17fc:	e59f1958 	ldr	r1, [pc, #2392]	; 102d215c <Process_Device_Twin_Properties+0x101c>
102d1800:	e1a00003 	mov	r0, r3
102d1804:	e12fff35 	blx	r5
		if (NULL != desired_obj)
102d1808:	e250b000 	subs	fp, r0, #0
102d180c:	0a000012 	beq	102d185c <Process_Device_Twin_Properties+0x71c>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_DPS_ID_SCOPE, desired_obj->valuestring);
102d1810:	e3a01000 	mov	r1, #0
102d1814:	e3a02c02 	mov	r2, #512	; 0x200
102d1818:	e59f08ec 	ldr	r0, [pc, #2284]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d181c:	e12fff34 	blx	r4
102d1820:	e59f1904 	ldr	r1, [pc, #2308]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d1824:	e59f2930 	ldr	r2, [pc, #2352]	; 102d215c <Process_Device_Twin_Properties+0x101c>
102d1828:	e59b3010 	ldr	r3, [fp, #16]
102d182c:	e597c000 	ldr	ip, [r7]
102d1830:	e59f08d4 	ldr	r0, [pc, #2260]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1834:	e12fff3c 	blx	ip
102d1838:	e59f08cc 	ldr	r0, [pc, #2252]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d183c:	e12fff38 	blx	r8
102d1840:	e59f18c4 	ldr	r1, [pc, #2244]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1844:	e1a02000 	mov	r2, r0
102d1848:	e3a0000a 	mov	r0, #10
102d184c:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d1850:	e28d0018 	add	r0, sp, #24
102d1854:	e59b1010 	ldr	r1, [fp, #16]
102d1858:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_DPS_ID_SCOPE);
102d185c:	e59d0004 	ldr	r0, [sp, #4]
102d1860:	e59f18f4 	ldr	r1, [pc, #2292]	; 102d215c <Process_Device_Twin_Properties+0x101c>
102d1864:	e12fff35 	blx	r5
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_DpsIdScope));
102d1868:	e2503000 	subs	r3, r0, #0
102d186c:	0a0001a1 	beq	102d1ef8 <Process_Device_Twin_Properties+0xdb8>
102d1870:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1874:	e5931010 	ldr	r1, [r3, #16]
102d1878:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d187c:	e35b0000 	cmp	fp, #0
102d1880:	0a000018 	beq	102d18e8 <Process_Device_Twin_Properties+0x7a8>
		{
			Ql_strcpy(RP_DpsIdScope, Desired_Property_Data);
102d1884:	e59fb8ac 	ldr	fp, [pc, #2220]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d1888:	e28d1018 	add	r1, sp, #24
102d188c:	e28b0fe5 	add	r0, fp, #916	; 0x394
102d1890:	e12fff36 	blx	r6
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1894:	e28d0018 	add	r0, sp, #24
102d1898:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d189c:	e59f3890 	ldr	r3, [pc, #2192]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d18a0:	e12fff33 	blx	r3
102d18a4:	e3500000 	cmp	r0, #0
102d18a8:	1a00016b 	bne	102d1e5c <Process_Device_Twin_Properties+0xd1c>
				Ql_strcpy(AZURE_IoT_DPS_ID,RP_DpsIdScope);
				Store_IoT_Persistent_Data(); // Store Updated DPS information
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DPS_ID_SCOPE;
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_DpsIdScope);
102d18ac:	e3a01000 	mov	r1, #0
102d18b0:	e3a02c02 	mov	r2, #512	; 0x200
102d18b4:	e59f0850 	ldr	r0, [pc, #2128]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d18b8:	e12fff34 	blx	r4
102d18bc:	e59f0848 	ldr	r0, [pc, #2120]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d18c0:	e59f1874 	ldr	r1, [pc, #2164]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d18c4:	e2802fb7 	add	r2, r0, #732	; 0x2dc
102d18c8:	e5973000 	ldr	r3, [r7]
102d18cc:	e12fff33 	blx	r3
102d18d0:	e59f0834 	ldr	r0, [pc, #2100]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d18d4:	e12fff38 	blx	r8
102d18d8:	e59f182c 	ldr	r1, [pc, #2092]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d18dc:	e1a02000 	mov	r2, r0
102d18e0:	e3a0000a 	mov	r0, #10
102d18e4:	e12fff3a 	blx	sl

		//7,8,9. DispFirmwareFileName , DispFirmwareVersion, DispFirmwareUrl
		// No -Action - We do not process Display Firmware seperatley

		//10. CntrlFirmwareFileName
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d18e8:	e3a01000 	mov	r1, #0
102d18ec:	e3a02096 	mov	r2, #150	; 0x96
102d18f0:	e28d0018 	add	r0, sp, #24
102d18f4:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d18f8:	e3a01000 	mov	r1, #0
102d18fc:	e3a02096 	mov	r2, #150	; 0x96
102d1900:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1904:	e12fff34 	blx	r4
		desired_obj = NULL;
		reported_obj = NULL;

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_CNTRL_FW_FILE_NAME);
102d1908:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d190c:	e59d2008 	ldr	r2, [sp, #8]
102d1910:	e3500001 	cmp	r0, #1
102d1914:	e59d300c 	ldr	r3, [sp, #12]
102d1918:	01a03002 	moveq	r3, r2
102d191c:	e59f183c 	ldr	r1, [pc, #2108]	; 102d2160 <Process_Device_Twin_Properties+0x1020>
102d1920:	e1a00003 	mov	r0, r3
102d1924:	e12fff35 	blx	r5
		if (NULL != desired_obj)
102d1928:	e250b000 	subs	fp, r0, #0
102d192c:	0a000012 	beq	102d197c <Process_Device_Twin_Properties+0x83c>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_CNTRL_FW_FILE_NAME, desired_obj->valuestring);
102d1930:	e3a01000 	mov	r1, #0
102d1934:	e3a02c02 	mov	r2, #512	; 0x200
102d1938:	e59f07cc 	ldr	r0, [pc, #1996]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d193c:	e12fff34 	blx	r4
102d1940:	e59f17e4 	ldr	r1, [pc, #2020]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d1944:	e59f2814 	ldr	r2, [pc, #2068]	; 102d2160 <Process_Device_Twin_Properties+0x1020>
102d1948:	e59b3010 	ldr	r3, [fp, #16]
102d194c:	e597c000 	ldr	ip, [r7]
102d1950:	e59f07b4 	ldr	r0, [pc, #1972]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1954:	e12fff3c 	blx	ip
102d1958:	e59f07ac 	ldr	r0, [pc, #1964]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d195c:	e12fff38 	blx	r8
102d1960:	e59f17a4 	ldr	r1, [pc, #1956]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1964:	e1a02000 	mov	r2, r0
102d1968:	e3a0000a 	mov	r0, #10
102d196c:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d1970:	e28d0018 	add	r0, sp, #24
102d1974:	e59b1010 	ldr	r1, [fp, #16]
102d1978:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_CNTRL_FW_FILE_NAME);
102d197c:	e59f17dc 	ldr	r1, [pc, #2012]	; 102d2160 <Process_Device_Twin_Properties+0x1020>
102d1980:	e59d0004 	ldr	r0, [sp, #4]
102d1984:	e12fff35 	blx	r5
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_CntrlFirmwareFileName));
102d1988:	e3500000 	cmp	r0, #0
102d198c:	15901010 	ldrne	r1, [r0, #16]
102d1990:	059f17cc 	ldreq	r1, [pc, #1996]	; 102d2164 <Process_Device_Twin_Properties+0x1024>
102d1994:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1998:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d199c:	e35b0000 	cmp	fp, #0
102d19a0:	0a00001b 	beq	102d1a14 <Process_Device_Twin_Properties+0x8d4>
		{
			Ql_strcpy(RP_CntrlFirmwareFileName, Desired_Property_Data);
102d19a4:	e59fb78c 	ldr	fp, [pc, #1932]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d19a8:	e28d1018 	add	r1, sp, #24
102d19ac:	e59f3774 	ldr	r3, [pc, #1908]	; 102d2128 <Process_Device_Twin_Properties+0xfe8>
102d19b0:	e28b0e3a 	add	r0, fp, #928	; 0x3a0
102d19b4:	e12fff33 	blx	r3
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d19b8:	e59f3774 	ldr	r3, [pc, #1908]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d19bc:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d19c0:	e28d0018 	add	r0, sp, #24
102d19c4:	e12fff33 	blx	r3
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_NAME;
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareFileName);
102d19c8:	e3a01000 	mov	r1, #0
102d19cc:	e3a02c02 	mov	r2, #512	; 0x200
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_CntrlFirmwareFileName));

		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_CntrlFirmwareFileName, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d19d0:	e3500000 	cmp	r0, #0
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_NAME;
102d19d4:	15db3476 	ldrbne	r3, [fp, #1142]	; 0x476
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareFileName);
102d19d8:	e59f072c 	ldr	r0, [pc, #1836]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_CntrlFirmwareFileName, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_NAME;
102d19dc:	13833001 	orrne	r3, r3, #1
102d19e0:	15cb3476 	strbne	r3, [fp, #1142]	; 0x476
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareFileName);
102d19e4:	e12fff34 	blx	r4
102d19e8:	e59f071c 	ldr	r0, [pc, #1820]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d19ec:	e59f1748 	ldr	r1, [pc, #1864]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d19f0:	e2802fba 	add	r2, r0, #744	; 0x2e8
102d19f4:	e5973000 	ldr	r3, [r7]
102d19f8:	e12fff33 	blx	r3
102d19fc:	e59f0708 	ldr	r0, [pc, #1800]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1a00:	e12fff38 	blx	r8
102d1a04:	e59f1700 	ldr	r1, [pc, #1792]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1a08:	e1a02000 	mov	r2, r0
102d1a0c:	e3a0000a 	mov	r0, #10
102d1a10:	e12fff3a 	blx	sl
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. no action
		{
		}
		//11. CntrlFirmwareVersion
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1a14:	e3a01000 	mov	r1, #0
102d1a18:	e3a02096 	mov	r2, #150	; 0x96
102d1a1c:	e28d0018 	add	r0, sp, #24
102d1a20:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1a24:	e3a01000 	mov	r1, #0
102d1a28:	e3a02096 	mov	r2, #150	; 0x96
102d1a2c:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1a30:	e12fff34 	blx	r4
		desired_obj = NULL;
		reported_obj = NULL;

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_CNTRL_FW_FILE_VER);
102d1a34:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d1a38:	e59d2008 	ldr	r2, [sp, #8]
102d1a3c:	e3500001 	cmp	r0, #1
102d1a40:	e59d300c 	ldr	r3, [sp, #12]
102d1a44:	01a03002 	moveq	r3, r2
102d1a48:	e59f1718 	ldr	r1, [pc, #1816]	; 102d2168 <Process_Device_Twin_Properties+0x1028>
102d1a4c:	e1a00003 	mov	r0, r3
102d1a50:	e12fff35 	blx	r5
		if (NULL != desired_obj)
102d1a54:	e250b000 	subs	fp, r0, #0
102d1a58:	0a000012 	beq	102d1aa8 <Process_Device_Twin_Properties+0x968>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_CNTRL_FW_FILE_VER, desired_obj->valuestring);
102d1a5c:	e3a01000 	mov	r1, #0
102d1a60:	e3a02c02 	mov	r2, #512	; 0x200
102d1a64:	e59f06a0 	ldr	r0, [pc, #1696]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1a68:	e12fff34 	blx	r4
102d1a6c:	e59f16b8 	ldr	r1, [pc, #1720]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d1a70:	e59f26f0 	ldr	r2, [pc, #1776]	; 102d2168 <Process_Device_Twin_Properties+0x1028>
102d1a74:	e59b3010 	ldr	r3, [fp, #16]
102d1a78:	e597c000 	ldr	ip, [r7]
102d1a7c:	e59f0688 	ldr	r0, [pc, #1672]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1a80:	e12fff3c 	blx	ip
102d1a84:	e59f0680 	ldr	r0, [pc, #1664]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1a88:	e12fff38 	blx	r8
102d1a8c:	e59f1678 	ldr	r1, [pc, #1656]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1a90:	e1a02000 	mov	r2, r0
102d1a94:	e3a0000a 	mov	r0, #10
102d1a98:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d1a9c:	e28d0018 	add	r0, sp, #24
102d1aa0:	e59b1010 	ldr	r1, [fp, #16]
102d1aa4:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_CNTRL_FW_FILE_VER);
102d1aa8:	e59d0004 	ldr	r0, [sp, #4]
102d1aac:	e59f16b4 	ldr	r1, [pc, #1716]	; 102d2168 <Process_Device_Twin_Properties+0x1028>
102d1ab0:	e12fff35 	blx	r5
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_CntrlFirmwareVersion));
102d1ab4:	e2503000 	subs	r3, r0, #0
102d1ab8:	0a000169 	beq	102d2064 <Process_Device_Twin_Properties+0xf24>
102d1abc:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1ac0:	e5931010 	ldr	r1, [r3, #16]
102d1ac4:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d1ac8:	e35b0000 	cmp	fp, #0
102d1acc:	0a00001a 	beq	102d1b3c <Process_Device_Twin_Properties+0x9fc>
		{
			Ql_strcpy(RP_CntrlFirmwareVersion, Desired_Property_Data);
102d1ad0:	e59fb660 	ldr	fp, [pc, #1632]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d1ad4:	e28d1018 	add	r1, sp, #24
102d1ad8:	e28b0ff5 	add	r0, fp, #980	; 0x3d4
102d1adc:	e12fff36 	blx	r6
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1ae0:	e59f364c 	ldr	r3, [pc, #1612]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d1ae4:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d1ae8:	e28d0018 	add	r0, sp, #24
102d1aec:	e12fff33 	blx	r3
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_VER;
			}

#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareVersion);
102d1af0:	e3a01000 	mov	r1, #0
102d1af4:	e3a02c02 	mov	r2, #512	; 0x200
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_CntrlFirmwareVersion));

		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_CntrlFirmwareVersion, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1af8:	e3500000 	cmp	r0, #0
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_VER;
102d1afc:	15db3476 	ldrbne	r3, [fp, #1142]	; 0x476
			}

#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareVersion);
102d1b00:	e59f0604 	ldr	r0, [pc, #1540]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_CntrlFirmwareVersion, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_VER;
102d1b04:	13833002 	orrne	r3, r3, #2
102d1b08:	15cb3476 	strbne	r3, [fp, #1142]	; 0x476
			}

#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareVersion);
102d1b0c:	e12fff34 	blx	r4
102d1b10:	e59f05f4 	ldr	r0, [pc, #1524]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1b14:	e59f1620 	ldr	r1, [pc, #1568]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d1b18:	e2802fc7 	add	r2, r0, #796	; 0x31c
102d1b1c:	e5973000 	ldr	r3, [r7]
102d1b20:	e12fff33 	blx	r3
102d1b24:	e59f05e0 	ldr	r0, [pc, #1504]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1b28:	e12fff38 	blx	r8
102d1b2c:	e59f15d8 	ldr	r1, [pc, #1496]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1b30:	e1a02000 	mov	r2, r0
102d1b34:	e3a0000a 	mov	r0, #10
102d1b38:	e12fff3a 	blx	sl
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTRL_FW_VER;
			}
		}

		//12. CntrlFirmwareUrl
		Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1b3c:	e3a01000 	mov	r1, #0
102d1b40:	e3a02096 	mov	r2, #150	; 0x96
102d1b44:	e28d0018 	add	r0, sp, #24
102d1b48:	e12fff34 	blx	r4
		Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1b4c:	e3a01000 	mov	r1, #0
102d1b50:	e3a02096 	mov	r2, #150	; 0x96
102d1b54:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1b58:	e12fff34 	blx	r4
		desired_obj = NULL;
		reported_obj = NULL;

		desired_obj = cJSON_GetObjectItem((FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == TRUE) ? root : desired, TWIN_CNTRL_FW_FILE_URL);
102d1b5c:	e5d90025 	ldrb	r0, [r9, #37]	; 0x25
102d1b60:	e59d200c 	ldr	r2, [sp, #12]
102d1b64:	e3500001 	cmp	r0, #1
102d1b68:	e59d3008 	ldr	r3, [sp, #8]
102d1b6c:	11a03002 	movne	r3, r2
102d1b70:	e59f15f4 	ldr	r1, [pc, #1524]	; 102d216c <Process_Device_Twin_Properties+0x102c>
102d1b74:	e1a00003 	mov	r0, r3
102d1b78:	e12fff35 	blx	r5
		if (NULL != desired_obj)
102d1b7c:	e250b000 	subs	fp, r0, #0
102d1b80:	0a000012 	beq	102d1bd0 <Process_Device_Twin_Properties+0xa90>
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r DP: %s --> %s ", TWIN_CNTRL_FW_FILE_URL, desired_obj->valuestring);
102d1b84:	e3a01000 	mov	r1, #0
102d1b88:	e3a02c02 	mov	r2, #512	; 0x200
102d1b8c:	e59f0578 	ldr	r0, [pc, #1400]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1b90:	e12fff34 	blx	r4
102d1b94:	e59f1590 	ldr	r1, [pc, #1424]	; 102d212c <Process_Device_Twin_Properties+0xfec>
102d1b98:	e59f25cc 	ldr	r2, [pc, #1484]	; 102d216c <Process_Device_Twin_Properties+0x102c>
102d1b9c:	e59b3010 	ldr	r3, [fp, #16]
102d1ba0:	e597c000 	ldr	ip, [r7]
102d1ba4:	e59f0560 	ldr	r0, [pc, #1376]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1ba8:	e12fff3c 	blx	ip
102d1bac:	e59f0558 	ldr	r0, [pc, #1368]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1bb0:	e12fff38 	blx	r8
102d1bb4:	e59f1550 	ldr	r1, [pc, #1360]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1bb8:	e1a02000 	mov	r2, r0
102d1bbc:	e3a0000a 	mov	r0, #10
102d1bc0:	e12fff3a 	blx	sl
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
102d1bc4:	e28d0018 	add	r0, sp, #24
102d1bc8:	e59b1010 	ldr	r1, [fp, #16]
102d1bcc:	e12fff36 	blx	r6
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_CNTRL_FW_FILE_URL);
102d1bd0:	e59f1594 	ldr	r1, [pc, #1428]	; 102d216c <Process_Device_Twin_Properties+0x102c>
102d1bd4:	e59d0004 	ldr	r0, [sp, #4]
102d1bd8:	e12fff35 	blx	r5
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_CntrlFirmwareFileURL));
102d1bdc:	e3500000 	cmp	r0, #0
102d1be0:	15901010 	ldrne	r1, [r0, #16]
102d1be4:	059f1584 	ldreq	r1, [pc, #1412]	; 102d2170 <Process_Device_Twin_Properties+0x1030>
102d1be8:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1bec:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d1bf0:	e35b0000 	cmp	fp, #0
102d1bf4:	0a00001b 	beq	102d1c68 <Process_Device_Twin_Properties+0xb28>
		{
			Ql_strcpy(RP_CntrlFirmwareFileURL, Desired_Property_Data);
102d1bf8:	e59fb538 	ldr	fp, [pc, #1336]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d1bfc:	e28d1018 	add	r1, sp, #24
102d1c00:	e59f3520 	ldr	r3, [pc, #1312]	; 102d2128 <Process_Device_Twin_Properties+0xfe8>
102d1c04:	e28b0e3e 	add	r0, fp, #992	; 0x3e0
102d1c08:	e12fff33 	blx	r3
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1c0c:	e59f3520 	ldr	r3, [pc, #1312]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d1c10:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d1c14:	e28d0018 	add	r0, sp, #24
102d1c18:	e12fff33 	blx	r3
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_URL;
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareFileURL);
102d1c1c:	e3a01000 	mov	r1, #0
102d1c20:	e3a02c02 	mov	r2, #512	; 0x200
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_CntrlFirmwareFileURL));

		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_CntrlFirmwareFileURL, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
102d1c24:	e3500000 	cmp	r0, #0
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_URL;
102d1c28:	15db3476 	ldrbne	r3, [fp, #1142]	; 0x476
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareFileURL);
102d1c2c:	e59f04d8 	ldr	r0, [pc, #1240]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_CntrlFirmwareFileURL, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
			{
				FOTA_information |= REPORT_TWIN_CNTRL_FW_FILE_URL;
102d1c30:	13833004 	orrne	r3, r3, #4
102d1c34:	15cb3476 	strbne	r3, [fp, #1142]	; 0x476
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareFileURL);
102d1c38:	e12fff34 	blx	r4
102d1c3c:	e59f04c8 	ldr	r0, [pc, #1224]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1c40:	e59f14f4 	ldr	r1, [pc, #1268]	; 102d213c <Process_Device_Twin_Properties+0xffc>
102d1c44:	e2802fca 	add	r2, r0, #808	; 0x328
102d1c48:	e5973000 	ldr	r3, [r7]
102d1c4c:	e12fff33 	blx	r3
102d1c50:	e59f04b4 	ldr	r0, [pc, #1204]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1c54:	e12fff38 	blx	r8
102d1c58:	e59f14ac 	ldr	r1, [pc, #1196]	; 102d210c <Process_Device_Twin_Properties+0xfcc>
102d1c5c:	e1a02000 	mov	r2, r0
102d1c60:	e3a0000a 	mov	r0, #10
102d1c64:	e12fff3a 	blx	sl
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. no action
		{
		}

		if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE) // These are not available in Desired properties
102d1c68:	e5d97025 	ldrb	r7, [r9, #37]	; 0x25
102d1c6c:	e3570000 	cmp	r7, #0
102d1c70:	0a00001e 	beq	102d1cf0 <Process_Device_Twin_Properties+0xbb0>
			}
		}
	}
	FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = FALSE; //Reset the flag

	if((FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_NAME) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_VER) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_URL))
102d1c74:	e59d2010 	ldr	r2, [sp, #16]
					FLAG.LAST_FOTA_ATTEMPT_FAILED = TRUE;// Update status less than 4 indiates, last FOTA was terminated incomplete i.e. without SUCCESS or FAIL
				}
			}
		}
	}
	FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = FALSE; //Reset the flag
102d1c78:	e3a01000 	mov	r1, #0

	if((FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_NAME) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_VER) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_URL))
102d1c7c:	e5d23476 	ldrb	r3, [r2, #1142]	; 0x476
					FLAG.LAST_FOTA_ATTEMPT_FAILED = TRUE;// Update status less than 4 indiates, last FOTA was terminated incomplete i.e. without SUCCESS or FAIL
				}
			}
		}
	}
	FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = FALSE; //Reset the flag
102d1c80:	e59fc478 	ldr	ip, [pc, #1144]	; 102d2100 <Process_Device_Twin_Properties+0xfc0>

	if((FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_NAME) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_VER) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_URL))
102d1c84:	e2032003 	and	r2, r3, #3
102d1c88:	e3520003 	cmp	r2, #3
					FLAG.LAST_FOTA_ATTEMPT_FAILED = TRUE;// Update status less than 4 indiates, last FOTA was terminated incomplete i.e. without SUCCESS or FAIL
				}
			}
		}
	}
	FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = FALSE; //Reset the flag
102d1c8c:	e5c91025 	strb	r1, [r9, #37]	; 0x25

	if((FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_NAME) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_VER) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_URL))
102d1c90:	e59f44a0 	ldr	r4, [pc, #1184]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d1c94:	0a000009 	beq	102d1cc0 <Process_Device_Twin_Properties+0xb80>
		// To act on a Firmware upgrade.. all three respective desired properties need to have change in them.. i.e.. File Name, File Version and File URL should have change
		Ql_strcpy(FOTA_URL, RP_CntrlFirmwareFileURL);
		Store_IoT_Persistent_Data();
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTRL_FW_INFO;
	}
	else if(!((FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_NAME) || (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_VER) || (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_URL)))
102d1c98:	e3520000 	cmp	r2, #0
102d1c9c:	1a000009 	bne	102d1cc8 <Process_Device_Twin_Properties+0xb88>
102d1ca0:	e2133004 	ands	r3, r3, #4
102d1ca4:	1a000007 	bne	102d1cc8 <Process_Device_Twin_Properties+0xb88>
	{
		// To act on a Firmware upgrade terminated without success of fail case .. all three respective desired properties need to not have change in them. and CntrlFirmwareUpdateStatus should be less than value 4
		if(FLAG.LAST_FOTA_ATTEMPT_FAILED == TRUE)// Update status less than 4 indiates, last FOTA was terminated incomplete i.e. without SUCCESS or FAIL
102d1ca8:	e5dc2027 	ldrb	r2, [ip, #39]	; 0x27
102d1cac:	e5940374 	ldr	r0, [r4, #884]	; 0x374
102d1cb0:	e3520001 	cmp	r2, #1
		{
			FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD = TRUE;
102d1cb4:	05cc2024 	strbeq	r2, [ip, #36]	; 0x24
			FLAG.LAST_FOTA_ATTEMPT_FAILED = FALSE;
102d1cb8:	05cc3027 	strbeq	r3, [ip, #39]	; 0x27
102d1cbc:	ea000002 	b	102d1ccc <Process_Device_Twin_Properties+0xb8c>
			}
		}
	}
	FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = FALSE; //Reset the flag

	if((FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_NAME) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_VER) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_URL))
102d1cc0:	e3130004 	tst	r3, #4
102d1cc4:	1a00006e 	bne	102d1e84 <Process_Device_Twin_Properties+0xd44>
102d1cc8:	e5940374 	ldr	r0, [r4, #884]	; 0x374
			FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD = TRUE;
			FLAG.LAST_FOTA_ATTEMPT_FAILED = FALSE;
		}
	}

	if(Process_TWIN_PROPERTY_CHANGE)// Schedule a reported property response for device twin for non -action items
102d1ccc:	e3500000 	cmp	r0, #0
102d1cd0:	0a000004 	beq	102d1ce8 <Process_Device_Twin_Properties+0xba8>
	{
		PUBLISH_RESPONSE_REQ_source |= SCHEDULE_DEVICE_TWIN_REPORT_MESSAGE;
102d1cd4:	e59f3498 	ldr	r3, [pc, #1176]	; 102d2174 <Process_Device_Twin_Properties+0x1034>

	}
	return RET_SUCCESS;
102d1cd8:	e3a00000 	mov	r0, #0
		}
	}

	if(Process_TWIN_PROPERTY_CHANGE)// Schedule a reported property response for device twin for non -action items
	{
		PUBLISH_RESPONSE_REQ_source |= SCHEDULE_DEVICE_TWIN_REPORT_MESSAGE;
102d1cdc:	e5932000 	ldr	r2, [r3]
102d1ce0:	e3822701 	orr	r2, r2, #262144	; 0x40000
102d1ce4:	e5832000 	str	r2, [r3]

	}
	return RET_SUCCESS;
}
102d1ce8:	e28ddf53 	add	sp, sp, #332	; 0x14c
102d1cec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}

		if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE) // These are not available in Desired properties
		{
			//13. IMEI
			Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1cf0:	e3a02096 	mov	r2, #150	; 0x96
102d1cf4:	e1a01007 	mov	r1, r7
102d1cf8:	e28d0018 	add	r0, sp, #24
102d1cfc:	e12fff34 	blx	r4
			Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1d00:	e1a01007 	mov	r1, r7
102d1d04:	e3a02096 	mov	r2, #150	; 0x96
102d1d08:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1d0c:	e12fff34 	blx	r4
			desired_obj = NULL;
			reported_obj = NULL;

			//This property is not available in desired property set
			//Check Reported Properties .. if found different .then report back
			reported_obj = cJSON_GetObjectItem(reported, TWIN_IMEI);
102d1d10:	e59d0004 	ldr	r0, [sp, #4]
102d1d14:	e59f145c 	ldr	r1, [pc, #1116]	; 102d2178 <Process_Device_Twin_Properties+0x1038>
102d1d18:	e12fff35 	blx	r5
			if (NULL != reported_obj) // Reported properties has property already reported in it
102d1d1c:	e2503000 	subs	r3, r0, #0
102d1d20:	0a000002 	beq	102d1d30 <Process_Device_Twin_Properties+0xbf0>
			{
				Ql_strcpy(Reported_Property_Data, reported_obj->valuestring);
102d1d24:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1d28:	e5931010 	ldr	r1, [r3, #16]
102d1d2c:	e12fff36 	blx	r6
			}
			if(Ql_strcmp(IMEI,Reported_Property_Data)) //If there is a change in IMEI number than the earlier reported then initiate a fresh reporting
102d1d30:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d1d34:	e59f0440 	ldr	r0, [pc, #1088]	; 102d217c <Process_Device_Twin_Properties+0x103c>
102d1d38:	e59f73f4 	ldr	r7, [pc, #1012]	; 102d2134 <Process_Device_Twin_Properties+0xff4>
102d1d3c:	e12fff37 	blx	r7
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_IMIE;
			}
			//14. CCD
			Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1d40:	e3a01000 	mov	r1, #0
			reported_obj = cJSON_GetObjectItem(reported, TWIN_IMEI);
			if (NULL != reported_obj) // Reported properties has property already reported in it
			{
				Ql_strcpy(Reported_Property_Data, reported_obj->valuestring);
			}
			if(Ql_strcmp(IMEI,Reported_Property_Data)) //If there is a change in IMEI number than the earlier reported then initiate a fresh reporting
102d1d44:	e3500000 	cmp	r0, #0
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_IMIE;
102d1d48:	159d2010 	ldrne	r2, [sp, #16]
			}
			//14. CCD
			Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1d4c:	e28d0018 	add	r0, sp, #24
			{
				Ql_strcpy(Reported_Property_Data, reported_obj->valuestring);
			}
			if(Ql_strcmp(IMEI,Reported_Property_Data)) //If there is a change in IMEI number than the earlier reported then initiate a fresh reporting
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_IMIE;
102d1d50:	15923374 	ldrne	r3, [r2, #884]	; 0x374
102d1d54:	13833c02 	orrne	r3, r3, #512	; 0x200
102d1d58:	15823374 	strne	r3, [r2, #884]	; 0x374
			}
			//14. CCD
			Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1d5c:	e3a02096 	mov	r2, #150	; 0x96
102d1d60:	e12fff34 	blx	r4
			Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1d64:	e3a01000 	mov	r1, #0
102d1d68:	e3a02096 	mov	r2, #150	; 0x96
102d1d6c:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1d70:	e12fff34 	blx	r4
			desired_obj = NULL;
			reported_obj = NULL;

			//This property is not available in desired property set
			//Check Reported Properties .. if found different .then report back
			reported_obj = cJSON_GetObjectItem(reported, TWIN_CCID);
102d1d74:	e59d0004 	ldr	r0, [sp, #4]
102d1d78:	e59f1400 	ldr	r1, [pc, #1024]	; 102d2180 <Process_Device_Twin_Properties+0x1040>
102d1d7c:	e12fff35 	blx	r5
			if (NULL != reported_obj) // Reported properties has property already reported in it
102d1d80:	e2503000 	subs	r3, r0, #0
102d1d84:	0a000002 	beq	102d1d94 <Process_Device_Twin_Properties+0xc54>
			{
				Ql_strcpy(Reported_Property_Data, reported_obj->valuestring);
102d1d88:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1d8c:	e5931010 	ldr	r1, [r3, #16]
102d1d90:	e12fff36 	blx	r6
			}
			if(Ql_strcmp(CCID,Reported_Property_Data)) //If there is a change in IMEI number than the earlier reported then initiate a fresh reporting
102d1d94:	e28d10b0 	add	r1, sp, #176	; 0xb0
102d1d98:	e59f03e4 	ldr	r0, [pc, #996]	; 102d2184 <Process_Device_Twin_Properties+0x1044>
102d1d9c:	e12fff37 	blx	r7
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CCID;
			}

			//15."CntrlFirmwareUpdateStatus":
			Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1da0:	e3a01000 	mov	r1, #0
			reported_obj = cJSON_GetObjectItem(reported, TWIN_CCID);
			if (NULL != reported_obj) // Reported properties has property already reported in it
			{
				Ql_strcpy(Reported_Property_Data, reported_obj->valuestring);
			}
			if(Ql_strcmp(CCID,Reported_Property_Data)) //If there is a change in IMEI number than the earlier reported then initiate a fresh reporting
102d1da4:	e3500000 	cmp	r0, #0
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CCID;
102d1da8:	159d2010 	ldrne	r2, [sp, #16]
			}

			//15."CntrlFirmwareUpdateStatus":
			Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1dac:	e28d0018 	add	r0, sp, #24
			{
				Ql_strcpy(Reported_Property_Data, reported_obj->valuestring);
			}
			if(Ql_strcmp(CCID,Reported_Property_Data)) //If there is a change in IMEI number than the earlier reported then initiate a fresh reporting
			{
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CCID;
102d1db0:	15923374 	ldrne	r3, [r2, #884]	; 0x374
102d1db4:	13833b01 	orrne	r3, r3, #1024	; 0x400
102d1db8:	15823374 	strne	r3, [r2, #884]	; 0x374
			}

			//15."CntrlFirmwareUpdateStatus":
			Ql_memset(Desired_Property_Data, 0x0, sizeof(Desired_Property_Data));
102d1dbc:	e3a02096 	mov	r2, #150	; 0x96
102d1dc0:	e12fff34 	blx	r4
			Ql_memset(Reported_Property_Data, 0x0, sizeof(Reported_Property_Data));
102d1dc4:	e3a02096 	mov	r2, #150	; 0x96
102d1dc8:	e3a01000 	mov	r1, #0
102d1dcc:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1dd0:	e12fff34 	blx	r4
			desired_obj = NULL;
			reported_obj = NULL;

			//This property is not available in desired property set
			//Check Reported Properties .. if found different .then report back
			reported_obj = cJSON_GetObjectItem(reported, TWIN_CNTRL_FW_UPDATE_STATUS);
102d1dd4:	e59f13ac 	ldr	r1, [pc, #940]	; 102d2188 <Process_Device_Twin_Properties+0x1048>
102d1dd8:	e59d0004 	ldr	r0, [sp, #4]
102d1ddc:	e12fff35 	blx	r5
			if (NULL != reported_obj) // Reported properties has property already reported in it
102d1de0:	e2503000 	subs	r3, r0, #0
			{
				Ql_strcpy(Reported_Property_Data, reported_obj->valuestring);
102d1de4:	15931010 	ldrne	r1, [r3, #16]
			}
			else
			{
				Ql_strcpy(Reported_Property_Data, "6");//mark valid data for first time used
102d1de8:	059f139c 	ldreq	r1, [pc, #924]	; 102d218c <Process_Device_Twin_Properties+0x104c>
			//This property is not available in desired property set
			//Check Reported Properties .. if found different .then report back
			reported_obj = cJSON_GetObjectItem(reported, TWIN_CNTRL_FW_UPDATE_STATUS);
			if (NULL != reported_obj) // Reported properties has property already reported in it
			{
				Ql_strcpy(Reported_Property_Data, reported_obj->valuestring);
102d1dec:	e28d00b0 	add	r0, sp, #176	; 0xb0
			}
			else
			{
				Ql_strcpy(Reported_Property_Data, "6");//mark valid data for first time used
102d1df0:	e12fff36 	blx	r6
			}
			if(Ql_strcmp(FW_Version_STRING,RP_CntrlFirmwareVersion)) //Compare communication module FW version with device twin reported FW version
102d1df4:	e59f0394 	ldr	r0, [pc, #916]	; 102d2190 <Process_Device_Twin_Properties+0x1050>
102d1df8:	e59f1394 	ldr	r1, [pc, #916]	; 102d2194 <Process_Device_Twin_Properties+0x1054>
102d1dfc:	e12fff37 	blx	r7
102d1e00:	e3500000 	cmp	r0, #0
102d1e04:	0affff9a 	beq	102d1c74 <Process_Device_Twin_Properties+0xb34>
			{
				if(atoi(Reported_Property_Data) < 4) //if last FOTA is fail due to power failure or another reason then FOTA is start automatically
102d1e08:	e59f3388 	ldr	r3, [pc, #904]	; 102d2198 <Process_Device_Twin_Properties+0x1058>
102d1e0c:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1e10:	e12fff33 	blx	r3
102d1e14:	e3500003 	cmp	r0, #3
				{
					FLAG.LAST_FOTA_ATTEMPT_FAILED = TRUE;// Update status less than 4 indiates, last FOTA was terminated incomplete i.e. without SUCCESS or FAIL
102d1e18:	d3a03001 	movle	r3, #1
102d1e1c:	d5c93027 	strble	r3, [r9, #39]	; 0x27
102d1e20:	eaffff93 	b	102d1c74 <Process_Device_Twin_Properties+0xb34>
102d1e24:	e59f230c 	ldr	r2, [pc, #780]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d1e28:	e58d2010 	str	r2, [sp, #16]
102d1e2c:	eafffd3f 	b	102d1330 <Process_Device_Twin_Properties+0x1f0>
		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_IotHubName, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
			{
				Ql_sprintf(AZURE_assigned_IoT_Hub,"%s.azure-devices.net",RP_IotHubName);
102d1e30:	e59f1364 	ldr	r1, [pc, #868]	; 102d219c <Process_Device_Twin_Properties+0x105c>
102d1e34:	e28b2fde 	add	r2, fp, #888	; 0x378
102d1e38:	e5973000 	ldr	r3, [r7]
102d1e3c:	e59f035c 	ldr	r0, [pc, #860]	; 102d21a0 <Process_Device_Twin_Properties+0x1060>
102d1e40:	e12fff33 	blx	r3
				Store_IoT_Persistent_Data(); // Store Updated assigned IoT Hub information in permanent storage
102d1e44:	e59f3358 	ldr	r3, [pc, #856]	; 102d21a4 <Process_Device_Twin_Properties+0x1064>
102d1e48:	e12fff33 	blx	r3
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_IOT_HUB_NAME;
102d1e4c:	e59b3374 	ldr	r3, [fp, #884]	; 0x374
102d1e50:	e3833010 	orr	r3, r3, #16
102d1e54:	e58b3374 	str	r3, [fp, #884]	; 0x374
102d1e58:	eafffe4b 	b	102d178c <Process_Device_Twin_Properties+0x64c>
		if (NULL != desired_obj) //If desired property available
		{
			Ql_strcpy(RP_DpsIdScope, Desired_Property_Data);
			if(Ql_strcmp(Desired_Property_Data,Reported_Property_Data)) //If there is a change in desired propery and reported property.. then take appropriate action
			{
				Ql_strcpy(AZURE_IoT_DPS_ID,RP_DpsIdScope);
102d1e5c:	e28b1fe5 	add	r1, fp, #916	; 0x394
102d1e60:	e59f32c0 	ldr	r3, [pc, #704]	; 102d2128 <Process_Device_Twin_Properties+0xfe8>
102d1e64:	e59f033c 	ldr	r0, [pc, #828]	; 102d21a8 <Process_Device_Twin_Properties+0x1068>
102d1e68:	e12fff33 	blx	r3
				Store_IoT_Persistent_Data(); // Store Updated DPS information
102d1e6c:	e59f3330 	ldr	r3, [pc, #816]	; 102d21a4 <Process_Device_Twin_Properties+0x1064>
102d1e70:	e12fff33 	blx	r3
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DPS_ID_SCOPE;
102d1e74:	e59b3374 	ldr	r3, [fp, #884]	; 0x374
102d1e78:	e3833020 	orr	r3, r3, #32
102d1e7c:	e58b3374 	str	r3, [fp, #884]	; 0x374
102d1e80:	eafffe89 	b	102d18ac <Process_Device_Twin_Properties+0x76c>
	FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = FALSE; //Reset the flag

	if((FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_NAME) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_VER) && (FOTA_information & REPORT_TWIN_CNTRL_FW_FILE_URL))
	{
		// To act on a Firmware upgrade.. all three respective desired properties need to have change in them.. i.e.. File Name, File Version and File URL should have change
		Ql_strcpy(FOTA_URL, RP_CntrlFirmwareFileURL);
102d1e84:	e2841e3e 	add	r1, r4, #992	; 0x3e0
102d1e88:	e59f031c 	ldr	r0, [pc, #796]	; 102d21ac <Process_Device_Twin_Properties+0x106c>
102d1e8c:	e12fff36 	blx	r6
		Store_IoT_Persistent_Data();
102d1e90:	e59f330c 	ldr	r3, [pc, #780]	; 102d21a4 <Process_Device_Twin_Properties+0x1064>
102d1e94:	e12fff33 	blx	r3
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTRL_FW_INFO;
102d1e98:	e5943374 	ldr	r3, [r4, #884]	; 0x374
102d1e9c:	e3833040 	orr	r3, r3, #64	; 0x40
102d1ea0:	e5843374 	str	r3, [r4, #884]	; 0x374
102d1ea4:	eaffff8a 	b	102d1cd4 <Process_Device_Twin_Properties+0xb94>
	//Check if the message is for entire property list via GET message or is a change notification
	// A change notification will have version information in root jason..
	desired_obj = cJSON_GetObjectItem(root, TWIN_VERSION);//Json object listing desired properties
	if(desired_obj == NULL) // This is a GET response with entire set of desired and reported properties
	{
		desired = cJSON_GetObjectItem(root, TWIN_DESIRED_PROPERTIES);//Json object listing desired properties
102d1ea8:	e59f1300 	ldr	r1, [pc, #768]	; 102d21b0 <Process_Device_Twin_Properties+0x1070>
102d1eac:	e59d0008 	ldr	r0, [sp, #8]
102d1eb0:	e12fff35 	blx	r5
		reported = cJSON_GetObjectItem(root, TWIN_REPORTED_PROPERTIES);//Json object listing reported properties
102d1eb4:	e59f12f8 	ldr	r1, [pc, #760]	; 102d21b4 <Process_Device_Twin_Properties+0x1074>
	//Check if the message is for entire property list via GET message or is a change notification
	// A change notification will have version information in root jason..
	desired_obj = cJSON_GetObjectItem(root, TWIN_VERSION);//Json object listing desired properties
	if(desired_obj == NULL) // This is a GET response with entire set of desired and reported properties
	{
		desired = cJSON_GetObjectItem(root, TWIN_DESIRED_PROPERTIES);//Json object listing desired properties
102d1eb8:	e58d000c 	str	r0, [sp, #12]
		reported = cJSON_GetObjectItem(root, TWIN_REPORTED_PROPERTIES);//Json object listing reported properties
102d1ebc:	e59d0008 	ldr	r0, [sp, #8]
102d1ec0:	e12fff35 	blx	r5
		if((desired == NULL) && (reported == NULL)) // Jason is incorect
102d1ec4:	e59d200c 	ldr	r2, [sp, #12]
102d1ec8:	e3500000 	cmp	r0, #0
102d1ecc:	03520000 	cmpeq	r2, #0
102d1ed0:	e58d0004 	str	r0, [sp, #4]
102d1ed4:	0a000005 	beq	102d1ef0 <Process_Device_Twin_Properties+0xdb0>
		{
			return RET_FAIL;
		}
		desired_obj = cJSON_GetObjectItem(desired, TWIN_VERSION);
102d1ed8:	e59d000c 	ldr	r0, [sp, #12]
102d1edc:	e59f1218 	ldr	r1, [pc, #536]	; 102d20fc <Process_Device_Twin_Properties+0xfbc>
102d1ee0:	e12fff35 	blx	r5
	{
		FLAG.DP_CHANGE_NOTIFICATION_RECEIVED = TRUE;
	}
	//The Twin message contains desired and reported properties jason objects and extract that information now
	//1. Check the version of desired properties data set
	if(desired_obj == NULL) // Version information could not be retrived for desired properties.. do not bother about reported properties version
102d1ee4:	e2506000 	subs	r6, r0, #0
102d1ee8:	159f9210 	ldrne	r9, [pc, #528]	; 102d2100 <Process_Device_Twin_Properties+0xfc0>
102d1eec:	1afffca8 	bne	102d1194 <Process_Device_Twin_Properties+0x54>
	{
		desired = cJSON_GetObjectItem(root, TWIN_DESIRED_PROPERTIES);//Json object listing desired properties
		reported = cJSON_GetObjectItem(root, TWIN_REPORTED_PROPERTIES);//Json object listing reported properties
		if((desired == NULL) && (reported == NULL)) // Jason is incorect
		{
			return RET_FAIL;
102d1ef0:	e3e00000 	mvn	r0, #0
102d1ef4:	eaffff7b 	b	102d1ce8 <Process_Device_Twin_Properties+0xba8>
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_DPS_ID_SCOPE);
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_DpsIdScope));
102d1ef8:	e59f2238 	ldr	r2, [pc, #568]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d1efc:	e58d2000 	str	r2, [sp]
102d1f00:	e2821fe5 	add	r1, r2, #916	; 0x394
102d1f04:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d1f08:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d1f0c:	e35b0000 	cmp	fp, #0
102d1f10:	e59d2000 	ldr	r2, [sp]
102d1f14:	1afffe5a 	bne	102d1884 <Process_Device_Twin_Properties+0x744>
			APP_DEBUG("\n\r RP: %s -->  ",RP_DpsIdScope);
#endif
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
102d1f18:	e5d93025 	ldrb	r3, [r9, #37]	; 0x25
102d1f1c:	e3530000 	cmp	r3, #0
102d1f20:	1afffe70 	bne	102d18e8 <Process_Device_Twin_Properties+0x7a8>
			{
				Ql_strcpy(RP_DpsIdScope, AZURE_IoT_DPS_ID);
102d1f24:	e2820fe5 	add	r0, r2, #916	; 0x394
102d1f28:	e59f31f8 	ldr	r3, [pc, #504]	; 102d2128 <Process_Device_Twin_Properties+0xfe8>
102d1f2c:	e58d2000 	str	r2, [sp]
102d1f30:	e59f1270 	ldr	r1, [pc, #624]	; 102d21a8 <Process_Device_Twin_Properties+0x1068>
102d1f34:	e12fff33 	blx	r3
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DPS_ID_SCOPE;
102d1f38:	e59d2000 	ldr	r2, [sp]
102d1f3c:	e5923374 	ldr	r3, [r2, #884]	; 0x374
102d1f40:	e3833020 	orr	r3, r3, #32
102d1f44:	e5823374 	str	r3, [r2, #884]	; 0x374
102d1f48:	eafffe66 	b	102d18e8 <Process_Device_Twin_Properties+0x7a8>
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_VENDOR_CODE);

		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_vendorcode));
102d1f4c:	e59f11f0 	ldr	r1, [pc, #496]	; 102d2144 <Process_Device_Twin_Properties+0x1004>
102d1f50:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d1f54:	e35b0000 	cmp	fp, #0
102d1f58:	1afffd23 	bne	102d13ec <Process_Device_Twin_Properties+0x2ac>
			APP_DEBUG("\n\r RP: %s -->  ",RP_vendorcode);
#endif
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
102d1f5c:	e5d93025 	ldrb	r3, [r9, #37]	; 0x25
102d1f60:	e3530000 	cmp	r3, #0
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_VENDOR_CODE;
102d1f64:	059d2010 	ldreq	r2, [sp, #16]
102d1f68:	05923374 	ldreq	r3, [r2, #884]	; 0x374
102d1f6c:	03833002 	orreq	r3, r3, #2
102d1f70:	05823374 	streq	r3, [r2, #884]	; 0x374
102d1f74:	eafffd37 	b	102d1458 <Process_Device_Twin_Properties+0x318>
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_DEVICE_STATUS);
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_devicestatus));
102d1f78:	e59f11d4 	ldr	r1, [pc, #468]	; 102d2154 <Process_Device_Twin_Properties+0x1014>
102d1f7c:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d1f80:	e35b0000 	cmp	fp, #0
102d1f84:	1afffdac 	bne	102d163c <Process_Device_Twin_Properties+0x4fc>
			APP_DEBUG("\n\r RP: %s -->  ",RP_devicestatus);
#endif
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
102d1f88:	e5d93025 	ldrb	r3, [r9, #37]	; 0x25
102d1f8c:	e3530000 	cmp	r3, #0
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_STATUS;
102d1f90:	059d2010 	ldreq	r2, [sp, #16]
102d1f94:	05923374 	ldreq	r3, [r2, #884]	; 0x374
102d1f98:	03833008 	orreq	r3, r3, #8
102d1f9c:	05823374 	streq	r3, [r2, #884]	; 0x374
102d1fa0:	eafffdc0 	b	102d16a8 <Process_Device_Twin_Properties+0x568>
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_DEVICE_TYPE);
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_devicetype));
102d1fa4:	e59f11a0 	ldr	r1, [pc, #416]	; 102d214c <Process_Device_Twin_Properties+0x100c>
102d1fa8:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d1fac:	e35b0000 	cmp	fp, #0
102d1fb0:	1afffd57 	bne	102d1514 <Process_Device_Twin_Properties+0x3d4>
			APP_DEBUG("\n\r RP: %s -->  ",RP_devicetype);
#endif
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
102d1fb4:	e5d93025 	ldrb	r3, [r9, #37]	; 0x25
102d1fb8:	e3530000 	cmp	r3, #0
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_DEVICE_TYPE;
102d1fbc:	059d2010 	ldreq	r2, [sp, #16]
102d1fc0:	05923374 	ldreq	r3, [r2, #884]	; 0x374
102d1fc4:	03833004 	orreq	r3, r3, #4
102d1fc8:	05823374 	streq	r3, [r2, #884]	; 0x374
102d1fcc:	eafffd6b 	b	102d1580 <Process_Device_Twin_Properties+0x440>
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_IOT_HUB_NAME);
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_IotHubName));
102d1fd0:	e59f11e0 	ldr	r1, [pc, #480]	; 102d21b8 <Process_Device_Twin_Properties+0x1078>
102d1fd4:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d1fd8:	e35b0000 	cmp	fp, #0
102d1fdc:	1afffde0 	bne	102d1764 <Process_Device_Twin_Properties+0x624>
			APP_DEBUG("\n\r RP: %s -->  ",RP_IotHubName);
#endif
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
102d1fe0:	e5d93025 	ldrb	r3, [r9, #37]	; 0x25
102d1fe4:	e3530000 	cmp	r3, #0
102d1fe8:	1afffdf6 	bne	102d17c8 <Process_Device_Twin_Properties+0x688>
					{
						RP_IotHubName[i] = AZURE_assigned_IoT_Hub[i];
					}
					else
					{
						RP_IotHubName[i] = '\0'; // terminate the string
102d1fec:	e58d6014 	str	r6, [sp, #20]
102d1ff0:	e1a0600b 	mov	r6, fp
102d1ff4:	e59db010 	ldr	fp, [sp, #16]
102d1ff8:	ea000001 	b	102d2004 <Process_Device_Twin_Properties+0xec4>
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
			{
				for(i=0;i<Ql_strlen(AZURE_assigned_IoT_Hub);i++)
102d1ffc:	e2863001 	add	r3, r6, #1
102d2000:	e20360ff 	and	r6, r3, #255	; 0xff
102d2004:	e59f0194 	ldr	r0, [pc, #404]	; 102d21a0 <Process_Device_Twin_Properties+0x1060>
102d2008:	e12fff38 	blx	r8
				{
					if(AZURE_assigned_IoT_Hub[i] != '.')
					{
						RP_IotHubName[i] = AZURE_assigned_IoT_Hub[i];
102d200c:	e08b1006 	add	r1, fp, r6
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
			{
				for(i=0;i<Ql_strlen(AZURE_assigned_IoT_Hub);i++)
102d2010:	e1560000 	cmp	r6, r0
102d2014:	2a00000c 	bcs	102d204c <Process_Device_Twin_Properties+0xf0c>
				{
					if(AZURE_assigned_IoT_Hub[i] != '.')
102d2018:	e59f3180 	ldr	r3, [pc, #384]	; 102d21a0 <Process_Device_Twin_Properties+0x1060>
102d201c:	e7d32006 	ldrb	r2, [r3, r6]
102d2020:	e352002e 	cmp	r2, #46	; 0x2e
					{
						RP_IotHubName[i] = AZURE_assigned_IoT_Hub[i];
102d2024:	15c12378 	strbne	r2, [r1, #888]	; 0x378
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
			{
				for(i=0;i<Ql_strlen(AZURE_assigned_IoT_Hub);i++)
				{
					if(AZURE_assigned_IoT_Hub[i] != '.')
102d2028:	1afffff3 	bne	102d1ffc <Process_Device_Twin_Properties+0xebc>
					{
						RP_IotHubName[i] = AZURE_assigned_IoT_Hub[i];
					}
					else
					{
						RP_IotHubName[i] = '\0'; // terminate the string
102d202c:	e08b3006 	add	r3, fp, r6
102d2030:	e3a02000 	mov	r2, #0
102d2034:	e5c32378 	strb	r2, [r3, #888]	; 0x378
						i = Ql_strlen(AZURE_assigned_IoT_Hub); // go out of for loop
102d2038:	e59f0160 	ldr	r0, [pc, #352]	; 102d21a0 <Process_Device_Twin_Properties+0x1060>
102d203c:	e59f30d0 	ldr	r3, [pc, #208]	; 102d2114 <Process_Device_Twin_Properties+0xfd4>
102d2040:	e12fff33 	blx	r3
102d2044:	e20060ff 	and	r6, r0, #255	; 0xff
102d2048:	eaffffeb 	b	102d1ffc <Process_Device_Twin_Properties+0xebc>
					}
				}
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_IOT_HUB_NAME;
102d204c:	e59d2010 	ldr	r2, [sp, #16]
102d2050:	e59d6014 	ldr	r6, [sp, #20]
102d2054:	e5923374 	ldr	r3, [r2, #884]	; 0x374
102d2058:	e3833010 	orr	r3, r3, #16
102d205c:	e5823374 	str	r3, [r2, #884]	; 0x374
102d2060:	eafffdd8 	b	102d17c8 <Process_Device_Twin_Properties+0x688>
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_CNTRL_FW_FILE_VER);
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_CntrlFirmwareVersion));
102d2064:	e59f20cc 	ldr	r2, [pc, #204]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d2068:	e58d2000 	str	r2, [sp]
102d206c:	e2821ff5 	add	r1, r2, #980	; 0x3d4
102d2070:	e28d00b0 	add	r0, sp, #176	; 0xb0
102d2074:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d2078:	e35b0000 	cmp	fp, #0
102d207c:	e59d2000 	ldr	r2, [sp]
102d2080:	1afffe92 	bne	102d1ad0 <Process_Device_Twin_Properties+0x990>
			APP_DEBUG("\n\r RP: %s -->  ",RP_CntrlFirmwareVersion);
#endif
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
102d2084:	e5d93025 	ldrb	r3, [r9, #37]	; 0x25
102d2088:	e3530000 	cmp	r3, #0
102d208c:	1afffeaa 	bne	102d1b3c <Process_Device_Twin_Properties+0x9fc>
			{
				Ql_strcpy(RP_CntrlFirmwareVersion, FW_Version_STRING);
102d2090:	e2820ff5 	add	r0, r2, #980	; 0x3d4
102d2094:	e59f308c 	ldr	r3, [pc, #140]	; 102d2128 <Process_Device_Twin_Properties+0xfe8>
102d2098:	e58d2000 	str	r2, [sp]
102d209c:	e59f10ec 	ldr	r1, [pc, #236]	; 102d2190 <Process_Device_Twin_Properties+0x1050>
102d20a0:	e12fff33 	blx	r3
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTRL_FW_VER;
102d20a4:	e59d2000 	ldr	r2, [sp]
102d20a8:	e5923374 	ldr	r3, [r2, #884]	; 0x374
102d20ac:	e3833080 	orr	r3, r3, #128	; 0x80
102d20b0:	e5823374 	str	r3, [r2, #884]	; 0x374
102d20b4:	eafffea0 	b	102d1b3c <Process_Device_Twin_Properties+0x9fc>
#endif
			Ql_strcpy(Desired_Property_Data, desired_obj->valuestring);
		}
		//Check Reported Properties .. if found different .then process the required action
		reported_obj = cJSON_GetObjectItem(reported, TWIN_GEOLOCATION);
		Ql_strcpy(Reported_Property_Data, ((NULL != reported_obj) ? reported_obj->valuestring : RP_Geolocation));
102d20b8:	e59f1070 	ldr	r1, [pc, #112]	; 102d2130 <Process_Device_Twin_Properties+0xff0>
102d20bc:	e12fff36 	blx	r6

		if (NULL != desired_obj) //If desired property available
102d20c0:	e35b0000 	cmp	fp, #0
102d20c4:	1afffc7b 	bne	102d12b8 <Process_Device_Twin_Properties+0x178>
			APP_DEBUG("\n\r RP: %s -->  ",RP_Geolocation);
#endif
		}
		else if (NULL == reported_obj) // Desired properties not available and reported properties are also not available.. first time connect to device twin
		{
			if(FLAG.DP_CHANGE_NOTIFICATION_RECEIVED == FALSE)
102d20c8:	e5d93025 	ldrb	r3, [r9, #37]	; 0x25
102d20cc:	e3530000 	cmp	r3, #0
				Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_GEOLOCATION;
102d20d0:	059f2060 	ldreq	r2, [pc, #96]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d20d4:	159f305c 	ldrne	r3, [pc, #92]	; 102d2138 <Process_Device_Twin_Properties+0xff8>
102d20d8:	05923374 	ldreq	r3, [r2, #884]	; 0x374
102d20dc:	158d3010 	strne	r3, [sp, #16]
102d20e0:	03833001 	orreq	r3, r3, #1
102d20e4:	058d2010 	streq	r2, [sp, #16]
102d20e8:	05823374 	streq	r3, [r2, #884]	; 0x374
102d20ec:	eafffc8f 	b	102d1330 <Process_Device_Twin_Properties+0x1f0>
102d20f0:	102d6ec8 	.word	0x102d6ec8
102d20f4:	102d7750 	.word	0x102d7750
102d20f8:	102d7880 	.word	0x102d7880
102d20fc:	102eede4 	.word	0x102eede4
102d2100:	f03da5f0 	.word	0xf03da5f0
102d2104:	f03de540 	.word	0xf03de540
102d2108:	102e58f4 	.word	0x102e58f4
102d210c:	f03d57e4 	.word	0xf03d57e4
102d2110:	102eee04 	.word	0x102eee04
102d2114:	102e57a4 	.word	0x102e57a4
102d2118:	102e6230 	.word	0x102e6230
102d211c:	102edef4 	.word	0x102edef4
102d2120:	f03d5bc8 	.word	0xf03d5bc8
102d2124:	102eec5c 	.word	0x102eec5c
102d2128:	102e55fc 	.word	0x102e55fc
102d212c:	102eee30 	.word	0x102eee30
102d2130:	f03d2070 	.word	0xf03d2070
102d2134:	102e581c 	.word	0x102e581c
102d2138:	f03d572c 	.word	0xf03d572c
102d213c:	102eee44 	.word	0x102eee44
102d2140:	102eec68 	.word	0x102eec68
102d2144:	f03d2078 	.word	0xf03d2078
102d2148:	102eec74 	.word	0x102eec74
102d214c:	f03d2084 	.word	0xf03d2084
102d2150:	102eec80 	.word	0x102eec80
102d2154:	f03d2090 	.word	0xf03d2090
102d2158:	102eec90 	.word	0x102eec90
102d215c:	102eec9c 	.word	0x102eec9c
102d2160:	102eeca8 	.word	0x102eeca8
102d2164:	f03d5acc 	.word	0xf03d5acc
102d2168:	102eecc0 	.word	0x102eecc0
102d216c:	102eecd8 	.word	0x102eecd8
102d2170:	f03d5b0c 	.word	0xf03d5b0c
102d2174:	f03da598 	.word	0xf03da598
102d2178:	102eed08 	.word	0x102eed08
102d217c:	f03da924 	.word	0xf03da924
102d2180:	102eed10 	.word	0x102eed10
102d2184:	f03da908 	.word	0xf03da908
102d2188:	102eecec 	.word	0x102eecec
102d218c:	102eee6c 	.word	0x102eee6c
102d2190:	102eea40 	.word	0x102eea40
102d2194:	f03d5b00 	.word	0xf03d5b00
102d2198:	102df8a9 	.word	0x102df8a9
102d219c:	102eee54 	.word	0x102eee54
102d21a0:	f03d5e34 	.word	0xf03d5e34
102d21a4:	102d3988 	.word	0x102d3988
102d21a8:	f03d5e18 	.word	0xf03d5e18
102d21ac:	f03d6168 	.word	0xf03d6168
102d21b0:	102eedf0 	.word	0x102eedf0
102d21b4:	102eedf8 	.word	0x102eedf8
102d21b8:	f03d5aa4 	.word	0xf03d5aa4

102d21bc <MQTT_Packet_Process>:
 *		char *buffer_mqtt_packet : actual packet data.
 * Return	 Status
 *
 *****************************************************************/
void MQTT_Packet_Process(u8 ssid, char *buffer_mqtt_packet)
{
102d21bc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s32 ret = -1;

	char *buf_temp = (char *)Ql_MEM_Alloc(RECVD_DATA_LENGTH);
102d21c0:	e59f39e0 	ldr	r3, [pc, #2528]	; 102d2ba8 <MQTT_Packet_Process+0x9ec>
 *		char *buffer_mqtt_packet : actual packet data.
 * Return	 Status
 *
 *****************************************************************/
void MQTT_Packet_Process(u8 ssid, char *buffer_mqtt_packet)
{
102d21c4:	e24dd084 	sub	sp, sp, #132	; 0x84
102d21c8:	e1a07000 	mov	r7, r0
	s32 ret = -1;

	char *buf_temp = (char *)Ql_MEM_Alloc(RECVD_DATA_LENGTH);
102d21cc:	e59f09d8 	ldr	r0, [pc, #2520]	; 102d2bac <MQTT_Packet_Process+0x9f0>
 *		char *buffer_mqtt_packet : actual packet data.
 * Return	 Status
 *
 *****************************************************************/
void MQTT_Packet_Process(u8 ssid, char *buffer_mqtt_packet)
{
102d21d0:	e1a06001 	mov	r6, r1
	s32 ret = -1;

	char *buf_temp = (char *)Ql_MEM_Alloc(RECVD_DATA_LENGTH);
102d21d4:	e12fff33 	blx	r3

	g_recvd_data_last_read_pos = 0;
102d21d8:	e59f59d0 	ldr	r5, [pc, #2512]	; 102d2bb0 <MQTT_Packet_Process+0x9f4>
102d21dc:	e3a03000 	mov	r3, #0

	MQTTString receivedTopic;

	/* MQTT Read Packet ----------------------------------------------------------------------*/

	if(ssid == SSID_HOST_AZURE)
102d21e0:	e1570003 	cmp	r7, r3
{
	s32 ret = -1;

	char *buf_temp = (char *)Ql_MEM_Alloc(RECVD_DATA_LENGTH);

	g_recvd_data_last_read_pos = 0;
102d21e4:	e58534a4 	str	r3, [r5, #1188]	; 0x4a4
	cJSON *root = NULL;
	cJSON *tmp = NULL;
	cJSON *tmp_obj = NULL;
	float RCbalance_now =0;

	char cmd_Parameter[2] = {0};
102d21e8:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
	char Received_TS[50] = {0};
102d21ec:	e58d304c 	str	r3, [sp, #76]	; 0x4c
102d21f0:	e58d3050 	str	r3, [sp, #80]	; 0x50
102d21f4:	e58d3054 	str	r3, [sp, #84]	; 0x54
102d21f8:	e58d3058 	str	r3, [sp, #88]	; 0x58
102d21fc:	e58d305c 	str	r3, [sp, #92]	; 0x5c
102d2200:	e58d3060 	str	r3, [sp, #96]	; 0x60
102d2204:	e58d3064 	str	r3, [sp, #100]	; 0x64
102d2208:	e58d3068 	str	r3, [sp, #104]	; 0x68
102d220c:	e58d306c 	str	r3, [sp, #108]	; 0x6c
102d2210:	e58d3070 	str	r3, [sp, #112]	; 0x70
102d2214:	e58d3074 	str	r3, [sp, #116]	; 0x74
102d2218:	e58d3078 	str	r3, [sp, #120]	; 0x78
102d221c:	e1cd37bc 	strh	r3, [sp, #124]	; 0x7c
 *****************************************************************/
void MQTT_Packet_Process(u8 ssid, char *buffer_mqtt_packet)
{
	s32 ret = -1;

	char *buf_temp = (char *)Ql_MEM_Alloc(RECVD_DATA_LENGTH);
102d2220:	e1a04000 	mov	r4, r0

	MQTTString receivedTopic;

	/* MQTT Read Packet ----------------------------------------------------------------------*/

	if(ssid == SSID_HOST_AZURE)
102d2224:	0a00000d 	beq	102d2260 <MQTT_Packet_Process+0xa4>
102d2228:	e59f8984 	ldr	r8, [pc, #2436]	; 102d2bb4 <MQTT_Packet_Process+0x9f8>

		default	:
			break;
		}
	}
	Ql_memset(buffer_mqtt_packet,0x0,RECVD_DATA_LENGTH);
102d222c:	e1a00006 	mov	r0, r6
102d2230:	e3a01000 	mov	r1, #0
102d2234:	e59f2970 	ldr	r2, [pc, #2416]	; 102d2bac <MQTT_Packet_Process+0x9f0>
102d2238:	e12fff38 	blx	r8
	Ql_memset(buf_temp,0x0,RECVD_DATA_LENGTH);
102d223c:	e1a00004 	mov	r0, r4
102d2240:	e3a01000 	mov	r1, #0
102d2244:	e59f2960 	ldr	r2, [pc, #2400]	; 102d2bac <MQTT_Packet_Process+0x9f0>
102d2248:	e12fff38 	blx	r8
	Ql_MEM_Free(buf_temp);
102d224c:	e1a00004 	mov	r0, r4
102d2250:	e59f3960 	ldr	r3, [pc, #2400]	; 102d2bb8 <MQTT_Packet_Process+0x9fc>
102d2254:	e12fff33 	blx	r3

	buf_temp = NULL;
}
102d2258:	e28dd084 	add	sp, sp, #132	; 0x84
102d225c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

	/* MQTT Read Packet ----------------------------------------------------------------------*/

	if(ssid == SSID_HOST_AZURE)
	{
		ret = MQTTPacket_read((unsigned char *)buf_temp, buflen, TCP_Socket_Read_Data_SSL);
102d2260:	e59f8954 	ldr	r8, [pc, #2388]	; 102d2bbc <MQTT_Packet_Process+0xa00>
102d2264:	e59f2954 	ldr	r2, [pc, #2388]	; 102d2bc0 <MQTT_Packet_Process+0xa04>
102d2268:	e5981000 	ldr	r1, [r8]
102d226c:	e59f3950 	ldr	r3, [pc, #2384]	; 102d2bc4 <MQTT_Packet_Process+0xa08>
102d2270:	e12fff33 	blx	r3
		else
		{
			APP_DEBUG("%s , MQTT packet type : %d\r\n",buf_temp, ret);
		}
#endif
		switch(ret)
102d2274:	e3500003 	cmp	r0, #3
102d2278:	0a000027 	beq	102d231c <MQTT_Packet_Process+0x160>
102d227c:	e3500009 	cmp	r0, #9
102d2280:	0a00000f 	beq	102d22c4 <MQTT_Packet_Process+0x108>
102d2284:	e3500002 	cmp	r0, #2
102d2288:	1affffe6 	bne	102d2228 <MQTT_Packet_Process+0x6c>
		{
		case CONNACK ://MQTT connection ACK
		{
			if(ssid == SSID_HOST_AZURE)
			{
				if (MQTTDeserialize_connack(&sessionPresent, &connack_rc, (unsigned char *)buffer_mqtt_packet, buflen) != 1 || connack_rc != 0)
102d228c:	e28d0020 	add	r0, sp, #32
102d2290:	e28d1021 	add	r1, sp, #33	; 0x21
102d2294:	e1a02006 	mov	r2, r6
102d2298:	e5983000 	ldr	r3, [r8]
102d229c:	e59fc924 	ldr	ip, [pc, #2340]	; 102d2bc8 <MQTT_Packet_Process+0xa0c>
102d22a0:	e12fff3c 	blx	ip
102d22a4:	e3500001 	cmp	r0, #1
102d22a8:	1affffde 	bne	102d2228 <MQTT_Packet_Process+0x6c>
102d22ac:	e5dd0021 	ldrb	r0, [sp, #33]	; 0x21
102d22b0:	e3500000 	cmp	r0, #0
102d22b4:	1affffdb 	bne	102d2228 <MQTT_Packet_Process+0x6c>
#endif
				}
				else
				{
					//MQTT connect ack received.. now Subcribe for topic IoT Hub device messages all
					MQTT_Send_SUB_Request(ssid, SUB_IOTHUB_TOPIC_ALL);
102d22b8:	e1a01000 	mov	r1, r0
102d22bc:	ebfff0e5 	bl	102ce658 <MQTT_Send_SUB_Request>
102d22c0:	eaffffd8 	b	102d2228 <MQTT_Packet_Process+0x6c>

		case SUBACK: //Subscribe ACK
		{
			if(ssid == SSID_HOST_AZURE)
			{
				MQTTDeserialize_suback(&submsgid,1,&subcount,&granted_qos,(unsigned char *)buffer_mqtt_packet,buflen);
102d22c4:	e5983000 	ldr	r3, [r8]
102d22c8:	e58d3004 	str	r3, [sp, #4]
102d22cc:	e58d6000 	str	r6, [sp]
102d22d0:	e28d3030 	add	r3, sp, #48	; 0x30
102d22d4:	e28d0028 	add	r0, sp, #40	; 0x28
102d22d8:	e3a01001 	mov	r1, #1
102d22dc:	e28d202c 	add	r2, sp, #44	; 0x2c
102d22e0:	e59fc8e4 	ldr	ip, [pc, #2276]	; 102d2bcc <MQTT_Packet_Process+0xa10>
102d22e4:	e12fff3c 	blx	ip

				if(submsgid == 1)// IoT HuB Message Topic Subscribe ACK
102d22e8:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
102d22ec:	e3530001 	cmp	r3, #1
102d22f0:	0a0000d8 	beq	102d2658 <MQTT_Packet_Process+0x49c>
					FLAG.MQTT_CONNECTION_STATUS = TRUE;
					PUBLISH_RESPONSE_REQ_source |=SCHEDULE_PUBLISH_CONNECTIVITY_ON;
					//Subscribe IoT Hub Message Topic ACK received.. now Subcribe device twin desired parameter update topic
					MQTT_Send_SUB_Request(ssid, SUB_DEVICE_TWIN_DESIRED_TOPIC);
				}
				else if(submsgid == 2)// IoT HuB Device twin desired topic Subscribe ACK
102d22f4:	e3530002 	cmp	r3, #2
102d22f8:	0a0000e1 	beq	102d2684 <MQTT_Packet_Process+0x4c8>
					APP_DEBUG("\n\r SUBACK:  Device Twin Desired Topic, Granted qos: %d \n\r", granted_qos);
#endif
					//Subscribe IoT Hub Message Topic ACK received.. now Subcribe device twin desired parameter update topic
					MQTT_Send_SUB_Request(ssid, SUB_DEVICETWIN_TOPIC);
				}
				else if(submsgid == 3)// IoT HuB Device twin Topic Subscribe ACK
102d22fc:	e3530003 	cmp	r3, #3
102d2300:	1affffc8 	bne	102d2228 <MQTT_Packet_Process+0x6c>
				{
#ifdef DEBUG_MQTT
					APP_DEBUG("\n\r SUBACK: Device Twin Topic, Granted qos: %d \n\r", granted_qos);
#endif
					//Publish an empty message to get the entire set of device twin desired and reported properties data
					PUBLISH_RESPONSE_REQ_source |=SCHEDULE_DEVICE_TWIN_GET_MESSAGE;
102d2304:	e59f38c4 	ldr	r3, [pc, #2244]	; 102d2bd0 <MQTT_Packet_Process+0xa14>
102d2308:	e59f88a4 	ldr	r8, [pc, #2212]	; 102d2bb4 <MQTT_Packet_Process+0x9f8>
102d230c:	e5932000 	ldr	r2, [r3]
102d2310:	e3822802 	orr	r2, r2, #131072	; 0x20000
102d2314:	e5832000 	str	r2, [r3]
102d2318:	eaffffc3 	b	102d222c <MQTT_Packet_Process+0x70>

		case PUBLISH : // Publish
		{
			if(ssid == SSID_HOST_AZURE )
			{
				MQTTDeserialize_publish(&dup, &qos, &retained, &msgid, &receivedTopic, &payload_in, &payloadlen_in, (unsigned char *)buffer_mqtt_packet, buflen);
102d231c:	e28dc040 	add	ip, sp, #64	; 0x40
102d2320:	e5980000 	ldr	r0, [r8]
102d2324:	e58dc000 	str	ip, [sp]
102d2328:	e28dc03c 	add	ip, sp, #60	; 0x3c
102d232c:	e58dc004 	str	ip, [sp, #4]
102d2330:	e28dc038 	add	ip, sp, #56	; 0x38
102d2334:	e28d1034 	add	r1, sp, #52	; 0x34
102d2338:	e28d2023 	add	r2, sp, #35	; 0x23
102d233c:	e28d302a 	add	r3, sp, #42	; 0x2a
102d2340:	e58dc008 	str	ip, [sp, #8]
102d2344:	e58d0010 	str	r0, [sp, #16]
102d2348:	e59fc884 	ldr	ip, [pc, #2180]	; 102d2bd4 <MQTT_Packet_Process+0xa18>
102d234c:	e58d600c 	str	r6, [sp, #12]
102d2350:	e28d0022 	add	r0, sp, #34	; 0x22
102d2354:	e12fff3c 	blx	ip

				tempstring = Ql_strstr(receivedTopic.lenstring.data, "/messages/devicebound");// A received topic will contain this string non twin messages only
102d2358:	e59f8878 	ldr	r8, [pc, #2168]	; 102d2bd8 <MQTT_Packet_Process+0xa1c>
102d235c:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
102d2360:	e59f1874 	ldr	r1, [pc, #2164]	; 102d2bdc <MQTT_Packet_Process+0xa20>
102d2364:	e12fff38 	blx	r8
				if(tempstring !=NULL)
102d2368:	e250a000 	subs	sl, r0, #0
102d236c:	0a00009a 	beq	102d25dc <MQTT_Packet_Process+0x420>
				{
#ifdef DEBUG_MSG
					APP_DEBUG("\r\n\n<--***AZURE_IOTHUB MESSAGE RECEIVED ***-->\r\n");
102d2370:	e59fb868 	ldr	fp, [pc, #2152]	; 102d2be0 <MQTT_Packet_Process+0xa24>
102d2374:	e3a02c02 	mov	r2, #512	; 0x200
102d2378:	e1a01007 	mov	r1, r7
102d237c:	e28500b8 	add	r0, r5, #184	; 0xb8
102d2380:	e59f882c 	ldr	r8, [pc, #2092]	; 102d2bb4 <MQTT_Packet_Process+0x9f8>
102d2384:	e12fff38 	blx	r8
102d2388:	e59b3000 	ldr	r3, [fp]
102d238c:	e59f1850 	ldr	r1, [pc, #2128]	; 102d2be4 <MQTT_Packet_Process+0xa28>
102d2390:	e28500b8 	add	r0, r5, #184	; 0xb8
102d2394:	e12fff33 	blx	r3
102d2398:	e59fa848 	ldr	sl, [pc, #2120]	; 102d2be8 <MQTT_Packet_Process+0xa2c>
102d239c:	e28500b8 	add	r0, r5, #184	; 0xb8
102d23a0:	e12fff3a 	blx	sl
102d23a4:	e59f9840 	ldr	r9, [pc, #2112]	; 102d2bec <MQTT_Packet_Process+0xa30>
102d23a8:	e28510b8 	add	r1, r5, #184	; 0xb8
102d23ac:	e1a02000 	mov	r2, r0
102d23b0:	e3a0000a 	mov	r0, #10
102d23b4:	e12fff39 	blx	r9
#endif

					cJSON_InitHooks(NULL); //init function pointers to Ql_MEM_Alloc calloc realloc
102d23b8:	e1a00007 	mov	r0, r7
102d23bc:	e59f382c 	ldr	r3, [pc, #2092]	; 102d2bf0 <MQTT_Packet_Process+0xa34>
102d23c0:	e12fff33 	blx	r3
					root = cJSON_Parse((const char *)payload_in);
102d23c4:	e59f3828 	ldr	r3, [pc, #2088]	; 102d2bf4 <MQTT_Packet_Process+0xa38>
102d23c8:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
102d23cc:	e12fff33 	blx	r3
					tmp = cJSON_GetObjectItem(root, "d");
102d23d0:	e59f7820 	ldr	r7, [pc, #2080]	; 102d2bf8 <MQTT_Packet_Process+0xa3c>
102d23d4:	e59f1820 	ldr	r1, [pc, #2080]	; 102d2bfc <MQTT_Packet_Process+0xa40>
102d23d8:	e12fff37 	blx	r7

					//1. Check if RESET command is received in the MQTT payload.
					tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RESET);
102d23dc:	e59f181c 	ldr	r1, [pc, #2076]	; 102d2c00 <MQTT_Packet_Process+0xa44>
					APP_DEBUG("\r\n\n<--***AZURE_IOTHUB MESSAGE RECEIVED ***-->\r\n");
#endif

					cJSON_InitHooks(NULL); //init function pointers to Ql_MEM_Alloc calloc realloc
					root = cJSON_Parse((const char *)payload_in);
					tmp = cJSON_GetObjectItem(root, "d");
102d23e0:	e58d001c 	str	r0, [sp, #28]

					//1. Check if RESET command is received in the MQTT payload.
					tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RESET);
102d23e4:	e12fff37 	blx	r7
					if(NULL != tmp_obj)
102d23e8:	e250c000 	subs	ip, r0, #0
102d23ec:	0a000045 	beq	102d2508 <MQTT_Packet_Process+0x34c>
					{
						Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
102d23f0:	e59c1010 	ldr	r1, [ip, #16]
102d23f4:	e59f9808 	ldr	r9, [pc, #2056]	; 102d2c04 <MQTT_Packet_Process+0xa48>
102d23f8:	e28d0024 	add	r0, sp, #36	; 0x24
102d23fc:	e12fff39 	blx	r9
#ifdef DEBUG_MQTT
						APP_DEBUG("RST = %s\r\n", cmd_Parameter);
#endif
						tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_TS);
102d2400:	e59f1800 	ldr	r1, [pc, #2048]	; 102d2c08 <MQTT_Packet_Process+0xa4c>
102d2404:	e59d001c 	ldr	r0, [sp, #28]
102d2408:	e12fff37 	blx	r7
						Ql_strcpy(Received_TS,tmp_obj->valuestring);
102d240c:	e5901010 	ldr	r1, [r0, #16]
102d2410:	e28d004c 	add	r0, sp, #76	; 0x4c
102d2414:	e12fff39 	blx	r9

						if(Ql_strncmp(cmd_Parameter,"1",Ql_strlen("1"))==0)
102d2418:	e59f07ec 	ldr	r0, [pc, #2028]	; 102d2c0c <MQTT_Packet_Process+0xa50>
102d241c:	e12fff3a 	blx	sl
102d2420:	e59f17e4 	ldr	r1, [pc, #2020]	; 102d2c0c <MQTT_Packet_Process+0xa50>
102d2424:	e59f37e4 	ldr	r3, [pc, #2020]	; 102d2c10 <MQTT_Packet_Process+0xa54>
102d2428:	e1a02000 	mov	r2, r0
102d242c:	e28d0024 	add	r0, sp, #36	; 0x24
102d2430:	e12fff33 	blx	r3
102d2434:	e3500000 	cmp	r0, #0
102d2438:	1affff7b 	bne	102d222c <MQTT_Packet_Process+0x70>
						{
							// ---------------Set up the language
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_LANGUAGE_ID);
102d243c:	e59f17d0 	ldr	r1, [pc, #2000]	; 102d2c14 <MQTT_Packet_Process+0xa58>
102d2440:	e59d001c 	ldr	r0, [sp, #28]
102d2444:	e12fff37 	blx	r7
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
#ifdef DEBUG_MQTT
							APP_DEBUG("LANGUAGE = %s\r\n", cmd_Parameter);
#endif
							Last_language_index = language_index;
102d2448:	e59fb7c8 	ldr	fp, [pc, #1992]	; 102d2c18 <MQTT_Packet_Process+0xa5c>
102d244c:	e59fa7c8 	ldr	sl, [pc, #1992]	; 102d2c1c <MQTT_Packet_Process+0xa60>

						if(Ql_strncmp(cmd_Parameter,"1",Ql_strlen("1"))==0)
						{
							// ---------------Set up the language
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_LANGUAGE_ID);
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
102d2450:	e5901010 	ldr	r1, [r0, #16]
102d2454:	e28d0024 	add	r0, sp, #36	; 0x24
102d2458:	e12fff39 	blx	r9
#ifdef DEBUG_MQTT
							APP_DEBUG("LANGUAGE = %s\r\n", cmd_Parameter);
#endif
							Last_language_index = language_index;
102d245c:	e59b2000 	ldr	r2, [fp]
							language_index = Ql_atoi((const char *)cmd_Parameter);
102d2460:	e28d0024 	add	r0, sp, #36	; 0x24
102d2464:	e59f37b4 	ldr	r3, [pc, #1972]	; 102d2c20 <MQTT_Packet_Process+0xa64>
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_LANGUAGE_ID);
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
#ifdef DEBUG_MQTT
							APP_DEBUG("LANGUAGE = %s\r\n", cmd_Parameter);
#endif
							Last_language_index = language_index;
102d2468:	e58a2000 	str	r2, [sl]
							language_index = Ql_atoi((const char *)cmd_Parameter);
102d246c:	e12fff33 	blx	r3
							if(language_index < LANGUAGES_SUPPORTED)
102d2470:	e3500001 	cmp	r0, #1
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
#ifdef DEBUG_MQTT
							APP_DEBUG("LANGUAGE = %s\r\n", cmd_Parameter);
#endif
							Last_language_index = language_index;
							language_index = Ql_atoi((const char *)cmd_Parameter);
102d2474:	e58b0000 	str	r0, [fp]
							if(language_index < LANGUAGES_SUPPORTED)
102d2478:	da00008b 	ble	102d26ac <MQTT_Packet_Process+0x4f0>
							{
								repaint_water_balance_screen();
							}
							else
							{
								language_index = Last_language_index;
102d247c:	e59a2000 	ldr	r2, [sl]
102d2480:	e58b2000 	str	r2, [fp]
							}

							// ---------------Set up the water measurement unit
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_WATERUNIT_ID);
102d2484:	e59f1798 	ldr	r1, [pc, #1944]	; 102d2c24 <MQTT_Packet_Process+0xa68>
102d2488:	e59d001c 	ldr	r0, [sp, #28]
102d248c:	e12fff37 	blx	r7
#endif

							Water_Unit_index_set = Ql_atoi((const char *)cmd_Parameter);
							if(Water_Unit_index_set < WATER_UNIT_SUPPORTED)
							{
								IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_UNIT_CMD; // Schedule IPC command towards Control Module
102d2490:	e59fa790 	ldr	sl, [pc, #1936]	; 102d2c28 <MQTT_Packet_Process+0xa6c>
								language_index = Last_language_index;
							}

							// ---------------Set up the water measurement unit
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_WATERUNIT_ID);
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
102d2494:	e5901010 	ldr	r1, [r0, #16]
102d2498:	e28d0024 	add	r0, sp, #36	; 0x24
102d249c:	e12fff39 	blx	r9
#ifdef DEBUG_MQTT
							APP_DEBUG("WATER UNIT = %s\r\n", cmd_Parameter);
#endif

							Water_Unit_index_set = Ql_atoi((const char *)cmd_Parameter);
102d24a0:	e59f3778 	ldr	r3, [pc, #1912]	; 102d2c20 <MQTT_Packet_Process+0xa64>
102d24a4:	e28d0024 	add	r0, sp, #36	; 0x24
102d24a8:	e12fff33 	blx	r3
							if(Water_Unit_index_set < WATER_UNIT_SUPPORTED)
							{
								IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_UNIT_CMD; // Schedule IPC command towards Control Module
							}

							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RC_TS);
102d24ac:	e59f1778 	ldr	r1, [pc, #1912]	; 102d2c2c <MQTT_Packet_Process+0xa70>
#ifdef DEBUG_MQTT
							APP_DEBUG("WATER UNIT = %s\r\n", cmd_Parameter);
#endif

							Water_Unit_index_set = Ql_atoi((const char *)cmd_Parameter);
							if(Water_Unit_index_set < WATER_UNIT_SUPPORTED)
102d24b0:	e3500002 	cmp	r0, #2
							{
								IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_UNIT_CMD; // Schedule IPC command towards Control Module
102d24b4:	d59a3000 	ldrle	r3, [sl]
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
#ifdef DEBUG_MQTT
							APP_DEBUG("WATER UNIT = %s\r\n", cmd_Parameter);
#endif

							Water_Unit_index_set = Ql_atoi((const char *)cmd_Parameter);
102d24b8:	e58504a8 	str	r0, [r5, #1192]	; 0x4a8
							if(Water_Unit_index_set < WATER_UNIT_SUPPORTED)
							{
								IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_UNIT_CMD; // Schedule IPC command towards Control Module
102d24bc:	d3833b02 	orrle	r3, r3, #2048	; 0x800
							}

							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RC_TS);
102d24c0:	e59d001c 	ldr	r0, [sp, #28]
#endif

							Water_Unit_index_set = Ql_atoi((const char *)cmd_Parameter);
							if(Water_Unit_index_set < WATER_UNIT_SUPPORTED)
							{
								IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_UNIT_CMD; // Schedule IPC command towards Control Module
102d24c4:	d58a3000 	strle	r3, [sl]
							}

							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RC_TS);
102d24c8:	e12fff37 	blx	r7
							Ql_strcpy(RCTS,tmp_obj->valuestring);
102d24cc:	e5901010 	ldr	r1, [r0, #16]
102d24d0:	e59f0758 	ldr	r0, [pc, #1880]	; 102d2c30 <MQTT_Packet_Process+0xa74>
102d24d4:	e12fff39 	blx	r9
#endif
							//Reset all persistent parameters, reset water balance to zero, and configure language and water unit, then do a soft reset to restart

							Water_Unit_index_get = Water_Unit_index_set;
							rechargebalance = 0;
							IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102d24d8:	e59a3000 	ldr	r3, [sl]
#ifdef DEBUG_MQTT
							APP_DEBUG("\r\n--> Resetting the water balance and configuring Language and water unit ..Please Wait...\r\n\n");
#endif
							//Reset all persistent parameters, reset water balance to zero, and configure language and water unit, then do a soft reset to restart

							Water_Unit_index_get = Water_Unit_index_set;
102d24dc:	e59f2750 	ldr	r2, [pc, #1872]	; 102d2c34 <MQTT_Packet_Process+0xa78>
							rechargebalance = 0;
							IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102d24e0:	e3833020 	orr	r3, r3, #32
#ifdef DEBUG_MQTT
							APP_DEBUG("\r\n--> Resetting the water balance and configuring Language and water unit ..Please Wait...\r\n\n");
#endif
							//Reset all persistent parameters, reset water balance to zero, and configure language and water unit, then do a soft reset to restart

							Water_Unit_index_get = Water_Unit_index_set;
102d24e4:	e59514a8 	ldr	r1, [r5, #1192]	; 0x4a8
102d24e8:	e5821000 	str	r1, [r2]
							rechargebalance = 0;
							IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102d24ec:	e58a3000 	str	r3, [sl]
							APP_DEBUG("\r\n--> Resetting the water balance and configuring Language and water unit ..Please Wait...\r\n\n");
#endif
							//Reset all persistent parameters, reset water balance to zero, and configure language and water unit, then do a soft reset to restart

							Water_Unit_index_get = Water_Unit_index_set;
							rechargebalance = 0;
102d24f0:	e3a02000 	mov	r2, #0
							IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
							FLAG.DEVICE_RESET_SCHEDULED = TRUE;
102d24f4:	e59f373c 	ldr	r3, [pc, #1852]	; 102d2c38 <MQTT_Packet_Process+0xa7c>
							APP_DEBUG("\r\n--> Resetting the water balance and configuring Language and water unit ..Please Wait...\r\n\n");
#endif
							//Reset all persistent parameters, reset water balance to zero, and configure language and water unit, then do a soft reset to restart

							Water_Unit_index_get = Water_Unit_index_set;
							rechargebalance = 0;
102d24f8:	e58524ac 	str	r2, [r5, #1196]	; 0x4ac
							IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
							FLAG.DEVICE_RESET_SCHEDULED = TRUE;
102d24fc:	e3a02001 	mov	r2, #1
102d2500:	e5c32011 	strb	r2, [r3, #17]
102d2504:	eaffff48 	b	102d222c <MQTT_Packet_Process+0x70>
					}

					//2. Check if RECHARGE command is received in the MQTT payload.
					if(NULL == tmp_obj)
					{
						tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RECHARGE);
102d2508:	e58dc018 	str	ip, [sp, #24]
102d250c:	e59d001c 	ldr	r0, [sp, #28]
102d2510:	e59f1724 	ldr	r1, [pc, #1828]	; 102d2c3c <MQTT_Packet_Process+0xa80>
102d2514:	e12fff37 	blx	r7
						if(NULL != tmp_obj)
102d2518:	e59dc018 	ldr	ip, [sp, #24]
102d251c:	e3500000 	cmp	r0, #0
102d2520:	0a000082 	beq	102d2730 <MQTT_Packet_Process+0x574>
						{
							Ql_strcpy(rcbal,tmp_obj->valuestring);
102d2524:	e5901010 	ldr	r1, [r0, #16]
102d2528:	e59f96d4 	ldr	r9, [pc, #1748]	; 102d2c04 <MQTT_Packet_Process+0xa48>
102d252c:	e58dc018 	str	ip, [sp, #24]
102d2530:	e2850e4b 	add	r0, r5, #1200	; 0x4b0
102d2534:	e12fff39 	blx	r9

							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RC_ID);
102d2538:	e59f1700 	ldr	r1, [pc, #1792]	; 102d2c40 <MQTT_Packet_Process+0xa84>
102d253c:	e59d001c 	ldr	r0, [sp, #28]
102d2540:	e12fff37 	blx	r7
							Ql_strcpy(RCID,tmp_obj->valuestring);
102d2544:	e5901010 	ldr	r1, [r0, #16]
102d2548:	e2850fce 	add	r0, r5, #824	; 0x338
102d254c:	e12fff39 	blx	r9

							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RC_TS);
102d2550:	e59f16d4 	ldr	r1, [pc, #1748]	; 102d2c2c <MQTT_Packet_Process+0xa70>
102d2554:	e59d001c 	ldr	r0, [sp, #28]
102d2558:	e12fff37 	blx	r7
							Ql_strcpy(RCTS,tmp_obj->valuestring);
102d255c:	e5901010 	ldr	r1, [r0, #16]
102d2560:	e2850fd5 	add	r0, r5, #852	; 0x354
102d2564:	e12fff39 	blx	r9
							APP_DEBUG("RC_BAL = %s \r\n", rcbal);
							APP_DEBUG("RC_ID = %s\r\n", RCID);
							APP_DEBUG("RC_TS = %s\r\n", RCTS);
#endif
							//recharge balance into integer
							if(rcbal[0] == '-') // Negative recharge
102d2568:	e5d534b0 	ldrb	r3, [r5, #1200]	; 0x4b0
102d256c:	e353002d 	cmp	r3, #45	; 0x2d
102d2570:	0a00014e 	beq	102d2ab0 <MQTT_Packet_Process+0x8f4>
								}

							}
							else // Positive recharge
							{
								if(rcbal[0] == '+')
102d2574:	e353002b 	cmp	r3, #43	; 0x2b
								{
									RCbalance_now = Ql_atof((const char *)rcbal[1]); // ignore positive sign if available
102d2578:	05d504b1 	ldrbeq	r0, [r5, #1201]	; 0x4b1
								}
								else
								{
									RCbalance_now = Ql_atof((const char *)rcbal);
102d257c:	12850e4b 	addne	r0, r5, #1200	; 0x4b0
102d2580:	e59f36bc 	ldr	r3, [pc, #1724]	; 102d2c44 <MQTT_Packet_Process+0xa88>
102d2584:	e12fff33 	blx	r3
102d2588:	e59f36b8 	ldr	r3, [pc, #1720]	; 102d2c48 <MQTT_Packet_Process+0xa8c>
102d258c:	e12fff33 	blx	r3
								}
								rechargebalance = RCbalance_now * 10; // to make received recharge in unit of 100 ml that is required by control module
102d2590:	e59f16b4 	ldr	r1, [pc, #1716]	; 102d2c4c <MQTT_Packet_Process+0xa90>
102d2594:	e59f36b4 	ldr	r3, [pc, #1716]	; 102d2c50 <MQTT_Packet_Process+0xa94>
102d2598:	e12fff33 	blx	r3
102d259c:	e59f36b0 	ldr	r3, [pc, #1712]	; 102d2c54 <MQTT_Packet_Process+0xa98>
102d25a0:	e12fff33 	blx	r3
102d25a4:	e59f7604 	ldr	r7, [pc, #1540]	; 102d2bb0 <MQTT_Packet_Process+0x9f4>
								if(rechargebalance == 0) // Do not attempt any actual recharge.. simply ack as success
102d25a8:	e3500000 	cmp	r0, #0
								}
								else
								{
									RCbalance_now = Ql_atof((const char *)rcbal);
								}
								rechargebalance = RCbalance_now * 10; // to make received recharge in unit of 100 ml that is required by control module
102d25ac:	e58504ac 	str	r0, [r5, #1196]	; 0x4ac
								if(rechargebalance == 0) // Do not attempt any actual recharge.. simply ack as success
102d25b0:	0a000115 	beq	102d2a0c <MQTT_Packet_Process+0x850>
									Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_RC_OK);
									Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_WATER_BALANCE); // Send updated water balance to cloud
								}
								else
								{
									if((water_balance) + (rechargebalance) <= MAX_ALLOWED_WATER_BALANCE)
102d25b4:	e59734c8 	ldr	r3, [r7, #1224]	; 0x4c8
102d25b8:	e0800003 	add	r0, r0, r3
102d25bc:	e59f3694 	ldr	r3, [pc, #1684]	; 102d2c58 <MQTT_Packet_Process+0xa9c>
102d25c0:	e1500003 	cmp	r0, r3
102d25c4:	8a00012b 	bhi	102d2a78 <MQTT_Packet_Process+0x8bc>
									{
										IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102d25c8:	e59f3658 	ldr	r3, [pc, #1624]	; 102d2c28 <MQTT_Packet_Process+0xa6c>
102d25cc:	e5932000 	ldr	r2, [r3]
102d25d0:	e3822002 	orr	r2, r2, #2
102d25d4:	e5832000 	str	r2, [r3]
102d25d8:	eaffff13 	b	102d222c <MQTT_Packet_Process+0x70>

				}
				else // Check if messageis for device twin properties..
				{
					// A received topic will contain topic string "$iothub/twin/res/200/?$rid=0" for entire Device Twin properties response
					tempstring = Ql_strstr(receivedTopic.lenstring.data, "$iothub/twin/res/200/?$rid=0");
102d25dc:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
102d25e0:	e59f1674 	ldr	r1, [pc, #1652]	; 102d2c5c <MQTT_Packet_Process+0xaa0>
102d25e4:	e12fff38 	blx	r8
					if(tempstring !=NULL) // Device twin response received with success status /200/ and message ID 0
102d25e8:	e2507000 	subs	r7, r0, #0
102d25ec:	0a000031 	beq	102d26b8 <MQTT_Packet_Process+0x4fc>
					{
#ifdef DEBUG_MSG
						APP_DEBUG("\r\n<--*** Device twin list received ***-->\r\n");
102d25f0:	e3a02c02 	mov	r2, #512	; 0x200
102d25f4:	e1a0100a 	mov	r1, sl
102d25f8:	e28500b8 	add	r0, r5, #184	; 0xb8
102d25fc:	e59f85b0 	ldr	r8, [pc, #1456]	; 102d2bb4 <MQTT_Packet_Process+0x9f8>
102d2600:	e12fff38 	blx	r8
102d2604:	e59f35d4 	ldr	r3, [pc, #1492]	; 102d2be0 <MQTT_Packet_Process+0xa24>
102d2608:	e59f1650 	ldr	r1, [pc, #1616]	; 102d2c60 <MQTT_Packet_Process+0xaa4>
102d260c:	e5933000 	ldr	r3, [r3]
102d2610:	e28500b8 	add	r0, r5, #184	; 0xb8
102d2614:	e12fff33 	blx	r3
102d2618:	e59f35c8 	ldr	r3, [pc, #1480]	; 102d2be8 <MQTT_Packet_Process+0xa2c>
102d261c:	e28500b8 	add	r0, r5, #184	; 0xb8
102d2620:	e12fff33 	blx	r3
102d2624:	e28510b8 	add	r1, r5, #184	; 0xb8
102d2628:	e59f35bc 	ldr	r3, [pc, #1468]	; 102d2bec <MQTT_Packet_Process+0xa30>
102d262c:	e1a02000 	mov	r2, r0
102d2630:	e3a0000a 	mov	r0, #10
102d2634:	e12fff33 	blx	r3
#endif
						if(Process_Device_Twin_Properties(payload_in) == RET_FAIL)
102d2638:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
102d263c:	ebfffabf 	bl	102d1140 <Process_Device_Twin_Properties>
102d2640:	e3700001 	cmn	r0, #1
102d2644:	0a000013 	beq	102d2698 <MQTT_Packet_Process+0x4dc>
							PUBLISH_RESPONSE_REQ_source |= SCHEDULE_DEVICE_TWIN_GET_MESSAGE; //Retry to get twin properties
						else
							FLAG.TWIN_PROPERTIES_PROCESSED = TRUE; // All the properties in the twin list are now processed..
102d2648:	e59f35e8 	ldr	r3, [pc, #1512]	; 102d2c38 <MQTT_Packet_Process+0xa7c>
102d264c:	e3a02001 	mov	r2, #1
102d2650:	e5c32026 	strb	r2, [r3, #38]	; 0x26
102d2654:	eafffef4 	b	102d222c <MQTT_Packet_Process+0x70>
				{
#ifdef DEBUG_MQTT
					APP_DEBUG("\n\r SUBACK: IoT Hub Message, Granted qos: %d \n\r", granted_qos);
#endif
					FLAG.MQTT_CONNECTION_STATUS = TRUE;
					PUBLISH_RESPONSE_REQ_source |=SCHEDULE_PUBLISH_CONNECTIVITY_ON;
102d2658:	e59f2570 	ldr	r2, [pc, #1392]	; 102d2bd0 <MQTT_Packet_Process+0xa14>
				if(submsgid == 1)// IoT HuB Message Topic Subscribe ACK
				{
#ifdef DEBUG_MQTT
					APP_DEBUG("\n\r SUBACK: IoT Hub Message, Granted qos: %d \n\r", granted_qos);
#endif
					FLAG.MQTT_CONNECTION_STATUS = TRUE;
102d265c:	e59fe5d4 	ldr	lr, [pc, #1492]	; 102d2c38 <MQTT_Packet_Process+0xa7c>
					PUBLISH_RESPONSE_REQ_source |=SCHEDULE_PUBLISH_CONNECTIVITY_ON;
102d2660:	e592c000 	ldr	ip, [r2]
					//Subscribe IoT Hub Message Topic ACK received.. now Subcribe device twin desired parameter update topic
					MQTT_Send_SUB_Request(ssid, SUB_DEVICE_TWIN_DESIRED_TOPIC);
102d2664:	e1a00007 	mov	r0, r7
				{
#ifdef DEBUG_MQTT
					APP_DEBUG("\n\r SUBACK: IoT Hub Message, Granted qos: %d \n\r", granted_qos);
#endif
					FLAG.MQTT_CONNECTION_STATUS = TRUE;
					PUBLISH_RESPONSE_REQ_source |=SCHEDULE_PUBLISH_CONNECTIVITY_ON;
102d2668:	e38cc020 	orr	ip, ip, #32
					//Subscribe IoT Hub Message Topic ACK received.. now Subcribe device twin desired parameter update topic
					MQTT_Send_SUB_Request(ssid, SUB_DEVICE_TWIN_DESIRED_TOPIC);
102d266c:	e3a01002 	mov	r1, #2
				if(submsgid == 1)// IoT HuB Message Topic Subscribe ACK
				{
#ifdef DEBUG_MQTT
					APP_DEBUG("\n\r SUBACK: IoT Hub Message, Granted qos: %d \n\r", granted_qos);
#endif
					FLAG.MQTT_CONNECTION_STATUS = TRUE;
102d2670:	e5ce300d 	strb	r3, [lr, #13]
					PUBLISH_RESPONSE_REQ_source |=SCHEDULE_PUBLISH_CONNECTIVITY_ON;
102d2674:	e582c000 	str	ip, [r2]
102d2678:	e59f8534 	ldr	r8, [pc, #1332]	; 102d2bb4 <MQTT_Packet_Process+0x9f8>
					//Subscribe IoT Hub Message Topic ACK received.. now Subcribe device twin desired parameter update topic
					MQTT_Send_SUB_Request(ssid, SUB_DEVICE_TWIN_DESIRED_TOPIC);
102d267c:	ebffeff5 	bl	102ce658 <MQTT_Send_SUB_Request>
102d2680:	eafffee9 	b	102d222c <MQTT_Packet_Process+0x70>
				{
#ifdef DEBUG_MQTT
					APP_DEBUG("\n\r SUBACK:  Device Twin Desired Topic, Granted qos: %d \n\r", granted_qos);
#endif
					//Subscribe IoT Hub Message Topic ACK received.. now Subcribe device twin desired parameter update topic
					MQTT_Send_SUB_Request(ssid, SUB_DEVICETWIN_TOPIC);
102d2684:	e1a00007 	mov	r0, r7
102d2688:	e3a01001 	mov	r1, #1
102d268c:	ebffeff1 	bl	102ce658 <MQTT_Send_SUB_Request>
102d2690:	e59f851c 	ldr	r8, [pc, #1308]	; 102d2bb4 <MQTT_Packet_Process+0x9f8>
102d2694:	eafffee4 	b	102d222c <MQTT_Packet_Process+0x70>
							{
								Process_Device_Twin_Properties(payload_in);
							}
							else
							{
								PUBLISH_RESPONSE_REQ_source |= SCHEDULE_DEVICE_TWIN_GET_MESSAGE; //first do a Retry to get twin properties
102d2698:	e59f3530 	ldr	r3, [pc, #1328]	; 102d2bd0 <MQTT_Packet_Process+0xa14>
102d269c:	e5932000 	ldr	r2, [r3]
102d26a0:	e3822802 	orr	r2, r2, #131072	; 0x20000
102d26a4:	e5832000 	str	r2, [r3]
102d26a8:	eafffedf 	b	102d222c <MQTT_Packet_Process+0x70>
#endif
							Last_language_index = language_index;
							language_index = Ql_atoi((const char *)cmd_Parameter);
							if(language_index < LANGUAGES_SUPPORTED)
							{
								repaint_water_balance_screen();
102d26ac:	e59f35b0 	ldr	r3, [pc, #1456]	; 102d2c64 <MQTT_Packet_Process+0xaa8>
102d26b0:	e12fff33 	blx	r3
102d26b4:	eaffff72 	b	102d2484 <MQTT_Packet_Process+0x2c8>
						else
							FLAG.TWIN_PROPERTIES_PROCESSED = TRUE; // All the properties in the twin list are now processed..
					}
					else
					{
						tempstring = Ql_strstr(receivedTopic.lenstring.data, "$iothub/twin/PATCH/properties/desired/");// A received topic wil contain the device ID for non twin messages only
102d26b8:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
102d26bc:	e59f15a4 	ldr	r1, [pc, #1444]	; 102d2c68 <MQTT_Packet_Process+0xaac>
102d26c0:	e12fff38 	blx	r8
						if(tempstring !=NULL) // Device twin desired properties change notificaiton received
102d26c4:	e3500000 	cmp	r0, #0
102d26c8:	0afffed6 	beq	102d2228 <MQTT_Packet_Process+0x6c>
						{
#ifdef DEBUG_MSG
							APP_DEBUG("\n\r<-- ***Device twin desired notification received ***-->\r\n");
102d26cc:	e3a02c02 	mov	r2, #512	; 0x200
102d26d0:	e1a01007 	mov	r1, r7
102d26d4:	e28500b8 	add	r0, r5, #184	; 0xb8
102d26d8:	e59f84d4 	ldr	r8, [pc, #1236]	; 102d2bb4 <MQTT_Packet_Process+0x9f8>
102d26dc:	e12fff38 	blx	r8
102d26e0:	e59f34f8 	ldr	r3, [pc, #1272]	; 102d2be0 <MQTT_Packet_Process+0xa24>
102d26e4:	e59f1580 	ldr	r1, [pc, #1408]	; 102d2c6c <MQTT_Packet_Process+0xab0>
102d26e8:	e5933000 	ldr	r3, [r3]
102d26ec:	e28500b8 	add	r0, r5, #184	; 0xb8
102d26f0:	e12fff33 	blx	r3
102d26f4:	e59f34ec 	ldr	r3, [pc, #1260]	; 102d2be8 <MQTT_Packet_Process+0xa2c>
102d26f8:	e28500b8 	add	r0, r5, #184	; 0xb8
102d26fc:	e12fff33 	blx	r3
102d2700:	e59f34e4 	ldr	r3, [pc, #1252]	; 102d2bec <MQTT_Packet_Process+0xa30>
102d2704:	e28510b8 	add	r1, r5, #184	; 0xb8
102d2708:	e1a02000 	mov	r2, r0
102d270c:	e3a0000a 	mov	r0, #10
102d2710:	e12fff33 	blx	r3
#endif
							if(FLAG.TWIN_PROPERTIES_PROCESSED == TRUE) // Process the desired properties change notifications only after twin list is processed
102d2714:	e59f351c 	ldr	r3, [pc, #1308]	; 102d2c38 <MQTT_Packet_Process+0xa7c>
102d2718:	e5d33026 	ldrb	r3, [r3, #38]	; 0x26
102d271c:	e3530001 	cmp	r3, #1
102d2720:	1affffdc 	bne	102d2698 <MQTT_Packet_Process+0x4dc>
							{
								Process_Device_Twin_Properties(payload_in);
102d2724:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
102d2728:	ebfffa84 	bl	102d1140 <Process_Device_Twin_Properties>
102d272c:	eafffebe 	b	102d222c <MQTT_Packet_Process+0x70>
					}

					//3. Check if LOCK command is received in the MQTT payload.
					if(NULL == tmp_obj)
					{
						tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_LOCK);
102d2730:	e59d001c 	ldr	r0, [sp, #28]
102d2734:	e59f1534 	ldr	r1, [pc, #1332]	; 102d2c70 <MQTT_Packet_Process+0xab4>
102d2738:	e12fff37 	blx	r7
						if(NULL != tmp_obj)
102d273c:	e3500000 	cmp	r0, #0
102d2740:	0a000016 	beq	102d27a0 <MQTT_Packet_Process+0x5e4>
						{
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
102d2744:	e5901010 	ldr	r1, [r0, #16]
102d2748:	e59f54b4 	ldr	r5, [pc, #1204]	; 102d2c04 <MQTT_Packet_Process+0xa48>
102d274c:	e28d0024 	add	r0, sp, #36	; 0x24
102d2750:	e12fff35 	blx	r5
#ifdef DEBUG_MQTT
							APP_DEBUG("LOCK = %s\r\n", cmd_Parameter);
#endif
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_TS);
102d2754:	e59f14ac 	ldr	r1, [pc, #1196]	; 102d2c08 <MQTT_Packet_Process+0xa4c>
102d2758:	e59d001c 	ldr	r0, [sp, #28]
102d275c:	e12fff37 	blx	r7
							Ql_strcpy(Received_TS,tmp_obj->valuestring);
102d2760:	e5901010 	ldr	r1, [r0, #16]
102d2764:	e28d004c 	add	r0, sp, #76	; 0x4c
102d2768:	e12fff35 	blx	r5

							if(Ql_strncmp(cmd_Parameter,"1",Ql_strlen("1"))==0)
102d276c:	e59f0498 	ldr	r0, [pc, #1176]	; 102d2c0c <MQTT_Packet_Process+0xa50>
102d2770:	e12fff3a 	blx	sl
102d2774:	e59f1490 	ldr	r1, [pc, #1168]	; 102d2c0c <MQTT_Packet_Process+0xa50>
102d2778:	e59f3490 	ldr	r3, [pc, #1168]	; 102d2c10 <MQTT_Packet_Process+0xa54>
102d277c:	e1a02000 	mov	r2, r0
102d2780:	e28d0024 	add	r0, sp, #36	; 0x24
102d2784:	e12fff33 	blx	r3
102d2788:	e3500000 	cmp	r0, #0
							{
								IPC_CMD_REQ_source |= SCHEDULE_IPC_LOCK_CMD;
102d278c:	059f3494 	ldreq	r3, [pc, #1172]	; 102d2c28 <MQTT_Packet_Process+0xa6c>
102d2790:	05932000 	ldreq	r2, [r3]
102d2794:	03822008 	orreq	r2, r2, #8
102d2798:	05832000 	streq	r2, [r3]
102d279c:	eafffea2 	b	102d222c <MQTT_Packet_Process+0x70>
					}

					//4. Check if UNLOCK command is received in the MQTT payload.
					if(NULL == tmp_obj)
					{
						tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_UNLOCK);
102d27a0:	e59d001c 	ldr	r0, [sp, #28]
102d27a4:	e59f14c8 	ldr	r1, [pc, #1224]	; 102d2c74 <MQTT_Packet_Process+0xab8>
102d27a8:	e12fff37 	blx	r7
						if(NULL != tmp_obj)
102d27ac:	e3500000 	cmp	r0, #0
102d27b0:	0a000016 	beq	102d2810 <MQTT_Packet_Process+0x654>
						{
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
102d27b4:	e5901010 	ldr	r1, [r0, #16]
102d27b8:	e59f5444 	ldr	r5, [pc, #1092]	; 102d2c04 <MQTT_Packet_Process+0xa48>
102d27bc:	e28d0024 	add	r0, sp, #36	; 0x24
102d27c0:	e12fff35 	blx	r5
#ifdef DEBUG_MQTT
							APP_DEBUG("UNLOCK = %s\r\n", cmd_Parameter);
#endif
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_TS);
102d27c4:	e59f143c 	ldr	r1, [pc, #1084]	; 102d2c08 <MQTT_Packet_Process+0xa4c>
102d27c8:	e59d001c 	ldr	r0, [sp, #28]
102d27cc:	e12fff37 	blx	r7
							Ql_strcpy(Received_TS,tmp_obj->valuestring);
102d27d0:	e5901010 	ldr	r1, [r0, #16]
102d27d4:	e28d004c 	add	r0, sp, #76	; 0x4c
102d27d8:	e12fff35 	blx	r5

							if(Ql_strncmp(cmd_Parameter,"1",Ql_strlen("1"))==0)
102d27dc:	e59f0428 	ldr	r0, [pc, #1064]	; 102d2c0c <MQTT_Packet_Process+0xa50>
102d27e0:	e12fff3a 	blx	sl
102d27e4:	e59f1420 	ldr	r1, [pc, #1056]	; 102d2c0c <MQTT_Packet_Process+0xa50>
102d27e8:	e59f3420 	ldr	r3, [pc, #1056]	; 102d2c10 <MQTT_Packet_Process+0xa54>
102d27ec:	e1a02000 	mov	r2, r0
102d27f0:	e28d0024 	add	r0, sp, #36	; 0x24
102d27f4:	e12fff33 	blx	r3
102d27f8:	e3500000 	cmp	r0, #0
							{
								IPC_CMD_REQ_source |= SCHEDULE_IPC_UNLOCK_CMD;
102d27fc:	059f3424 	ldreq	r3, [pc, #1060]	; 102d2c28 <MQTT_Packet_Process+0xa6c>
102d2800:	05932000 	ldreq	r2, [r3]
102d2804:	03822004 	orreq	r2, r2, #4
102d2808:	05832000 	streq	r2, [r3]
102d280c:	eafffe86 	b	102d222c <MQTT_Packet_Process+0x70>
					}

					//5. Check if CONFIG command is received in the MQTT payload.
					if(NULL == tmp_obj)
					{
						tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_LANGUAGE_ID);
102d2810:	e59d001c 	ldr	r0, [sp, #28]
102d2814:	e59f13f8 	ldr	r1, [pc, #1016]	; 102d2c14 <MQTT_Packet_Process+0xa58>
102d2818:	e12fff37 	blx	r7
						if(NULL != tmp_obj)
102d281c:	e3500000 	cmp	r0, #0
102d2820:	0a000016 	beq	102d2880 <MQTT_Packet_Process+0x6c4>
						{
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
102d2824:	e5901010 	ldr	r1, [r0, #16]
102d2828:	e59fa3d4 	ldr	sl, [pc, #980]	; 102d2c04 <MQTT_Packet_Process+0xa48>
102d282c:	e28d0024 	add	r0, sp, #36	; 0x24
102d2830:	e12fff3a 	blx	sl
#ifdef DEBUG_MQTT
							APP_DEBUG("LANGUAGE = %s\r\n", cmd_Parameter);
#endif
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_TS);
102d2834:	e59f13cc 	ldr	r1, [pc, #972]	; 102d2c08 <MQTT_Packet_Process+0xa4c>
102d2838:	e59d001c 	ldr	r0, [sp, #28]
102d283c:	e12fff37 	blx	r7
							Ql_strcpy(Received_TS,tmp_obj->valuestring);

							Last_language_index = language_index;
102d2840:	e59f53d0 	ldr	r5, [pc, #976]	; 102d2c18 <MQTT_Packet_Process+0xa5c>
102d2844:	e59f73d0 	ldr	r7, [pc, #976]	; 102d2c1c <MQTT_Packet_Process+0xa60>
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
#ifdef DEBUG_MQTT
							APP_DEBUG("LANGUAGE = %s\r\n", cmd_Parameter);
#endif
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_TS);
							Ql_strcpy(Received_TS,tmp_obj->valuestring);
102d2848:	e5901010 	ldr	r1, [r0, #16]
102d284c:	e28d004c 	add	r0, sp, #76	; 0x4c
102d2850:	e12fff3a 	blx	sl

							Last_language_index = language_index;
102d2854:	e5953000 	ldr	r3, [r5]
102d2858:	e5873000 	str	r3, [r7]
							language_index = Ql_atoi((const char *)cmd_Parameter);
102d285c:	e28d0024 	add	r0, sp, #36	; 0x24
102d2860:	e59f33b8 	ldr	r3, [pc, #952]	; 102d2c20 <MQTT_Packet_Process+0xa64>
102d2864:	e12fff33 	blx	r3
							if(language_index < LANGUAGES_SUPPORTED)
102d2868:	e3500001 	cmp	r0, #1
#endif
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_TS);
							Ql_strcpy(Received_TS,tmp_obj->valuestring);

							Last_language_index = language_index;
							language_index = Ql_atoi((const char *)cmd_Parameter);
102d286c:	e5850000 	str	r0, [r5]
							if(language_index < LANGUAGES_SUPPORTED)
102d2870:	da0000a6 	ble	102d2b10 <MQTT_Packet_Process+0x954>
							{
								repaint_water_balance_screen();
								PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_RESPONSE_FOR_LANGUAGE_CMD;
							}
							else
								language_index = Last_language_index;
102d2874:	e5973000 	ldr	r3, [r7]
102d2878:	e5853000 	str	r3, [r5]
102d287c:	eafffe6a 	b	102d222c <MQTT_Packet_Process+0x70>
					}

					//6. Check if RESTART command is received in the MQTT payload.
					if(NULL == tmp_obj)
					{
						tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_RESTART);
102d2880:	e59d001c 	ldr	r0, [sp, #28]
102d2884:	e59f13ec 	ldr	r1, [pc, #1004]	; 102d2c78 <MQTT_Packet_Process+0xabc>
102d2888:	e12fff37 	blx	r7
						if(NULL != tmp_obj)
102d288c:	e3500000 	cmp	r0, #0
102d2890:	0a000016 	beq	102d28f0 <MQTT_Packet_Process+0x734>
						{
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
102d2894:	e5901010 	ldr	r1, [r0, #16]
102d2898:	e59f5364 	ldr	r5, [pc, #868]	; 102d2c04 <MQTT_Packet_Process+0xa48>
102d289c:	e28d0024 	add	r0, sp, #36	; 0x24
102d28a0:	e12fff35 	blx	r5
#ifdef DEBUG_MQTT
							APP_DEBUG("RESTART = %s\r\n", cmd_Parameter);
#endif
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_TS);
102d28a4:	e59f135c 	ldr	r1, [pc, #860]	; 102d2c08 <MQTT_Packet_Process+0xa4c>
102d28a8:	e59d001c 	ldr	r0, [sp, #28]
102d28ac:	e12fff37 	blx	r7
							Ql_strcpy(Received_TS,tmp_obj->valuestring);
102d28b0:	e5901010 	ldr	r1, [r0, #16]
102d28b4:	e28d004c 	add	r0, sp, #76	; 0x4c
102d28b8:	e12fff35 	blx	r5

							if(Ql_strncmp(cmd_Parameter,"1",Ql_strlen("1"))==0)
102d28bc:	e59f0348 	ldr	r0, [pc, #840]	; 102d2c0c <MQTT_Packet_Process+0xa50>
102d28c0:	e12fff3a 	blx	sl
102d28c4:	e59f1340 	ldr	r1, [pc, #832]	; 102d2c0c <MQTT_Packet_Process+0xa50>
102d28c8:	e59f3340 	ldr	r3, [pc, #832]	; 102d2c10 <MQTT_Packet_Process+0xa54>
102d28cc:	e1a02000 	mov	r2, r0
102d28d0:	e28d0024 	add	r0, sp, #36	; 0x24
102d28d4:	e12fff33 	blx	r3
102d28d8:	e3500000 	cmp	r0, #0
							{
								IPC_CMD_REQ_source|=SCHEDULE_POWER_DOWN_WITH_BACKUP;;
102d28dc:	059f3344 	ldreq	r3, [pc, #836]	; 102d2c28 <MQTT_Packet_Process+0xa6c>
102d28e0:	05932000 	ldreq	r2, [r3]
102d28e4:	03822a01 	orreq	r2, r2, #4096	; 0x1000
102d28e8:	05832000 	streq	r2, [r3]
102d28ec:	eafffe4e 	b	102d222c <MQTT_Packet_Process+0x70>
						}
					}
					//7. Check if Firmware upgrade command is received in the MQTT payload.
					if(NULL == tmp_obj)
					{
						tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_LICENSE);
102d28f0:	e59d001c 	ldr	r0, [sp, #28]
102d28f4:	e59f1380 	ldr	r1, [pc, #896]	; 102d2c7c <MQTT_Packet_Process+0xac0>
102d28f8:	e12fff37 	blx	r7
						if(NULL != tmp_obj)
102d28fc:	e3500000 	cmp	r0, #0
102d2900:	0afffe49 	beq	102d222c <MQTT_Packet_Process+0x70>
						{
							Ql_strcpy(cmd_Parameter,tmp_obj->valuestring);
102d2904:	e59f52f8 	ldr	r5, [pc, #760]	; 102d2c04 <MQTT_Packet_Process+0xa48>
102d2908:	e5901010 	ldr	r1, [r0, #16]
102d290c:	e28d0024 	add	r0, sp, #36	; 0x24
102d2910:	e12fff35 	blx	r5
//#ifdef DEBUG_MQTT
							APP_DEBUG("FW_UPGRADE = %s\r\n", cmd_Parameter);
102d2914:	e3a01000 	mov	r1, #0
102d2918:	e3a02c02 	mov	r2, #512	; 0x200
102d291c:	e59f035c 	ldr	r0, [pc, #860]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d2920:	e12fff38 	blx	r8
102d2924:	e59b3000 	ldr	r3, [fp]
102d2928:	e28d2024 	add	r2, sp, #36	; 0x24
102d292c:	e59f1350 	ldr	r1, [pc, #848]	; 102d2c84 <MQTT_Packet_Process+0xac8>
102d2930:	e59f0348 	ldr	r0, [pc, #840]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d2934:	e12fff33 	blx	r3
102d2938:	e59f0340 	ldr	r0, [pc, #832]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d293c:	e12fff3a 	blx	sl
102d2940:	e59f1338 	ldr	r1, [pc, #824]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d2944:	e1a02000 	mov	r2, r0
102d2948:	e3a0000a 	mov	r0, #10
102d294c:	e12fff39 	blx	r9
//#endif
							tmp_obj = cJSON_GetObjectItem(tmp, MQTT_PAYLOAD_TS);
102d2950:	e59d001c 	ldr	r0, [sp, #28]
102d2954:	e59f12ac 	ldr	r1, [pc, #684]	; 102d2c08 <MQTT_Packet_Process+0xa4c>
102d2958:	e12fff37 	blx	r7
							Ql_strcpy(Received_TS,tmp_obj->valuestring);
102d295c:	e5901010 	ldr	r1, [r0, #16]
102d2960:	e28d004c 	add	r0, sp, #76	; 0x4c
102d2964:	e12fff35 	blx	r5
//#ifdef DEBUG_MQTT
							APP_DEBUG("TS = %s\r\n", Received_TS);
102d2968:	e3a01000 	mov	r1, #0
102d296c:	e3a02c02 	mov	r2, #512	; 0x200
102d2970:	e59f0308 	ldr	r0, [pc, #776]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d2974:	e12fff38 	blx	r8
102d2978:	e59b3000 	ldr	r3, [fp]
102d297c:	e28d204c 	add	r2, sp, #76	; 0x4c
102d2980:	e59f1300 	ldr	r1, [pc, #768]	; 102d2c88 <MQTT_Packet_Process+0xacc>
102d2984:	e59f02f4 	ldr	r0, [pc, #756]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d2988:	e12fff33 	blx	r3
102d298c:	e59f02ec 	ldr	r0, [pc, #748]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d2990:	e12fff3a 	blx	sl
102d2994:	e59f12e4 	ldr	r1, [pc, #740]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d2998:	e1a02000 	mov	r2, r0
102d299c:	e3a0000a 	mov	r0, #10
102d29a0:	e12fff39 	blx	r9
//#endif
							tmp_obj = cJSON_GetObjectItem(tmp,"FWURL");
102d29a4:	e59d001c 	ldr	r0, [sp, #28]
102d29a8:	e59f12dc 	ldr	r1, [pc, #732]	; 102d2c8c <MQTT_Packet_Process+0xad0>
102d29ac:	e12fff37 	blx	r7
							Ql_strcpy(HTTP_LICENSE_URL_ADDR,tmp_obj->valuestring);
102d29b0:	e5901010 	ldr	r1, [r0, #16]
102d29b4:	e59f02d4 	ldr	r0, [pc, #724]	; 102d2c90 <MQTT_Packet_Process+0xad4>
102d29b8:	e12fff35 	blx	r5
//#ifdef DEBUG_MQTT
							APP_DEBUG("FWURL = %s \r\n", HTTP_LICENSE_URL_ADDR);
102d29bc:	e3a01000 	mov	r1, #0
102d29c0:	e3a02c02 	mov	r2, #512	; 0x200
102d29c4:	e59f02b4 	ldr	r0, [pc, #692]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d29c8:	e12fff38 	blx	r8
102d29cc:	e59b3000 	ldr	r3, [fp]
102d29d0:	e59f12bc 	ldr	r1, [pc, #700]	; 102d2c94 <MQTT_Packet_Process+0xad8>
102d29d4:	e59f22b4 	ldr	r2, [pc, #692]	; 102d2c90 <MQTT_Packet_Process+0xad4>
102d29d8:	e59f02a0 	ldr	r0, [pc, #672]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d29dc:	e12fff33 	blx	r3
102d29e0:	e59f0298 	ldr	r0, [pc, #664]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d29e4:	e12fff3a 	blx	sl
102d29e8:	e59f1290 	ldr	r1, [pc, #656]	; 102d2c80 <MQTT_Packet_Process+0xac4>
102d29ec:	e1a02000 	mov	r2, r0
102d29f0:	e3a0000a 	mov	r0, #10
102d29f4:	e12fff39 	blx	r9
//#endif
							ret = LICENSE_INIT();	//Call function for FOTA_INIT
102d29f8:	e59f3298 	ldr	r3, [pc, #664]	; 102d2c98 <MQTT_Packet_Process+0xadc>
102d29fc:	e12fff33 	blx	r3
//#ifdef DEBUG_MQTT
							Read_License();
102d2a00:	e59f3294 	ldr	r3, [pc, #660]	; 102d2c9c <MQTT_Packet_Process+0xae0>
102d2a04:	e12fff33 	blx	r3
102d2a08:	eafffe07 	b	102d222c <MQTT_Packet_Process+0x70>
									RCbalance_now = Ql_atof((const char *)rcbal);
								}
								rechargebalance = RCbalance_now * 10; // to make received recharge in unit of 100 ml that is required by control module
								if(rechargebalance == 0) // Do not attempt any actual recharge.. simply ack as success
								{
									Ql_strcpy(cmdrcbal,rcbal);
102d2a0c:	e2871e4b 	add	r1, r7, #1200	; 0x4b0
102d2a10:	e281000c 	add	r0, r1, #12
102d2a14:	e12fff39 	blx	r9
									Ql_strcpy(Received_RCID,RCID);
102d2a18:	e2871fce 	add	r1, r7, #824	; 0x338
102d2a1c:	e2870d0b 	add	r0, r7, #704	; 0x2c0
102d2a20:	e12fff39 	blx	r9
									Ql_strcpy(Received_RCTS,RCTS);
102d2a24:	e2871fd5 	add	r1, r7, #852	; 0x354
102d2a28:	e2870fb7 	add	r0, r7, #732	; 0x2dc
102d2a2c:	e12fff39 	blx	r9
									Store_Persistent_Data();   //Write permanent data to flash file with recharge information
102d2a30:	e59f3268 	ldr	r3, [pc, #616]	; 102d2ca0 <MQTT_Packet_Process+0xae4>
102d2a34:	e12fff33 	blx	r3
									if(FLAG.DIGNOSTIC_MODE == TRUE)
102d2a38:	e59f31f8 	ldr	r3, [pc, #504]	; 102d2c38 <MQTT_Packet_Process+0xa7c>
102d2a3c:	e5d3300a 	ldrb	r3, [r3, #10]
102d2a40:	e3530001 	cmp	r3, #1
102d2a44:	0a000038 	beq	102d2b2c <MQTT_Packet_Process+0x970>
102d2a48:	e59f5254 	ldr	r5, [pc, #596]	; 102d2ca4 <MQTT_Packet_Process+0xae8>
									Store_Persistent_Data();   //Write permanent data to flash file with recharge information
									if(FLAG.DIGNOSTIC_MODE == TRUE)
									{
										Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_DIAG_RECHARGE_INFO);//Update the recharge information on diagnostic screen
									}
									Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_RC_OK);
102d2a4c:	e3a00000 	mov	r0, #0
102d2a50:	e59f1250 	ldr	r1, [pc, #592]	; 102d2ca8 <MQTT_Packet_Process+0xaec>
102d2a54:	e1a02000 	mov	r2, r0
102d2a58:	e3a0300c 	mov	r3, #12
102d2a5c:	e12fff35 	blx	r5
									Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_WATER_BALANCE); // Send updated water balance to cloud
102d2a60:	e3a00000 	mov	r0, #0
102d2a64:	e59f123c 	ldr	r1, [pc, #572]	; 102d2ca8 <MQTT_Packet_Process+0xaec>
102d2a68:	e1a02000 	mov	r2, r0
102d2a6c:	e3a03001 	mov	r3, #1
102d2a70:	e12fff35 	blx	r5
102d2a74:	eafffdec 	b	102d222c <MQTT_Packet_Process+0x70>
									{
										IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
									}
									else
									{
										rechargebalance =0;
102d2a78:	e3a05000 	mov	r5, #0
										Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_RC_FAIL); // Send a NACK to cloud recharge requested indicating a fail
102d2a7c:	e1a02005 	mov	r2, r5
102d2a80:	e1a00005 	mov	r0, r5
102d2a84:	e59f121c 	ldr	r1, [pc, #540]	; 102d2ca8 <MQTT_Packet_Process+0xaec>
102d2a88:	e3a0300d 	mov	r3, #13
102d2a8c:	e59fa210 	ldr	sl, [pc, #528]	; 102d2ca4 <MQTT_Packet_Process+0xae8>
									{
										IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
									}
									else
									{
										rechargebalance =0;
102d2a90:	e58754ac 	str	r5, [r7, #1196]	; 0x4ac
										Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_RC_FAIL); // Send a NACK to cloud recharge requested indicating a fail
102d2a94:	e12fff3a 	blx	sl
										Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_WATER_BALANCE); // Send updated water balance to cloud
102d2a98:	e1a00005 	mov	r0, r5
102d2a9c:	e59f1204 	ldr	r1, [pc, #516]	; 102d2ca8 <MQTT_Packet_Process+0xaec>
102d2aa0:	e1a02005 	mov	r2, r5
102d2aa4:	e3a03001 	mov	r3, #1
102d2aa8:	e12fff3a 	blx	sl
102d2aac:	eafffdde 	b	102d222c <MQTT_Packet_Process+0x70>
							APP_DEBUG("RC_TS = %s\r\n", RCTS);
#endif
							//recharge balance into integer
							if(rcbal[0] == '-') // Negative recharge
							{
								RCbalance_now = Ql_atof((const char *)&rcbal[1]); //Ignore negative sign
102d2ab0:	e59f318c 	ldr	r3, [pc, #396]	; 102d2c44 <MQTT_Packet_Process+0xa88>
102d2ab4:	e59f01f0 	ldr	r0, [pc, #496]	; 102d2cac <MQTT_Packet_Process+0xaf0>
102d2ab8:	e12fff33 	blx	r3
102d2abc:	e59f3184 	ldr	r3, [pc, #388]	; 102d2c48 <MQTT_Packet_Process+0xa8c>
102d2ac0:	e12fff33 	blx	r3
								rechargebalance = RCbalance_now * 10; // to make received recharge in unit of 100 ml that is required by control module
102d2ac4:	e59f1180 	ldr	r1, [pc, #384]	; 102d2c4c <MQTT_Packet_Process+0xa90>
102d2ac8:	e59f3180 	ldr	r3, [pc, #384]	; 102d2c50 <MQTT_Packet_Process+0xa94>
102d2acc:	e12fff33 	blx	r3
102d2ad0:	e59f317c 	ldr	r3, [pc, #380]	; 102d2c54 <MQTT_Packet_Process+0xa98>
102d2ad4:	e12fff33 	blx	r3
								if(rechargebalance == 0) // DO not attempt any actual recharge.. simply ack as success
102d2ad8:	e59dc018 	ldr	ip, [sp, #24]
102d2adc:	e3500000 	cmp	r0, #0
#endif
							//recharge balance into integer
							if(rcbal[0] == '-') // Negative recharge
							{
								RCbalance_now = Ql_atof((const char *)&rcbal[1]); //Ignore negative sign
								rechargebalance = RCbalance_now * 10; // to make received recharge in unit of 100 ml that is required by control module
102d2ae0:	e58504ac 	str	r0, [r5, #1196]	; 0x4ac
								if(rechargebalance == 0) // DO not attempt any actual recharge.. simply ack as success
102d2ae4:	0a000017 	beq	102d2b48 <MQTT_Packet_Process+0x98c>
									Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_WATER_BALANCE); // Send updated water balance to cloud

								}
								else
								{
									if((water_balance) >= (rechargebalance)) // Recharge balance should never go negative
102d2ae8:	e59524c8 	ldr	r2, [r5, #1224]	; 0x4c8
102d2aec:	e1500002 	cmp	r0, r2
102d2af0:	8a00001d 	bhi	102d2b6c <MQTT_Packet_Process+0x9b0>
									{
										rechargebalance = (water_balance) - (rechargebalance);
										IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102d2af4:	e59f312c 	ldr	r3, [pc, #300]	; 102d2c28 <MQTT_Packet_Process+0xa6c>
								}
								else
								{
									if((water_balance) >= (rechargebalance)) // Recharge balance should never go negative
									{
										rechargebalance = (water_balance) - (rechargebalance);
102d2af8:	e0600002 	rsb	r0, r0, r2
										IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102d2afc:	e5932000 	ldr	r2, [r3]
								}
								else
								{
									if((water_balance) >= (rechargebalance)) // Recharge balance should never go negative
									{
										rechargebalance = (water_balance) - (rechargebalance);
102d2b00:	e58504ac 	str	r0, [r5, #1196]	; 0x4ac
										IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102d2b04:	e3822020 	orr	r2, r2, #32
102d2b08:	e5832000 	str	r2, [r3]
102d2b0c:	eafffdc6 	b	102d222c <MQTT_Packet_Process+0x70>

							Last_language_index = language_index;
							language_index = Ql_atoi((const char *)cmd_Parameter);
							if(language_index < LANGUAGES_SUPPORTED)
							{
								repaint_water_balance_screen();
102d2b10:	e59f314c 	ldr	r3, [pc, #332]	; 102d2c64 <MQTT_Packet_Process+0xaa8>
102d2b14:	e12fff33 	blx	r3
								PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_RESPONSE_FOR_LANGUAGE_CMD;
102d2b18:	e59f30b0 	ldr	r3, [pc, #176]	; 102d2bd0 <MQTT_Packet_Process+0xa14>
102d2b1c:	e5932000 	ldr	r2, [r3]
102d2b20:	e3822a01 	orr	r2, r2, #4096	; 0x1000
102d2b24:	e5832000 	str	r2, [r3]
102d2b28:	eafffdbf 	b	102d222c <MQTT_Packet_Process+0x70>
									Ql_strcpy(Received_RCID,RCID);
									Ql_strcpy(Received_RCTS,RCTS);
									Store_Persistent_Data();   //Write permanent data to flash file with recharge information
									if(FLAG.DIGNOSTIC_MODE == TRUE)
									{
										Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_DIAG_RECHARGE_INFO);//Update the recharge information on diagnostic screen
102d2b2c:	e59f1174 	ldr	r1, [pc, #372]	; 102d2ca8 <MQTT_Packet_Process+0xaec>
102d2b30:	e3a02002 	mov	r2, #2
102d2b34:	e3a0301d 	mov	r3, #29
102d2b38:	e59f5164 	ldr	r5, [pc, #356]	; 102d2ca4 <MQTT_Packet_Process+0xae8>
102d2b3c:	e3a00003 	mov	r0, #3
102d2b40:	e12fff35 	blx	r5
102d2b44:	eaffffc0 	b	102d2a4c <MQTT_Packet_Process+0x890>
							{
								RCbalance_now = Ql_atof((const char *)&rcbal[1]); //Ignore negative sign
								rechargebalance = RCbalance_now * 10; // to make received recharge in unit of 100 ml that is required by control module
								if(rechargebalance == 0) // DO not attempt any actual recharge.. simply ack as success
								{
									Ql_strcpy(cmdrcbal,rcbal);
102d2b48:	e2851e4b 	add	r1, r5, #1200	; 0x4b0
102d2b4c:	e281000c 	add	r0, r1, #12
102d2b50:	e12fff39 	blx	r9
									Ql_strcpy(Received_RCID,RCID);
102d2b54:	e2851fce 	add	r1, r5, #824	; 0x338
102d2b58:	e2850d0b 	add	r0, r5, #704	; 0x2c0
102d2b5c:	e12fff39 	blx	r9
									Ql_strcpy(Received_RCTS,RCTS);
102d2b60:	e2851fd5 	add	r1, r5, #852	; 0x354
102d2b64:	e2850fb7 	add	r0, r5, #732	; 0x2dc
102d2b68:	eaffffaf 	b	102d2a2c <MQTT_Packet_Process+0x870>
										rechargebalance = (water_balance) - (rechargebalance);
										IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
									}
									else
									{
										rechargebalance =0;
102d2b6c:	e585c4ac 	str	ip, [r5, #1196]	; 0x4ac
										Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_RC_FAIL); // Send a NACK to cloud recharge requested indicating a fail
102d2b70:	e1a0200c 	mov	r2, ip
102d2b74:	e58dc018 	str	ip, [sp, #24]
102d2b78:	e1a0000c 	mov	r0, ip
102d2b7c:	e59f1124 	ldr	r1, [pc, #292]	; 102d2ca8 <MQTT_Packet_Process+0xaec>
102d2b80:	e3a0300d 	mov	r3, #13
102d2b84:	e59f7118 	ldr	r7, [pc, #280]	; 102d2ca4 <MQTT_Packet_Process+0xae8>
102d2b88:	e12fff37 	blx	r7
										Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PUBLISH_DATA, MQTT_WATER_BALANCE); // Send updated water balance to cloud
102d2b8c:	e59dc018 	ldr	ip, [sp, #24]
102d2b90:	e59f1110 	ldr	r1, [pc, #272]	; 102d2ca8 <MQTT_Packet_Process+0xaec>
102d2b94:	e1a0000c 	mov	r0, ip
102d2b98:	e1a0200c 	mov	r2, ip
102d2b9c:	e3a03001 	mov	r3, #1
102d2ba0:	e12fff37 	blx	r7
102d2ba4:	eafffda0 	b	102d222c <MQTT_Packet_Process+0x70>
102d2ba8:	102e4840 	.word	0x102e4840
102d2bac:	00003908 	.word	0x00003908
102d2bb0:	f03d572c 	.word	0xf03d572c
102d2bb4:	102e58f4 	.word	0x102e58f4
102d2bb8:	102e48b8 	.word	0x102e48b8
102d2bbc:	f03d203c 	.word	0xf03d203c
102d2bc0:	102dcf78 	.word	0x102dcf78
102d2bc4:	102cdd80 	.word	0x102cdd80
102d2bc8:	102cd69c 	.word	0x102cd69c
102d2bcc:	102ce398 	.word	0x102ce398
102d2bd0:	f03da598 	.word	0xf03da598
102d2bd4:	102cd7ac 	.word	0x102cd7ac
102d2bd8:	102e5a04 	.word	0x102e5a04
102d2bdc:	102eee70 	.word	0x102eee70
102d2be0:	f03de540 	.word	0xf03de540
102d2be4:	102eee88 	.word	0x102eee88
102d2be8:	102e57a4 	.word	0x102e57a4
102d2bec:	102e6230 	.word	0x102e6230
102d2bf0:	102d6ec8 	.word	0x102d6ec8
102d2bf4:	102d7750 	.word	0x102d7750
102d2bf8:	102d7880 	.word	0x102d7880
102d2bfc:	102ef9b8 	.word	0x102ef9b8
102d2c00:	102e70dc 	.word	0x102e70dc
102d2c04:	102e55fc 	.word	0x102e55fc
102d2c08:	102e7020 	.word	0x102e7020
102d2c0c:	102ee9e0 	.word	0x102ee9e0
102d2c10:	102e5884 	.word	0x102e5884
102d2c14:	102e70e0 	.word	0x102e70e0
102d2c18:	f03d64f8 	.word	0xf03d64f8
102d2c1c:	f03d6500 	.word	0xf03d6500
102d2c20:	102e5a8c 	.word	0x102e5a8c
102d2c24:	102e70ec 	.word	0x102e70ec
102d2c28:	f03da514 	.word	0xf03da514
102d2c2c:	102e7018 	.word	0x102e7018
102d2c30:	f03d5a80 	.word	0xf03d5a80
102d2c34:	f03da4f8 	.word	0xf03da4f8
102d2c38:	f03da5f0 	.word	0xf03da5f0
102d2c3c:	102e70f4 	.word	0x102e70f4
102d2c40:	102e7010 	.word	0x102e7010
102d2c44:	102e5564 	.word	0x102e5564
102d2c48:	102e39b0 	.word	0x102e39b0
102d2c4c:	41200000 	.word	0x41200000
102d2c50:	102e3a50 	.word	0x102e3a50
102d2c54:	102e3e5c 	.word	0x102e3e5c
102d2c58:	0000270f 	.word	0x0000270f
102d2c5c:	102eeef0 	.word	0x102eeef0
102d2c60:	102eef10 	.word	0x102eef10
102d2c64:	102da0f4 	.word	0x102da0f4
102d2c68:	102eef3c 	.word	0x102eef3c
102d2c6c:	102eef64 	.word	0x102eef64
102d2c70:	102e70fc 	.word	0x102e70fc
102d2c74:	102e7104 	.word	0x102e7104
102d2c78:	102e710c 	.word	0x102e710c
102d2c7c:	102e7114 	.word	0x102e7114
102d2c80:	f03d57e4 	.word	0xf03d57e4
102d2c84:	102eeeb8 	.word	0x102eeeb8
102d2c88:	102eeecc 	.word	0x102eeecc
102d2c8c:	102eeed8 	.word	0x102eeed8
102d2c90:	f03d6214 	.word	0xf03d6214
102d2c94:	102eeee0 	.word	0x102eeee0
102d2c98:	102d5af4 	.word	0x102d5af4
102d2c9c:	102d456c 	.word	0x102d456c
102d2ca0:	102d3078 	.word	0x102d3078
102d2ca4:	102e5cb4 	.word	0x102e5cb4
102d2ca8:	000010c8 	.word	0x000010c8
102d2cac:	f03d5bdd 	.word	0xf03d5bdd

102d2cb0 <fileSys_SetFileSystem>:
	APP_DEBUG("\r<-- File System(SD) Selected! -->\r\n");
#endif
#endif

	// format Storage memory
	if(format == TRUE)
102d2cb0:	e3500001 	cmp	r0, #1
 *
 * RETURNS
 *
 *****************************************************************************/
s32 fileSys_SetFileSystem(bool format)
{
102d2cb4:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
102d2cb8:	e24dd00c 	sub	sp, sp, #12
	APP_DEBUG("\r<-- File System(SD) Selected! -->\r\n");
#endif
#endif

	// format Storage memory
	if(format == TRUE)
102d2cbc:	0a00003c 	beq	102d2db4 <fileSys_SetFileSystem+0x104>
			APP_DEBUG("\r<-- Format error. -->\r\n");
#endif
		}
	}
	//check freespace
	Free_space  = Ql_FS_GetFreeSpace(storage);
102d2cc0:	e59f3100 	ldr	r3, [pc, #256]	; 102d2dc8 <fileSys_SetFileSystem+0x118>
102d2cc4:	e3a00001 	mov	r0, #1
102d2cc8:	e12fff33 	blx	r3
102d2ccc:	e1a04000 	mov	r4, r0
102d2cd0:	e1a05001 	mov	r5, r1
	if(Free_space < 0)
102d2cd4:	e3540000 	cmp	r4, #0
102d2cd8:	e2d53000 	sbcs	r3, r5, #0
102d2cdc:	ba000037 	blt	102d2dc0 <fileSys_SetFileSystem+0x110>
#endif
		return -1;
	}

	//check total space
	Total_space = Ql_FS_GetTotalSpace(storage);
102d2ce0:	e59f30e4 	ldr	r3, [pc, #228]	; 102d2dcc <fileSys_SetFileSystem+0x11c>
102d2ce4:	e3a00001 	mov	r0, #1
102d2ce8:	e12fff33 	blx	r3
102d2cec:	e1a06000 	mov	r6, r0
102d2cf0:	e1a07001 	mov	r7, r1
	if(Total_space < 0)
102d2cf4:	e3560000 	cmp	r6, #0
102d2cf8:	e2d73000 	sbcs	r3, r7, #0
102d2cfc:	ba00002f 	blt	102d2dc0 <fileSys_SetFileSystem+0x110>
#endif
		return -1;
	}

#ifdef DEBUG_MSG
	APP_DEBUG("<-- STORAGE Free Space : %lld Byte's out of total %lld Byte's-->\r\n",Free_space, Total_space);
102d2d00:	e59f80c8 	ldr	r8, [pc, #200]	; 102d2dd0 <fileSys_SetFileSystem+0x120>
102d2d04:	e3a01000 	mov	r1, #0
102d2d08:	e3a02c02 	mov	r2, #512	; 0x200
102d2d0c:	e59fa0c0 	ldr	sl, [pc, #192]	; 102d2dd4 <fileSys_SetFileSystem+0x124>
102d2d10:	e59f00c0 	ldr	r0, [pc, #192]	; 102d2dd8 <fileSys_SetFileSystem+0x128>
102d2d14:	e12fff3a 	blx	sl
102d2d18:	e598c000 	ldr	ip, [r8]
102d2d1c:	e1a02004 	mov	r2, r4
102d2d20:	e59f10b4 	ldr	r1, [pc, #180]	; 102d2ddc <fileSys_SetFileSystem+0x12c>
102d2d24:	e1a03005 	mov	r3, r5
102d2d28:	e1cd60f0 	strd	r6, [sp]
102d2d2c:	e59f00a4 	ldr	r0, [pc, #164]	; 102d2dd8 <fileSys_SetFileSystem+0x128>
102d2d30:	e12fff3c 	blx	ip
102d2d34:	e59f30a4 	ldr	r3, [pc, #164]	; 102d2de0 <fileSys_SetFileSystem+0x130>
102d2d38:	e59f0098 	ldr	r0, [pc, #152]	; 102d2dd8 <fileSys_SetFileSystem+0x128>
102d2d3c:	e12fff33 	blx	r3
102d2d40:	e59f309c 	ldr	r3, [pc, #156]	; 102d2de4 <fileSys_SetFileSystem+0x134>
102d2d44:	e59f108c 	ldr	r1, [pc, #140]	; 102d2dd8 <fileSys_SetFileSystem+0x128>
102d2d48:	e1a02000 	mov	r2, r0
102d2d4c:	e3a0000a 	mov	r0, #10
102d2d50:	e12fff33 	blx	r3
#endif

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d2d54:	e3a01000 	mov	r1, #0
102d2d58:	e3a02064 	mov	r2, #100	; 0x64
102d2d5c:	e59f0084 	ldr	r0, [pc, #132]	; 102d2de8 <fileSys_SetFileSystem+0x138>
102d2d60:	e12fff3a 	blx	sl
	Ql_sprintf(filePath,"%s\\\0",(char*)PATH_ROOT);
102d2d64:	e59f1080 	ldr	r1, [pc, #128]	; 102d2dec <fileSys_SetFileSystem+0x13c>
102d2d68:	e59f2080 	ldr	r2, [pc, #128]	; 102d2df0 <fileSys_SetFileSystem+0x140>
102d2d6c:	e5983000 	ldr	r3, [r8]
102d2d70:	e59f0070 	ldr	r0, [pc, #112]	; 102d2de8 <fileSys_SetFileSystem+0x138>
102d2d74:	e12fff33 	blx	r3

	ret = Ql_FS_CheckDir(filePath);
102d2d78:	e59f0068 	ldr	r0, [pc, #104]	; 102d2de8 <fileSys_SetFileSystem+0x138>
102d2d7c:	e59f3070 	ldr	r3, [pc, #112]	; 102d2df4 <fileSys_SetFileSystem+0x144>
102d2d80:	e12fff33 	blx	r3
	if(ret != QL_RET_OK)
102d2d84:	e3500000 	cmp	r0, #0
102d2d88:	1a000002 	bne	102d2d98 <fileSys_SetFileSystem+0xe8>
	if(Free_space < 0)
	{
#ifdef FILE_STORAGE
		APP_DEBUG("<-- STORAGE NOT PRESENT -->\r\n");
#endif
		return -1;
102d2d8c:	e3a00000 	mov	r0, #0
#endif
			return -2;
		}
	}
	return ret;
}
102d2d90:	e28dd00c 	add	sp, sp, #12
102d2d94:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
	if(ret != QL_RET_OK)
	{
#ifdef FILE_STORAGE
		APP_DEBUG("\r<-- Dir(%s) is not exist, creating.... -->\r\n", filePath);
#endif
		ret  = Ql_FS_CreateDir(filePath);
102d2d98:	e59f0048 	ldr	r0, [pc, #72]	; 102d2de8 <fileSys_SetFileSystem+0x138>
102d2d9c:	e59f3054 	ldr	r3, [pc, #84]	; 102d2df8 <fileSys_SetFileSystem+0x148>
102d2da0:	e12fff33 	blx	r3
		if(ret != QL_RET_OK)
102d2da4:	e3500000 	cmp	r0, #0
102d2da8:	0afffff7 	beq	102d2d8c <fileSys_SetFileSystem+0xdc>
		{
#ifdef FILE_STORAGE
			APP_DEBUG("\r<-- failed!! Create Dir(%s) fail-->\r\n", filePath);
#endif
			return -2;
102d2dac:	e3e00001 	mvn	r0, #1
102d2db0:	eafffff6 	b	102d2d90 <fileSys_SetFileSystem+0xe0>
#endif

	// format Storage memory
	if(format == TRUE)
	{
		ret = Ql_FS_Format(storage);
102d2db4:	e59f3040 	ldr	r3, [pc, #64]	; 102d2dfc <fileSys_SetFileSystem+0x14c>
102d2db8:	e12fff33 	blx	r3
102d2dbc:	eaffffbf 	b	102d2cc0 <fileSys_SetFileSystem+0x10>
	if(Free_space < 0)
	{
#ifdef FILE_STORAGE
		APP_DEBUG("<-- STORAGE NOT PRESENT -->\r\n");
#endif
		return -1;
102d2dc0:	e3e00000 	mvn	r0, #0
102d2dc4:	eafffff1 	b	102d2d90 <fileSys_SetFileSystem+0xe0>
102d2dc8:	102e44a0 	.word	0x102e44a0
102d2dcc:	102e4514 	.word	0x102e4514
102d2dd0:	f03de540 	.word	0xf03de540
102d2dd4:	102e58f4 	.word	0x102e58f4
102d2dd8:	f03d5bfc 	.word	0xf03d5bfc
102d2ddc:	102eefa0 	.word	0x102eefa0
102d2de0:	102e57a4 	.word	0x102e57a4
102d2de4:	102e6230 	.word	0x102e6230
102d2de8:	f03db900 	.word	0xf03db900
102d2dec:	102e711c 	.word	0x102e711c
102d2df0:	102eefe4 	.word	0x102eefe4
102d2df4:	102e4440 	.word	0x102e4440
102d2df8:	102e43e0 	.word	0x102e43e0
102d2dfc:	102e4588 	.word	0x102e4588

102d2e00 <fileSys_OpenOrCreateFile>:
 *
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_OpenOrCreateFile(u8 *file_name)
{
102d2e00:	e92d4010 	push	{r4, lr}
	s32 ret = -1;
	s32 filehandle = -1;

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d2e04:	e3a01000 	mov	r1, #0
 *
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_OpenOrCreateFile(u8 *file_name)
{
102d2e08:	e1a04000 	mov	r4, r0
	s32 ret = -1;
	s32 filehandle = -1;

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d2e0c:	e3a02064 	mov	r2, #100	; 0x64
102d2e10:	e59f3048 	ldr	r3, [pc, #72]	; 102d2e60 <fileSys_OpenOrCreateFile+0x60>
102d2e14:	e59f0048 	ldr	r0, [pc, #72]	; 102d2e64 <fileSys_OpenOrCreateFile+0x64>
102d2e18:	e12fff33 	blx	r3
	Ql_sprintf(filePath,"%s\\%s\0", PATH_ROOT, file_name);
102d2e1c:	e59f0044 	ldr	r0, [pc, #68]	; 102d2e68 <fileSys_OpenOrCreateFile+0x68>
102d2e20:	e59f2044 	ldr	r2, [pc, #68]	; 102d2e6c <fileSys_OpenOrCreateFile+0x6c>
102d2e24:	e590c000 	ldr	ip, [r0]
102d2e28:	e1a03004 	mov	r3, r4
102d2e2c:	e59f103c 	ldr	r1, [pc, #60]	; 102d2e70 <fileSys_OpenOrCreateFile+0x70>
102d2e30:	e59f002c 	ldr	r0, [pc, #44]	; 102d2e64 <fileSys_OpenOrCreateFile+0x64>
102d2e34:	e12fff3c 	blx	ip

	//Creates a file
	ret = Ql_FS_Open(filePath, QL_FS_READ_WRITE|QL_FS_CREATE);
102d2e38:	e3a01801 	mov	r1, #65536	; 0x10000
102d2e3c:	e59f3030 	ldr	r3, [pc, #48]	; 102d2e74 <fileSys_OpenOrCreateFile+0x74>
102d2e40:	e59f001c 	ldr	r0, [pc, #28]	; 102d2e64 <fileSys_OpenOrCreateFile+0x64>
102d2e44:	e12fff33 	blx	r3
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Error File Open/Create : %s -->\r\n", filePath);
#endif
	}

	Ql_FS_Flush(filehandle);
102d2e48:	e59f3028 	ldr	r3, [pc, #40]	; 102d2e78 <fileSys_OpenOrCreateFile+0x78>

	Ql_memset(filePath, 0x0, sizeof(filePath));
	Ql_sprintf(filePath,"%s\\%s\0", PATH_ROOT, file_name);

	//Creates a file
	ret = Ql_FS_Open(filePath, QL_FS_READ_WRITE|QL_FS_CREATE);
102d2e4c:	e1a04000 	mov	r4, r0
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Error File Open/Create : %s -->\r\n", filePath);
#endif
	}

	Ql_FS_Flush(filehandle);
102d2e50:	e1800fc0 	orr	r0, r0, r0, asr #31
102d2e54:	e12fff33 	blx	r3

	return ret;
}
102d2e58:	e1a00004 	mov	r0, r4
102d2e5c:	e8bd8010 	pop	{r4, pc}
102d2e60:	102e58f4 	.word	0x102e58f4
102d2e64:	f03db900 	.word	0xf03db900
102d2e68:	f03de540 	.word	0xf03de540
102d2e6c:	102eefe4 	.word	0x102eefe4
102d2e70:	102e7124 	.word	0x102e7124
102d2e74:	102e4050 	.word	0x102e4050
102d2e78:	102e4218 	.word	0x102e4218

102d2e7c <fileSys_WriteFile>:
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_WriteFile(s32 filehandle, u8 *data_to_write, u8 write_type, u16 wtite_to_size)
{
	s32 ret = -1;
	if(write_type == CASCADE_WRITE)
102d2e7c:	e3520000 	cmp	r2, #0
                                      1 : OVER_WRITE_TO_SIZE
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_WriteFile(s32 filehandle, u8 *data_to_write, u8 write_type, u16 wtite_to_size)
{
102d2e80:	e92d4070 	push	{r4, r5, r6, lr}
102d2e84:	e1a05001 	mov	r5, r1
102d2e88:	e1a06000 	mov	r6, r0
	s32 ret = -1;
	if(write_type == CASCADE_WRITE)
	{
		ret = Ql_FS_Seek(filehandle, OFFSET , QL_FS_FILE_END);
102d2e8c:	01a01002 	moveq	r1, r2
                                      1 : OVER_WRITE_TO_SIZE
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_WriteFile(s32 filehandle, u8 *data_to_write, u8 write_type, u16 wtite_to_size)
{
102d2e90:	e1a04003 	mov	r4, r3
	s32 ret = -1;
	if(write_type == CASCADE_WRITE)
	{
		ret = Ql_FS_Seek(filehandle, OFFSET , QL_FS_FILE_END);
102d2e94:	03a02002 	moveq	r2, #2
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_WriteFile(s32 filehandle, u8 *data_to_write, u8 write_type, u16 wtite_to_size)
{
	s32 ret = -1;
	if(write_type == CASCADE_WRITE)
102d2e98:	0a000014 	beq	102d2ef0 <fileSys_WriteFile+0x74>
#ifdef FILE_STORAGE
			APP_DEBUG("<-- Error in File Write [CASCADE_WRITE] = %d-->\r\n", ret);
#endif
		}
	}
	else if(write_type == OVER_WRITE)
102d2e9c:	e3520001 	cmp	r2, #1
102d2ea0:	0a000010 	beq	102d2ee8 <fileSys_WriteFile+0x6c>
#ifdef FILE_STORAGE
			APP_DEBUG("<-- Error in File Write [OVER_WRITE] = %d-->\r\n", ret);
#endif
		}
	}
	else if(write_type == OVER_WRITE_TO_SIZE && wtite_to_size)
102d2ea4:	e2933000 	adds	r3, r3, #0
102d2ea8:	13a03001 	movne	r3, #1
102d2eac:	e3520002 	cmp	r2, #2
102d2eb0:	13a03000 	movne	r3, #0
102d2eb4:	e3530000 	cmp	r3, #0
102d2eb8:	0a000018 	beq	102d2f20 <fileSys_WriteFile+0xa4>
	{
		//Move the file pointer to the starting position.
		ret=Ql_FS_Seek(filehandle, OFFSET , QL_FS_FILE_BEGIN);
102d2ebc:	e3a01000 	mov	r1, #0
102d2ec0:	e1a02001 	mov	r2, r1
102d2ec4:	e59f305c 	ldr	r3, [pc, #92]	; 102d2f28 <fileSys_WriteFile+0xac>
102d2ec8:	e12fff33 	blx	r3
#ifdef FILE_STORAGE
			APP_DEBUG("<-- Error File Ql_FS_Seek [OVER_WRITE_TO_SIZE] ret : %d -->\r\n", ret);
#endif
		}

		ret=Ql_FS_Write(filehandle, data_to_write, wtite_to_size, &writeedlen);
102d2ecc:	e1a00006 	mov	r0, r6
102d2ed0:	e1a01005 	mov	r1, r5
102d2ed4:	e1a02004 	mov	r2, r4
102d2ed8:	e59f304c 	ldr	r3, [pc, #76]	; 102d2f2c <fileSys_WriteFile+0xb0>
102d2edc:	e59fc04c 	ldr	ip, [pc, #76]	; 102d2f30 <fileSys_WriteFile+0xb4>
102d2ee0:	e12fff3c 	blx	ip
102d2ee4:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}
	else if(write_type == OVER_WRITE)
	{
		//Move the file pointer to the starting position.
		ret=Ql_FS_Seek(filehandle, OFFSET , QL_FS_FILE_BEGIN);
102d2ee8:	e3a01000 	mov	r1, #0
102d2eec:	e1a02001 	mov	r2, r1
102d2ef0:	e59f3030 	ldr	r3, [pc, #48]	; 102d2f28 <fileSys_WriteFile+0xac>
102d2ef4:	e12fff33 	blx	r3
#ifdef FILE_STORAGE
			APP_DEBUG("<-- Error File Ql_FS_Seek [OVER_WRITE] ret : %d -->\r\n", ret);
#endif
		}

		ret=Ql_FS_Write(filehandle, data_to_write, Ql_strlen((char*)data_to_write), &writeedlen);
102d2ef8:	e1a00005 	mov	r0, r5
102d2efc:	e59f3030 	ldr	r3, [pc, #48]	; 102d2f34 <fileSys_WriteFile+0xb8>
102d2f00:	e12fff33 	blx	r3
102d2f04:	e1a01005 	mov	r1, r5
102d2f08:	e59f301c 	ldr	r3, [pc, #28]	; 102d2f2c <fileSys_WriteFile+0xb0>
102d2f0c:	e59fc01c 	ldr	ip, [pc, #28]	; 102d2f30 <fileSys_WriteFile+0xb4>
102d2f10:	e1a02000 	mov	r2, r0
102d2f14:	e1a00006 	mov	r0, r6
102d2f18:	e12fff3c 	blx	ip
102d2f1c:	e8bd8070 	pop	{r4, r5, r6, pc}
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_WriteFile(s32 filehandle, u8 *data_to_write, u8 write_type, u16 wtite_to_size)
{
	s32 ret = -1;
102d2f20:	e3e00000 	mvn	r0, #0
#endif
	}
	data_to_write = NULL;

	return ret;
}
102d2f24:	e8bd8070 	pop	{r4, r5, r6, pc}
102d2f28:	102e41a8 	.word	0x102e41a8
102d2f2c:	f03db8f0 	.word	0xf03db8f0
102d2f30:	102e4130 	.word	0x102e4130
102d2f34:	102e57a4 	.word	0x102e57a4

102d2f38 <fileSys_checkFile>:
 *
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_checkFile(u8 *file_name)
{
102d2f38:	e92d4038 	push	{r3, r4, r5, lr}
	s32 ret = -1;

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d2f3c:	e59f4040 	ldr	r4, [pc, #64]	; 102d2f84 <fileSys_checkFile+0x4c>
 *
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_checkFile(u8 *file_name)
{
102d2f40:	e1a05000 	mov	r5, r0
	s32 ret = -1;

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d2f44:	e3a01000 	mov	r1, #0
102d2f48:	e3a02064 	mov	r2, #100	; 0x64
102d2f4c:	e1a00004 	mov	r0, r4
102d2f50:	e59f3030 	ldr	r3, [pc, #48]	; 102d2f88 <fileSys_checkFile+0x50>
102d2f54:	e12fff33 	blx	r3
	Ql_sprintf(filePath,"%s\\%s\0", PATH_ROOT, file_name);
102d2f58:	e59f302c 	ldr	r3, [pc, #44]	; 102d2f8c <fileSys_checkFile+0x54>
102d2f5c:	e1a00004 	mov	r0, r4
102d2f60:	e593c000 	ldr	ip, [r3]
102d2f64:	e59f1024 	ldr	r1, [pc, #36]	; 102d2f90 <fileSys_checkFile+0x58>
102d2f68:	e1a03005 	mov	r3, r5
102d2f6c:	e59f2020 	ldr	r2, [pc, #32]	; 102d2f94 <fileSys_checkFile+0x5c>
102d2f70:	e12fff3c 	blx	ip

	ret = Ql_FS_Check(filePath);
102d2f74:	e1a00004 	mov	r0, r4
102d2f78:	e59f3018 	ldr	r3, [pc, #24]	; 102d2f98 <fileSys_checkFile+0x60>
102d2f7c:	e12fff33 	blx	r3

	return ret;
}
102d2f80:	e8bd8038 	pop	{r3, r4, r5, pc}
102d2f84:	f03db900 	.word	0xf03db900
102d2f88:	102e58f4 	.word	0x102e58f4
102d2f8c:	f03de540 	.word	0xf03de540
102d2f90:	102e7124 	.word	0x102e7124
102d2f94:	102eefe4 	.word	0x102eefe4
102d2f98:	102e4380 	.word	0x102e4380

102d2f9c <fileSys_CloseFile>:
 * PARAMETERS
 *
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
102d2f9c:	e92d4008 	push	{r3, lr}
	//Close the file
	Ql_FS_Close(filehandle);
102d2fa0:	e59f3004 	ldr	r3, [pc, #4]	; 102d2fac <fileSys_CloseFile+0x10>
102d2fa4:	e12fff33 	blx	r3
102d2fa8:	e8bd8008 	pop	{r3, pc}
102d2fac:	102e426c 	.word	0x102e426c

102d2fb0 <fileSys_deleteFile>:
 *
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_deleteFile(u8 *file_name)
{
102d2fb0:	e92d4038 	push	{r3, r4, r5, lr}
	s32 ret = -1;

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d2fb4:	e59f4040 	ldr	r4, [pc, #64]	; 102d2ffc <fileSys_deleteFile+0x4c>
 *
 * RETURNS
 *  <ret>     SUCCESS or ERROR value
 *****************************************************************************/
s32 fileSys_deleteFile(u8 *file_name)
{
102d2fb8:	e1a05000 	mov	r5, r0
	s32 ret = -1;

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d2fbc:	e3a01000 	mov	r1, #0
102d2fc0:	e3a02064 	mov	r2, #100	; 0x64
102d2fc4:	e1a00004 	mov	r0, r4
102d2fc8:	e59f3030 	ldr	r3, [pc, #48]	; 102d3000 <fileSys_deleteFile+0x50>
102d2fcc:	e12fff33 	blx	r3
	Ql_sprintf(filePath,"%s\\%s\0", PATH_ROOT, file_name);
102d2fd0:	e59f302c 	ldr	r3, [pc, #44]	; 102d3004 <fileSys_deleteFile+0x54>
102d2fd4:	e1a00004 	mov	r0, r4
102d2fd8:	e593c000 	ldr	ip, [r3]
102d2fdc:	e59f1024 	ldr	r1, [pc, #36]	; 102d3008 <fileSys_deleteFile+0x58>
102d2fe0:	e1a03005 	mov	r3, r5
102d2fe4:	e59f2020 	ldr	r2, [pc, #32]	; 102d300c <fileSys_deleteFile+0x5c>
102d2fe8:	e12fff3c 	blx	ip

	ret = Ql_FS_Delete(filePath);
102d2fec:	e1a00004 	mov	r0, r4
102d2ff0:	e59f3018 	ldr	r3, [pc, #24]	; 102d3010 <fileSys_deleteFile+0x60>
102d2ff4:	e12fff33 	blx	r3
	{
		APP_DEBUG("\r\n<-- Error : Ql_FS_Delete %s ret : %d-->\r\n", __FUNCTION__, ret);
	}
#endif
	return ret;
}
102d2ff8:	e8bd8038 	pop	{r3, r4, r5, pc}
102d2ffc:	f03db900 	.word	0xf03db900
102d3000:	102e58f4 	.word	0x102e58f4
102d3004:	f03de540 	.word	0xf03de540
102d3008:	102e7124 	.word	0x102e7124
102d300c:	102eefe4 	.word	0x102eefe4
102d3010:	102e4320 	.word	0x102e4320

102d3014 <fileSys_getFileSize>:
 *
 * RETURNS
 *  <ret>     File size in bytes
 *****************************************************************************/
s32 fileSys_getFileSize(u8 *file_name)
{
102d3014:	e92d4010 	push	{r4, lr}
	s32 ret = -1;

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d3018:	e3a01000 	mov	r1, #0
 *
 * RETURNS
 *  <ret>     File size in bytes
 *****************************************************************************/
s32 fileSys_getFileSize(u8 *file_name)
{
102d301c:	e1a04000 	mov	r4, r0
	s32 ret = -1;

	Ql_memset(filePath, 0x0, sizeof(filePath));
102d3020:	e3a02064 	mov	r2, #100	; 0x64
102d3024:	e59f3034 	ldr	r3, [pc, #52]	; 102d3060 <fileSys_getFileSize+0x4c>
102d3028:	e59f0034 	ldr	r0, [pc, #52]	; 102d3064 <fileSys_getFileSize+0x50>
102d302c:	e12fff33 	blx	r3
	Ql_sprintf(filePath,"%s\\%s\0", PATH_ROOT, file_name);
102d3030:	e59f0030 	ldr	r0, [pc, #48]	; 102d3068 <fileSys_getFileSize+0x54>
102d3034:	e59f1030 	ldr	r1, [pc, #48]	; 102d306c <fileSys_getFileSize+0x58>
102d3038:	e590c000 	ldr	ip, [r0]
102d303c:	e59f202c 	ldr	r2, [pc, #44]	; 102d3070 <fileSys_getFileSize+0x5c>
102d3040:	e1a03004 	mov	r3, r4
102d3044:	e59f0018 	ldr	r0, [pc, #24]	; 102d3064 <fileSys_getFileSize+0x50>
102d3048:	e12fff3c 	blx	ip
	ret = Ql_FS_GetSize(filePath);
102d304c:	e59f3020 	ldr	r3, [pc, #32]	; 102d3074 <fileSys_getFileSize+0x60>
102d3050:	e59f000c 	ldr	r0, [pc, #12]	; 102d3064 <fileSys_getFileSize+0x50>
102d3054:	e12fff33 	blx	r3
#endif
		return -1;
	}

	return ret;
}
102d3058:	e1800fc0 	orr	r0, r0, r0, asr #31
102d305c:	e8bd8010 	pop	{r4, pc}
102d3060:	102e58f4 	.word	0x102e58f4
102d3064:	f03db900 	.word	0xf03db900
102d3068:	f03de540 	.word	0xf03de540
102d306c:	102e7124 	.word	0x102e7124
102d3070:	102eefe4 	.word	0x102eefe4
102d3074:	102e42c0 	.word	0x102e42c0

102d3078 <Store_Persistent_Data>:
//8. Empty and available for future use
//9. Empty and available for future use
//10. Empty and available for future use
//Each persistent parameter starts with '{'
s32 Store_Persistent_Data(void)
{
102d3078:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
102d307c:	e24ddc01 	sub	sp, sp, #256	; 0x100
	char temp[256] = {0};
102d3080:	e59f3470 	ldr	r3, [pc, #1136]	; 102d34f8 <Store_Persistent_Data+0x480>
102d3084:	e3a01000 	mov	r1, #0
102d3088:	e3a02c01 	mov	r2, #256	; 0x100
102d308c:	e1a0000d 	mov	r0, sp
	s32 ret = -1;
	s32 file_handle = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--Store to Persistent Parameters File -->\n\r");
102d3090:	e59f4464 	ldr	r4, [pc, #1124]	; 102d34fc <Store_Persistent_Data+0x484>
//9. Empty and available for future use
//10. Empty and available for future use
//Each persistent parameter starts with '{'
s32 Store_Persistent_Data(void)
{
	char temp[256] = {0};
102d3094:	e12fff33 	blx	r3
	s32 ret = -1;
	s32 file_handle = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--Store to Persistent Parameters File -->\n\r");
102d3098:	e59f7460 	ldr	r7, [pc, #1120]	; 102d3500 <Store_Persistent_Data+0x488>
102d309c:	e3a02c02 	mov	r2, #512	; 0x200
102d30a0:	e3a01000 	mov	r1, #0
102d30a4:	e59f0458 	ldr	r0, [pc, #1112]	; 102d3504 <Store_Persistent_Data+0x48c>
102d30a8:	e12fff37 	blx	r7
102d30ac:	e5943000 	ldr	r3, [r4]
102d30b0:	e59f1450 	ldr	r1, [pc, #1104]	; 102d3508 <Store_Persistent_Data+0x490>
102d30b4:	e59f0448 	ldr	r0, [pc, #1096]	; 102d3504 <Store_Persistent_Data+0x48c>
102d30b8:	e12fff33 	blx	r3
102d30bc:	e59f6448 	ldr	r6, [pc, #1096]	; 102d350c <Store_Persistent_Data+0x494>
102d30c0:	e59f043c 	ldr	r0, [pc, #1084]	; 102d3504 <Store_Persistent_Data+0x48c>
102d30c4:	e12fff36 	blx	r6
102d30c8:	e59f5440 	ldr	r5, [pc, #1088]	; 102d3510 <Store_Persistent_Data+0x498>
102d30cc:	e59f1430 	ldr	r1, [pc, #1072]	; 102d3504 <Store_Persistent_Data+0x48c>
102d30d0:	e1a02000 	mov	r2, r0
102d30d4:	e3a0000a 	mov	r0, #10
102d30d8:	e12fff35 	blx	r5
#endif
	//create file.. if not available or open the file if avaialble
	file_handle = fileSys_OpenOrCreateFile((u8 *)file_devicedata);
102d30dc:	e59f3430 	ldr	r3, [pc, #1072]	; 102d3514 <Store_Persistent_Data+0x49c>
102d30e0:	e5930000 	ldr	r0, [r3]
102d30e4:	ebffff45 	bl	102d2e00 <fileSys_OpenOrCreateFile>
	if(file_handle >= QL_RET_OK)
102d30e8:	e2509000 	subs	r9, r0, #0
102d30ec:	ba0000ff 	blt	102d34f0 <Store_Persistent_Data+0x478>
	{
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Writing Persistent Parameters ..\n\r");
#endif
		//1. Last sucessful cloud Connected time stamp in UTC
		Ql_sprintf(temp,"{%s",last_connectedtime);
102d30f0:	e5943000 	ldr	r3, [r4]
102d30f4:	e1a0000d 	mov	r0, sp
102d30f8:	e59f1418 	ldr	r1, [pc, #1048]	; 102d3518 <Store_Persistent_Data+0x4a0>
102d30fc:	e59f2418 	ldr	r2, [pc, #1048]	; 102d351c <Store_Persistent_Data+0x4a4>
102d3100:	e12fff33 	blx	r3
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d3104:	e5dd3001 	ldrb	r3, [sp, #1]
102d3108:	e3530000 	cmp	r3, #0
102d310c:	1a0000cf 	bne	102d3450 <Store_Persistent_Data+0x3d8>
			strcpy(persistent_parameter_array[0],temp);
		else
		{
			if(persistent_parameter_array[0][0] != '{') // if it is an invalid parameter mark it
102d3110:	e59f8408 	ldr	r8, [pc, #1032]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d3114:	e5d82000 	ldrb	r2, [r8]
102d3118:	e352007b 	cmp	r2, #123	; 0x7b
			{
				persistent_parameter_array[0][0] = '{';
102d311c:	13a0207b 	movne	r2, #123	; 0x7b
102d3120:	15c82000 	strbne	r2, [r8]
				persistent_parameter_array[0][1] = '\0';
102d3124:	15c83001 	strbne	r3, [r8, #1]
			}
		}
#ifdef DEBUG_MSG
		APP_DEBUG("1. Last Connected Time      --> %s\n\r",persistent_parameter_array[0]);
102d3128:	e59fa3f0 	ldr	sl, [pc, #1008]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d312c:	e3a01000 	mov	r1, #0
102d3130:	e3a02c02 	mov	r2, #512	; 0x200
102d3134:	e59f03c8 	ldr	r0, [pc, #968]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3138:	e12fff37 	blx	r7
102d313c:	e5943000 	ldr	r3, [r4]
102d3140:	e59f13dc 	ldr	r1, [pc, #988]	; 102d3524 <Store_Persistent_Data+0x4ac>
102d3144:	e1a0200a 	mov	r2, sl
102d3148:	e59f03b4 	ldr	r0, [pc, #948]	; 102d3504 <Store_Persistent_Data+0x48c>
102d314c:	e12fff33 	blx	r3
102d3150:	e59f03ac 	ldr	r0, [pc, #940]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3154:	e12fff36 	blx	r6
102d3158:	e59f13a4 	ldr	r1, [pc, #932]	; 102d3504 <Store_Persistent_Data+0x48c>
102d315c:	e1a02000 	mov	r2, r0
102d3160:	e3a0000a 	mov	r0, #10
102d3164:	e12fff35 	blx	r5
#endif
		//2. GPS information in terms of Lattitude and Longitude read out of Cellular service provider communicatoin
		Ql_sprintf(temp,"{%s,%s",latitude_,longitude_);
102d3168:	e59f33b8 	ldr	r3, [pc, #952]	; 102d3528 <Store_Persistent_Data+0x4b0>
102d316c:	e594c000 	ldr	ip, [r4]
102d3170:	e1a0000d 	mov	r0, sp
102d3174:	e59f13b0 	ldr	r1, [pc, #944]	; 102d352c <Store_Persistent_Data+0x4b4>
102d3178:	e59f23b0 	ldr	r2, [pc, #944]	; 102d3530 <Store_Persistent_Data+0x4b8>
102d317c:	e12fff3c 	blx	ip
		if(temp[1] != '\0' && temp[1] != ',') //Update the last stored parameter only if the parameter is not NULL
102d3180:	e5dd3001 	ldrb	r3, [sp, #1]
102d3184:	e353002c 	cmp	r3, #44	; 0x2c
102d3188:	13530000 	cmpne	r3, #0
102d318c:	03a03000 	moveq	r3, #0
102d3190:	13a03001 	movne	r3, #1
102d3194:	1a0000c7 	bne	102d34b8 <Store_Persistent_Data+0x440>
			strcpy(persistent_parameter_array[1],temp);
		else
		{
			if(persistent_parameter_array[1][0] != '{') // if it is an invalid parameter mark it
102d3198:	e5da2032 	ldrb	r2, [sl, #50]	; 0x32
102d319c:	e352007b 	cmp	r2, #123	; 0x7b
			{
				persistent_parameter_array[1][0] = '{';
102d31a0:	13a0207b 	movne	r2, #123	; 0x7b
102d31a4:	15ca2032 	strbne	r2, [sl, #50]	; 0x32
				persistent_parameter_array[1][1] = '\0';
102d31a8:	15ca3033 	strbne	r3, [sl, #51]	; 0x33
			}
		}
#ifdef DEBUG_MSG
		APP_DEBUG("2. GPS Co-ordinates         --> %s\n\r",persistent_parameter_array[1]);
102d31ac:	e3a01000 	mov	r1, #0
102d31b0:	e3a02c02 	mov	r2, #512	; 0x200
102d31b4:	e59f0348 	ldr	r0, [pc, #840]	; 102d3504 <Store_Persistent_Data+0x48c>
102d31b8:	e12fff37 	blx	r7
102d31bc:	e5943000 	ldr	r3, [r4]
102d31c0:	e59f136c 	ldr	r1, [pc, #876]	; 102d3534 <Store_Persistent_Data+0x4bc>
102d31c4:	e59f236c 	ldr	r2, [pc, #876]	; 102d3538 <Store_Persistent_Data+0x4c0>
102d31c8:	e59f0334 	ldr	r0, [pc, #820]	; 102d3504 <Store_Persistent_Data+0x48c>
102d31cc:	e12fff33 	blx	r3
102d31d0:	e59f032c 	ldr	r0, [pc, #812]	; 102d3504 <Store_Persistent_Data+0x48c>
102d31d4:	e12fff36 	blx	r6
102d31d8:	e59f1324 	ldr	r1, [pc, #804]	; 102d3504 <Store_Persistent_Data+0x48c>
102d31dc:	e1a02000 	mov	r2, r0
102d31e0:	e3a0000a 	mov	r0, #10
102d31e4:	e12fff35 	blx	r5
#endif

		//3. Last Water Balance Recharge amount
		Ql_sprintf(temp,"{%s",cmdrcbal);
102d31e8:	e5943000 	ldr	r3, [r4]
102d31ec:	e1a0000d 	mov	r0, sp
102d31f0:	e59f1320 	ldr	r1, [pc, #800]	; 102d3518 <Store_Persistent_Data+0x4a0>
102d31f4:	e59f2340 	ldr	r2, [pc, #832]	; 102d353c <Store_Persistent_Data+0x4c4>
102d31f8:	e12fff33 	blx	r3
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d31fc:	e5dd3001 	ldrb	r3, [sp, #1]
102d3200:	e3530000 	cmp	r3, #0
102d3204:	1a0000a6 	bne	102d34a4 <Store_Persistent_Data+0x42c>
			strcpy(persistent_parameter_array[2],temp);
		else
		{
			if(persistent_parameter_array[2][0] != '{') // if it is an invalid parameter mark it
102d3208:	e5d81064 	ldrb	r1, [r8, #100]	; 0x64
102d320c:	e59f230c 	ldr	r2, [pc, #780]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d3210:	e351007b 	cmp	r1, #123	; 0x7b
			{
				persistent_parameter_array[2][0] = '{';
102d3214:	13a0107b 	movne	r1, #123	; 0x7b
102d3218:	15c21064 	strbne	r1, [r2, #100]	; 0x64
				persistent_parameter_array[2][1] = '\0';
102d321c:	15c23065 	strbne	r3, [r2, #101]	; 0x65
			}
		}
#ifdef DEBUG_MSG
		APP_DEBUG("3. Last Recharge value      --> %s\n\r",persistent_parameter_array[2]);
102d3220:	e3a01000 	mov	r1, #0
102d3224:	e3a02c02 	mov	r2, #512	; 0x200
102d3228:	e59f02d4 	ldr	r0, [pc, #724]	; 102d3504 <Store_Persistent_Data+0x48c>
102d322c:	e12fff37 	blx	r7
102d3230:	e5943000 	ldr	r3, [r4]
102d3234:	e59f1304 	ldr	r1, [pc, #772]	; 102d3540 <Store_Persistent_Data+0x4c8>
102d3238:	e59f2304 	ldr	r2, [pc, #772]	; 102d3544 <Store_Persistent_Data+0x4cc>
102d323c:	e59f02c0 	ldr	r0, [pc, #704]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3240:	e12fff33 	blx	r3
102d3244:	e59f02b8 	ldr	r0, [pc, #696]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3248:	e12fff36 	blx	r6
102d324c:	e59f12b0 	ldr	r1, [pc, #688]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3250:	e1a02000 	mov	r2, r0
102d3254:	e3a0000a 	mov	r0, #10
102d3258:	e12fff35 	blx	r5
#endif

		//4. Last Water Balance Recharge ID
		Ql_sprintf(temp,"{%s",Received_RCID);
102d325c:	e5943000 	ldr	r3, [r4]
102d3260:	e1a0000d 	mov	r0, sp
102d3264:	e59f12ac 	ldr	r1, [pc, #684]	; 102d3518 <Store_Persistent_Data+0x4a0>
102d3268:	e59f22d8 	ldr	r2, [pc, #728]	; 102d3548 <Store_Persistent_Data+0x4d0>
102d326c:	e12fff33 	blx	r3
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d3270:	e5dd3001 	ldrb	r3, [sp, #1]
102d3274:	e3530000 	cmp	r3, #0
102d3278:	1a000084 	bne	102d3490 <Store_Persistent_Data+0x418>
			strcpy(persistent_parameter_array[3],temp);
		else
		{
			if(persistent_parameter_array[3][0] != '{') // if it is an invalid parameter mark it
102d327c:	e5d81096 	ldrb	r1, [r8, #150]	; 0x96
102d3280:	e59f2298 	ldr	r2, [pc, #664]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d3284:	e351007b 	cmp	r1, #123	; 0x7b
			{
				persistent_parameter_array[3][0] = '{';
102d3288:	13a0107b 	movne	r1, #123	; 0x7b
102d328c:	15c21096 	strbne	r1, [r2, #150]	; 0x96
				persistent_parameter_array[3][1] = '\0';
102d3290:	15c23097 	strbne	r3, [r2, #151]	; 0x97
			}
		}
#ifdef DEBUG_MSG
		APP_DEBUG("4. Last Recharge ID         --> %s\n\r",persistent_parameter_array[3]);
102d3294:	e3a01000 	mov	r1, #0
102d3298:	e3a02c02 	mov	r2, #512	; 0x200
102d329c:	e59f0260 	ldr	r0, [pc, #608]	; 102d3504 <Store_Persistent_Data+0x48c>
102d32a0:	e12fff37 	blx	r7
102d32a4:	e5943000 	ldr	r3, [r4]
102d32a8:	e59f129c 	ldr	r1, [pc, #668]	; 102d354c <Store_Persistent_Data+0x4d4>
102d32ac:	e59f229c 	ldr	r2, [pc, #668]	; 102d3550 <Store_Persistent_Data+0x4d8>
102d32b0:	e59f024c 	ldr	r0, [pc, #588]	; 102d3504 <Store_Persistent_Data+0x48c>
102d32b4:	e12fff33 	blx	r3
102d32b8:	e59f0244 	ldr	r0, [pc, #580]	; 102d3504 <Store_Persistent_Data+0x48c>
102d32bc:	e12fff36 	blx	r6
102d32c0:	e59f123c 	ldr	r1, [pc, #572]	; 102d3504 <Store_Persistent_Data+0x48c>
102d32c4:	e1a02000 	mov	r2, r0
102d32c8:	e3a0000a 	mov	r0, #10
102d32cc:	e12fff35 	blx	r5
#endif

		//5. Last Water Balance Recharge Time Stamp
		Ql_sprintf(temp,"{%s",Received_RCTS);
102d32d0:	e5943000 	ldr	r3, [r4]
102d32d4:	e1a0000d 	mov	r0, sp
102d32d8:	e59f1238 	ldr	r1, [pc, #568]	; 102d3518 <Store_Persistent_Data+0x4a0>
102d32dc:	e59f2270 	ldr	r2, [pc, #624]	; 102d3554 <Store_Persistent_Data+0x4dc>
102d32e0:	e12fff33 	blx	r3
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d32e4:	e5dd3001 	ldrb	r3, [sp, #1]
102d32e8:	e3530000 	cmp	r3, #0
102d32ec:	1a000062 	bne	102d347c <Store_Persistent_Data+0x404>
			strcpy(persistent_parameter_array[4],temp);
		else
		{
			if(persistent_parameter_array[4][0] != '{') // if it is an invalid parameter mark it
102d32f0:	e5d810c8 	ldrb	r1, [r8, #200]	; 0xc8
102d32f4:	e59f2224 	ldr	r2, [pc, #548]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d32f8:	e351007b 	cmp	r1, #123	; 0x7b
			{
				persistent_parameter_array[4][0] = '{';
102d32fc:	13a0107b 	movne	r1, #123	; 0x7b
102d3300:	15c210c8 	strbne	r1, [r2, #200]	; 0xc8
				persistent_parameter_array[4][1] = '\0';
102d3304:	15c230c9 	strbne	r3, [r2, #201]	; 0xc9
			}
		}
#ifdef DEBUG_MSG
		APP_DEBUG("5. Last Recharge Time Stamp --> %s\n\r",persistent_parameter_array[4]);
102d3308:	e3a01000 	mov	r1, #0
102d330c:	e3a02c02 	mov	r2, #512	; 0x200
102d3310:	e59f01ec 	ldr	r0, [pc, #492]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3314:	e12fff37 	blx	r7
102d3318:	e5943000 	ldr	r3, [r4]
102d331c:	e59f1234 	ldr	r1, [pc, #564]	; 102d3558 <Store_Persistent_Data+0x4e0>
102d3320:	e59f2234 	ldr	r2, [pc, #564]	; 102d355c <Store_Persistent_Data+0x4e4>
102d3324:	e59f01d8 	ldr	r0, [pc, #472]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3328:	e12fff33 	blx	r3
102d332c:	e59f01d0 	ldr	r0, [pc, #464]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3330:	e12fff36 	blx	r6
102d3334:	e59f11c8 	ldr	r1, [pc, #456]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3338:	e1a02000 	mov	r2, r0
102d333c:	e3a0000a 	mov	r0, #10
102d3340:	e12fff35 	blx	r5
#endif

		//6. Language COnfigured
		Ql_sprintf(temp,"{%d",language_index);
102d3344:	e59f2214 	ldr	r2, [pc, #532]	; 102d3560 <Store_Persistent_Data+0x4e8>
102d3348:	e5943000 	ldr	r3, [r4]
102d334c:	e1a0000d 	mov	r0, sp
102d3350:	e59f120c 	ldr	r1, [pc, #524]	; 102d3564 <Store_Persistent_Data+0x4ec>
102d3354:	e5922000 	ldr	r2, [r2]
102d3358:	e12fff33 	blx	r3
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d335c:	e5dd3001 	ldrb	r3, [sp, #1]
102d3360:	e3530000 	cmp	r3, #0
102d3364:	1a00003f 	bne	102d3468 <Store_Persistent_Data+0x3f0>
			strcpy(persistent_parameter_array[5],temp);
		else
		{
			if(persistent_parameter_array[5][0] != '{') // if it is an invalid parameter mark it as default ENGLISH language
102d3368:	e5d810fa 	ldrb	r1, [r8, #250]	; 0xfa
102d336c:	e59f21ac 	ldr	r2, [pc, #428]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d3370:	e351007b 	cmp	r1, #123	; 0x7b
			{
				persistent_parameter_array[5][0] = '{';
102d3374:	13a0107b 	movne	r1, #123	; 0x7b
102d3378:	15c210fa 	strbne	r1, [r2, #250]	; 0xfa
				persistent_parameter_array[5][1] = '0';
102d337c:	13a01030 	movne	r1, #48	; 0x30
102d3380:	15c210fb 	strbne	r1, [r2, #251]	; 0xfb
				persistent_parameter_array[5][2] = '\0';
102d3384:	15c230fc 	strbne	r3, [r2, #252]	; 0xfc
			}
		}
#ifdef DEBUG_MSG
		APP_DEBUG("6. Language Configured      --> ");
102d3388:	e3a02c02 	mov	r2, #512	; 0x200
102d338c:	e3a01000 	mov	r1, #0
102d3390:	e59f016c 	ldr	r0, [pc, #364]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3394:	e12fff37 	blx	r7
102d3398:	e5943000 	ldr	r3, [r4]
102d339c:	e59f11c4 	ldr	r1, [pc, #452]	; 102d3568 <Store_Persistent_Data+0x4f0>
102d33a0:	e59f015c 	ldr	r0, [pc, #348]	; 102d3504 <Store_Persistent_Data+0x48c>
102d33a4:	e12fff33 	blx	r3
102d33a8:	e59f0154 	ldr	r0, [pc, #340]	; 102d3504 <Store_Persistent_Data+0x48c>
102d33ac:	e12fff36 	blx	r6
102d33b0:	e59f114c 	ldr	r1, [pc, #332]	; 102d3504 <Store_Persistent_Data+0x48c>
102d33b4:	e59f6140 	ldr	r6, [pc, #320]	; 102d34fc <Store_Persistent_Data+0x484>
102d33b8:	e59f4150 	ldr	r4, [pc, #336]	; 102d3510 <Store_Persistent_Data+0x498>
102d33bc:	e1a02000 	mov	r2, r0
102d33c0:	e3a0000a 	mov	r0, #10
102d33c4:	e12fff35 	blx	r5
		if(persistent_parameter_array[5][1] == '0')
102d33c8:	e5d830fb 	ldrb	r3, [r8, #251]	; 0xfb
				persistent_parameter_array[5][1] = '0';
				persistent_parameter_array[5][2] = '\0';
			}
		}
#ifdef DEBUG_MSG
		APP_DEBUG("6. Language Configured      --> ");
102d33cc:	e59fc12c 	ldr	ip, [pc, #300]	; 102d3500 <Store_Persistent_Data+0x488>
		if(persistent_parameter_array[5][1] == '0')
102d33d0:	e3530030 	cmp	r3, #48	; 0x30
		{
			APP_DEBUG("ENGLISH \n\r");
102d33d4:	e3a02c02 	mov	r2, #512	; 0x200
102d33d8:	e3a01000 	mov	r1, #0
102d33dc:	e59f0120 	ldr	r0, [pc, #288]	; 102d3504 <Store_Persistent_Data+0x48c>
				persistent_parameter_array[5][1] = '0';
				persistent_parameter_array[5][2] = '\0';
			}
		}
#ifdef DEBUG_MSG
		APP_DEBUG("6. Language Configured      --> ");
102d33e0:	e59f5124 	ldr	r5, [pc, #292]	; 102d350c <Store_Persistent_Data+0x494>
		if(persistent_parameter_array[5][1] == '0')
102d33e4:	0a00003b 	beq	102d34d8 <Store_Persistent_Data+0x460>
		{
			APP_DEBUG("ENGLISH \n\r");
		}
		else if(persistent_parameter_array[5][1] == '1')
102d33e8:	e3530031 	cmp	r3, #49	; 0x31
102d33ec:	0a000036 	beq	102d34cc <Store_Persistent_Data+0x454>
		{
			APP_DEBUG("BAHASA \n\r");
		}
		else
		{
			APP_DEBUG("INVALID \n\r");
102d33f0:	e12fff3c 	blx	ip
102d33f4:	e59f1170 	ldr	r1, [pc, #368]	; 102d356c <Store_Persistent_Data+0x4f4>
102d33f8:	e5963000 	ldr	r3, [r6]
102d33fc:	e59f0100 	ldr	r0, [pc, #256]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3400:	e12fff33 	blx	r3
102d3404:	e59f00f8 	ldr	r0, [pc, #248]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3408:	e12fff35 	blx	r5
102d340c:	e59f10f0 	ldr	r1, [pc, #240]	; 102d3504 <Store_Persistent_Data+0x48c>
102d3410:	e1a02000 	mov	r2, r0
102d3414:	e3a0000a 	mov	r0, #10
102d3418:	e12fff34 	blx	r4
		}
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)persistent_parameter_array, OVER_WRITE_TO_SIZE, MAX_PERSISTENT_PARAMETERS * PERSISTENT_PARAMETER_LENGTH);
102d341c:	e3a03f7d 	mov	r3, #500	; 0x1f4
102d3420:	e1a00009 	mov	r0, r9
102d3424:	e59f10f4 	ldr	r1, [pc, #244]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d3428:	e3a02002 	mov	r2, #2
102d342c:	ebfffe92 	bl	102d2e7c <fileSys_WriteFile>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d3430:	e59f3138 	ldr	r3, [pc, #312]	; 102d3570 <Store_Persistent_Data+0x4f8>
			APP_DEBUG("INVALID \n\r");
		}
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)persistent_parameter_array, OVER_WRITE_TO_SIZE, MAX_PERSISTENT_PARAMETERS * PERSISTENT_PARAMETER_LENGTH);
		if(QL_RET_OK != ret)
102d3434:	e2504000 	subs	r4, r0, #0
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d3438:	e1a00009 	mov	r0, r9
			APP_DEBUG("INVALID \n\r");
		}
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)persistent_parameter_array, OVER_WRITE_TO_SIZE, MAX_PERSISTENT_PARAMETERS * PERSISTENT_PARAMETER_LENGTH);
		if(QL_RET_OK != ret)
102d343c:	1a000028 	bne	102d34e4 <Store_Persistent_Data+0x46c>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d3440:	e12fff33 	blx	r3
#endif
		return -1;
	}

	return ret;
}
102d3444:	e1a00004 	mov	r0, r4
102d3448:	e28ddc01 	add	sp, sp, #256	; 0x100
102d344c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
		APP_DEBUG("<-- Writing Persistent Parameters ..\n\r");
#endif
		//1. Last sucessful cloud Connected time stamp in UTC
		Ql_sprintf(temp,"{%s",last_connectedtime);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_array[0],temp);
102d3450:	e59f00c8 	ldr	r0, [pc, #200]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d3454:	e1a0100d 	mov	r1, sp
102d3458:	e59f3114 	ldr	r3, [pc, #276]	; 102d3574 <Store_Persistent_Data+0x4fc>
102d345c:	e12fff33 	blx	r3
102d3460:	e59f80b8 	ldr	r8, [pc, #184]	; 102d3520 <Store_Persistent_Data+0x4a8>
102d3464:	eaffff2f 	b	102d3128 <Store_Persistent_Data+0xb0>
#endif

		//6. Language COnfigured
		Ql_sprintf(temp,"{%d",language_index);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_array[5],temp);
102d3468:	e1a0100d 	mov	r1, sp
102d346c:	e59f3100 	ldr	r3, [pc, #256]	; 102d3574 <Store_Persistent_Data+0x4fc>
102d3470:	e59f0100 	ldr	r0, [pc, #256]	; 102d3578 <Store_Persistent_Data+0x500>
102d3474:	e12fff33 	blx	r3
102d3478:	eaffffc2 	b	102d3388 <Store_Persistent_Data+0x310>
#endif

		//5. Last Water Balance Recharge Time Stamp
		Ql_sprintf(temp,"{%s",Received_RCTS);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_array[4],temp);
102d347c:	e1a0100d 	mov	r1, sp
102d3480:	e59f30ec 	ldr	r3, [pc, #236]	; 102d3574 <Store_Persistent_Data+0x4fc>
102d3484:	e59f00d0 	ldr	r0, [pc, #208]	; 102d355c <Store_Persistent_Data+0x4e4>
102d3488:	e12fff33 	blx	r3
102d348c:	eaffff9d 	b	102d3308 <Store_Persistent_Data+0x290>
#endif

		//4. Last Water Balance Recharge ID
		Ql_sprintf(temp,"{%s",Received_RCID);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_array[3],temp);
102d3490:	e1a0100d 	mov	r1, sp
102d3494:	e59f30d8 	ldr	r3, [pc, #216]	; 102d3574 <Store_Persistent_Data+0x4fc>
102d3498:	e59f00b0 	ldr	r0, [pc, #176]	; 102d3550 <Store_Persistent_Data+0x4d8>
102d349c:	e12fff33 	blx	r3
102d34a0:	eaffff7b 	b	102d3294 <Store_Persistent_Data+0x21c>
#endif

		//3. Last Water Balance Recharge amount
		Ql_sprintf(temp,"{%s",cmdrcbal);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_array[2],temp);
102d34a4:	e1a0100d 	mov	r1, sp
102d34a8:	e59f30c4 	ldr	r3, [pc, #196]	; 102d3574 <Store_Persistent_Data+0x4fc>
102d34ac:	e59f0090 	ldr	r0, [pc, #144]	; 102d3544 <Store_Persistent_Data+0x4cc>
102d34b0:	e12fff33 	blx	r3
102d34b4:	eaffff59 	b	102d3220 <Store_Persistent_Data+0x1a8>
		APP_DEBUG("1. Last Connected Time      --> %s\n\r",persistent_parameter_array[0]);
#endif
		//2. GPS information in terms of Lattitude and Longitude read out of Cellular service provider communicatoin
		Ql_sprintf(temp,"{%s,%s",latitude_,longitude_);
		if(temp[1] != '\0' && temp[1] != ',') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_array[1],temp);
102d34b8:	e28a0032 	add	r0, sl, #50	; 0x32
102d34bc:	e1a0100d 	mov	r1, sp
102d34c0:	e59f30ac 	ldr	r3, [pc, #172]	; 102d3574 <Store_Persistent_Data+0x4fc>
102d34c4:	e12fff33 	blx	r3
102d34c8:	eaffff37 	b	102d31ac <Store_Persistent_Data+0x134>
		{
			APP_DEBUG("ENGLISH \n\r");
		}
		else if(persistent_parameter_array[5][1] == '1')
		{
			APP_DEBUG("BAHASA \n\r");
102d34cc:	e12fff3c 	blx	ip
102d34d0:	e59f10a4 	ldr	r1, [pc, #164]	; 102d357c <Store_Persistent_Data+0x504>
102d34d4:	eaffffc7 	b	102d33f8 <Store_Persistent_Data+0x380>
		}
#ifdef DEBUG_MSG
		APP_DEBUG("6. Language Configured      --> ");
		if(persistent_parameter_array[5][1] == '0')
		{
			APP_DEBUG("ENGLISH \n\r");
102d34d8:	e12fff3c 	blx	ip
102d34dc:	e59f109c 	ldr	r1, [pc, #156]	; 102d3580 <Store_Persistent_Data+0x508>
102d34e0:	eaffffc4 	b	102d33f8 <Store_Persistent_Data+0x380>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d34e4:	e12fff33 	blx	r3
		{
#ifdef FILE_STORAGE
			APP_DEBUG("<--Error : fileSys_WriteFile [%s] ret : %d-->\r\n",__FUNCTION__,ret);
#endif
			fileSys_CloseFile(file_handle);
			return -1;
102d34e8:	e3e04000 	mvn	r4, #0
102d34ec:	eaffffd4 	b	102d3444 <Store_Persistent_Data+0x3cc>
	{
		//Open file failed.
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Failed to Create File (%s) ret=%d -->\r\n", file_devicedata, ret);
#endif
		return -1;
102d34f0:	e3e04000 	mvn	r4, #0
102d34f4:	eaffffd2 	b	102d3444 <Store_Persistent_Data+0x3cc>
102d34f8:	102df9d5 	.word	0x102df9d5
102d34fc:	f03de540 	.word	0xf03de540
102d3500:	102e58f4 	.word	0x102e58f4
102d3504:	f03d5bfc 	.word	0xf03d5bfc
102d3508:	102eefec 	.word	0x102eefec
102d350c:	102e57a4 	.word	0x102e57a4
102d3510:	102e6230 	.word	0x102e6230
102d3514:	f03d209c 	.word	0xf03d209c
102d3518:	102ef01c 	.word	0x102ef01c
102d351c:	f03d5bac 	.word	0xf03d5bac
102d3520:	f03ddd54 	.word	0xf03ddd54
102d3524:	102ef020 	.word	0x102ef020
102d3528:	f03da830 	.word	0xf03da830
102d352c:	102ef048 	.word	0x102ef048
102d3530:	f03da824 	.word	0xf03da824
102d3534:	102ef050 	.word	0x102ef050
102d3538:	f03ddd86 	.word	0xf03ddd86
102d353c:	f03d5be8 	.word	0xf03d5be8
102d3540:	102ef078 	.word	0x102ef078
102d3544:	f03dddb8 	.word	0xf03dddb8
102d3548:	f03d59ec 	.word	0xf03d59ec
102d354c:	102ef0a0 	.word	0x102ef0a0
102d3550:	f03dddea 	.word	0xf03dddea
102d3554:	f03d5a08 	.word	0xf03d5a08
102d3558:	102ef0c8 	.word	0x102ef0c8
102d355c:	f03dde1c 	.word	0xf03dde1c
102d3560:	f03d64f8 	.word	0xf03d64f8
102d3564:	102ef0f0 	.word	0x102ef0f0
102d3568:	102ef0f4 	.word	0x102ef0f4
102d356c:	102ef130 	.word	0x102ef130
102d3570:	102e426c 	.word	0x102e426c
102d3574:	102dff55 	.word	0x102dff55
102d3578:	f03dde4e 	.word	0xf03dde4e
102d357c:	102ef124 	.word	0x102ef124
102d3580:	102ef118 	.word	0x102ef118

102d3584 <Read_Persistent_Data>:
	return ret;
}


s32 Read_Persistent_Data(void)
{
102d3584:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u32 i = 0;

	s32 ret = -1;
	s32 fileHandl = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Read From Persistent Parameters File -->\r\n");
102d3588:	e59f9374 	ldr	r9, [pc, #884]	; 102d3904 <Read_Persistent_Data+0x380>
	return ret;
}


s32 Read_Persistent_Data(void)
{
102d358c:	e24dd00c 	sub	sp, sp, #12
	u32 i = 0;

	s32 ret = -1;
	s32 fileHandl = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Read From Persistent Parameters File -->\r\n");
102d3590:	e3a02c02 	mov	r2, #512	; 0x200
102d3594:	e3a01000 	mov	r1, #0
102d3598:	e59f0368 	ldr	r0, [pc, #872]	; 102d3908 <Read_Persistent_Data+0x384>
102d359c:	e59f7368 	ldr	r7, [pc, #872]	; 102d390c <Read_Persistent_Data+0x388>
102d35a0:	e12fff37 	blx	r7
102d35a4:	e5993000 	ldr	r3, [r9]
102d35a8:	e59f1360 	ldr	r1, [pc, #864]	; 102d3910 <Read_Persistent_Data+0x38c>
102d35ac:	e59f0354 	ldr	r0, [pc, #852]	; 102d3908 <Read_Persistent_Data+0x384>
102d35b0:	e12fff33 	blx	r3
102d35b4:	e59fa358 	ldr	sl, [pc, #856]	; 102d3914 <Read_Persistent_Data+0x390>
102d35b8:	e59f0348 	ldr	r0, [pc, #840]	; 102d3908 <Read_Persistent_Data+0x384>
102d35bc:	e12fff3a 	blx	sl
#endif

	char *parameter_ = NULL;

	fileHandl = fileSys_checkFile((u8*)file_devicedata);
102d35c0:	e59f4350 	ldr	r4, [pc, #848]	; 102d3918 <Read_Persistent_Data+0x394>
	u32 i = 0;

	s32 ret = -1;
	s32 fileHandl = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Read From Persistent Parameters File -->\r\n");
102d35c4:	e59f133c 	ldr	r1, [pc, #828]	; 102d3908 <Read_Persistent_Data+0x384>
102d35c8:	e59f834c 	ldr	r8, [pc, #844]	; 102d391c <Read_Persistent_Data+0x398>
102d35cc:	e1a02000 	mov	r2, r0
102d35d0:	e3a0000a 	mov	r0, #10
102d35d4:	e12fff38 	blx	r8
#endif

	char *parameter_ = NULL;

	fileHandl = fileSys_checkFile((u8*)file_devicedata);
102d35d8:	e5940000 	ldr	r0, [r4]
102d35dc:	ebfffe55 	bl	102d2f38 <fileSys_checkFile>

	if(fileHandl == QL_RET_OK) // If file already present
102d35e0:	e2505000 	subs	r5, r0, #0
102d35e4:	0a000002 	beq	102d35f4 <Read_Persistent_Data+0x70>
#endif
		//return RET_FAIL;
	}

	return 1;
}
102d35e8:	e3a00001 	mov	r0, #1
102d35ec:	e28dd00c 	add	sp, sp, #12
102d35f0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(fileHandl == QL_RET_OK) // If file already present
	{
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Persistent parameters: file present : ->\r\n");
#endif
		fileHandl = fileSys_OpenOrCreateFile((u8*)file_devicedata); //Open the file
102d35f4:	e5940000 	ldr	r0, [r4]
102d35f8:	ebfffe00 	bl	102d2e00 <fileSys_OpenOrCreateFile>

		if(fileHandl >= QL_RET_OK)
102d35fc:	e3500000 	cmp	r0, #0
102d3600:	e58d0000 	str	r0, [sp]
102d3604:	bafffff7 	blt	102d35e8 <Read_Persistent_Data+0x64>
102d3608:	e59f6310 	ldr	r6, [pc, #784]	; 102d3920 <Read_Persistent_Data+0x39c>
102d360c:	e1a0b005 	mov	fp, r5
102d3610:	ea000027 	b	102d36b4 <Read_Persistent_Data+0x130>
#ifdef DEBUG_MSG
				if(i==0)
				{
					APP_DEBUG("1. Last Connect time");
				}
				else if(i==1)
102d3614:	e35b0001 	cmp	fp, #1
102d3618:	0a000077 	beq	102d37fc <Read_Persistent_Data+0x278>
				{
					APP_DEBUG("2. GPS Co-ordinates");
				}
				else if(i==2)
102d361c:	e35b0002 	cmp	fp, #2
102d3620:	0a00007c 	beq	102d3818 <Read_Persistent_Data+0x294>
				{
					APP_DEBUG("3. Last Recharge value");
				}
				else if(i==3)
102d3624:	e35b0003 	cmp	fp, #3
102d3628:	0a000086 	beq	102d3848 <Read_Persistent_Data+0x2c4>
				{
					APP_DEBUG("4. Last Recharge ID");
				}
				else if(i==4)
102d362c:	e35b0004 	cmp	fp, #4
102d3630:	0a00008b 	beq	102d3864 <Read_Persistent_Data+0x2e0>
				{
					APP_DEBUG("5. Last Recharge Time Stamp");
				}
				else if(i==5)
102d3634:	e35b0005 	cmp	fp, #5
102d3638:	0a000090 	beq	102d3880 <Read_Persistent_Data+0x2fc>
				{
					APP_DEBUG("6. Language Configured");
				}
#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
102d363c:	e5d43000 	ldrb	r3, [r4]
102d3640:	e353007b 	cmp	r3, #123	; 0x7b
102d3644:	0a000044 	beq	102d375c <Read_Persistent_Data+0x1d8>
				{

					persistent_parameter_array[i][0]= '{';
102d3648:	e59fc2d0 	ldr	ip, [pc, #720]	; 102d3920 <Read_Persistent_Data+0x39c>
					persistent_parameter_array[i][1]= NULL;
102d364c:	e3a03000 	mov	r3, #0
				}
#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
				{

					persistent_parameter_array[i][0]= '{';
102d3650:	e3a0e07b 	mov	lr, #123	; 0x7b
					persistent_parameter_array[i][1]= NULL;
#ifdef DEBUG_MSG
					APP_DEBUG(": -->\n\r");
102d3654:	e3a02c02 	mov	r2, #512	; 0x200
				}
#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
				{

					persistent_parameter_array[i][0]= '{';
102d3658:	e7cce005 	strb	lr, [ip, r5]
					persistent_parameter_array[i][1]= NULL;
#ifdef DEBUG_MSG
					APP_DEBUG(": -->\n\r");
102d365c:	e1a01003 	mov	r1, r3
102d3660:	e59f02a0 	ldr	r0, [pc, #672]	; 102d3908 <Read_Persistent_Data+0x384>
#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
				{

					persistent_parameter_array[i][0]= '{';
					persistent_parameter_array[i][1]= NULL;
102d3664:	e5c63001 	strb	r3, [r6, #1]
#ifdef DEBUG_MSG
					APP_DEBUG(": -->\n\r");
102d3668:	e12fff37 	blx	r7
102d366c:	e59f12b0 	ldr	r1, [pc, #688]	; 102d3924 <Read_Persistent_Data+0x3a0>
102d3670:	e5993000 	ldr	r3, [r9]
102d3674:	e59f028c 	ldr	r0, [pc, #652]	; 102d3908 <Read_Persistent_Data+0x384>
102d3678:	e12fff33 	blx	r3
102d367c:	e59f0284 	ldr	r0, [pc, #644]	; 102d3908 <Read_Persistent_Data+0x384>
102d3680:	e12fff3a 	blx	sl
102d3684:	e59f127c 	ldr	r1, [pc, #636]	; 102d3908 <Read_Persistent_Data+0x384>
102d3688:	e1a02000 	mov	r2, r0
102d368c:	e3a0000a 	mov	r0, #10
102d3690:	e12fff38 	blx	r8
					}

					//Copy in the array that will be used to stoer back while power down
					strcpy(persistent_parameter_array[i],parameter_);
				}
				Ql_MEM_Free(parameter_);
102d3694:	e1a00004 	mov	r0, r4
#endif
		fileHandl = fileSys_OpenOrCreateFile((u8*)file_devicedata); //Open the file

		if(fileHandl >= QL_RET_OK)
		{
			for(i = 0; i<MAX_PERSISTENT_PARAMETERS ; i++) // Scan for all persistent parameters one by one in the file
102d3698:	e28bb001 	add	fp, fp, #1
					}

					//Copy in the array that will be used to stoer back while power down
					strcpy(persistent_parameter_array[i],parameter_);
				}
				Ql_MEM_Free(parameter_);
102d369c:	e59f3284 	ldr	r3, [pc, #644]	; 102d3928 <Read_Persistent_Data+0x3a4>
102d36a0:	e12fff33 	blx	r3
#endif
		fileHandl = fileSys_OpenOrCreateFile((u8*)file_devicedata); //Open the file

		if(fileHandl >= QL_RET_OK)
		{
			for(i = 0; i<MAX_PERSISTENT_PARAMETERS ; i++) // Scan for all persistent parameters one by one in the file
102d36a4:	e35b000a 	cmp	fp, #10
102d36a8:	e2855032 	add	r5, r5, #50	; 0x32
102d36ac:	e2866032 	add	r6, r6, #50	; 0x32
102d36b0:	0a00004d 	beq	102d37ec <Read_Persistent_Data+0x268>
			{
				Ql_WTD_Feed(wtdid);
102d36b4:	e59f3270 	ldr	r3, [pc, #624]	; 102d392c <Read_Persistent_Data+0x3a8>
102d36b8:	e59fc270 	ldr	ip, [pc, #624]	; 102d3930 <Read_Persistent_Data+0x3ac>
102d36bc:	e5930000 	ldr	r0, [r3]
102d36c0:	e12fff3c 	blx	ip
				ret = Ql_FS_Seek(fileHandl, i*PERSISTENT_PARAMETER_LENGTH , QL_FS_FILE_BEGIN); // Point to the start of required message in the file
102d36c4:	e59f3268 	ldr	r3, [pc, #616]	; 102d3934 <Read_Persistent_Data+0x3b0>
102d36c8:	e1a01005 	mov	r1, r5
102d36cc:	e3a02000 	mov	r2, #0
102d36d0:	e59d0000 	ldr	r0, [sp]
102d36d4:	e12fff33 	blx	r3
#ifdef FILE_STORAGE
					APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
#endif
				}

				parameter_ = (char*)Ql_MEM_Alloc(PERSISTENT_PARAMETER_LENGTH);
102d36d8:	e59fc258 	ldr	ip, [pc, #600]	; 102d3938 <Read_Persistent_Data+0x3b4>
102d36dc:	e3a00032 	mov	r0, #50	; 0x32
102d36e0:	e12fff3c 	blx	ip
				Ql_memset(parameter_, 0x0,PERSISTENT_PARAMETER_LENGTH );
102d36e4:	e3a02032 	mov	r2, #50	; 0x32
102d36e8:	e3a01000 	mov	r1, #0
#ifdef FILE_STORAGE
					APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
#endif
				}

				parameter_ = (char*)Ql_MEM_Alloc(PERSISTENT_PARAMETER_LENGTH);
102d36ec:	e1a04000 	mov	r4, r0
				Ql_memset(parameter_, 0x0,PERSISTENT_PARAMETER_LENGTH );
102d36f0:	e12fff37 	blx	r7
				ret = Ql_FS_Read(fileHandl,(u8*)parameter_,PERSISTENT_PARAMETER_LENGTH, &readedlen); // Read the payload from the file
102d36f4:	e59d0000 	ldr	r0, [sp]
102d36f8:	e1a01004 	mov	r1, r4
102d36fc:	e3a02032 	mov	r2, #50	; 0x32
102d3700:	e59f3234 	ldr	r3, [pc, #564]	; 102d393c <Read_Persistent_Data+0x3b8>
102d3704:	e59fc234 	ldr	ip, [pc, #564]	; 102d3940 <Read_Persistent_Data+0x3bc>
102d3708:	e12fff3c 	blx	ip
					APP_DEBUG("\r\nError : Ql_FS_Read ret : %d\r\n",ret);
#endif
				}

#ifdef DEBUG_MSG
				if(i==0)
102d370c:	e35b0000 	cmp	fp, #0
102d3710:	1affffbf 	bne	102d3614 <Read_Persistent_Data+0x90>
				{
					APP_DEBUG("1. Last Connect time");
102d3714:	e1a0100b 	mov	r1, fp
102d3718:	e3a02c02 	mov	r2, #512	; 0x200
102d371c:	e59f01e4 	ldr	r0, [pc, #484]	; 102d3908 <Read_Persistent_Data+0x384>
102d3720:	e59f31e4 	ldr	r3, [pc, #484]	; 102d390c <Read_Persistent_Data+0x388>
102d3724:	e12fff33 	blx	r3
102d3728:	e59f1214 	ldr	r1, [pc, #532]	; 102d3944 <Read_Persistent_Data+0x3c0>
				{
					APP_DEBUG("5. Last Recharge Time Stamp");
				}
				else if(i==5)
				{
					APP_DEBUG("6. Language Configured");
102d372c:	e5993000 	ldr	r3, [r9]
102d3730:	e59f01d0 	ldr	r0, [pc, #464]	; 102d3908 <Read_Persistent_Data+0x384>
102d3734:	e12fff33 	blx	r3
102d3738:	e59f01c8 	ldr	r0, [pc, #456]	; 102d3908 <Read_Persistent_Data+0x384>
102d373c:	e12fff3a 	blx	sl
102d3740:	e59f11c0 	ldr	r1, [pc, #448]	; 102d3908 <Read_Persistent_Data+0x384>
102d3744:	e1a02000 	mov	r2, r0
102d3748:	e3a0000a 	mov	r0, #10
102d374c:	e12fff38 	blx	r8
				}
#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
102d3750:	e5d43000 	ldrb	r3, [r4]
102d3754:	e353007b 	cmp	r3, #123	; 0x7b
102d3758:	1affffba 	bne	102d3648 <Read_Persistent_Data+0xc4>
#endif
				}
				else // Valid parameter
				{
#ifdef DEBUG_MSG
					APP_DEBUG(": %s -->\n\r",&parameter_[1]);
102d375c:	e2843001 	add	r3, r4, #1
102d3760:	e3a01000 	mov	r1, #0
102d3764:	e3a02c02 	mov	r2, #512	; 0x200
102d3768:	e59f0198 	ldr	r0, [pc, #408]	; 102d3908 <Read_Persistent_Data+0x384>
102d376c:	e58d3004 	str	r3, [sp, #4]
102d3770:	e12fff37 	blx	r7
102d3774:	e59f11cc 	ldr	r1, [pc, #460]	; 102d3948 <Read_Persistent_Data+0x3c4>
102d3778:	e59d2004 	ldr	r2, [sp, #4]
102d377c:	e5993000 	ldr	r3, [r9]
102d3780:	e59f0180 	ldr	r0, [pc, #384]	; 102d3908 <Read_Persistent_Data+0x384>
102d3784:	e12fff33 	blx	r3
102d3788:	e59f0178 	ldr	r0, [pc, #376]	; 102d3908 <Read_Persistent_Data+0x384>
102d378c:	e12fff3a 	blx	sl
102d3790:	e59f1170 	ldr	r1, [pc, #368]	; 102d3908 <Read_Persistent_Data+0x384>
102d3794:	e1a02000 	mov	r2, r0
102d3798:	e3a0000a 	mov	r0, #10
102d379c:	e12fff38 	blx	r8
#endif
					//Read the parameter and assign them to global variables..
					if(i == 0)//Last sucessful cloud Connected time stamp in UTC
102d37a0:	e35b0000 	cmp	fp, #0
102d37a4:	0a000022 	beq	102d3834 <Read_Persistent_Data+0x2b0>
					{
						Ql_strcpy(last_connectedtime,&parameter_[1]);
					}
					else if(i == 1)//GPS information in terms of Lattitude and Longitude read out of Cellular service provider communicatoin
102d37a8:	e35b0001 	cmp	fp, #1
102d37ac:	0a00003a 	beq	102d389c <Read_Persistent_Data+0x318>
					{
						Ql_strcpy(latlong,&parameter_[1]);
					}
					else if(i == 2)//Last Water Balance Recharge amount
102d37b0:	e35b0002 	cmp	fp, #2
102d37b4:	0a00003d 	beq	102d38b0 <Read_Persistent_Data+0x32c>
					{
						Ql_strcpy(cmdrcbal,&parameter_[1]);
					}
					else if(i == 3)//Last Water Balance Recharge ID
102d37b8:	e35b0003 	cmp	fp, #3
102d37bc:	0a000040 	beq	102d38c4 <Read_Persistent_Data+0x340>
					{
						Ql_strcpy(Received_RCID,&parameter_[1]);
					}
					else if(i == 4)//Last Water Balance Recharge Time Stamp
102d37c0:	e35b0004 	cmp	fp, #4
102d37c4:	0a000043 	beq	102d38d8 <Read_Persistent_Data+0x354>
					{
						Ql_strcpy(Received_RCTS,&parameter_[1]);
					}
					else if(i == 5)//Language Configured
102d37c8:	e35b0005 	cmp	fp, #5
102d37cc:	0a000046 	beq	102d38ec <Read_Persistent_Data+0x368>
					{
						language_index = Ql_atoi(&parameter_[1]);
					}

					//Copy in the array that will be used to stoer back while power down
					strcpy(persistent_parameter_array[i],parameter_);
102d37d0:	e59fc148 	ldr	ip, [pc, #328]	; 102d3920 <Read_Persistent_Data+0x39c>
102d37d4:	e3a00032 	mov	r0, #50	; 0x32
102d37d8:	e020c09b 	mla	r0, fp, r0, ip
102d37dc:	e1a01004 	mov	r1, r4
102d37e0:	e59f3164 	ldr	r3, [pc, #356]	; 102d394c <Read_Persistent_Data+0x3c8>
102d37e4:	e12fff33 	blx	r3
102d37e8:	eaffffa9 	b	102d3694 <Read_Persistent_Data+0x110>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d37ec:	e59d0000 	ldr	r0, [sp]
102d37f0:	e59f3158 	ldr	r3, [pc, #344]	; 102d3950 <Read_Persistent_Data+0x3cc>
102d37f4:	e12fff33 	blx	r3
102d37f8:	eaffff7a 	b	102d35e8 <Read_Persistent_Data+0x64>
				{
					APP_DEBUG("1. Last Connect time");
				}
				else if(i==1)
				{
					APP_DEBUG("2. GPS Co-ordinates");
102d37fc:	e3a01000 	mov	r1, #0
102d3800:	e3a02c02 	mov	r2, #512	; 0x200
102d3804:	e59f00fc 	ldr	r0, [pc, #252]	; 102d3908 <Read_Persistent_Data+0x384>
102d3808:	e59fc0fc 	ldr	ip, [pc, #252]	; 102d390c <Read_Persistent_Data+0x388>
102d380c:	e12fff3c 	blx	ip
102d3810:	e59f113c 	ldr	r1, [pc, #316]	; 102d3954 <Read_Persistent_Data+0x3d0>
102d3814:	eaffffc4 	b	102d372c <Read_Persistent_Data+0x1a8>
				}
				else if(i==2)
				{
					APP_DEBUG("3. Last Recharge value");
102d3818:	e3a01000 	mov	r1, #0
102d381c:	e3a02c02 	mov	r2, #512	; 0x200
102d3820:	e59f00e0 	ldr	r0, [pc, #224]	; 102d3908 <Read_Persistent_Data+0x384>
102d3824:	e59f30e0 	ldr	r3, [pc, #224]	; 102d390c <Read_Persistent_Data+0x388>
102d3828:	e12fff33 	blx	r3
102d382c:	e59f1124 	ldr	r1, [pc, #292]	; 102d3958 <Read_Persistent_Data+0x3d4>
102d3830:	eaffffbd 	b	102d372c <Read_Persistent_Data+0x1a8>
					APP_DEBUG(": %s -->\n\r",&parameter_[1]);
#endif
					//Read the parameter and assign them to global variables..
					if(i == 0)//Last sucessful cloud Connected time stamp in UTC
					{
						Ql_strcpy(last_connectedtime,&parameter_[1]);
102d3834:	e59d1004 	ldr	r1, [sp, #4]
102d3838:	e59f311c 	ldr	r3, [pc, #284]	; 102d395c <Read_Persistent_Data+0x3d8>
102d383c:	e59f011c 	ldr	r0, [pc, #284]	; 102d3960 <Read_Persistent_Data+0x3dc>
102d3840:	e12fff33 	blx	r3
102d3844:	eaffffe1 	b	102d37d0 <Read_Persistent_Data+0x24c>
				{
					APP_DEBUG("3. Last Recharge value");
				}
				else if(i==3)
				{
					APP_DEBUG("4. Last Recharge ID");
102d3848:	e3a01000 	mov	r1, #0
102d384c:	e3a02c02 	mov	r2, #512	; 0x200
102d3850:	e59f00b0 	ldr	r0, [pc, #176]	; 102d3908 <Read_Persistent_Data+0x384>
102d3854:	e59fc0b0 	ldr	ip, [pc, #176]	; 102d390c <Read_Persistent_Data+0x388>
102d3858:	e12fff3c 	blx	ip
102d385c:	e59f1100 	ldr	r1, [pc, #256]	; 102d3964 <Read_Persistent_Data+0x3e0>
102d3860:	eaffffb1 	b	102d372c <Read_Persistent_Data+0x1a8>
				}
				else if(i==4)
				{
					APP_DEBUG("5. Last Recharge Time Stamp");
102d3864:	e3a01000 	mov	r1, #0
102d3868:	e3a02c02 	mov	r2, #512	; 0x200
102d386c:	e59f0094 	ldr	r0, [pc, #148]	; 102d3908 <Read_Persistent_Data+0x384>
102d3870:	e59f3094 	ldr	r3, [pc, #148]	; 102d390c <Read_Persistent_Data+0x388>
102d3874:	e12fff33 	blx	r3
102d3878:	e59f10e8 	ldr	r1, [pc, #232]	; 102d3968 <Read_Persistent_Data+0x3e4>
102d387c:	eaffffaa 	b	102d372c <Read_Persistent_Data+0x1a8>
				}
				else if(i==5)
				{
					APP_DEBUG("6. Language Configured");
102d3880:	e3a01000 	mov	r1, #0
102d3884:	e3a02c02 	mov	r2, #512	; 0x200
102d3888:	e59f0078 	ldr	r0, [pc, #120]	; 102d3908 <Read_Persistent_Data+0x384>
102d388c:	e59fc078 	ldr	ip, [pc, #120]	; 102d390c <Read_Persistent_Data+0x388>
102d3890:	e12fff3c 	blx	ip
102d3894:	e59f10d0 	ldr	r1, [pc, #208]	; 102d396c <Read_Persistent_Data+0x3e8>
102d3898:	eaffffa3 	b	102d372c <Read_Persistent_Data+0x1a8>
					{
						Ql_strcpy(last_connectedtime,&parameter_[1]);
					}
					else if(i == 1)//GPS information in terms of Lattitude and Longitude read out of Cellular service provider communicatoin
					{
						Ql_strcpy(latlong,&parameter_[1]);
102d389c:	e59d1004 	ldr	r1, [sp, #4]
102d38a0:	e59f30b4 	ldr	r3, [pc, #180]	; 102d395c <Read_Persistent_Data+0x3d8>
102d38a4:	e59f00c4 	ldr	r0, [pc, #196]	; 102d3970 <Read_Persistent_Data+0x3ec>
102d38a8:	e12fff33 	blx	r3
102d38ac:	eaffffc7 	b	102d37d0 <Read_Persistent_Data+0x24c>
					}
					else if(i == 2)//Last Water Balance Recharge amount
					{
						Ql_strcpy(cmdrcbal,&parameter_[1]);
102d38b0:	e59d1004 	ldr	r1, [sp, #4]
102d38b4:	e59f30a0 	ldr	r3, [pc, #160]	; 102d395c <Read_Persistent_Data+0x3d8>
102d38b8:	e59f00b4 	ldr	r0, [pc, #180]	; 102d3974 <Read_Persistent_Data+0x3f0>
102d38bc:	e12fff33 	blx	r3
102d38c0:	eaffffc2 	b	102d37d0 <Read_Persistent_Data+0x24c>
					}
					else if(i == 3)//Last Water Balance Recharge ID
					{
						Ql_strcpy(Received_RCID,&parameter_[1]);
102d38c4:	e59d1004 	ldr	r1, [sp, #4]
102d38c8:	e59f308c 	ldr	r3, [pc, #140]	; 102d395c <Read_Persistent_Data+0x3d8>
102d38cc:	e59f00a4 	ldr	r0, [pc, #164]	; 102d3978 <Read_Persistent_Data+0x3f4>
102d38d0:	e12fff33 	blx	r3
102d38d4:	eaffffbd 	b	102d37d0 <Read_Persistent_Data+0x24c>
					}
					else if(i == 4)//Last Water Balance Recharge Time Stamp
					{
						Ql_strcpy(Received_RCTS,&parameter_[1]);
102d38d8:	e59d1004 	ldr	r1, [sp, #4]
102d38dc:	e59f3078 	ldr	r3, [pc, #120]	; 102d395c <Read_Persistent_Data+0x3d8>
102d38e0:	e59f0094 	ldr	r0, [pc, #148]	; 102d397c <Read_Persistent_Data+0x3f8>
102d38e4:	e12fff33 	blx	r3
102d38e8:	eaffffb8 	b	102d37d0 <Read_Persistent_Data+0x24c>
					}
					else if(i == 5)//Language Configured
					{
						language_index = Ql_atoi(&parameter_[1]);
102d38ec:	e59f308c 	ldr	r3, [pc, #140]	; 102d3980 <Read_Persistent_Data+0x3fc>
102d38f0:	e59d0004 	ldr	r0, [sp, #4]
102d38f4:	e12fff33 	blx	r3
102d38f8:	e59f3084 	ldr	r3, [pc, #132]	; 102d3984 <Read_Persistent_Data+0x400>
102d38fc:	e5830000 	str	r0, [r3]
102d3900:	eaffffb2 	b	102d37d0 <Read_Persistent_Data+0x24c>
102d3904:	f03de540 	.word	0xf03de540
102d3908:	f03d5bfc 	.word	0xf03d5bfc
102d390c:	102e58f4 	.word	0x102e58f4
102d3910:	102ef13c 	.word	0x102ef13c
102d3914:	102e57a4 	.word	0x102e57a4
102d3918:	f03d209c 	.word	0xf03d209c
102d391c:	102e6230 	.word	0x102e6230
102d3920:	f03ddd54 	.word	0xf03ddd54
102d3924:	102ef1fc 	.word	0x102ef1fc
102d3928:	102e48b8 	.word	0x102e48b8
102d392c:	f03da8c8 	.word	0xf03da8c8
102d3930:	102e642c 	.word	0x102e642c
102d3934:	102e41a8 	.word	0x102e41a8
102d3938:	102e4840 	.word	0x102e4840
102d393c:	f03db8f8 	.word	0xf03db8f8
102d3940:	102e40b8 	.word	0x102e40b8
102d3944:	102ef170 	.word	0x102ef170
102d3948:	102ef204 	.word	0x102ef204
102d394c:	102dff55 	.word	0x102dff55
102d3950:	102e426c 	.word	0x102e426c
102d3954:	102ef188 	.word	0x102ef188
102d3958:	102ef19c 	.word	0x102ef19c
102d395c:	102e55fc 	.word	0x102e55fc
102d3960:	f03d5bac 	.word	0xf03d5bac
102d3964:	102ef1b4 	.word	0x102ef1b4
102d3968:	102ef1c8 	.word	0x102ef1c8
102d396c:	102ef1e4 	.word	0x102ef1e4
102d3970:	f03da8a8 	.word	0xf03da8a8
102d3974:	f03d5be8 	.word	0xf03d5be8
102d3978:	f03d59ec 	.word	0xf03d59ec
102d397c:	f03d5a08 	.word	0xf03d5a08
102d3980:	102e5a8c 	.word	0x102e5a8c
102d3984:	f03d64f8 	.word	0xf03d64f8

102d3988 <Store_IoT_Persistent_Data>:
//8. Empty and available for future use
//9. Empty and available for future use
//10. Empty and available for future use
//Each persistent parameter starts with '{'
s32 Store_IoT_Persistent_Data(void)
{
102d3988:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
102d398c:	e24ddc01 	sub	sp, sp, #256	; 0x100
	char temp[256] = {0};
102d3990:	e59f3230 	ldr	r3, [pc, #560]	; 102d3bc8 <Store_IoT_Persistent_Data+0x240>
102d3994:	e3a01000 	mov	r1, #0
102d3998:	e3a02c01 	mov	r2, #256	; 0x100
102d399c:	e1a0000d 	mov	r0, sp
	s32 ret = -1;
	s32 file_handle = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--Store to IoT Persistent Parameters File -->\n\r");
102d39a0:	e59f4224 	ldr	r4, [pc, #548]	; 102d3bcc <Store_IoT_Persistent_Data+0x244>
//9. Empty and available for future use
//10. Empty and available for future use
//Each persistent parameter starts with '{'
s32 Store_IoT_Persistent_Data(void)
{
	char temp[256] = {0};
102d39a4:	e12fff33 	blx	r3
	s32 ret = -1;
	s32 file_handle = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--Store to IoT Persistent Parameters File -->\n\r");
102d39a8:	e59f7220 	ldr	r7, [pc, #544]	; 102d3bd0 <Store_IoT_Persistent_Data+0x248>
102d39ac:	e3a02c02 	mov	r2, #512	; 0x200
102d39b0:	e3a01000 	mov	r1, #0
102d39b4:	e59f0218 	ldr	r0, [pc, #536]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d39b8:	e12fff37 	blx	r7
102d39bc:	e5943000 	ldr	r3, [r4]
102d39c0:	e59f1210 	ldr	r1, [pc, #528]	; 102d3bd8 <Store_IoT_Persistent_Data+0x250>
102d39c4:	e59f0208 	ldr	r0, [pc, #520]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d39c8:	e12fff33 	blx	r3
102d39cc:	e59f6208 	ldr	r6, [pc, #520]	; 102d3bdc <Store_IoT_Persistent_Data+0x254>
102d39d0:	e59f01fc 	ldr	r0, [pc, #508]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d39d4:	e12fff36 	blx	r6
102d39d8:	e59f5200 	ldr	r5, [pc, #512]	; 102d3be0 <Store_IoT_Persistent_Data+0x258>
102d39dc:	e59f11f0 	ldr	r1, [pc, #496]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d39e0:	e1a02000 	mov	r2, r0
102d39e4:	e3a0000a 	mov	r0, #10
102d39e8:	e12fff35 	blx	r5
#endif
	//create file.. if not available or open the file if avaialble
	file_handle = fileSys_OpenOrCreateFile((u8 *)file_IoTdata);
102d39ec:	e59f31f0 	ldr	r3, [pc, #496]	; 102d3be4 <Store_IoT_Persistent_Data+0x25c>
102d39f0:	e5930004 	ldr	r0, [r3, #4]
102d39f4:	ebfffd01 	bl	102d2e00 <fileSys_OpenOrCreateFile>
	if(file_handle >= QL_RET_OK)
102d39f8:	e2509000 	subs	r9, r0, #0
102d39fc:	ba00006f 	blt	102d3bc0 <Store_IoT_Persistent_Data+0x238>
	{
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Writing IoT Persistent Parameters ..\n\r");
#endif
		//1. Device Serial ID string
		Ql_sprintf(temp,"{%s",AZURE_IoT_device_ID);
102d3a00:	e5943000 	ldr	r3, [r4]
102d3a04:	e1a0000d 	mov	r0, sp
102d3a08:	e59f11d8 	ldr	r1, [pc, #472]	; 102d3be8 <Store_IoT_Persistent_Data+0x260>
102d3a0c:	e59f21d8 	ldr	r2, [pc, #472]	; 102d3bec <Store_IoT_Persistent_Data+0x264>
102d3a10:	e12fff33 	blx	r3
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d3a14:	e5dd3001 	ldrb	r3, [sp, #1]
102d3a18:	e3530000 	cmp	r3, #0
102d3a1c:	1a000054 	bne	102d3b74 <Store_IoT_Persistent_Data+0x1ec>
			strcpy(persistent_parameter_IoT_array[0],temp);
		else
		{
			persistent_parameter_IoT_array[0][0] = '{';
102d3a20:	e59f81c8 	ldr	r8, [pc, #456]	; 102d3bf0 <Store_IoT_Persistent_Data+0x268>
102d3a24:	e3a0207b 	mov	r2, #123	; 0x7b
102d3a28:	e5c82000 	strb	r2, [r8]
			persistent_parameter_IoT_array[0][1] = '\0';
102d3a2c:	e5c83001 	strb	r3, [r8, #1]
		}
#ifdef DEBUG_MSG
		APP_DEBUG("1. Device Serial ID --> %s\n\r",persistent_parameter_IoT_array[0]);
102d3a30:	e59fa1b8 	ldr	sl, [pc, #440]	; 102d3bf0 <Store_IoT_Persistent_Data+0x268>
102d3a34:	e3a01000 	mov	r1, #0
102d3a38:	e3a02c02 	mov	r2, #512	; 0x200
102d3a3c:	e59f0190 	ldr	r0, [pc, #400]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3a40:	e12fff37 	blx	r7
102d3a44:	e5943000 	ldr	r3, [r4]
102d3a48:	e59f11a4 	ldr	r1, [pc, #420]	; 102d3bf4 <Store_IoT_Persistent_Data+0x26c>
102d3a4c:	e1a0200a 	mov	r2, sl
102d3a50:	e59f017c 	ldr	r0, [pc, #380]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3a54:	e12fff33 	blx	r3
102d3a58:	e59f0174 	ldr	r0, [pc, #372]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3a5c:	e12fff36 	blx	r6
102d3a60:	e59f116c 	ldr	r1, [pc, #364]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3a64:	e1a02000 	mov	r2, r0
102d3a68:	e3a0000a 	mov	r0, #10
102d3a6c:	e12fff35 	blx	r5
#endif

		//2. IoT DPS  details
		Ql_sprintf(temp,"{%s",AZURE_IoT_DPS_ID);
102d3a70:	e59f2180 	ldr	r2, [pc, #384]	; 102d3bf8 <Store_IoT_Persistent_Data+0x270>
102d3a74:	e5943000 	ldr	r3, [r4]
102d3a78:	e1a0000d 	mov	r0, sp
102d3a7c:	e59f1164 	ldr	r1, [pc, #356]	; 102d3be8 <Store_IoT_Persistent_Data+0x260>
102d3a80:	e12fff33 	blx	r3
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d3a84:	e5dd3001 	ldrb	r3, [sp, #1]
102d3a88:	e3530000 	cmp	r3, #0
			strcpy(persistent_parameter_IoT_array[1],temp);
		else
		{
			persistent_parameter_IoT_array[1][0] = '{';
102d3a8c:	03a0207b 	moveq	r2, #123	; 0x7b
			persistent_parameter_IoT_array[1][1] = '\0';
102d3a90:	05ca3097 	strbeq	r3, [sl, #151]	; 0x97
		Ql_sprintf(temp,"{%s",AZURE_IoT_DPS_ID);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_IoT_array[1],temp);
		else
		{
			persistent_parameter_IoT_array[1][0] = '{';
102d3a94:	05ca2096 	strbeq	r2, [sl, #150]	; 0x96
		APP_DEBUG("1. Device Serial ID --> %s\n\r",persistent_parameter_IoT_array[0]);
#endif

		//2. IoT DPS  details
		Ql_sprintf(temp,"{%s",AZURE_IoT_DPS_ID);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d3a98:	1a000040 	bne	102d3ba0 <Store_IoT_Persistent_Data+0x218>
		{
			persistent_parameter_IoT_array[1][0] = '{';
			persistent_parameter_IoT_array[1][1] = '\0';
		}	
#ifdef DEBUG_MSG
		APP_DEBUG("2. Assigned DPS ID  --> %s\n\r",persistent_parameter_IoT_array[1]);
102d3a9c:	e3a01000 	mov	r1, #0
102d3aa0:	e3a02c02 	mov	r2, #512	; 0x200
102d3aa4:	e59f0128 	ldr	r0, [pc, #296]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3aa8:	e12fff37 	blx	r7
102d3aac:	e5943000 	ldr	r3, [r4]
102d3ab0:	e59f1144 	ldr	r1, [pc, #324]	; 102d3bfc <Store_IoT_Persistent_Data+0x274>
102d3ab4:	e59f2144 	ldr	r2, [pc, #324]	; 102d3c00 <Store_IoT_Persistent_Data+0x278>
102d3ab8:	e59f0114 	ldr	r0, [pc, #276]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3abc:	e12fff33 	blx	r3
102d3ac0:	e59f010c 	ldr	r0, [pc, #268]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3ac4:	e12fff36 	blx	r6
102d3ac8:	e59f1104 	ldr	r1, [pc, #260]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3acc:	e1a02000 	mov	r2, r0
102d3ad0:	e3a0000a 	mov	r0, #10
102d3ad4:	e12fff35 	blx	r5
#endif

		//3. IoT Hub details
		Ql_sprintf(temp,"{%s",AZURE_assigned_IoT_Hub);
102d3ad8:	e59f2124 	ldr	r2, [pc, #292]	; 102d3c04 <Store_IoT_Persistent_Data+0x27c>
102d3adc:	e5943000 	ldr	r3, [r4]
102d3ae0:	e1a0000d 	mov	r0, sp
102d3ae4:	e59f10fc 	ldr	r1, [pc, #252]	; 102d3be8 <Store_IoT_Persistent_Data+0x260>
102d3ae8:	e12fff33 	blx	r3
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d3aec:	e5dd3001 	ldrb	r3, [sp, #1]
102d3af0:	e3530000 	cmp	r3, #0
			strcpy(persistent_parameter_IoT_array[2],temp);
		else
		{
			persistent_parameter_IoT_array[2][0] = '{';
102d3af4:	03a0207b 	moveq	r2, #123	; 0x7b
			persistent_parameter_IoT_array[2][1] = '\0';
102d3af8:	05c8312d 	strbeq	r3, [r8, #301]	; 0x12d
		Ql_sprintf(temp,"{%s",AZURE_assigned_IoT_Hub);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_IoT_array[2],temp);
		else
		{
			persistent_parameter_IoT_array[2][0] = '{';
102d3afc:	05c8212c 	strbeq	r2, [r8, #300]	; 0x12c
		APP_DEBUG("2. Assigned DPS ID  --> %s\n\r",persistent_parameter_IoT_array[1]);
#endif

		//3. IoT Hub details
		Ql_sprintf(temp,"{%s",AZURE_assigned_IoT_Hub);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
102d3b00:	1a000021 	bne	102d3b8c <Store_IoT_Persistent_Data+0x204>
		{
			persistent_parameter_IoT_array[2][0] = '{';
			persistent_parameter_IoT_array[2][1] = '\0';
		}	
#ifdef DEBUG_MSG
		APP_DEBUG("3. Assigned IoT Hub --> %s\n\r",persistent_parameter_IoT_array[2]);
102d3b04:	e3a01000 	mov	r1, #0
102d3b08:	e3a02c02 	mov	r2, #512	; 0x200
102d3b0c:	e59f00c0 	ldr	r0, [pc, #192]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3b10:	e12fff37 	blx	r7
102d3b14:	e5943000 	ldr	r3, [r4]
102d3b18:	e59f10e8 	ldr	r1, [pc, #232]	; 102d3c08 <Store_IoT_Persistent_Data+0x280>
102d3b1c:	e59f20e8 	ldr	r2, [pc, #232]	; 102d3c0c <Store_IoT_Persistent_Data+0x284>
102d3b20:	e59f00ac 	ldr	r0, [pc, #172]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3b24:	e12fff33 	blx	r3
102d3b28:	e59f00a4 	ldr	r0, [pc, #164]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3b2c:	e12fff36 	blx	r6
102d3b30:	e59f109c 	ldr	r1, [pc, #156]	; 102d3bd4 <Store_IoT_Persistent_Data+0x24c>
102d3b34:	e1a02000 	mov	r2, r0
102d3b38:	e3a0000a 	mov	r0, #10
102d3b3c:	e12fff35 	blx	r5
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)persistent_parameter_IoT_array, OVER_WRITE_TO_SIZE, MAX_PERSISTENT_IOT_PARAMETERS * PERSISTENT_IOT_PARAMETER_LENGTH);
102d3b40:	e59f30c8 	ldr	r3, [pc, #200]	; 102d3c10 <Store_IoT_Persistent_Data+0x288>
102d3b44:	e1a00009 	mov	r0, r9
102d3b48:	e59f10a0 	ldr	r1, [pc, #160]	; 102d3bf0 <Store_IoT_Persistent_Data+0x268>
102d3b4c:	e3a02002 	mov	r2, #2
102d3b50:	ebfffcc9 	bl	102d2e7c <fileSys_WriteFile>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d3b54:	e59f30b8 	ldr	r3, [pc, #184]	; 102d3c14 <Store_IoT_Persistent_Data+0x28c>
#ifdef DEBUG_MSG
		APP_DEBUG("3. Assigned IoT Hub --> %s\n\r",persistent_parameter_IoT_array[2]);
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)persistent_parameter_IoT_array, OVER_WRITE_TO_SIZE, MAX_PERSISTENT_IOT_PARAMETERS * PERSISTENT_IOT_PARAMETER_LENGTH);
		if(QL_RET_OK != ret)
102d3b58:	e2504000 	subs	r4, r0, #0
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d3b5c:	e1a00009 	mov	r0, r9
#ifdef DEBUG_MSG
		APP_DEBUG("3. Assigned IoT Hub --> %s\n\r",persistent_parameter_IoT_array[2]);
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)persistent_parameter_IoT_array, OVER_WRITE_TO_SIZE, MAX_PERSISTENT_IOT_PARAMETERS * PERSISTENT_IOT_PARAMETER_LENGTH);
		if(QL_RET_OK != ret)
102d3b60:	1a000013 	bne	102d3bb4 <Store_IoT_Persistent_Data+0x22c>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d3b64:	e12fff33 	blx	r3
#endif
		return -1;
	}

	return ret;
}
102d3b68:	e1a00004 	mov	r0, r4
102d3b6c:	e28ddc01 	add	sp, sp, #256	; 0x100
102d3b70:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
		APP_DEBUG("<-- Writing IoT Persistent Parameters ..\n\r");
#endif
		//1. Device Serial ID string
		Ql_sprintf(temp,"{%s",AZURE_IoT_device_ID);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_IoT_array[0],temp);
102d3b74:	e59f0074 	ldr	r0, [pc, #116]	; 102d3bf0 <Store_IoT_Persistent_Data+0x268>
102d3b78:	e1a0100d 	mov	r1, sp
102d3b7c:	e59f3094 	ldr	r3, [pc, #148]	; 102d3c18 <Store_IoT_Persistent_Data+0x290>
102d3b80:	e12fff33 	blx	r3
102d3b84:	e59f8064 	ldr	r8, [pc, #100]	; 102d3bf0 <Store_IoT_Persistent_Data+0x268>
102d3b88:	eaffffa8 	b	102d3a30 <Store_IoT_Persistent_Data+0xa8>
#endif

		//3. IoT Hub details
		Ql_sprintf(temp,"{%s",AZURE_assigned_IoT_Hub);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_IoT_array[2],temp);
102d3b8c:	e1a0100d 	mov	r1, sp
102d3b90:	e59f3080 	ldr	r3, [pc, #128]	; 102d3c18 <Store_IoT_Persistent_Data+0x290>
102d3b94:	e59f0070 	ldr	r0, [pc, #112]	; 102d3c0c <Store_IoT_Persistent_Data+0x284>
102d3b98:	e12fff33 	blx	r3
102d3b9c:	eaffffd8 	b	102d3b04 <Store_IoT_Persistent_Data+0x17c>
#endif

		//2. IoT DPS  details
		Ql_sprintf(temp,"{%s",AZURE_IoT_DPS_ID);
		if(temp[1] != '\0') //Update the last stored parameter only if the parameter is not NULL
			strcpy(persistent_parameter_IoT_array[1],temp);
102d3ba0:	e28a0096 	add	r0, sl, #150	; 0x96
102d3ba4:	e1a0100d 	mov	r1, sp
102d3ba8:	e59f3068 	ldr	r3, [pc, #104]	; 102d3c18 <Store_IoT_Persistent_Data+0x290>
102d3bac:	e12fff33 	blx	r3
102d3bb0:	eaffffb9 	b	102d3a9c <Store_IoT_Persistent_Data+0x114>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d3bb4:	e12fff33 	blx	r3
		{
#ifdef FILE_STORAGE
			APP_DEBUG("<--Error : fileSys_WriteFile [%s] ret : %d-->\r\n",__FUNCTION__,ret);
#endif
			fileSys_CloseFile(file_handle);
			return -1;
102d3bb8:	e3e04000 	mvn	r4, #0
102d3bbc:	eaffffe9 	b	102d3b68 <Store_IoT_Persistent_Data+0x1e0>
	{
		//Open file failed.
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Failed to Create File (%s) ret=%d -->\r\n", file_IoTdata, ret);
#endif
		return -1;
102d3bc0:	e3e04000 	mvn	r4, #0
102d3bc4:	eaffffe7 	b	102d3b68 <Store_IoT_Persistent_Data+0x1e0>
102d3bc8:	102df9d5 	.word	0x102df9d5
102d3bcc:	f03de540 	.word	0xf03de540
102d3bd0:	102e58f4 	.word	0x102e58f4
102d3bd4:	f03d5bfc 	.word	0xf03d5bfc
102d3bd8:	102ef210 	.word	0x102ef210
102d3bdc:	102e57a4 	.word	0x102e57a4
102d3be0:	102e6230 	.word	0x102e6230
102d3be4:	f03d209c 	.word	0xf03d209c
102d3be8:	102ef01c 	.word	0x102ef01c
102d3bec:	f03d5dfc 	.word	0xf03d5dfc
102d3bf0:	f03ddf48 	.word	0xf03ddf48
102d3bf4:	102ef244 	.word	0x102ef244
102d3bf8:	f03d5e18 	.word	0xf03d5e18
102d3bfc:	102ef264 	.word	0x102ef264
102d3c00:	f03ddfde 	.word	0xf03ddfde
102d3c04:	f03d5e34 	.word	0xf03d5e34
102d3c08:	102ef284 	.word	0x102ef284
102d3c0c:	f03de074 	.word	0xf03de074
102d3c10:	000005dc 	.word	0x000005dc
102d3c14:	102e426c 	.word	0x102e426c
102d3c18:	102dff55 	.word	0x102dff55

102d3c1c <Read_IoT_Persistent_Data>:

	return ret;
}

s32 Read_IoT_Persistent_Data(void)
{
102d3c1c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u32 i = 0;

	s32 ret = -1;
	s32 fileHandl = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Read From IoT Persistent Parameters File -->\r\n");
102d3c20:	e59f9368 	ldr	r9, [pc, #872]	; 102d3f90 <Read_IoT_Persistent_Data+0x374>

	return ret;
}

s32 Read_IoT_Persistent_Data(void)
{
102d3c24:	e24dd014 	sub	sp, sp, #20
	u32 i = 0;

	s32 ret = -1;
	s32 fileHandl = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Read From IoT Persistent Parameters File -->\r\n");
102d3c28:	e3a02c02 	mov	r2, #512	; 0x200
102d3c2c:	e3a01000 	mov	r1, #0
102d3c30:	e59f035c 	ldr	r0, [pc, #860]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3c34:	e59f835c 	ldr	r8, [pc, #860]	; 102d3f98 <Read_IoT_Persistent_Data+0x37c>
102d3c38:	e12fff38 	blx	r8
102d3c3c:	e59f1358 	ldr	r1, [pc, #856]	; 102d3f9c <Read_IoT_Persistent_Data+0x380>
102d3c40:	e5993000 	ldr	r3, [r9]
102d3c44:	e59f0348 	ldr	r0, [pc, #840]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3c48:	e12fff33 	blx	r3
102d3c4c:	e59fb34c 	ldr	fp, [pc, #844]	; 102d3fa0 <Read_IoT_Persistent_Data+0x384>
102d3c50:	e59f033c 	ldr	r0, [pc, #828]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3c54:	e12fff3b 	blx	fp
#endif

	char *parameter_ = NULL;

	fileHandl = fileSys_checkFile((u8*)file_IoTdata);
102d3c58:	e59f4344 	ldr	r4, [pc, #836]	; 102d3fa4 <Read_IoT_Persistent_Data+0x388>
	u32 i = 0;

	s32 ret = -1;
	s32 fileHandl = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Read From IoT Persistent Parameters File -->\r\n");
102d3c5c:	e59f1330 	ldr	r1, [pc, #816]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3c60:	e59f3340 	ldr	r3, [pc, #832]	; 102d3fa8 <Read_IoT_Persistent_Data+0x38c>
102d3c64:	e1a02000 	mov	r2, r0
102d3c68:	e3a0000a 	mov	r0, #10
102d3c6c:	e12fff33 	blx	r3
#endif

	char *parameter_ = NULL;

	fileHandl = fileSys_checkFile((u8*)file_IoTdata);
102d3c70:	e5940004 	ldr	r0, [r4, #4]
102d3c74:	ebfffcaf 	bl	102d2f38 <fileSys_checkFile>

	if(fileHandl == QL_RET_OK) // If file already present
102d3c78:	e2506000 	subs	r6, r0, #0
102d3c7c:	0a000002 	beq	102d3c8c <Read_IoT_Persistent_Data+0x70>
#endif
		//return RET_FAIL;
	}

	return 1;
}
102d3c80:	e3a00001 	mov	r0, #1
102d3c84:	e28dd014 	add	sp, sp, #20
102d3c88:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(fileHandl == QL_RET_OK) // If file already present
	{
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Persistent IoT parameters: file present : ->\r\n");
#endif
		fileHandl = fileSys_OpenOrCreateFile((u8*)file_IoTdata); //Open the file
102d3c8c:	e5940004 	ldr	r0, [r4, #4]
102d3c90:	ebfffc5a 	bl	102d2e00 <fileSys_OpenOrCreateFile>

		if(fileHandl >= QL_RET_OK)
102d3c94:	e250a000 	subs	sl, r0, #0
102d3c98:	bafffff8 	blt	102d3c80 <Read_IoT_Persistent_Data+0x64>
102d3c9c:	e59f7308 	ldr	r7, [pc, #776]	; 102d3fac <Read_IoT_Persistent_Data+0x390>
102d3ca0:	e1a04006 	mov	r4, r6
102d3ca4:	ea000022 	b	102d3d34 <Read_IoT_Persistent_Data+0x118>
#ifdef DEBUG_MSG
				if(i==0)
				{
					APP_DEBUG("1. Device Serial ID");
				}
				else if(i==1)
102d3ca8:	e3540001 	cmp	r4, #1
102d3cac:	0a00006f 	beq	102d3e70 <Read_IoT_Persistent_Data+0x254>
				{
					APP_DEBUG("2. Assigned DPS ID");
				}
				else if(i==2)
102d3cb0:	e3540002 	cmp	r4, #2
102d3cb4:	0a000074 	beq	102d3e8c <Read_IoT_Persistent_Data+0x270>
				{
					APP_DEBUG("3. Assigned IoT Hub");
				}

#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
102d3cb8:	e5d53000 	ldrb	r3, [r5]
102d3cbc:	e353007b 	cmp	r3, #123	; 0x7b
102d3cc0:	0a000046 	beq	102d3de0 <Read_IoT_Persistent_Data+0x1c4>
				{

					persistent_parameter_IoT_array[i][0]= '{';
102d3cc4:	e59fe2e0 	ldr	lr, [pc, #736]	; 102d3fac <Read_IoT_Persistent_Data+0x390>
					persistent_parameter_IoT_array[i][1]= NULL;
102d3cc8:	e3a03000 	mov	r3, #0

#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
				{

					persistent_parameter_IoT_array[i][0]= '{';
102d3ccc:	e3a0c07b 	mov	ip, #123	; 0x7b
					persistent_parameter_IoT_array[i][1]= NULL;
#ifdef DEBUG_MSG
					APP_DEBUG(": -->\n\r");
102d3cd0:	e3a02c02 	mov	r2, #512	; 0x200

#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
				{

					persistent_parameter_IoT_array[i][0]= '{';
102d3cd4:	e7cec006 	strb	ip, [lr, r6]
					persistent_parameter_IoT_array[i][1]= NULL;
#ifdef DEBUG_MSG
					APP_DEBUG(": -->\n\r");
102d3cd8:	e1a01003 	mov	r1, r3
102d3cdc:	e59f02b0 	ldr	r0, [pc, #688]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
				{

					persistent_parameter_IoT_array[i][0]= '{';
					persistent_parameter_IoT_array[i][1]= NULL;
102d3ce0:	e5c73001 	strb	r3, [r7, #1]
#ifdef DEBUG_MSG
					APP_DEBUG(": -->\n\r");
102d3ce4:	e12fff38 	blx	r8
102d3ce8:	e59f12c0 	ldr	r1, [pc, #704]	; 102d3fb0 <Read_IoT_Persistent_Data+0x394>
102d3cec:	e5993000 	ldr	r3, [r9]
102d3cf0:	e59f029c 	ldr	r0, [pc, #668]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3cf4:	e12fff33 	blx	r3
102d3cf8:	e59f0294 	ldr	r0, [pc, #660]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3cfc:	e12fff3b 	blx	fp
102d3d00:	e59f128c 	ldr	r1, [pc, #652]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3d04:	e59f329c 	ldr	r3, [pc, #668]	; 102d3fa8 <Read_IoT_Persistent_Data+0x38c>
102d3d08:	e1a02000 	mov	r2, r0
102d3d0c:	e3a0000a 	mov	r0, #10
102d3d10:	e12fff33 	blx	r3
					}

					//Copy in the array that will be used to stoer back while power down
					strcpy(persistent_parameter_IoT_array[i],parameter_);
				}
				Ql_MEM_Free(parameter_);
102d3d14:	e1a00005 	mov	r0, r5
#endif
		fileHandl = fileSys_OpenOrCreateFile((u8*)file_IoTdata); //Open the file

		if(fileHandl >= QL_RET_OK)
		{
			for(i = 0; i<MAX_PERSISTENT_IOT_PARAMETERS ; i++) // Scan for all persistent parameters one by one in the file
102d3d18:	e2844001 	add	r4, r4, #1
					}

					//Copy in the array that will be used to stoer back while power down
					strcpy(persistent_parameter_IoT_array[i],parameter_);
				}
				Ql_MEM_Free(parameter_);
102d3d1c:	e59fc290 	ldr	ip, [pc, #656]	; 102d3fb4 <Read_IoT_Persistent_Data+0x398>
102d3d20:	e12fff3c 	blx	ip
#endif
		fileHandl = fileSys_OpenOrCreateFile((u8*)file_IoTdata); //Open the file

		if(fileHandl >= QL_RET_OK)
		{
			for(i = 0; i<MAX_PERSISTENT_IOT_PARAMETERS ; i++) // Scan for all persistent parameters one by one in the file
102d3d24:	e354000a 	cmp	r4, #10
102d3d28:	e2866096 	add	r6, r6, #150	; 0x96
102d3d2c:	e2877096 	add	r7, r7, #150	; 0x96
102d3d30:	0a00004a 	beq	102d3e60 <Read_IoT_Persistent_Data+0x244>
			{
				Ql_WTD_Feed(wtdid);
102d3d34:	e59fc27c 	ldr	ip, [pc, #636]	; 102d3fb8 <Read_IoT_Persistent_Data+0x39c>
102d3d38:	e59f327c 	ldr	r3, [pc, #636]	; 102d3fbc <Read_IoT_Persistent_Data+0x3a0>
102d3d3c:	e59c0000 	ldr	r0, [ip]
102d3d40:	e12fff33 	blx	r3
				ret = Ql_FS_Seek(fileHandl, i*PERSISTENT_IOT_PARAMETER_LENGTH , QL_FS_FILE_BEGIN); // Point to the start of required message in the file
102d3d44:	e59fc274 	ldr	ip, [pc, #628]	; 102d3fc0 <Read_IoT_Persistent_Data+0x3a4>
102d3d48:	e1a01006 	mov	r1, r6
102d3d4c:	e3a02000 	mov	r2, #0
102d3d50:	e1a0000a 	mov	r0, sl
102d3d54:	e12fff3c 	blx	ip
#ifdef FILE_STORAGE
					APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
#endif
				}

				parameter_ = (char*)Ql_MEM_Alloc(PERSISTENT_IOT_PARAMETER_LENGTH);
102d3d58:	e59f3264 	ldr	r3, [pc, #612]	; 102d3fc4 <Read_IoT_Persistent_Data+0x3a8>
102d3d5c:	e3a00096 	mov	r0, #150	; 0x96
102d3d60:	e12fff33 	blx	r3
				Ql_memset(parameter_, 0x0,PERSISTENT_IOT_PARAMETER_LENGTH );
102d3d64:	e3a02096 	mov	r2, #150	; 0x96
102d3d68:	e3a01000 	mov	r1, #0
#ifdef FILE_STORAGE
					APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
#endif
				}

				parameter_ = (char*)Ql_MEM_Alloc(PERSISTENT_IOT_PARAMETER_LENGTH);
102d3d6c:	e1a05000 	mov	r5, r0
				Ql_memset(parameter_, 0x0,PERSISTENT_IOT_PARAMETER_LENGTH );
102d3d70:	e12fff38 	blx	r8
				ret = Ql_FS_Read(fileHandl,(u8*)parameter_,PERSISTENT_IOT_PARAMETER_LENGTH, &readedlen); // Read the payload from the file
102d3d74:	e1a0000a 	mov	r0, sl
102d3d78:	e1a01005 	mov	r1, r5
102d3d7c:	e3a02096 	mov	r2, #150	; 0x96
102d3d80:	e59f3240 	ldr	r3, [pc, #576]	; 102d3fc8 <Read_IoT_Persistent_Data+0x3ac>
102d3d84:	e59fc240 	ldr	ip, [pc, #576]	; 102d3fcc <Read_IoT_Persistent_Data+0x3b0>
102d3d88:	e12fff3c 	blx	ip
					APP_DEBUG("\r\nError : Ql_FS_Read ret : %d\r\n",ret);
#endif
				}

#ifdef DEBUG_MSG
				if(i==0)
102d3d8c:	e3540000 	cmp	r4, #0
102d3d90:	1affffc4 	bne	102d3ca8 <Read_IoT_Persistent_Data+0x8c>
				{
					APP_DEBUG("1. Device Serial ID");
102d3d94:	e1a01004 	mov	r1, r4
102d3d98:	e3a02c02 	mov	r2, #512	; 0x200
102d3d9c:	e59f01f0 	ldr	r0, [pc, #496]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3da0:	e59f31f0 	ldr	r3, [pc, #496]	; 102d3f98 <Read_IoT_Persistent_Data+0x37c>
102d3da4:	e12fff33 	blx	r3
102d3da8:	e59f1220 	ldr	r1, [pc, #544]	; 102d3fd0 <Read_IoT_Persistent_Data+0x3b4>
				{
					APP_DEBUG("2. Assigned DPS ID");
				}
				else if(i==2)
				{
					APP_DEBUG("3. Assigned IoT Hub");
102d3dac:	e5993000 	ldr	r3, [r9]
102d3db0:	e59f01dc 	ldr	r0, [pc, #476]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3db4:	e12fff33 	blx	r3
102d3db8:	e59f01d4 	ldr	r0, [pc, #468]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3dbc:	e12fff3b 	blx	fp
102d3dc0:	e59f11cc 	ldr	r1, [pc, #460]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3dc4:	e59fc1dc 	ldr	ip, [pc, #476]	; 102d3fa8 <Read_IoT_Persistent_Data+0x38c>
102d3dc8:	e1a02000 	mov	r2, r0
102d3dcc:	e3a0000a 	mov	r0, #10
102d3dd0:	e12fff3c 	blx	ip
				}

#endif
				if(parameter_[0] != '{') //A parameter is invalid if it start with character other than '{'
102d3dd4:	e5d53000 	ldrb	r3, [r5]
102d3dd8:	e353007b 	cmp	r3, #123	; 0x7b
102d3ddc:	1affffb8 	bne	102d3cc4 <Read_IoT_Persistent_Data+0xa8>
					APP_DEBUG(": -->\n\r");
#endif
				}
				else // Valid parameter
				{
					APP_DEBUG(": %s -->\n\r",&parameter_[1]);
102d3de0:	e285c001 	add	ip, r5, #1
102d3de4:	e3a01000 	mov	r1, #0
102d3de8:	e3a02c02 	mov	r2, #512	; 0x200
102d3dec:	e59f01a0 	ldr	r0, [pc, #416]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3df0:	e58dc00c 	str	ip, [sp, #12]
102d3df4:	e12fff38 	blx	r8
102d3df8:	e59f11d4 	ldr	r1, [pc, #468]	; 102d3fd4 <Read_IoT_Persistent_Data+0x3b8>
102d3dfc:	e59d200c 	ldr	r2, [sp, #12]
102d3e00:	e5993000 	ldr	r3, [r9]
102d3e04:	e59f0188 	ldr	r0, [pc, #392]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3e08:	e12fff33 	blx	r3
102d3e0c:	e59f0180 	ldr	r0, [pc, #384]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3e10:	e12fff3b 	blx	fp
102d3e14:	e59f318c 	ldr	r3, [pc, #396]	; 102d3fa8 <Read_IoT_Persistent_Data+0x38c>
102d3e18:	e59f1174 	ldr	r1, [pc, #372]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3e1c:	e1a02000 	mov	r2, r0
102d3e20:	e3a0000a 	mov	r0, #10
102d3e24:	e12fff33 	blx	r3
					//Read the parameter and assign them to global variables..
					if(i == 0)//Device serial ID
102d3e28:	e3540000 	cmp	r4, #0
					APP_DEBUG(": -->\n\r");
#endif
				}
				else // Valid parameter
				{
					APP_DEBUG(": %s -->\n\r",&parameter_[1]);
102d3e2c:	e59f316c 	ldr	r3, [pc, #364]	; 102d3fa0 <Read_IoT_Persistent_Data+0x384>
					//Read the parameter and assign them to global variables..
					if(i == 0)//Device serial ID
102d3e30:	0a00001c 	beq	102d3ea8 <Read_IoT_Persistent_Data+0x28c>
							{
								Ql_strcpy(AZURE_IoT_device_ID,&parameter_[1]);
							}
						}
					}
					else if(i == 1)//Azure DPS ID
102d3e34:	e3540001 	cmp	r4, #1
102d3e38:	0a000027 	beq	102d3edc <Read_IoT_Persistent_Data+0x2c0>
							{
								Ql_strcpy(AZURE_IoT_DPS_ID,&parameter_[1]);
							}
						}
					}
					else if(i == 2)//Azure Assigned Hub
102d3e3c:	e3540002 	cmp	r4, #2
102d3e40:	0a000032 	beq	102d3f10 <Read_IoT_Persistent_Data+0x2f4>
							}
						}
					}

					//Copy in the array that will be used to stoer back while power down
					strcpy(persistent_parameter_IoT_array[i],parameter_);
102d3e44:	e59f3160 	ldr	r3, [pc, #352]	; 102d3fac <Read_IoT_Persistent_Data+0x390>
102d3e48:	e3a00096 	mov	r0, #150	; 0x96
102d3e4c:	e0203094 	mla	r0, r4, r0, r3
102d3e50:	e1a01005 	mov	r1, r5
102d3e54:	e59f317c 	ldr	r3, [pc, #380]	; 102d3fd8 <Read_IoT_Persistent_Data+0x3bc>
102d3e58:	e12fff33 	blx	r3
102d3e5c:	eaffffac 	b	102d3d14 <Read_IoT_Persistent_Data+0xf8>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d3e60:	e1a0000a 	mov	r0, sl
102d3e64:	e59f3170 	ldr	r3, [pc, #368]	; 102d3fdc <Read_IoT_Persistent_Data+0x3c0>
102d3e68:	e12fff33 	blx	r3
102d3e6c:	eaffff83 	b	102d3c80 <Read_IoT_Persistent_Data+0x64>
				{
					APP_DEBUG("1. Device Serial ID");
				}
				else if(i==1)
				{
					APP_DEBUG("2. Assigned DPS ID");
102d3e70:	e3a01000 	mov	r1, #0
102d3e74:	e3a02c02 	mov	r2, #512	; 0x200
102d3e78:	e59f0114 	ldr	r0, [pc, #276]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3e7c:	e59f3114 	ldr	r3, [pc, #276]	; 102d3f98 <Read_IoT_Persistent_Data+0x37c>
102d3e80:	e12fff33 	blx	r3
102d3e84:	e59f1154 	ldr	r1, [pc, #340]	; 102d3fe0 <Read_IoT_Persistent_Data+0x3c4>
102d3e88:	eaffffc7 	b	102d3dac <Read_IoT_Persistent_Data+0x190>
				}
				else if(i==2)
				{
					APP_DEBUG("3. Assigned IoT Hub");
102d3e8c:	e3a01000 	mov	r1, #0
102d3e90:	e3a02c02 	mov	r2, #512	; 0x200
102d3e94:	e59f00f8 	ldr	r0, [pc, #248]	; 102d3f94 <Read_IoT_Persistent_Data+0x378>
102d3e98:	e59f30f8 	ldr	r3, [pc, #248]	; 102d3f98 <Read_IoT_Persistent_Data+0x37c>
102d3e9c:	e12fff33 	blx	r3
102d3ea0:	e59f113c 	ldr	r1, [pc, #316]	; 102d3fe4 <Read_IoT_Persistent_Data+0x3c8>
102d3ea4:	eaffffc0 	b	102d3dac <Read_IoT_Persistent_Data+0x190>
				{
					APP_DEBUG(": %s -->\n\r",&parameter_[1]);
					//Read the parameter and assign them to global variables..
					if(i == 0)//Device serial ID
					{
						if(Ql_strlen(&parameter_[1]))// There is a valid string i.e. non zero string length
102d3ea8:	e59d000c 	ldr	r0, [sp, #12]
102d3eac:	e12fff33 	blx	r3
102d3eb0:	e3500000 	cmp	r0, #0
102d3eb4:	0affffe2 	beq	102d3e44 <Read_IoT_Persistent_Data+0x228>
						{
							if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE)//Do not recover if recovered earlier
102d3eb8:	e59f3128 	ldr	r3, [pc, #296]	; 102d3fe8 <Read_IoT_Persistent_Data+0x3cc>
102d3ebc:	e5d33017 	ldrb	r3, [r3, #23]
102d3ec0:	e3530000 	cmp	r3, #0
102d3ec4:	1affffde 	bne	102d3e44 <Read_IoT_Persistent_Data+0x228>
							{
								Ql_strcpy(AZURE_IoT_device_ID,&parameter_[1]);
102d3ec8:	e59d100c 	ldr	r1, [sp, #12]
102d3ecc:	e59f3118 	ldr	r3, [pc, #280]	; 102d3fec <Read_IoT_Persistent_Data+0x3d0>
102d3ed0:	e59f0118 	ldr	r0, [pc, #280]	; 102d3ff0 <Read_IoT_Persistent_Data+0x3d4>
102d3ed4:	e12fff33 	blx	r3
102d3ed8:	eaffffd9 	b	102d3e44 <Read_IoT_Persistent_Data+0x228>
							}
						}
					}
					else if(i == 1)//Azure DPS ID
					{
						if(Ql_strlen(&parameter_[1])) // There is a valid string i.e. non zero string length
102d3edc:	e59d000c 	ldr	r0, [sp, #12]
102d3ee0:	e12fff33 	blx	r3
102d3ee4:	e3500000 	cmp	r0, #0
102d3ee8:	0affffd5 	beq	102d3e44 <Read_IoT_Persistent_Data+0x228>
						{
							if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE)//Do not recover if recovered earlier
102d3eec:	e59f30f4 	ldr	r3, [pc, #244]	; 102d3fe8 <Read_IoT_Persistent_Data+0x3cc>
102d3ef0:	e5d33017 	ldrb	r3, [r3, #23]
102d3ef4:	e3530000 	cmp	r3, #0
102d3ef8:	1affffd1 	bne	102d3e44 <Read_IoT_Persistent_Data+0x228>
							{
								Ql_strcpy(AZURE_IoT_DPS_ID,&parameter_[1]);
102d3efc:	e59d100c 	ldr	r1, [sp, #12]
102d3f00:	e59f30e4 	ldr	r3, [pc, #228]	; 102d3fec <Read_IoT_Persistent_Data+0x3d0>
102d3f04:	e59f00e8 	ldr	r0, [pc, #232]	; 102d3ff4 <Read_IoT_Persistent_Data+0x3d8>
102d3f08:	e12fff33 	blx	r3
102d3f0c:	eaffffcc 	b	102d3e44 <Read_IoT_Persistent_Data+0x228>
							}
						}
					}
					else if(i == 2)//Azure Assigned Hub
					{
						if(Ql_strlen(&parameter_[1])) // There is a valid string i.e. non zero string length
102d3f10:	e59d000c 	ldr	r0, [sp, #12]
102d3f14:	e12fff33 	blx	r3
102d3f18:	e3500000 	cmp	r0, #0
102d3f1c:	0affffc8 	beq	102d3e44 <Read_IoT_Persistent_Data+0x228>
						{
							Ql_strcpy(AZURE_assigned_IoT_Hub,&parameter_[1]);
102d3f20:	e59f30c4 	ldr	r3, [pc, #196]	; 102d3fec <Read_IoT_Persistent_Data+0x3d0>
102d3f24:	e59f00cc 	ldr	r0, [pc, #204]	; 102d3ff8 <Read_IoT_Persistent_Data+0x3dc>
102d3f28:	e59d100c 	ldr	r1, [sp, #12]
102d3f2c:	e12fff33 	blx	r3
							if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE)//Do not recover if recovered earlier
102d3f30:	e59f30b0 	ldr	r3, [pc, #176]	; 102d3fe8 <Read_IoT_Persistent_Data+0x3cc>
102d3f34:	e5d33017 	ldrb	r3, [r3, #23]
102d3f38:	e3530000 	cmp	r3, #0
102d3f3c:	1affffc0 	bne	102d3e44 <Read_IoT_Persistent_Data+0x228>
							{
								Ql_sprintf(DEVICE_USER_ID, "%s/%s",AZURE_assigned_IoT_Hub,AZURE_IoT_device_ID);
102d3f40:	e59f20b0 	ldr	r2, [pc, #176]	; 102d3ff8 <Read_IoT_Persistent_Data+0x3dc>
102d3f44:	e59fc044 	ldr	ip, [pc, #68]	; 102d3f90 <Read_IoT_Persistent_Data+0x374>
102d3f48:	e2423038 	sub	r3, r2, #56	; 0x38
102d3f4c:	e59cc000 	ldr	ip, [ip]
102d3f50:	e59f10a4 	ldr	r1, [pc, #164]	; 102d3ffc <Read_IoT_Persistent_Data+0x3e0>
102d3f54:	e59f00a4 	ldr	r0, [pc, #164]	; 102d4000 <Read_IoT_Persistent_Data+0x3e4>
102d3f58:	e12fff3c 	blx	ip
								Ql_sprintf(DEVICE_CLIENT_ID, "%s",AZURE_IoT_device_ID);
102d3f5c:	e59fe02c 	ldr	lr, [pc, #44]	; 102d3f90 <Read_IoT_Persistent_Data+0x374>
102d3f60:	e59f109c 	ldr	r1, [pc, #156]	; 102d4004 <Read_IoT_Persistent_Data+0x3e8>
102d3f64:	e59e3000 	ldr	r3, [lr]
102d3f68:	e59f2080 	ldr	r2, [pc, #128]	; 102d3ff0 <Read_IoT_Persistent_Data+0x3d4>
102d3f6c:	e59f0094 	ldr	r0, [pc, #148]	; 102d4008 <Read_IoT_Persistent_Data+0x3ec>
102d3f70:	e12fff33 	blx	r3
#ifndef POWER_ON_DPS_CONNECT
								FLAG.AUTOPROVISIONING_COMPLETE = TRUE;
#endif
								Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102d3f74:	e59f1090 	ldr	r1, [pc, #144]	; 102d400c <Read_IoT_Persistent_Data+0x3f0>
102d3f78:	e1a02004 	mov	r2, r4
102d3f7c:	e1a03004 	mov	r3, r4
102d3f80:	e59fc088 	ldr	ip, [pc, #136]	; 102d4010 <Read_IoT_Persistent_Data+0x3f4>
102d3f84:	e3a00003 	mov	r0, #3
102d3f88:	e12fff3c 	blx	ip
102d3f8c:	eaffffac 	b	102d3e44 <Read_IoT_Persistent_Data+0x228>
102d3f90:	f03de540 	.word	0xf03de540
102d3f94:	f03d5bfc 	.word	0xf03d5bfc
102d3f98:	102e58f4 	.word	0x102e58f4
102d3f9c:	102ef2a4 	.word	0x102ef2a4
102d3fa0:	102e57a4 	.word	0x102e57a4
102d3fa4:	f03d209c 	.word	0xf03d209c
102d3fa8:	102e6230 	.word	0x102e6230
102d3fac:	f03ddf48 	.word	0xf03ddf48
102d3fb0:	102ef1fc 	.word	0x102ef1fc
102d3fb4:	102e48b8 	.word	0x102e48b8
102d3fb8:	f03da8c8 	.word	0xf03da8c8
102d3fbc:	102e642c 	.word	0x102e642c
102d3fc0:	102e41a8 	.word	0x102e41a8
102d3fc4:	102e4840 	.word	0x102e4840
102d3fc8:	f03db8f8 	.word	0xf03db8f8
102d3fcc:	102e40b8 	.word	0x102e40b8
102d3fd0:	102ef2dc 	.word	0x102ef2dc
102d3fd4:	102ef204 	.word	0x102ef204
102d3fd8:	102dff55 	.word	0x102dff55
102d3fdc:	102e426c 	.word	0x102e426c
102d3fe0:	102ef2f0 	.word	0x102ef2f0
102d3fe4:	102ef304 	.word	0x102ef304
102d3fe8:	f03da5f0 	.word	0xf03da5f0
102d3fec:	102e55fc 	.word	0x102e55fc
102d3ff0:	f03d5dfc 	.word	0xf03d5dfc
102d3ff4:	f03d5e18 	.word	0xf03d5e18
102d3ff8:	f03d5e34 	.word	0xf03d5e34
102d3ffc:	102ef318 	.word	0x102ef318
102d4000:	f03d574c 	.word	0xf03d574c
102d4004:	102ef04c 	.word	0x102ef04c
102d4008:	f03d5730 	.word	0xf03d5730
102d400c:	000010c8 	.word	0x000010c8
102d4010:	102e5cb4 	.word	0x102e5cb4

102d4014 <Find_Newest_Payload_Number>:
 *
 * Return:
 *
 *****************************************************************/
void Find_Newest_Payload_Number(void)
{
102d4014:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8 valid_payload = 0;
#ifdef FILE_STORAGE
	APP_DEBUG("\r\n<-- Find Next MQTT Pending Message number to Wtite the payload -->\n\r");
#endif
	// Open the log file that stored unpublished MQTT messages or pending messgaes
	filehandleData = fileSys_OpenOrCreateFile((u8*)file_data);
102d4018:	e59f30e8 	ldr	r3, [pc, #232]	; 102d4108 <Find_Newest_Payload_Number+0xf4>
102d401c:	e5930008 	ldr	r0, [r3, #8]
102d4020:	ebfffb76 	bl	102d2e00 <fileSys_OpenOrCreateFile>
	if(filehandleData >= QL_RET_OK)
102d4024:	e2505000 	subs	r5, r0, #0
102d4028:	b8bd8ff8 	poplt	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102d402c:	e3a04000 	mov	r4, #0
102d4030:	e59fb0d4 	ldr	fp, [pc, #212]	; 102d410c <Find_Newest_Payload_Number+0xf8>
102d4034:	e59f90d4 	ldr	r9, [pc, #212]	; 102d4110 <Find_Newest_Payload_Number+0xfc>
102d4038:	e59fa0d4 	ldr	sl, [pc, #212]	; 102d4114 <Find_Newest_Payload_Number+0x100>
102d403c:	e59f60d4 	ldr	r6, [pc, #212]	; 102d4118 <Find_Newest_Payload_Number+0x104>
102d4040:	e59f80d4 	ldr	r8, [pc, #212]	; 102d411c <Find_Newest_Payload_Number+0x108>
102d4044:	e1a07004 	mov	r7, r4
	{
		for(i = 0; i<MAX_PAYLOADS ; i++) // Read through all payloads / records one by one and copy in the corresponding array records
		{
			Ql_WTD_Feed(wtdid);
102d4048:	e59b0000 	ldr	r0, [fp]
102d404c:	e12fff39 	blx	r9
			ret = Ql_FS_Seek(filehandleData, i*PAYLOAD_LENGTH , QL_FS_FILE_BEGIN); // Reach to the start of the current payload number
102d4050:	e1a01004 	mov	r1, r4
102d4054:	e3a02000 	mov	r2, #0
102d4058:	e1a00005 	mov	r0, r5
102d405c:	e12fff3a 	blx	sl
#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
#endif
			}

			ret = Ql_FS_Read(filehandleData,(u8*)payload_array[i],PAYLOAD_LENGTH, &readedlen); // Read the entire payload and copy in the array
102d4060:	e3a030c8 	mov	r3, #200	; 0xc8
102d4064:	e0216793 	mla	r1, r3, r7, r6
102d4068:	e1a02003 	mov	r2, r3
102d406c:	e1a00005 	mov	r0, r5
102d4070:	e59f30a8 	ldr	r3, [pc, #168]	; 102d4120 <Find_Newest_Payload_Number+0x10c>
#endif
	// Open the log file that stored unpublished MQTT messages or pending messgaes
	filehandleData = fileSys_OpenOrCreateFile((u8*)file_data);
	if(filehandleData >= QL_RET_OK)
	{
		for(i = 0; i<MAX_PAYLOADS ; i++) // Read through all payloads / records one by one and copy in the corresponding array records
102d4074:	e2877001 	add	r7, r7, #1
#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
#endif
			}

			ret = Ql_FS_Read(filehandleData,(u8*)payload_array[i],PAYLOAD_LENGTH, &readedlen); // Read the entire payload and copy in the array
102d4078:	e12fff38 	blx	r8
#endif
	// Open the log file that stored unpublished MQTT messages or pending messgaes
	filehandleData = fileSys_OpenOrCreateFile((u8*)file_data);
	if(filehandleData >= QL_RET_OK)
	{
		for(i = 0; i<MAX_PAYLOADS ; i++) // Read through all payloads / records one by one and copy in the corresponding array records
102d407c:	e357002e 	cmp	r7, #46	; 0x2e
102d4080:	e28440c8 	add	r4, r4, #200	; 0xc8
102d4084:	1affffef 	bne	102d4048 <Find_Newest_Payload_Number+0x34>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d4088:	e1a00005 	mov	r0, r5
102d408c:	e59f3090 	ldr	r3, [pc, #144]	; 102d4124 <Find_Newest_Payload_Number+0x110>
102d4090:	e59f5090 	ldr	r5, [pc, #144]	; 102d4128 <Find_Newest_Payload_Number+0x114>
102d4094:	e12fff33 	blx	r3
102d4098:	e3a03000 	mov	r3, #0
102d409c:	e5d54000 	ldrb	r4, [r5]
void Find_Newest_Payload_Number(void)
{
	s32  i = 0;
	s32  ret = -1;
	s32  filehandleData = -1;
	u8 valid_payload = 0;
102d40a0:	e1a02003 	mov	r2, r3
		// Close the log file that stored unpublished MQTT messages or pending messgaes.. as all the payloads / messages are now copied in array temporarly
		// Array pointer handling is easy than file pointer handling :-)
		fileSys_CloseFile(filehandleData);

		// Scan the array for all records and find out where is the new MQTT message payload to be stored i.e. an empty payload storage just after latest Message
		for(i = 0; i<MAX_PAYLOADS ; i++)
102d40a4:	e1a01003 	mov	r1, r3
102d40a8:	ea000007 	b	102d40cc <Find_Newest_Payload_Number+0xb8>
		{
			if(valid_payload && payload_array[i][0]!='{')// An empty / invalid payload found after a valid messgae / payload storage
102d40ac:	e7d62003 	ldrb	r2, [r6, r3]
102d40b0:	e352007b 	cmp	r2, #123	; 0x7b
102d40b4:	1a000011 	bne	102d4100 <Find_Newest_Payload_Number+0xec>
		// Close the log file that stored unpublished MQTT messages or pending messgaes.. as all the payloads / messages are now copied in array temporarly
		// Array pointer handling is easy than file pointer handling :-)
		fileSys_CloseFile(filehandleData);

		// Scan the array for all records and find out where is the new MQTT message payload to be stored i.e. an empty payload storage just after latest Message
		for(i = 0; i<MAX_PAYLOADS ; i++)
102d40b8:	e2811001 	add	r1, r1, #1
102d40bc:	e351002e 	cmp	r1, #46	; 0x2e
			else if((!valid_payload) && payload_array[i][0]!='{')
			{
				payload_count = 0; // No valid payload found to re-wind to start of the array.
			}
			if(payload_array[i][0] == '{')
				valid_payload++; // This is a valid payload so scan the next payload.
102d40c0:	e20020ff 	and	r2, r0, #255	; 0xff
102d40c4:	e28330c8 	add	r3, r3, #200	; 0xc8
		// Close the log file that stored unpublished MQTT messages or pending messgaes.. as all the payloads / messages are now copied in array temporarly
		// Array pointer handling is easy than file pointer handling :-)
		fileSys_CloseFile(filehandleData);

		// Scan the array for all records and find out where is the new MQTT message payload to be stored i.e. an empty payload storage just after latest Message
		for(i = 0; i<MAX_PAYLOADS ; i++)
102d40c8:	0a00000a 	beq	102d40f8 <Find_Newest_Payload_Number+0xe4>
		{
			if(valid_payload && payload_array[i][0]!='{')// An empty / invalid payload found after a valid messgae / payload storage
102d40cc:	e3520000 	cmp	r2, #0
			else if((!valid_payload) && payload_array[i][0]!='{')
			{
				payload_count = 0; // No valid payload found to re-wind to start of the array.
			}
			if(payload_array[i][0] == '{')
				valid_payload++; // This is a valid payload so scan the next payload.
102d40d0:	e2820001 	add	r0, r2, #1
		fileSys_CloseFile(filehandleData);

		// Scan the array for all records and find out where is the new MQTT message payload to be stored i.e. an empty payload storage just after latest Message
		for(i = 0; i<MAX_PAYLOADS ; i++)
		{
			if(valid_payload && payload_array[i][0]!='{')// An empty / invalid payload found after a valid messgae / payload storage
102d40d4:	1afffff4 	bne	102d40ac <Find_Newest_Payload_Number+0x98>
			{
				payload_count = i;
				break;
			}
			else if((!valid_payload) && payload_array[i][0]!='{')
102d40d8:	e7d6c003 	ldrb	ip, [r6, r3]
102d40dc:	e35c007b 	cmp	ip, #123	; 0x7b
102d40e0:	0afffff4 	beq	102d40b8 <Find_Newest_Payload_Number+0xa4>
		// Close the log file that stored unpublished MQTT messages or pending messgaes.. as all the payloads / messages are now copied in array temporarly
		// Array pointer handling is easy than file pointer handling :-)
		fileSys_CloseFile(filehandleData);

		// Scan the array for all records and find out where is the new MQTT message payload to be stored i.e. an empty payload storage just after latest Message
		for(i = 0; i<MAX_PAYLOADS ; i++)
102d40e4:	e2811001 	add	r1, r1, #1
102d40e8:	e351002e 	cmp	r1, #46	; 0x2e
				payload_count = i;
				break;
			}
			else if((!valid_payload) && payload_array[i][0]!='{')
			{
				payload_count = 0; // No valid payload found to re-wind to start of the array.
102d40ec:	e1a04002 	mov	r4, r2
102d40f0:	e28330c8 	add	r3, r3, #200	; 0xc8
		// Close the log file that stored unpublished MQTT messages or pending messgaes.. as all the payloads / messages are now copied in array temporarly
		// Array pointer handling is easy than file pointer handling :-)
		fileSys_CloseFile(filehandleData);

		// Scan the array for all records and find out where is the new MQTT message payload to be stored i.e. an empty payload storage just after latest Message
		for(i = 0; i<MAX_PAYLOADS ; i++)
102d40f4:	1afffff4 	bne	102d40cc <Find_Newest_Payload_Number+0xb8>
102d40f8:	e5c54000 	strb	r4, [r5]
102d40fc:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		{
			if(valid_payload && payload_array[i][0]!='{')// An empty / invalid payload found after a valid messgae / payload storage
			{
				payload_count = i;
102d4100:	e5c51000 	strb	r1, [r5]
				break;
102d4104:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102d4108:	f03d209c 	.word	0xf03d209c
102d410c:	f03da8c8 	.word	0xf03da8c8
102d4110:	102e642c 	.word	0x102e642c
102d4114:	102e41a8 	.word	0x102e41a8
102d4118:	f03db964 	.word	0xf03db964
102d411c:	102e40b8 	.word	0x102e40b8
102d4120:	f03db8f8 	.word	0xf03db8f8
102d4124:	102e426c 	.word	0x102e426c
102d4128:	f03d5bf8 	.word	0xf03d5bf8

102d412c <Write_And_Store_Pending_MQTT_Log_Messages>:
 *
 * Return:
 *
 *****************************************************************/
s32 Write_And_Store_Pending_MQTT_Log_Messages(char* payload)
{
102d412c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	s32  filehandle = -1;
	s32 ret = -1;
	Find_Newest_Payload_Number(); // Find the next empty payload number in the storage
	strcpy(payload_array[payload_count],payload);
102d4130:	e59f4104 	ldr	r4, [pc, #260]	; 102d423c <Write_And_Store_Pending_MQTT_Log_Messages+0x110>
 *
 * Return:
 *
 *****************************************************************/
s32 Write_And_Store_Pending_MQTT_Log_Messages(char* payload)
{
102d4134:	e1a07000 	mov	r7, r0
	s32  filehandle = -1;
	s32 ret = -1;
	Find_Newest_Payload_Number(); // Find the next empty payload number in the storage
	strcpy(payload_array[payload_count],payload);
102d4138:	e59f5100 	ldr	r5, [pc, #256]	; 102d4240 <Write_And_Store_Pending_MQTT_Log_Messages+0x114>
 *****************************************************************/
s32 Write_And_Store_Pending_MQTT_Log_Messages(char* payload)
{
	s32  filehandle = -1;
	s32 ret = -1;
	Find_Newest_Payload_Number(); // Find the next empty payload number in the storage
102d413c:	ebffffb4 	bl	102d4014 <Find_Newest_Payload_Number>
	strcpy(payload_array[payload_count],payload);
102d4140:	e5d40000 	ldrb	r0, [r4]
102d4144:	e3a060c8 	mov	r6, #200	; 0xc8
102d4148:	e1a01007 	mov	r1, r7
102d414c:	e0205096 	mla	r0, r6, r0, r5
102d4150:	e59f30ec 	ldr	r3, [pc, #236]	; 102d4244 <Write_And_Store_Pending_MQTT_Log_Messages+0x118>
102d4154:	e12fff33 	blx	r3
#ifdef DEBUG_MSG
	APP_DEBUG("\r<-- Storing in New Pending MQTT Message [%d] -->\r\n",payload_count);
102d4158:	e3a01000 	mov	r1, #0
102d415c:	e3a02c02 	mov	r2, #512	; 0x200
102d4160:	e59f30e0 	ldr	r3, [pc, #224]	; 102d4248 <Write_And_Store_Pending_MQTT_Log_Messages+0x11c>
102d4164:	e59f00e0 	ldr	r0, [pc, #224]	; 102d424c <Write_And_Store_Pending_MQTT_Log_Messages+0x120>
102d4168:	e12fff33 	blx	r3
102d416c:	e59f30dc 	ldr	r3, [pc, #220]	; 102d4250 <Write_And_Store_Pending_MQTT_Log_Messages+0x124>
102d4170:	e5d42000 	ldrb	r2, [r4]
102d4174:	e59f10d8 	ldr	r1, [pc, #216]	; 102d4254 <Write_And_Store_Pending_MQTT_Log_Messages+0x128>
102d4178:	e5933000 	ldr	r3, [r3]
102d417c:	e59f00c8 	ldr	r0, [pc, #200]	; 102d424c <Write_And_Store_Pending_MQTT_Log_Messages+0x120>
102d4180:	e12fff33 	blx	r3
102d4184:	e59f30cc 	ldr	r3, [pc, #204]	; 102d4258 <Write_And_Store_Pending_MQTT_Log_Messages+0x12c>
102d4188:	e59f00bc 	ldr	r0, [pc, #188]	; 102d424c <Write_And_Store_Pending_MQTT_Log_Messages+0x120>
102d418c:	e12fff33 	blx	r3
102d4190:	e59f10b4 	ldr	r1, [pc, #180]	; 102d424c <Write_And_Store_Pending_MQTT_Log_Messages+0x120>
102d4194:	e59f30c0 	ldr	r3, [pc, #192]	; 102d425c <Write_And_Store_Pending_MQTT_Log_Messages+0x130>
102d4198:	e1a02000 	mov	r2, r0
102d419c:	e3a0000a 	mov	r0, #10
102d41a0:	e12fff33 	blx	r3
#endif
	//Make space for next payload. Mark the next payload as invalid or empty payload to store next / upcomming payload
	if(payload_count == (MAX_PAYLOADS -1)) // This is the last payload so it is time to rewind.
102d41a4:	e5d43000 	ldrb	r3, [r4]
102d41a8:	e353002d 	cmp	r3, #45	; 0x2d
		payload_array[0][0] = NULL;		//Set first payload NULL
		payload_count = 0;
	}
	else
	{
		payload_count++;
102d41ac:	12833001 	addne	r3, r3, #1
102d41b0:	120330ff 	andne	r3, r3, #255	; 0xff
		payload_array[payload_count][0] = NULL;		//Set next payload NULL
102d41b4:	10060693 	mulne	r6, r3, r6
	APP_DEBUG("\r<-- Storing in New Pending MQTT Message [%d] -->\r\n",payload_count);
#endif
	//Make space for next payload. Mark the next payload as invalid or empty payload to store next / upcomming payload
	if(payload_count == (MAX_PAYLOADS -1)) // This is the last payload so it is time to rewind.
	{
		payload_array[0][0] = NULL;		//Set first payload NULL
102d41b8:	03a03000 	moveq	r3, #0
		payload_count = 0;
	}
	else
	{
		payload_count++;
102d41bc:	15c43000 	strbne	r3, [r4]
		payload_array[payload_count][0] = NULL;		//Set next payload NULL
102d41c0:	13a03000 	movne	r3, #0
	APP_DEBUG("\r<-- Storing in New Pending MQTT Message [%d] -->\r\n",payload_count);
#endif
	//Make space for next payload. Mark the next payload as invalid or empty payload to store next / upcomming payload
	if(payload_count == (MAX_PAYLOADS -1)) // This is the last payload so it is time to rewind.
	{
		payload_array[0][0] = NULL;		//Set first payload NULL
102d41c4:	05c53000 	strbeq	r3, [r5]
		payload_count = 0;
102d41c8:	05c43000 	strbeq	r3, [r4]
	}
	else
	{
		payload_count++;
		payload_array[payload_count][0] = NULL;		//Set next payload NULL
102d41cc:	17c53006 	strbne	r3, [r5, r6]
	}


	//create file.. if not available or open the file if avaialble
	filehandle = fileSys_OpenOrCreateFile((u8*)file_data);
102d41d0:	e59f3088 	ldr	r3, [pc, #136]	; 102d4260 <Write_And_Store_Pending_MQTT_Log_Messages+0x134>
102d41d4:	e5930008 	ldr	r0, [r3, #8]
102d41d8:	ebfffb08 	bl	102d2e00 <fileSys_OpenOrCreateFile>
	if(filehandle >= QL_RET_OK)
102d41dc:	e2504000 	subs	r4, r0, #0
102d41e0:	ba000013 	blt	102d4234 <Write_And_Store_Pending_MQTT_Log_Messages+0x108>
	{
		ret = fileSys_WriteFile(filehandle,(u8*)payload_array,OVER_WRITE_TO_SIZE, MAX_PAYLOADS*PAYLOAD_LENGTH);
102d41e4:	e59f1054 	ldr	r1, [pc, #84]	; 102d4240 <Write_And_Store_Pending_MQTT_Log_Messages+0x114>
102d41e8:	e3a02002 	mov	r2, #2
102d41ec:	e59f3070 	ldr	r3, [pc, #112]	; 102d4264 <Write_And_Store_Pending_MQTT_Log_Messages+0x138>
102d41f0:	ebfffb21 	bl	102d2e7c <fileSys_WriteFile>
		if(QL_RET_OK != ret)
102d41f4:	e3500000 	cmp	r0, #0
102d41f8:	1a000008 	bne	102d4220 <Write_And_Store_Pending_MQTT_Log_Messages+0xf4>
#endif
			fileSys_CloseFile(filehandle);
			return -1;
		}
		else
			PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_PENDING_MESSAGES; //schedule event to send pending messgaes in next connection success
102d41fc:	e59f3064 	ldr	r3, [pc, #100]	; 102d4268 <Write_And_Store_Pending_MQTT_Log_Messages+0x13c>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d4200:	e1a00004 	mov	r0, r4
#endif
			fileSys_CloseFile(filehandle);
			return -1;
		}
		else
			PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_PENDING_MESSAGES; //schedule event to send pending messgaes in next connection success
102d4204:	e5932000 	ldr	r2, [r3]
102d4208:	e3822040 	orr	r2, r2, #64	; 0x40
102d420c:	e5832000 	str	r2, [r3]
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d4210:	e59f3054 	ldr	r3, [pc, #84]	; 102d426c <Write_And_Store_Pending_MQTT_Log_Messages+0x140>
102d4214:	e12fff33 	blx	r3
#ifdef FILE_STORAGE
		APP_DEBUG("\r\nError : File Open/Create [%s] ret : %d\r\n",file_data,ret);
#endif
		return -1;
	}
	return 1;
102d4218:	e3a00001 	mov	r0, #1
102d421c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d4220:	e1a00004 	mov	r0, r4
102d4224:	e59f3040 	ldr	r3, [pc, #64]	; 102d426c <Write_And_Store_Pending_MQTT_Log_Messages+0x140>
102d4228:	e12fff33 	blx	r3
		{
#ifdef FILE_STORAGE
			APP_DEBUG("\r\nError : fileSys_WriteFile [%s] ret : %d\r\n",__FUNCTION__,ret);
#endif
			fileSys_CloseFile(filehandle);
			return -1;
102d422c:	e3e00000 	mvn	r0, #0
102d4230:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	else
	{
#ifdef FILE_STORAGE
		APP_DEBUG("\r\nError : File Open/Create [%s] ret : %d\r\n",file_data,ret);
#endif
		return -1;
102d4234:	e3e00000 	mvn	r0, #0
	}
	return 1;
}
102d4238:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102d423c:	f03d5bf8 	.word	0xf03d5bf8
102d4240:	f03db964 	.word	0xf03db964
102d4244:	102dff55 	.word	0x102dff55
102d4248:	102e58f4 	.word	0x102e58f4
102d424c:	f03d5bfc 	.word	0xf03d5bfc
102d4250:	f03de540 	.word	0xf03de540
102d4254:	102ef320 	.word	0x102ef320
102d4258:	102e57a4 	.word	0x102e57a4
102d425c:	102e6230 	.word	0x102e6230
102d4260:	f03d209c 	.word	0xf03d209c
102d4264:	000023f0 	.word	0x000023f0
102d4268:	f03da598 	.word	0xf03da598
102d426c:	102e426c 	.word	0x102e426c

102d4270 <Write_Error_Messages>:
 *
 * Return:
 *
 *****************************************************************/
s32 Write_Error_Messages(void)
{
102d4270:	e92d45f8 	push	{r3, r4, r5, r6, r7, r8, sl, lr}

	int i;
	s32 ret = -1;
	s32 file_handle = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--Store Fault Flags:");
102d4274:	e59f8134 	ldr	r8, [pc, #308]	; 102d43b0 <Write_Error_Messages+0x140>
102d4278:	e3a02c02 	mov	r2, #512	; 0x200
102d427c:	e3a01000 	mov	r1, #0
102d4280:	e59f012c 	ldr	r0, [pc, #300]	; 102d43b4 <Write_Error_Messages+0x144>
102d4284:	e59fa12c 	ldr	sl, [pc, #300]	; 102d43b8 <Write_Error_Messages+0x148>
102d4288:	e12fff3a 	blx	sl
102d428c:	e59f1128 	ldr	r1, [pc, #296]	; 102d43bc <Write_Error_Messages+0x14c>
102d4290:	e5983000 	ldr	r3, [r8]
102d4294:	e59f0118 	ldr	r0, [pc, #280]	; 102d43b4 <Write_Error_Messages+0x144>
102d4298:	e12fff33 	blx	r3
102d429c:	e59f711c 	ldr	r7, [pc, #284]	; 102d43c0 <Write_Error_Messages+0x150>
102d42a0:	e59f010c 	ldr	r0, [pc, #268]	; 102d43b4 <Write_Error_Messages+0x144>
102d42a4:	e12fff37 	blx	r7
102d42a8:	e59f6114 	ldr	r6, [pc, #276]	; 102d43c4 <Write_Error_Messages+0x154>
102d42ac:	e59f1100 	ldr	r1, [pc, #256]	; 102d43b4 <Write_Error_Messages+0x144>
102d42b0:	e59f5110 	ldr	r5, [pc, #272]	; 102d43c8 <Write_Error_Messages+0x158>
102d42b4:	e3a04000 	mov	r4, #0
102d42b8:	e1a02000 	mov	r2, r0
102d42bc:	e3a0000a 	mov	r0, #10
102d42c0:	e12fff36 	blx	r6
102d42c4:	ea000001 	b	102d42d0 <Write_Error_Messages+0x60>
	for(i=0;i<11;i++)
102d42c8:	e354000b 	cmp	r4, #11
102d42cc:	0a000014 	beq	102d4324 <Write_Error_Messages+0xb4>
	{
		if(Error_messages_array[i])
102d42d0:	e5f53001 	ldrb	r3, [r5, #1]!
102d42d4:	e2844001 	add	r4, r4, #1
102d42d8:	e3530000 	cmp	r3, #0
102d42dc:	0afffff9 	beq	102d42c8 <Write_Error_Messages+0x58>
			APP_DEBUG("E[%d], ",i+1);
102d42e0:	e3a01000 	mov	r1, #0
102d42e4:	e3a02c02 	mov	r2, #512	; 0x200
102d42e8:	e59f00c4 	ldr	r0, [pc, #196]	; 102d43b4 <Write_Error_Messages+0x144>
102d42ec:	e12fff3a 	blx	sl
102d42f0:	e59f10d4 	ldr	r1, [pc, #212]	; 102d43cc <Write_Error_Messages+0x15c>
102d42f4:	e1a02004 	mov	r2, r4
102d42f8:	e5983000 	ldr	r3, [r8]
102d42fc:	e59f00b0 	ldr	r0, [pc, #176]	; 102d43b4 <Write_Error_Messages+0x144>
102d4300:	e12fff33 	blx	r3
102d4304:	e59f00a8 	ldr	r0, [pc, #168]	; 102d43b4 <Write_Error_Messages+0x144>
102d4308:	e12fff37 	blx	r7
102d430c:	e59f10a0 	ldr	r1, [pc, #160]	; 102d43b4 <Write_Error_Messages+0x144>
102d4310:	e1a02000 	mov	r2, r0
102d4314:	e3a0000a 	mov	r0, #10
102d4318:	e12fff36 	blx	r6
	int i;
	s32 ret = -1;
	s32 file_handle = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<--Store Fault Flags:");
	for(i=0;i<11;i++)
102d431c:	e354000b 	cmp	r4, #11
102d4320:	1affffea 	bne	102d42d0 <Write_Error_Messages+0x60>
	{
		if(Error_messages_array[i])
			APP_DEBUG("E[%d], ",i+1);
	}
	APP_DEBUG(" -->\n\r");
102d4324:	e3a02c02 	mov	r2, #512	; 0x200
102d4328:	e3a01000 	mov	r1, #0
102d432c:	e59f0080 	ldr	r0, [pc, #128]	; 102d43b4 <Write_Error_Messages+0x144>
102d4330:	e12fff3a 	blx	sl
102d4334:	e5983000 	ldr	r3, [r8]
102d4338:	e59f1090 	ldr	r1, [pc, #144]	; 102d43d0 <Write_Error_Messages+0x160>
102d433c:	e59f0070 	ldr	r0, [pc, #112]	; 102d43b4 <Write_Error_Messages+0x144>
102d4340:	e12fff33 	blx	r3
102d4344:	e59f0068 	ldr	r0, [pc, #104]	; 102d43b4 <Write_Error_Messages+0x144>
102d4348:	e12fff37 	blx	r7
102d434c:	e59f1060 	ldr	r1, [pc, #96]	; 102d43b4 <Write_Error_Messages+0x144>
102d4350:	e1a02000 	mov	r2, r0
102d4354:	e3a0000a 	mov	r0, #10
102d4358:	e12fff36 	blx	r6
#endif

	//create file.. if not available or open the file if available
	file_handle = fileSys_OpenOrCreateFile((u8 *)Error_Messagesdata);
102d435c:	e59f3070 	ldr	r3, [pc, #112]	; 102d43d4 <Write_Error_Messages+0x164>
102d4360:	e593000c 	ldr	r0, [r3, #12]
102d4364:	ebfffaa5 	bl	102d2e00 <fileSys_OpenOrCreateFile>
	if(file_handle >= QL_RET_OK)
102d4368:	e2505000 	subs	r5, r0, #0
102d436c:	ba00000d 	blt	102d43a8 <Write_Error_Messages+0x138>
	{
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Writing Fault Messages ..\n\r");
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)Error_messages_array, OVER_WRITE_TO_SIZE, MAX_ERROR_COUNT);
102d4370:	e1a03004 	mov	r3, r4
102d4374:	e59f105c 	ldr	r1, [pc, #92]	; 102d43d8 <Write_Error_Messages+0x168>
102d4378:	e3a02002 	mov	r2, #2
102d437c:	ebfffabe 	bl	102d2e7c <fileSys_WriteFile>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d4380:	e59f3054 	ldr	r3, [pc, #84]	; 102d43dc <Write_Error_Messages+0x16c>
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Writing Fault Messages ..\n\r");
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)Error_messages_array, OVER_WRITE_TO_SIZE, MAX_ERROR_COUNT);
		if(QL_RET_OK != ret)
102d4384:	e3500000 	cmp	r0, #0
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d4388:	e1a00005 	mov	r0, r5
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Writing Fault Messages ..\n\r");
#endif

		ret = fileSys_WriteFile(file_handle, (u8*)Error_messages_array, OVER_WRITE_TO_SIZE, MAX_ERROR_COUNT);
		if(QL_RET_OK != ret)
102d438c:	1a000002 	bne	102d439c <Write_Error_Messages+0x12c>
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d4390:	e12fff33 	blx	r3
		APP_DEBUG("<-- Failed to Create File (%s) ret=%d -->\r\n", Error_Messagesdata, ret);
#endif
		return -1;
	}

	return 1;
102d4394:	e3a00001 	mov	r0, #1
102d4398:	e8bd85f8 	pop	{r3, r4, r5, r6, r7, r8, sl, pc}
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d439c:	e12fff33 	blx	r3
		{
#ifdef FILE_STORAGE
			APP_DEBUG("<--Error : fileSys_WriteFile [%s] ret : %d-->\r\n",__FUNCTION__,ret);
#endif
			fileSys_CloseFile(file_handle);
			return -1;
102d43a0:	e3e00000 	mvn	r0, #0
102d43a4:	e8bd85f8 	pop	{r3, r4, r5, r6, r7, r8, sl, pc}
	{
		//Open file failed.
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Failed to Create File (%s) ret=%d -->\r\n", Error_Messagesdata, ret);
#endif
		return -1;
102d43a8:	e3e00000 	mvn	r0, #0
	}

	return 1;

}
102d43ac:	e8bd85f8 	pop	{r3, r4, r5, r6, r7, r8, sl, pc}
102d43b0:	f03de540 	.word	0xf03de540
102d43b4:	f03d5bfc 	.word	0xf03d5bfc
102d43b8:	102e58f4 	.word	0x102e58f4
102d43bc:	102ef354 	.word	0x102ef354
102d43c0:	102e57a4 	.word	0x102e57a4
102d43c4:	102e6230 	.word	0x102e6230
102d43c8:	f03da5ab 	.word	0xf03da5ab
102d43cc:	102ef36c 	.word	0x102ef36c
102d43d0:	102ef23c 	.word	0x102ef23c
102d43d4:	f03d209c 	.word	0xf03d209c
102d43d8:	f03da5ac 	.word	0xf03da5ac
102d43dc:	102e426c 	.word	0x102e426c

102d43e0 <Read_Fault_Flag_File>:
 *
 * Return:
 *
 *****************************************************************/
s32 Read_Fault_Flag_File(void)
{
102d43e0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
	u32 i = 0;

	s32 ret = -1;
	s32 fileHandl = -1;

	fileHandl = fileSys_checkFile((u8*)Error_Messagesdata);
102d43e4:	e59f5144 	ldr	r5, [pc, #324]	; 102d4530 <Read_Fault_Flag_File+0x150>
102d43e8:	e595000c 	ldr	r0, [r5, #12]
102d43ec:	ebfffad1 	bl	102d2f38 <fileSys_checkFile>
	if(fileHandl == QL_RET_OK) // If file already present
102d43f0:	e2504000 	subs	r4, r0, #0
102d43f4:	0a000001 	beq	102d4400 <Read_Fault_Flag_File+0x20>
#endif
		}
		fileSys_CloseFile((s32)fileHandl); //Close the file
	}
	return 1;
}
102d43f8:	e3a00001 	mov	r0, #1
102d43fc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
	if(fileHandl == QL_RET_OK) // If file already present
	{
#ifdef FILE_STORAGE
		APP_DEBUG("<-- Fault flag  file present : ->\r\n");
#endif
		fileHandl = fileSys_OpenOrCreateFile((u8*)Error_Messagesdata); //Open the file
102d4400:	e595000c 	ldr	r0, [r5, #12]
102d4404:	ebfffa7d 	bl	102d2e00 <fileSys_OpenOrCreateFile>
		if(fileHandl >= QL_RET_OK)
102d4408:	e2509000 	subs	r9, r0, #0
102d440c:	ba000042 	blt	102d451c <Read_Fault_Flag_File+0x13c>
		{
			ret = Ql_FS_Seek(fileHandl, OFFSET , QL_FS_FILE_BEGIN); // Reach to the start of the current payload number
102d4410:	e1a01004 	mov	r1, r4
102d4414:	e1a02004 	mov	r2, r4
102d4418:	e59f3114 	ldr	r3, [pc, #276]	; 102d4534 <Read_Fault_Flag_File+0x154>
102d441c:	e12fff33 	blx	r3
#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Read ret : %d\r\n",ret);
#endif
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\r\n<--Read Fault Flags:");
102d4420:	e59f8110 	ldr	r8, [pc, #272]	; 102d4538 <Read_Fault_Flag_File+0x158>
#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
#endif
			}

			ret = Ql_FS_Read(fileHandl,(u8*)Error_messages_array,MAX_ERROR_COUNT, &readedlen); // Read the payload from the file
102d4424:	e59fc110 	ldr	ip, [pc, #272]	; 102d453c <Read_Fault_Flag_File+0x15c>
102d4428:	e59f3110 	ldr	r3, [pc, #272]	; 102d4540 <Read_Fault_Flag_File+0x160>
102d442c:	e59f1110 	ldr	r1, [pc, #272]	; 102d4544 <Read_Fault_Flag_File+0x164>
102d4430:	e3a0200b 	mov	r2, #11
102d4434:	e1a00009 	mov	r0, r9
102d4438:	e12fff3c 	blx	ip
#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Read ret : %d\r\n",ret);
#endif
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\r\n<--Read Fault Flags:");
102d443c:	e59fa104 	ldr	sl, [pc, #260]	; 102d4548 <Read_Fault_Flag_File+0x168>
102d4440:	e3a02c02 	mov	r2, #512	; 0x200
102d4444:	e1a01004 	mov	r1, r4
102d4448:	e59f00fc 	ldr	r0, [pc, #252]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d444c:	e12fff3a 	blx	sl
102d4450:	e59f10f8 	ldr	r1, [pc, #248]	; 102d4550 <Read_Fault_Flag_File+0x170>
102d4454:	e5983000 	ldr	r3, [r8]
102d4458:	e59f00ec 	ldr	r0, [pc, #236]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d445c:	e12fff33 	blx	r3
102d4460:	e59f70ec 	ldr	r7, [pc, #236]	; 102d4554 <Read_Fault_Flag_File+0x174>
102d4464:	e59f00e0 	ldr	r0, [pc, #224]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d4468:	e12fff37 	blx	r7
102d446c:	e59f60e4 	ldr	r6, [pc, #228]	; 102d4558 <Read_Fault_Flag_File+0x178>
102d4470:	e59f10d4 	ldr	r1, [pc, #212]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d4474:	e59f50e0 	ldr	r5, [pc, #224]	; 102d455c <Read_Fault_Flag_File+0x17c>
102d4478:	e1a02000 	mov	r2, r0
102d447c:	e3a0000a 	mov	r0, #10
102d4480:	e12fff36 	blx	r6
102d4484:	ea000001 	b	102d4490 <Read_Fault_Flag_File+0xb0>
			for(i=0;i<11;i++)
102d4488:	e354000b 	cmp	r4, #11
102d448c:	0a000014 	beq	102d44e4 <Read_Fault_Flag_File+0x104>
			{
				if(Error_messages_array[i])
102d4490:	e5f53001 	ldrb	r3, [r5, #1]!
102d4494:	e2844001 	add	r4, r4, #1
102d4498:	e3530000 	cmp	r3, #0
102d449c:	0afffff9 	beq	102d4488 <Read_Fault_Flag_File+0xa8>
					APP_DEBUG("E[%d], ",i+1);
102d44a0:	e3a01000 	mov	r1, #0
102d44a4:	e3a02c02 	mov	r2, #512	; 0x200
102d44a8:	e59f009c 	ldr	r0, [pc, #156]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d44ac:	e12fff3a 	blx	sl
102d44b0:	e59f10a8 	ldr	r1, [pc, #168]	; 102d4560 <Read_Fault_Flag_File+0x180>
102d44b4:	e1a02004 	mov	r2, r4
102d44b8:	e5983000 	ldr	r3, [r8]
102d44bc:	e59f0088 	ldr	r0, [pc, #136]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d44c0:	e12fff33 	blx	r3
102d44c4:	e59f0080 	ldr	r0, [pc, #128]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d44c8:	e12fff37 	blx	r7
102d44cc:	e59f1078 	ldr	r1, [pc, #120]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d44d0:	e1a02000 	mov	r2, r0
102d44d4:	e3a0000a 	mov	r0, #10
102d44d8:	e12fff36 	blx	r6
				APP_DEBUG("\r\nError : Ql_FS_Read ret : %d\r\n",ret);
#endif
			}
#ifdef DEBUG_MSG
			APP_DEBUG("\r\n<--Read Fault Flags:");
			for(i=0;i<11;i++)
102d44dc:	e354000b 	cmp	r4, #11
102d44e0:	1affffea 	bne	102d4490 <Read_Fault_Flag_File+0xb0>
			{
				if(Error_messages_array[i])
					APP_DEBUG("E[%d], ",i+1);
			}
			APP_DEBUG(" -->\n\r");
102d44e4:	e3a02c02 	mov	r2, #512	; 0x200
102d44e8:	e3a01000 	mov	r1, #0
102d44ec:	e59f0058 	ldr	r0, [pc, #88]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d44f0:	e12fff3a 	blx	sl
102d44f4:	e59f1068 	ldr	r1, [pc, #104]	; 102d4564 <Read_Fault_Flag_File+0x184>
102d44f8:	e5983000 	ldr	r3, [r8]
102d44fc:	e59f0048 	ldr	r0, [pc, #72]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d4500:	e12fff33 	blx	r3
102d4504:	e59f0040 	ldr	r0, [pc, #64]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d4508:	e12fff37 	blx	r7
102d450c:	e59f1038 	ldr	r1, [pc, #56]	; 102d454c <Read_Fault_Flag_File+0x16c>
102d4510:	e1a02000 	mov	r2, r0
102d4514:	e3a0000a 	mov	r0, #10
102d4518:	e12fff36 	blx	r6
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d451c:	e1a00009 	mov	r0, r9
102d4520:	e59f3040 	ldr	r3, [pc, #64]	; 102d4568 <Read_Fault_Flag_File+0x188>
102d4524:	e12fff33 	blx	r3
#endif
		}
		fileSys_CloseFile((s32)fileHandl); //Close the file
	}
	return 1;
}
102d4528:	e3a00001 	mov	r0, #1
102d452c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
102d4530:	f03d209c 	.word	0xf03d209c
102d4534:	102e41a8 	.word	0x102e41a8
102d4538:	f03de540 	.word	0xf03de540
102d453c:	102e40b8 	.word	0x102e40b8
102d4540:	f03db8f8 	.word	0xf03db8f8
102d4544:	f03da5ac 	.word	0xf03da5ac
102d4548:	102e58f4 	.word	0x102e58f4
102d454c:	f03d5bfc 	.word	0xf03d5bfc
102d4550:	102ef374 	.word	0x102ef374
102d4554:	102e57a4 	.word	0x102e57a4
102d4558:	102e6230 	.word	0x102e6230
102d455c:	f03da5ab 	.word	0xf03da5ab
102d4560:	102ef36c 	.word	0x102ef36c
102d4564:	102ef23c 	.word	0x102ef23c
102d4568:	102e426c 	.word	0x102e426c

102d456c <Read_License>:


s32 Read_License(void)
{
102d456c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s32 fileHandl = -1;
	s32  parameter_length_ID  = 0;
	char parameter_ID_temp[6000];
	char *parameter_ID = NULL;
	//#ifdef FILE_STORAGE
	APP_DEBUG("\r\n<-- Read  Device ID -->\r\n");
102d4570:	e59f7488 	ldr	r7, [pc, #1160]	; 102d4a00 <Read_License+0x494>
	return 1;
}


s32 Read_License(void)
{
102d4574:	e24ddd5d 	sub	sp, sp, #5952	; 0x1740
102d4578:	e24dd03c 	sub	sp, sp, #60	; 0x3c
	s32 fileHandl = -1;
	s32  parameter_length_ID  = 0;
	char parameter_ID_temp[6000];
	char *parameter_ID = NULL;
	//#ifdef FILE_STORAGE
	APP_DEBUG("\r\n<-- Read  Device ID -->\r\n");
102d457c:	e3a02c02 	mov	r2, #512	; 0x200
102d4580:	e3a01000 	mov	r1, #0
102d4584:	e59f0478 	ldr	r0, [pc, #1144]	; 102d4a04 <Read_License+0x498>
102d4588:	e59f5478 	ldr	r5, [pc, #1144]	; 102d4a08 <Read_License+0x49c>
102d458c:	e12fff35 	blx	r5
102d4590:	e5973000 	ldr	r3, [r7]
102d4594:	e59f1470 	ldr	r1, [pc, #1136]	; 102d4a0c <Read_License+0x4a0>
102d4598:	e59f0464 	ldr	r0, [pc, #1124]	; 102d4a04 <Read_License+0x498>
102d459c:	e12fff33 	blx	r3
102d45a0:	e59f4468 	ldr	r4, [pc, #1128]	; 102d4a10 <Read_License+0x4a4>
102d45a4:	e59f0458 	ldr	r0, [pc, #1112]	; 102d4a04 <Read_License+0x498>
102d45a8:	e12fff34 	blx	r4
	//#endif
	fileHandl = fileSys_checkFile((u8*)File_Licensepem);
102d45ac:	e59fa460 	ldr	sl, [pc, #1120]	; 102d4a14 <Read_License+0x4a8>
	s32 fileHandl = -1;
	s32  parameter_length_ID  = 0;
	char parameter_ID_temp[6000];
	char *parameter_ID = NULL;
	//#ifdef FILE_STORAGE
	APP_DEBUG("\r\n<-- Read  Device ID -->\r\n");
102d45b0:	e59f144c 	ldr	r1, [pc, #1100]	; 102d4a04 <Read_License+0x498>
102d45b4:	e59f645c 	ldr	r6, [pc, #1116]	; 102d4a18 <Read_License+0x4ac>
102d45b8:	e1a02000 	mov	r2, r0
102d45bc:	e3a0000a 	mov	r0, #10
102d45c0:	e12fff36 	blx	r6
	//#endif
	fileHandl = fileSys_checkFile((u8*)File_Licensepem);
102d45c4:	e59a0010 	ldr	r0, [sl, #16]
102d45c8:	ebfffa5a 	bl	102d2f38 <fileSys_checkFile>
	if(fileHandl == QL_RET_OK) // If file already present
102d45cc:	e2508000 	subs	r8, r0, #0
102d45d0:	0a000003 	beq	102d45e4 <Read_License+0x78>
		Ql_MEM_Free(parameter_ID);
		parameter_ID = NULL;
		fileSys_CloseFile((s32)fileHandl); //Close the file
	}
	return 1;
}
102d45d4:	e3a00001 	mov	r0, #1
102d45d8:	e28ddfdf 	add	sp, sp, #892	; 0x37c
102d45dc:	e28ddb05 	add	sp, sp, #5120	; 0x1400
102d45e0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	APP_DEBUG("\r\n<-- Read  Device ID -->\r\n");
	//#endif
	fileHandl = fileSys_checkFile((u8*)File_Licensepem);
	if(fileHandl == QL_RET_OK) // If file already present
	{
		ret = fileSys_getFileSize(File_Licensepem);
102d45e4:	e59a0010 	ldr	r0, [sl, #16]
102d45e8:	ebfffa89 	bl	102d3014 <fileSys_getFileSize>
		APP_DEBUG("<-- File size: %d ->\r\n",ret);
102d45ec:	e1a01008 	mov	r1, r8
102d45f0:	e3a02c02 	mov	r2, #512	; 0x200
	APP_DEBUG("\r\n<-- Read  Device ID -->\r\n");
	//#endif
	fileHandl = fileSys_checkFile((u8*)File_Licensepem);
	if(fileHandl == QL_RET_OK) // If file already present
	{
		ret = fileSys_getFileSize(File_Licensepem);
102d45f4:	e1a09000 	mov	r9, r0
		APP_DEBUG("<-- File size: %d ->\r\n",ret);
102d45f8:	e59f0404 	ldr	r0, [pc, #1028]	; 102d4a04 <Read_License+0x498>
102d45fc:	e12fff35 	blx	r5
102d4600:	e5973000 	ldr	r3, [r7]
102d4604:	e59f1410 	ldr	r1, [pc, #1040]	; 102d4a1c <Read_License+0x4b0>
102d4608:	e1a02009 	mov	r2, r9
102d460c:	e59f03f0 	ldr	r0, [pc, #1008]	; 102d4a04 <Read_License+0x498>
102d4610:	e12fff33 	blx	r3
102d4614:	e59f03e8 	ldr	r0, [pc, #1000]	; 102d4a04 <Read_License+0x498>
102d4618:	e12fff34 	blx	r4
102d461c:	e59f13e0 	ldr	r1, [pc, #992]	; 102d4a04 <Read_License+0x498>
102d4620:	e1a02000 	mov	r2, r0
102d4624:	e3a0000a 	mov	r0, #10
102d4628:	e12fff36 	blx	r6
		//#ifdef FILE_STORAGE
		APP_DEBUG("<-- Device ID: file present : ->\r\n");
102d462c:	e3a02c02 	mov	r2, #512	; 0x200
102d4630:	e1a01008 	mov	r1, r8
102d4634:	e59f03c8 	ldr	r0, [pc, #968]	; 102d4a04 <Read_License+0x498>
102d4638:	e12fff35 	blx	r5
102d463c:	e5973000 	ldr	r3, [r7]
102d4640:	e59f13d8 	ldr	r1, [pc, #984]	; 102d4a20 <Read_License+0x4b4>
102d4644:	e59f03b8 	ldr	r0, [pc, #952]	; 102d4a04 <Read_License+0x498>
102d4648:	e12fff33 	blx	r3
102d464c:	e59f03b0 	ldr	r0, [pc, #944]	; 102d4a04 <Read_License+0x498>
102d4650:	e12fff34 	blx	r4
102d4654:	e59f13a8 	ldr	r1, [pc, #936]	; 102d4a04 <Read_License+0x498>
102d4658:	e1a02000 	mov	r2, r0
102d465c:	e3a0000a 	mov	r0, #10
102d4660:	e12fff36 	blx	r6
		//#endif
		fileHandl = fileSys_OpenOrCreateFile((u8*)File_Licensepem); //Open the file
102d4664:	e59a0010 	ldr	r0, [sl, #16]
102d4668:	ebfff9e4 	bl	102d2e00 <fileSys_OpenOrCreateFile>
		if(fileHandl >= QL_RET_OK)
102d466c:	e250a000 	subs	sl, r0, #0
102d4670:	ba0000b4 	blt	102d4948 <Read_License+0x3dc>
		{
			ret = Ql_FS_Seek(fileHandl, OFFSET , QL_FS_FILE_BEGIN); // Reach to the start of the current payload number
102d4674:	e1a01008 	mov	r1, r8
102d4678:	e1a02008 	mov	r2, r8
102d467c:	e59f33a0 	ldr	r3, [pc, #928]	; 102d4a24 <Read_License+0x4b8>
102d4680:	e12fff33 	blx	r3
			if(QL_RET_OK != ret)
102d4684:	e2509000 	subs	r9, r0, #0
102d4688:	1a0000cc 	bne	102d49c0 <Read_License+0x454>
			{
				//#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
				//#endif
			}
			parameter_ID = (char*)Ql_MEM_Alloc(6000);
102d468c:	e59f3394 	ldr	r3, [pc, #916]	; 102d4a28 <Read_License+0x4bc>
102d4690:	e59f0394 	ldr	r0, [pc, #916]	; 102d4a2c <Read_License+0x4c0>
102d4694:	e12fff33 	blx	r3
			Ql_memset(parameter_ID, 0x0,6000);
102d4698:	e59f238c 	ldr	r2, [pc, #908]	; 102d4a2c <Read_License+0x4c0>
102d469c:	e3a01000 	mov	r1, #0
			{
				//#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
				//#endif
			}
			parameter_ID = (char*)Ql_MEM_Alloc(6000);
102d46a0:	e1a08000 	mov	r8, r0
			Ql_memset(parameter_ID, 0x0,6000);
102d46a4:	e12fff35 	blx	r5
			ret = Ql_FS_Read(fileHandl,(u8*)parameter_ID,6000, &readedlen); // Read the payload from the file
102d46a8:	e1a0000a 	mov	r0, sl
102d46ac:	e1a01008 	mov	r1, r8
102d46b0:	e59f2374 	ldr	r2, [pc, #884]	; 102d4a2c <Read_License+0x4c0>
102d46b4:	e59f3374 	ldr	r3, [pc, #884]	; 102d4a30 <Read_License+0x4c4>
102d46b8:	e59fc374 	ldr	ip, [pc, #884]	; 102d4a34 <Read_License+0x4c8>
102d46bc:	e12fff3c 	blx	ip
			if(QL_RET_OK != ret)
102d46c0:	e2509000 	subs	r9, r0, #0
102d46c4:	1a0000ac 	bne	102d497c <Read_License+0x410>
			{
				//#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Read ret : %d\r\n",ret);
				//#endif
			}
			APP_DEBUG("\r\nreadedlen: %d\r\n",readedlen);
102d46c8:	e3a01000 	mov	r1, #0
102d46cc:	e3a02c02 	mov	r2, #512	; 0x200
102d46d0:	e59f032c 	ldr	r0, [pc, #812]	; 102d4a04 <Read_License+0x498>
102d46d4:	e12fff35 	blx	r5
102d46d8:	e59f3350 	ldr	r3, [pc, #848]	; 102d4a30 <Read_License+0x4c4>
102d46dc:	e59f1354 	ldr	r1, [pc, #852]	; 102d4a38 <Read_License+0x4cc>
102d46e0:	e5932000 	ldr	r2, [r3]
102d46e4:	e59f0318 	ldr	r0, [pc, #792]	; 102d4a04 <Read_License+0x498>
102d46e8:	e5973000 	ldr	r3, [r7]
102d46ec:	e12fff33 	blx	r3
102d46f0:	e59f030c 	ldr	r0, [pc, #780]	; 102d4a04 <Read_License+0x498>
102d46f4:	e12fff34 	blx	r4
102d46f8:	e59f1304 	ldr	r1, [pc, #772]	; 102d4a04 <Read_License+0x498>
102d46fc:	e1a02000 	mov	r2, r0
102d4700:	e3a0000a 	mov	r0, #10
102d4704:	e12fff36 	blx	r6
			parameter_length_ID = Ql_strlen(parameter_ID); // Find out the payload length
102d4708:	e1a00008 	mov	r0, r8
102d470c:	e12fff34 	blx	r4
	}
	return 1;
}


s32 Read_License(void)
102d4710:	e3a03000 	mov	r3, #0
102d4714:	e2481001 	sub	r1, r8, #1

	char new_CK0[2000];
	char new_CC0[2000];
	char new_CA0[2000];
	int j,ctr;
	j=0; ctr=0;
102d4718:	e1a0c003 	mov	ip, r3
102d471c:	e1a0e003 	mov	lr, r3
102d4720:	ea00000e 	b	102d4760 <Read_License+0x1f4>
				if(parameter_ID[i]==' ' && parameter_ID[i+1]=='-')
				{
					ctr++;  //for next word
					j=0;    //for next word, init index to 0
				}
				else if (ctr == 1)
102d4724:	e35c0001 	cmp	ip, #1
				{

					new_CK0[j]=parameter_ID[i];
102d4728:	028d9008 	addeq	r9, sp, #8
102d472c:	07c9200e 	strbeq	r2, [r9, lr]
					j++;
102d4730:	028ee001 	addeq	lr, lr, #1
				if(parameter_ID[i]==' ' && parameter_ID[i+1]=='-')
				{
					ctr++;  //for next word
					j=0;    //for next word, init index to 0
				}
				else if (ctr == 1)
102d4734:	0a000007 	beq	102d4758 <Read_License+0x1ec>
				{

					new_CK0[j]=parameter_ID[i];
					j++;
				}
				else if (ctr == 2)
102d4738:	e35c0002 	cmp	ip, #2
102d473c:	0a000088 	beq	102d4964 <Read_License+0x3f8>
				{
					new_CC0[j]=parameter_ID[i];
					j++;
				}
				else if (ctr == 3)
102d4740:	e35c0003 	cmp	ip, #3
				{
					new_CA0[j]=parameter_ID[i];
102d4744:	028dbd5d 	addeq	fp, sp, #5952	; 0x1740
102d4748:	028bb038 	addeq	fp, fp, #56	; 0x38
102d474c:	008b900e 	addeq	r9, fp, lr
102d4750:	028ee001 	addeq	lr, lr, #1
102d4754:	054927d0 	strbeq	r2, [r9, #-2000]	; 0xfffff830
			parameter_length_ID = Ql_strlen(parameter_ID); // Find out the payload length
			//#ifdef DEBUG_MSG
			//APP_DEBUG("\r\n--> Length is %d Device ID is %s\r\n\n",parameter_length_ID,parameter_ID);
			//#endif

			for(i=0;i<=(parameter_length_ID);i++)
102d4758:	e1500003 	cmp	r0, r3
102d475c:	3a00000a 	bcc	102d478c <Read_License+0x220>
			{
				// if space or NULL found, assign NULL into newString[ctr]
				if(parameter_ID[i]==' ' && parameter_ID[i+1]=='-')
102d4760:	e5f12001 	ldrb	r2, [r1, #1]!
102d4764:	e2833001 	add	r3, r3, #1
102d4768:	e3520020 	cmp	r2, #32
102d476c:	1affffec 	bne	102d4724 <Read_License+0x1b8>
102d4770:	e5d19001 	ldrb	r9, [r1, #1]
102d4774:	e359002d 	cmp	r9, #45	; 0x2d
				{
					ctr++;  //for next word
102d4778:	028cc001 	addeq	ip, ip, #1
					j=0;    //for next word, init index to 0
102d477c:	03a0e000 	moveq	lr, #0
			//#endif

			for(i=0;i<=(parameter_length_ID);i++)
			{
				// if space or NULL found, assign NULL into newString[ctr]
				if(parameter_ID[i]==' ' && parameter_ID[i+1]=='-')
102d4780:	1affffe7 	bne	102d4724 <Read_License+0x1b8>
			parameter_length_ID = Ql_strlen(parameter_ID); // Find out the payload length
			//#ifdef DEBUG_MSG
			//APP_DEBUG("\r\n--> Length is %d Device ID is %s\r\n\n",parameter_length_ID,parameter_ID);
			//#endif

			for(i=0;i<=(parameter_length_ID);i++)
102d4784:	e1500003 	cmp	r0, r3
102d4788:	2afffff4 	bcs	102d4760 <Read_License+0x1f4>
					j++;
				}
			}


			APP_DEBUG("\r\n--> Length is %d Device ID is %s\r\n\n",Ql_strlen(new_CK0),new_CK0);
102d478c:	e3a01000 	mov	r1, #0
102d4790:	e3a02c02 	mov	r2, #512	; 0x200
102d4794:	e59f0268 	ldr	r0, [pc, #616]	; 102d4a04 <Read_License+0x498>
102d4798:	e12fff35 	blx	r5
102d479c:	e28d0008 	add	r0, sp, #8
102d47a0:	e5979000 	ldr	r9, [r7]
102d47a4:	e12fff34 	blx	r4
102d47a8:	e28d3008 	add	r3, sp, #8
102d47ac:	e59f1288 	ldr	r1, [pc, #648]	; 102d4a3c <Read_License+0x4d0>
			Ql_Sleep(100);
102d47b0:	e59fb288 	ldr	fp, [pc, #648]	; 102d4a40 <Read_License+0x4d4>
					j++;
				}
			}


			APP_DEBUG("\r\n--> Length is %d Device ID is %s\r\n\n",Ql_strlen(new_CK0),new_CK0);
102d47b4:	e1a02000 	mov	r2, r0
102d47b8:	e59f0244 	ldr	r0, [pc, #580]	; 102d4a04 <Read_License+0x498>
102d47bc:	e12fff39 	blx	r9
102d47c0:	e59f023c 	ldr	r0, [pc, #572]	; 102d4a04 <Read_License+0x498>
102d47c4:	e12fff34 	blx	r4
102d47c8:	e59f1234 	ldr	r1, [pc, #564]	; 102d4a04 <Read_License+0x498>
			Ql_Sleep(100);
			ret = RIL_SSL_QSSLCERTIFICATE_DEL("CK0");	//First Delete file if available.
102d47cc:	e59f9270 	ldr	r9, [pc, #624]	; 102d4a44 <Read_License+0x4d8>
					j++;
				}
			}


			APP_DEBUG("\r\n--> Length is %d Device ID is %s\r\n\n",Ql_strlen(new_CK0),new_CK0);
102d47d0:	e1a02000 	mov	r2, r0
102d47d4:	e3a0000a 	mov	r0, #10
102d47d8:	e12fff36 	blx	r6
			Ql_Sleep(100);
102d47dc:	e3a00064 	mov	r0, #100	; 0x64
102d47e0:	e12fff3b 	blx	fp
			ret = RIL_SSL_QSSLCERTIFICATE_DEL("CK0");	//First Delete file if available.
102d47e4:	e59f025c 	ldr	r0, [pc, #604]	; 102d4a48 <Read_License+0x4dc>
102d47e8:	e12fff39 	blx	r9
			ret= RIL_SSL_QSSLCERTIFICATE_WRITE("CK0",new_CK0,Ql_strlen(new_CK0),100); //Write Licence file in NVRAM
102d47ec:	e28d0008 	add	r0, sp, #8
102d47f0:	e12fff34 	blx	r4
102d47f4:	e59fc250 	ldr	ip, [pc, #592]	; 102d4a4c <Read_License+0x4e0>
102d47f8:	e28d1008 	add	r1, sp, #8
102d47fc:	e3a03064 	mov	r3, #100	; 0x64
102d4800:	e1a02000 	mov	r2, r0
102d4804:	e59f023c 	ldr	r0, [pc, #572]	; 102d4a48 <Read_License+0x4dc>
102d4808:	e12fff3c 	blx	ip
			RIL_SSL_QSSLCERTIFICATE_READ("CK0");
102d480c:	e59f323c 	ldr	r3, [pc, #572]	; 102d4a50 <Read_License+0x4e4>
102d4810:	e59f0230 	ldr	r0, [pc, #560]	; 102d4a48 <Read_License+0x4dc>
102d4814:	e12fff33 	blx	r3


			APP_DEBUG("\r\n--> Length is %d Device ID is %s\r\n\n",Ql_strlen(new_CC0),new_CC0);
102d4818:	e3a01000 	mov	r1, #0
102d481c:	e3a02c02 	mov	r2, #512	; 0x200
102d4820:	e59f01dc 	ldr	r0, [pc, #476]	; 102d4a04 <Read_License+0x498>
102d4824:	e12fff35 	blx	r5
102d4828:	e28d0e7d 	add	r0, sp, #2000	; 0x7d0
102d482c:	e597c000 	ldr	ip, [r7]
102d4830:	e2800008 	add	r0, r0, #8
102d4834:	e58dc004 	str	ip, [sp, #4]
102d4838:	e12fff34 	blx	r4
102d483c:	e28d3e7d 	add	r3, sp, #2000	; 0x7d0
102d4840:	e2833008 	add	r3, r3, #8
102d4844:	e59dc004 	ldr	ip, [sp, #4]
102d4848:	e59f11ec 	ldr	r1, [pc, #492]	; 102d4a3c <Read_License+0x4d0>
102d484c:	e1a02000 	mov	r2, r0
102d4850:	e59f01ac 	ldr	r0, [pc, #428]	; 102d4a04 <Read_License+0x498>
102d4854:	e12fff3c 	blx	ip
102d4858:	e59f01a4 	ldr	r0, [pc, #420]	; 102d4a04 <Read_License+0x498>
102d485c:	e12fff34 	blx	r4
102d4860:	e59f119c 	ldr	r1, [pc, #412]	; 102d4a04 <Read_License+0x498>
102d4864:	e1a02000 	mov	r2, r0
102d4868:	e3a0000a 	mov	r0, #10
102d486c:	e12fff36 	blx	r6
			Ql_Sleep(100);
102d4870:	e3a00064 	mov	r0, #100	; 0x64
102d4874:	e12fff3b 	blx	fp
			ret = RIL_SSL_QSSLCERTIFICATE_DEL("CC0");	//First Delete file if available.
102d4878:	e59f01d4 	ldr	r0, [pc, #468]	; 102d4a54 <Read_License+0x4e8>
102d487c:	e12fff39 	blx	r9
			ret= RIL_SSL_QSSLCERTIFICATE_WRITE("CC0",new_CC0,Ql_strlen(new_CC0),100); //Write Licence file in NVRAM
102d4880:	e28d0e7d 	add	r0, sp, #2000	; 0x7d0
102d4884:	e2800008 	add	r0, r0, #8
102d4888:	e12fff34 	blx	r4
102d488c:	e28d1e7d 	add	r1, sp, #2000	; 0x7d0
102d4890:	e59fc1b4 	ldr	ip, [pc, #436]	; 102d4a4c <Read_License+0x4e0>
102d4894:	e2811008 	add	r1, r1, #8
102d4898:	e3a03064 	mov	r3, #100	; 0x64
102d489c:	e1a02000 	mov	r2, r0
102d48a0:	e59f01ac 	ldr	r0, [pc, #428]	; 102d4a54 <Read_License+0x4e8>
102d48a4:	e12fff3c 	blx	ip
			RIL_SSL_QSSLCERTIFICATE_READ("CC0");
102d48a8:	e59f31a0 	ldr	r3, [pc, #416]	; 102d4a50 <Read_License+0x4e4>
102d48ac:	e59f01a0 	ldr	r0, [pc, #416]	; 102d4a54 <Read_License+0x4e8>
102d48b0:	e12fff33 	blx	r3


			APP_DEBUG("\r\n--> Length is %d Device ID is %s\r\n\n",Ql_strlen(new_CA0),new_CA0);
102d48b4:	e3a01000 	mov	r1, #0
102d48b8:	e3a02c02 	mov	r2, #512	; 0x200
102d48bc:	e59f0140 	ldr	r0, [pc, #320]	; 102d4a04 <Read_License+0x498>
102d48c0:	e12fff35 	blx	r5
102d48c4:	e28d0efa 	add	r0, sp, #4000	; 0xfa0
102d48c8:	e2800008 	add	r0, r0, #8
102d48cc:	e5975000 	ldr	r5, [r7]
102d48d0:	e12fff34 	blx	r4
102d48d4:	e28d3efa 	add	r3, sp, #4000	; 0xfa0
102d48d8:	e2833008 	add	r3, r3, #8
102d48dc:	e59f1158 	ldr	r1, [pc, #344]	; 102d4a3c <Read_License+0x4d0>
102d48e0:	e1a02000 	mov	r2, r0
102d48e4:	e59f0118 	ldr	r0, [pc, #280]	; 102d4a04 <Read_License+0x498>
102d48e8:	e12fff35 	blx	r5
102d48ec:	e59f0110 	ldr	r0, [pc, #272]	; 102d4a04 <Read_License+0x498>
102d48f0:	e12fff34 	blx	r4
102d48f4:	e59f1108 	ldr	r1, [pc, #264]	; 102d4a04 <Read_License+0x498>
102d48f8:	e1a02000 	mov	r2, r0
102d48fc:	e3a0000a 	mov	r0, #10
102d4900:	e12fff36 	blx	r6
			Ql_Sleep(100);
102d4904:	e3a00064 	mov	r0, #100	; 0x64
102d4908:	e12fff3b 	blx	fp
			ret = RIL_SSL_QSSLCERTIFICATE_DEL("CA0");	//First Delete file if available.
102d490c:	e59f0144 	ldr	r0, [pc, #324]	; 102d4a58 <Read_License+0x4ec>
102d4910:	e12fff39 	blx	r9
			ret= RIL_SSL_QSSLCERTIFICATE_WRITE("CA0",new_CA0,Ql_strlen(new_CA0),100); //Write Licence file in NVRAM
102d4914:	e28d0efa 	add	r0, sp, #4000	; 0xfa0
102d4918:	e2800008 	add	r0, r0, #8
102d491c:	e12fff34 	blx	r4
102d4920:	e28d1efa 	add	r1, sp, #4000	; 0xfa0
102d4924:	e2811008 	add	r1, r1, #8
102d4928:	e3a03064 	mov	r3, #100	; 0x64
102d492c:	e59f9118 	ldr	r9, [pc, #280]	; 102d4a4c <Read_License+0x4e0>
			RIL_SSL_QSSLCERTIFICATE_READ("CA0");
102d4930:	e59fb118 	ldr	fp, [pc, #280]	; 102d4a50 <Read_License+0x4e4>


			APP_DEBUG("\r\n--> Length is %d Device ID is %s\r\n\n",Ql_strlen(new_CA0),new_CA0);
			Ql_Sleep(100);
			ret = RIL_SSL_QSSLCERTIFICATE_DEL("CA0");	//First Delete file if available.
			ret= RIL_SSL_QSSLCERTIFICATE_WRITE("CA0",new_CA0,Ql_strlen(new_CA0),100); //Write Licence file in NVRAM
102d4934:	e1a02000 	mov	r2, r0
102d4938:	e59f0118 	ldr	r0, [pc, #280]	; 102d4a58 <Read_License+0x4ec>
102d493c:	e12fff39 	blx	r9
			RIL_SSL_QSSLCERTIFICATE_READ("CA0");
102d4940:	e59f0110 	ldr	r0, [pc, #272]	; 102d4a58 <Read_License+0x4ec>
102d4944:	e12fff3b 	blx	fp

		}
		Ql_MEM_Free(parameter_ID);
102d4948:	e1a00008 	mov	r0, r8
102d494c:	e59f3108 	ldr	r3, [pc, #264]	; 102d4a5c <Read_License+0x4f0>
102d4950:	e12fff33 	blx	r3
 * RETURNS
 *****************************************************************************/
void fileSys_CloseFile(s32 filehandle)
{
	//Close the file
	Ql_FS_Close(filehandle);
102d4954:	e1a0000a 	mov	r0, sl
102d4958:	e59f3100 	ldr	r3, [pc, #256]	; 102d4a60 <Read_License+0x4f4>
102d495c:	e12fff33 	blx	r3
102d4960:	eaffff1b 	b	102d45d4 <Read_License+0x68>
					new_CK0[j]=parameter_ID[i];
					j++;
				}
				else if (ctr == 2)
				{
					new_CC0[j]=parameter_ID[i];
102d4964:	e28dbd5d 	add	fp, sp, #5952	; 0x1740
102d4968:	e28bb038 	add	fp, fp, #56	; 0x38
102d496c:	e08b900e 	add	r9, fp, lr
102d4970:	e5492fa0 	strb	r2, [r9, #-4000]	; 0xfffff060
					j++;
102d4974:	e28ee001 	add	lr, lr, #1
102d4978:	eaffff76 	b	102d4758 <Read_License+0x1ec>
			Ql_memset(parameter_ID, 0x0,6000);
			ret = Ql_FS_Read(fileHandl,(u8*)parameter_ID,6000, &readedlen); // Read the payload from the file
			if(QL_RET_OK != ret)
			{
				//#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Read ret : %d\r\n",ret);
102d497c:	e3a01000 	mov	r1, #0
102d4980:	e3a02c02 	mov	r2, #512	; 0x200
102d4984:	e59f307c 	ldr	r3, [pc, #124]	; 102d4a08 <Read_License+0x49c>
102d4988:	e59f0074 	ldr	r0, [pc, #116]	; 102d4a04 <Read_License+0x498>
102d498c:	e12fff33 	blx	r3
102d4990:	e1a02009 	mov	r2, r9
102d4994:	e59f10c8 	ldr	r1, [pc, #200]	; 102d4a64 <Read_License+0x4f8>
102d4998:	e5973000 	ldr	r3, [r7]
102d499c:	e59f0060 	ldr	r0, [pc, #96]	; 102d4a04 <Read_License+0x498>
102d49a0:	e12fff33 	blx	r3
102d49a4:	e59f0058 	ldr	r0, [pc, #88]	; 102d4a04 <Read_License+0x498>
102d49a8:	e12fff34 	blx	r4
102d49ac:	e59f1050 	ldr	r1, [pc, #80]	; 102d4a04 <Read_License+0x498>
102d49b0:	e1a02000 	mov	r2, r0
102d49b4:	e3a0000a 	mov	r0, #10
102d49b8:	e12fff36 	blx	r6
102d49bc:	eaffff41 	b	102d46c8 <Read_License+0x15c>
		{
			ret = Ql_FS_Seek(fileHandl, OFFSET , QL_FS_FILE_BEGIN); // Reach to the start of the current payload number
			if(QL_RET_OK != ret)
			{
				//#ifdef FILE_STORAGE
				APP_DEBUG("\r\nError : Ql_FS_Seek ret : %d\r\n",ret);
102d49c0:	e1a01008 	mov	r1, r8
102d49c4:	e3a02c02 	mov	r2, #512	; 0x200
102d49c8:	e59f0034 	ldr	r0, [pc, #52]	; 102d4a04 <Read_License+0x498>
102d49cc:	e12fff35 	blx	r5
102d49d0:	e1a02009 	mov	r2, r9
102d49d4:	e59f108c 	ldr	r1, [pc, #140]	; 102d4a68 <Read_License+0x4fc>
102d49d8:	e5973000 	ldr	r3, [r7]
102d49dc:	e59f0020 	ldr	r0, [pc, #32]	; 102d4a04 <Read_License+0x498>
102d49e0:	e12fff33 	blx	r3
102d49e4:	e59f0018 	ldr	r0, [pc, #24]	; 102d4a04 <Read_License+0x498>
102d49e8:	e12fff34 	blx	r4
102d49ec:	e59f1010 	ldr	r1, [pc, #16]	; 102d4a04 <Read_License+0x498>
102d49f0:	e1a02000 	mov	r2, r0
102d49f4:	e3a0000a 	mov	r0, #10
102d49f8:	e12fff36 	blx	r6
102d49fc:	eaffff22 	b	102d468c <Read_License+0x120>
102d4a00:	f03de540 	.word	0xf03de540
102d4a04:	f03d5bfc 	.word	0xf03d5bfc
102d4a08:	102e58f4 	.word	0x102e58f4
102d4a0c:	102ef38c 	.word	0x102ef38c
102d4a10:	102e57a4 	.word	0x102e57a4
102d4a14:	f03d209c 	.word	0xf03d209c
102d4a18:	102e6230 	.word	0x102e6230
102d4a1c:	102ef3a8 	.word	0x102ef3a8
102d4a20:	102ef3c0 	.word	0x102ef3c0
102d4a24:	102e41a8 	.word	0x102e41a8
102d4a28:	102e4840 	.word	0x102e4840
102d4a2c:	00001770 	.word	0x00001770
102d4a30:	f03db8f8 	.word	0xf03db8f8
102d4a34:	102e40b8 	.word	0x102e40b8
102d4a38:	102ef424 	.word	0x102ef424
102d4a3c:	102ef438 	.word	0x102ef438
102d4a40:	102e5b10 	.word	0x102e5b10
102d4a44:	102dbec8 	.word	0x102dbec8
102d4a48:	102ef460 	.word	0x102ef460
102d4a4c:	102dbf64 	.word	0x102dbf64
102d4a50:	102dc014 	.word	0x102dc014
102d4a54:	102ef464 	.word	0x102ef464
102d4a58:	102ef468 	.word	0x102ef468
102d4a5c:	102e48b8 	.word	0x102e48b8
102d4a60:	102e426c 	.word	0x102e426c
102d4a64:	102ef404 	.word	0x102ef404
102d4a68:	102ef3e4 	.word	0x102ef3e4

102d4a6c <Callback_HTTPS_RecvData>:

//#endif // __FOTA_HTTPS_SD__


static void Callback_HTTPS_RecvData(u8* ptrData, u32 dataLen, void* reserved)
{
102d4a6c:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s32 ret = -1;
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
//#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
102d4a70:	e59f40e8 	ldr	r4, [pc, #232]	; 102d4b60 <Callback_HTTPS_RecvData+0xf4>

static void Callback_HTTPS_RecvData(u8* ptrData, u32 dataLen, void* reserved)
{
	s32 ret = -1;
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
102d4a74:	e59f30e8 	ldr	r3, [pc, #232]	; 102d4b64 <Callback_HTTPS_RecvData+0xf8>

//#endif // __FOTA_HTTPS_SD__


static void Callback_HTTPS_RecvData(u8* ptrData, u32 dataLen, void* reserved)
{
102d4a78:	e1a05001 	mov	r5, r1
102d4a7c:	e1a0b000 	mov	fp, r0
	s32 ret = -1;
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
//#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
102d4a80:	e3a01000 	mov	r1, #0
102d4a84:	e3a02c02 	mov	r2, #512	; 0x200
102d4a88:	e1a00004 	mov	r0, r4
102d4a8c:	e59f90d4 	ldr	r9, [pc, #212]	; 102d4b68 <Callback_HTTPS_RecvData+0xfc>

static void Callback_HTTPS_RecvData(u8* ptrData, u32 dataLen, void* reserved)
{
	s32 ret = -1;
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
102d4a90:	e5835000 	str	r5, [r3]
//#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
102d4a94:	e59f80d0 	ldr	r8, [pc, #208]	; 102d4b6c <Callback_HTTPS_RecvData+0x100>
102d4a98:	e12fff39 	blx	r9
102d4a9c:	e5942200 	ldr	r2, [r4, #512]	; 0x200
102d4aa0:	e5983000 	ldr	r3, [r8]
102d4aa4:	e59f10c4 	ldr	r1, [pc, #196]	; 102d4b70 <Callback_HTTPS_RecvData+0x104>
102d4aa8:	e0852002 	add	r2, r5, r2
102d4aac:	e1a00004 	mov	r0, r4
102d4ab0:	e12fff33 	blx	r3
102d4ab4:	e59f70b8 	ldr	r7, [pc, #184]	; 102d4b74 <Callback_HTTPS_RecvData+0x108>
102d4ab8:	e1a00004 	mov	r0, r4
102d4abc:	e12fff37 	blx	r7
102d4ac0:	e59f60b0 	ldr	r6, [pc, #176]	; 102d4b78 <Callback_HTTPS_RecvData+0x10c>
102d4ac4:	e1a01004 	mov	r1, r4
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
	total_size = g_rcvdDataLen + dataLen;

//	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
	{
		ret=Ql_FS_Write(g_Handle_File_LICENSEPEM, ptrData, dataLen, &writeedlen);
102d4ac8:	e59fa0ac 	ldr	sl, [pc, #172]	; 102d4b7c <Callback_HTTPS_RecvData+0x110>
{
	s32 ret = -1;
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
//#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
102d4acc:	e1a02000 	mov	r2, r0
102d4ad0:	e3a0000a 	mov	r0, #10
102d4ad4:	e12fff36 	blx	r6
//#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
102d4ad8:	e3a00028 	mov	r0, #40	; 0x28
102d4adc:	e59f309c 	ldr	r3, [pc, #156]	; 102d4b80 <Callback_HTTPS_RecvData+0x114>
102d4ae0:	e12fff33 	blx	r3
	total_size = g_rcvdDataLen + dataLen;
102d4ae4:	e594e200 	ldr	lr, [r4, #512]	; 0x200

//	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
	{
		ret=Ql_FS_Write(g_Handle_File_LICENSEPEM, ptrData, dataLen, &writeedlen);
102d4ae8:	e59f3094 	ldr	r3, [pc, #148]	; 102d4b84 <Callback_HTTPS_RecvData+0x118>
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
//#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
//#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
	total_size = g_rcvdDataLen + dataLen;
102d4aec:	e59fc094 	ldr	ip, [pc, #148]	; 102d4b88 <Callback_HTTPS_RecvData+0x11c>
102d4af0:	e085e00e 	add	lr, r5, lr

//	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
	{
		ret=Ql_FS_Write(g_Handle_File_LICENSEPEM, ptrData, dataLen, &writeedlen);
102d4af4:	e5930000 	ldr	r0, [r3]
102d4af8:	e1a0100b 	mov	r1, fp
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
//#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
//#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
	total_size = g_rcvdDataLen + dataLen;
102d4afc:	e58ce000 	str	lr, [ip]

//	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
	{
		ret=Ql_FS_Write(g_Handle_File_LICENSEPEM, ptrData, dataLen, &writeedlen);
102d4b00:	e1a02005 	mov	r2, r5
102d4b04:	e1a0300a 	mov	r3, sl
102d4b08:	e59fc07c 	ldr	ip, [pc, #124]	; 102d4b8c <Callback_HTTPS_RecvData+0x120>
102d4b0c:	e12fff3c 	blx	ip

		if(ret == QL_RET_OK)
102d4b10:	e2501000 	subs	r1, r0, #0
102d4b14:	1a00000d 	bne	102d4b50 <Callback_HTTPS_RecvData+0xe4>
		{
//#ifdef FOTA_MSG
			APP_DEBUG("<-- File Writen Data : %d -->\r\n", writeedlen);
102d4b18:	e3a02c02 	mov	r2, #512	; 0x200
102d4b1c:	e1a00004 	mov	r0, r4
102d4b20:	e12fff39 	blx	r9
102d4b24:	e59f1064 	ldr	r1, [pc, #100]	; 102d4b90 <Callback_HTTPS_RecvData+0x124>
102d4b28:	e59a2000 	ldr	r2, [sl]
102d4b2c:	e5983000 	ldr	r3, [r8]
102d4b30:	e1a00004 	mov	r0, r4
102d4b34:	e12fff33 	blx	r3
102d4b38:	e1a00004 	mov	r0, r4
102d4b3c:	e12fff37 	blx	r7
102d4b40:	e1a01004 	mov	r1, r4
102d4b44:	e1a02000 	mov	r2, r0
102d4b48:	e3a0000a 	mov	r0, #10
102d4b4c:	e12fff36 	blx	r6
#endif
			}
		}
	}// end of else get FOTA URL
	*/
	g_rcvdDataLen += dataLen;
102d4b50:	e5943200 	ldr	r3, [r4, #512]	; 0x200
102d4b54:	e0855003 	add	r5, r5, r3
102d4b58:	e5845200 	str	r5, [r4, #512]	; 0x200
102d4b5c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102d4b60:	f03d5e68 	.word	0xf03d5e68
102d4b64:	f03de524 	.word	0xf03de524
102d4b68:	102e58f4 	.word	0x102e58f4
102d4b6c:	f03de540 	.word	0xf03de540
102d4b70:	102ef4d4 	.word	0x102ef4d4
102d4b74:	102e57a4 	.word	0x102e57a4
102d4b78:	102e6230 	.word	0x102e6230
102d4b7c:	f03db8f0 	.word	0xf03db8f0
102d4b80:	102da2a0 	.word	0x102da2a0
102d4b84:	f03d20b4 	.word	0xf03d20b4
102d4b88:	f03de52c 	.word	0xf03de52c
102d4b8c:	102e4130 	.word	0x102e4130
102d4b90:	102ef504 	.word	0x102ef504

102d4b94 <Callback_HTTPS_RcvData>:
	}

}

static void Callback_HTTPS_RcvData(u8* ptrData, u32 dataLen, void* reserved)
{
102d4b94:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s32 ret = -1;
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
102d4b98:	e59f31d4 	ldr	r3, [pc, #468]	; 102d4d74 <Callback_HTTPS_RcvData+0x1e0>
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
	total_size = g_rcvdDataLen + dataLen;

	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
102d4b9c:	e59f71d4 	ldr	r7, [pc, #468]	; 102d4d78 <Callback_HTTPS_RcvData+0x1e4>

static void Callback_HTTPS_RcvData(u8* ptrData, u32 dataLen, void* reserved)
{
	s32 ret = -1;
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
102d4ba0:	e5831000 	str	r1, [r3]
#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
	total_size = g_rcvdDataLen + dataLen;
102d4ba4:	e59f41d0 	ldr	r4, [pc, #464]	; 102d4d7c <Callback_HTTPS_RcvData+0x1e8>
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
102d4ba8:	e59f31d0 	ldr	r3, [pc, #464]	; 102d4d80 <Callback_HTTPS_RcvData+0x1ec>
	}

}

static void Callback_HTTPS_RcvData(u8* ptrData, u32 dataLen, void* reserved)
{
102d4bac:	e1a06000 	mov	r6, r0
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
102d4bb0:	e3a00028 	mov	r0, #40	; 0x28
	}

}

static void Callback_HTTPS_RcvData(u8* ptrData, u32 dataLen, void* reserved)
{
102d4bb4:	e1a05001 	mov	r5, r1
	u16 i = 0;
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
102d4bb8:	e12fff33 	blx	r3
	total_size = g_rcvdDataLen + dataLen;

	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
102d4bbc:	e5d71024 	ldrb	r1, [r7, #36]	; 0x24
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
	total_size = g_rcvdDataLen + dataLen;
102d4bc0:	e5942200 	ldr	r2, [r4, #512]	; 0x200

	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
102d4bc4:	e3510001 	cmp	r1, #1
	dataLen_here= dataLen;  //pass this value trough global variable to outside functions
#ifdef FOTA_MSG
	APP_DEBUG("<-- Data coming on https, total len: %d -->\r\n", (g_rcvdDataLen + dataLen) );
#endif
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
	total_size = g_rcvdDataLen + dataLen;
102d4bc8:	e59f11b4 	ldr	r1, [pc, #436]	; 102d4d84 <Callback_HTTPS_RcvData+0x1f0>
102d4bcc:	e0853002 	add	r3, r5, r2
102d4bd0:	e5813000 	str	r3, [r1]

	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
102d4bd4:	0a000019 	beq	102d4c40 <Callback_HTTPS_RcvData+0xac>

		}
	}
	else	// start of else get FOTA URL
	{
		if ((g_rcvdDataLen + dataLen) <= sizeof(g_HttpRcvBuf))
102d4bd8:	e35300fa 	cmp	r3, #250	; 0xfa
102d4bdc:	9a00000d 	bls	102d4c18 <Callback_HTTPS_RcvData+0x84>
		{
			Ql_memcpy((void*)(g_HttpRcvBuf + g_rcvdDataLen), (const void*)ptrData, dataLen);
		}
		else
		{
			if (g_rcvdDataLen < sizeof(g_HttpRcvBuf))
102d4be0:	e35200f9 	cmp	r2, #249	; 0xf9
102d4be4:	9a000001 	bls	102d4bf0 <Callback_HTTPS_RcvData+0x5c>
				APP_DEBUG("<-- No more buffer, discard data (len:%d) -->\r\n", dataLen);
#endif
			}
		}
	}// end of else get FOTA URL
	g_rcvdDataLen += dataLen;
102d4be8:	e5843200 	str	r3, [r4, #512]	; 0x200
102d4bec:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		else
		{
			if (g_rcvdDataLen < sizeof(g_HttpRcvBuf))
			{// buffer is not enough
				u32 realAcceptLen = sizeof(g_HttpRcvBuf) - g_rcvdDataLen;
				Ql_memcpy((void*)(g_HttpRcvBuf + g_rcvdDataLen), (const void*)ptrData, realAcceptLen);
102d4bf0:	e2840f81 	add	r0, r4, #516	; 0x204
102d4bf4:	e0800002 	add	r0, r0, r2
102d4bf8:	e1a01006 	mov	r1, r6
102d4bfc:	e26220fa 	rsb	r2, r2, #250	; 0xfa
102d4c00:	e59f3180 	ldr	r3, [pc, #384]	; 102d4d88 <Callback_HTTPS_RcvData+0x1f4>
102d4c04:	e12fff33 	blx	r3
102d4c08:	e5943200 	ldr	r3, [r4, #512]	; 0x200
102d4c0c:	e0853003 	add	r3, r5, r3
				APP_DEBUG("<-- No more buffer, discard data (len:%d) -->\r\n", dataLen);
#endif
			}
		}
	}// end of else get FOTA URL
	g_rcvdDataLen += dataLen;
102d4c10:	e5843200 	str	r3, [r4, #512]	; 0x200
102d4c14:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	else	// start of else get FOTA URL
	{
		if ((g_rcvdDataLen + dataLen) <= sizeof(g_HttpRcvBuf))
		{
			Ql_memcpy((void*)(g_HttpRcvBuf + g_rcvdDataLen), (const void*)ptrData, dataLen);
102d4c18:	e2840f81 	add	r0, r4, #516	; 0x204
102d4c1c:	e0800002 	add	r0, r0, r2
102d4c20:	e59f3160 	ldr	r3, [pc, #352]	; 102d4d88 <Callback_HTTPS_RcvData+0x1f4>
102d4c24:	e1a01006 	mov	r1, r6
102d4c28:	e1a02005 	mov	r2, r5
102d4c2c:	e12fff33 	blx	r3
102d4c30:	e5943200 	ldr	r3, [r4, #512]	; 0x200
102d4c34:	e0853003 	add	r3, r5, r3
				APP_DEBUG("<-- No more buffer, discard data (len:%d) -->\r\n", dataLen);
#endif
			}
		}
	}// end of else get FOTA URL
	g_rcvdDataLen += dataLen;
102d4c38:	e5843200 	str	r3, [r4, #512]	; 0x200
102d4c3c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	display_on_tftlcd(TFT_FOTA_FILE_DOWNLOAD_SIZE);	//Display updated downloading FILE SIZE on LCD, till Downloading completed.
	total_size = g_rcvdDataLen + dataLen;

	if(FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD == TRUE)	// If FOTA URL is got then save file
	{
		ret=Ql_FS_Write(g_Handle_File_FotaAppBin, ptrData, dataLen, &writeedlen);
102d4c40:	e59f3144 	ldr	r3, [pc, #324]	; 102d4d8c <Callback_HTTPS_RcvData+0x1f8>
102d4c44:	e59f8144 	ldr	r8, [pc, #324]	; 102d4d90 <Callback_HTTPS_RcvData+0x1fc>
102d4c48:	e5930004 	ldr	r0, [r3, #4]
102d4c4c:	e1a01006 	mov	r1, r6
102d4c50:	e1a02005 	mov	r2, r5
102d4c54:	e1a03008 	mov	r3, r8
102d4c58:	e59fc134 	ldr	ip, [pc, #308]	; 102d4d94 <Callback_HTTPS_RcvData+0x200>
102d4c5c:	e12fff3c 	blx	ip

		if(ret == QL_RET_OK)
102d4c60:	e3500000 	cmp	r0, #0
102d4c64:	1affffe7 	bne	102d4c08 <Callback_HTTPS_RcvData+0x74>
									APP_DEBUG("<--FW_VERSION_MAJOR       = %x -->\r\n", ptrData[i+5]);
									APP_DEBUG("<--FW_VERSION_MINOR       = %x -->\r\n", ptrData[i+6]);
									APP_DEBUG("<--CON_IPC_VERSION        = %x -->\r\n", ptrData[i+7]);
									APP_DEBUG("<--MODEL_PAYGO_RO_TDS_AMC = %x -->\r\n", ptrData[i+8]);
#endif
									if((Control_Module_Indentity_data[4] == ptrData[i+8])// Make sure the FW is for correct set of Control HW Model
102d4c68:	e59f3128 	ldr	r3, [pc, #296]	; 102d4d98 <Callback_HTTPS_RcvData+0x204>
102d4c6c:	e5981000 	ldr	r1, [r8]
										&& (Control_Module_Indentity_data[0] == ptrData[i+4]))// Make sure the FW is for correct set of Control HW module version
102d4c70:	e5d3c000 	ldrb	ip, [r3]
									APP_DEBUG("<--FW_VERSION_MAJOR       = %x -->\r\n", ptrData[i+5]);
									APP_DEBUG("<--FW_VERSION_MINOR       = %x -->\r\n", ptrData[i+6]);
									APP_DEBUG("<--CON_IPC_VERSION        = %x -->\r\n", ptrData[i+7]);
									APP_DEBUG("<--MODEL_PAYGO_RO_TDS_AMC = %x -->\r\n", ptrData[i+8]);
#endif
									if((Control_Module_Indentity_data[4] == ptrData[i+8])// Make sure the FW is for correct set of Control HW Model
102d4c74:	e5d38004 	ldrb	r8, [r3, #4]
										else
										{
#ifdef FOTA_MSG
											APP_DEBUG("<-- COM FW Version is Invalid-->\r\n");
#endif
											if(FLAG.DIGNOSTIC_MODE == TRUE) // Force FW upgrade in case in Diagnostic mode with same version number
102d4c78:	e5d7900a 	ldrb	r9, [r7, #10]
									APP_DEBUG("<--FW_VERSION_MINOR       = %x -->\r\n", ptrData[i+6]);
									APP_DEBUG("<--CON_IPC_VERSION        = %x -->\r\n", ptrData[i+7]);
									APP_DEBUG("<--MODEL_PAYGO_RO_TDS_AMC = %x -->\r\n", ptrData[i+8]);
#endif
									if((Control_Module_Indentity_data[4] == ptrData[i+8])// Make sure the FW is for correct set of Control HW Model
										&& (Control_Module_Indentity_data[0] == ptrData[i+4]))// Make sure the FW is for correct set of Control HW module version
102d4c7c:	e1a03000 	mov	r3, r0
										{
#ifdef FOTA_MSG
											APP_DEBUG("<-- COM FW Version is Invalid-->\r\n");
#endif
											if(FLAG.DIGNOSTIC_MODE == TRUE) // Force FW upgrade in case in Diagnostic mode with same version number
												FLAG.FOTA_FILE_COM_FW_INVALID = FALSE;
102d4c80:	e1a0a000 	mov	sl, r0
102d4c84:	ea000007 	b	102d4ca8 <Callback_HTTPS_RcvData+0x114>
						}
					}
				}
				// Extract the CON Module version information of the new / updated code..from the FOTA Downloaded FW
				// Scan through the entire FW copy and find a token of '<', '*', '!', '=' .. version info is right after it.
				if(ptrData[i] == '<')
102d4c88:	e352003c 	cmp	r2, #60	; 0x3c
102d4c8c:	0a000021 	beq	102d4d18 <Callback_HTTPS_RcvData+0x184>
			APP_DEBUG("<-- File Writen Data : %d -->\r\n", writeedlen);
#endif
			// Extract the FW version of the new / updated code..from the FOTA Downloaded FW
			// Scan through the entire FW copy and find a token of '&', '$', '@', '#' .. version info is right after it.

			for(i=0;i<=writeedlen;i++)
102d4c90:	e2833001 	add	r3, r3, #1
102d4c94:	e1a03803 	lsl	r3, r3, #16
102d4c98:	e1a03823 	lsr	r3, r3, #16
102d4c9c:	e1530001 	cmp	r3, r1
102d4ca0:	e1a00003 	mov	r0, r3
102d4ca4:	8affffd7 	bhi	102d4c08 <Callback_HTTPS_RcvData+0x74>
			{
				if(ptrData[i] == '&')
102d4ca8:	e7d62000 	ldrb	r2, [r6, r0]
102d4cac:	e0860000 	add	r0, r6, r0
102d4cb0:	e3520026 	cmp	r2, #38	; 0x26
102d4cb4:	1afffff3 	bne	102d4c88 <Callback_HTTPS_RcvData+0xf4>
				{
					if(ptrData[i+1] == '$')
102d4cb8:	e5d02001 	ldrb	r2, [r0, #1]
102d4cbc:	e3520024 	cmp	r2, #36	; 0x24
102d4cc0:	1afffff2 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
					{
						if(ptrData[i+2] == '@')
102d4cc4:	e5d02002 	ldrb	r2, [r0, #2]
102d4cc8:	e3520040 	cmp	r2, #64	; 0x40
102d4ccc:	1affffef 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
						{
							if(ptrData[i+3] == '#')
102d4cd0:	e5d02003 	ldrb	r2, [r0, #3]
102d4cd4:	e3520023 	cmp	r2, #35	; 0x23
102d4cd8:	1affffec 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
							{
								if(ptrData[i+4] == HW_Version_COMM) // Check if received FOTA is for correct COM module HW version
102d4cdc:	e5d02004 	ldrb	r2, [r0, #4]
102d4ce0:	e3520000 	cmp	r2, #0
102d4ce4:	1affffe9 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
								{
									if(ptrData[i+5] == HW_Version_CON) // Check if received FOTA is for correct CON module HW version
102d4ce8:	e5d02005 	ldrb	r2, [r0, #5]
102d4cec:	e3520000 	cmp	r2, #0
102d4cf0:	1affffe6 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
										APP_DEBUG("<--HW_Version_CON        = %x -->\r\n", ptrData[i+5]);
										APP_DEBUG("<--FW_Version_Major_COMM = %x -->\r\n", ptrData[i+6]);
										APP_DEBUG("<--FW_Version_Minor_COMM = %x -->\r\n", ptrData[i+7]);
#endif
										// There should be change in version information
										if(FW_Version_Major_COMM != ptrData[i+6] && FW_Version_Minor_COMM != ptrData[i+7]) 
102d4cf4:	e5d0b006 	ldrb	fp, [r0, #6]
102d4cf8:	e35b0000 	cmp	fp, #0
102d4cfc:	0a000017 	beq	102d4d60 <Callback_HTTPS_RcvData+0x1cc>
102d4d00:	e5d0b007 	ldrb	fp, [r0, #7]
102d4d04:	e35b0004 	cmp	fp, #4
102d4d08:	0a000014 	beq	102d4d60 <Callback_HTTPS_RcvData+0x1cc>
										{
											FLAG.FOTA_FILE_COM_FW_INVALID = FALSE;
102d4d0c:	e5c72021 	strb	r2, [r7, #33]	; 0x21
102d4d10:	e5d02000 	ldrb	r2, [r0]
102d4d14:	eaffffdb 	b	102d4c88 <Callback_HTTPS_RcvData+0xf4>
				}
				// Extract the CON Module version information of the new / updated code..from the FOTA Downloaded FW
				// Scan through the entire FW copy and find a token of '<', '*', '!', '=' .. version info is right after it.
				if(ptrData[i] == '<')
				{
					if(ptrData[i+1] == '*')
102d4d18:	e5d02001 	ldrb	r2, [r0, #1]
102d4d1c:	e352002a 	cmp	r2, #42	; 0x2a
102d4d20:	1affffda 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
					{
						if(ptrData[i+2] == '!')
102d4d24:	e5d02002 	ldrb	r2, [r0, #2]
102d4d28:	e3520021 	cmp	r2, #33	; 0x21
102d4d2c:	1affffd7 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
						{
							if(ptrData[i+3] == '=')
102d4d30:	e5d02003 	ldrb	r2, [r0, #3]
102d4d34:	e352003d 	cmp	r2, #61	; 0x3d
102d4d38:	1affffd4 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
							{
								if(ptrData[i+4] == HW_Version_CON) // Check if received FOTA is for correct CON module HW version
102d4d3c:	e5d02004 	ldrb	r2, [r0, #4]
102d4d40:	e3520000 	cmp	r2, #0
102d4d44:	1affffd1 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
									APP_DEBUG("<--FW_VERSION_MAJOR       = %x -->\r\n", ptrData[i+5]);
									APP_DEBUG("<--FW_VERSION_MINOR       = %x -->\r\n", ptrData[i+6]);
									APP_DEBUG("<--CON_IPC_VERSION        = %x -->\r\n", ptrData[i+7]);
									APP_DEBUG("<--MODEL_PAYGO_RO_TDS_AMC = %x -->\r\n", ptrData[i+8]);
#endif
									if((Control_Module_Indentity_data[4] == ptrData[i+8])// Make sure the FW is for correct set of Control HW Model
102d4d48:	e5d02008 	ldrb	r2, [r0, #8]
102d4d4c:	e1520008 	cmp	r2, r8
102d4d50:	1affffce 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
										&& (Control_Module_Indentity_data[0] == ptrData[i+4]))// Make sure the FW is for correct set of Control HW module version
102d4d54:	e35c0000 	cmp	ip, #0
									{
										FLAG.FOTA_FILE_CON_FW_INVALID = FALSE;
102d4d58:	05c7c022 	strbeq	ip, [r7, #34]	; 0x22
102d4d5c:	eaffffcb 	b	102d4c90 <Callback_HTTPS_RcvData+0xfc>
										else
										{
#ifdef FOTA_MSG
											APP_DEBUG("<-- COM FW Version is Invalid-->\r\n");
#endif
											if(FLAG.DIGNOSTIC_MODE == TRUE) // Force FW upgrade in case in Diagnostic mode with same version number
102d4d60:	e3590001 	cmp	r9, #1
102d4d64:	1affffc9 	bne	102d4c90 <Callback_HTTPS_RcvData+0xfc>
												FLAG.FOTA_FILE_COM_FW_INVALID = FALSE;
102d4d68:	e5c7a021 	strb	sl, [r7, #33]	; 0x21
102d4d6c:	e5d02000 	ldrb	r2, [r0]
102d4d70:	eaffffc4 	b	102d4c88 <Callback_HTTPS_RcvData+0xf4>
102d4d74:	f03de524 	.word	0xf03de524
102d4d78:	f03da5f0 	.word	0xf03da5f0
102d4d7c:	f03d5e68 	.word	0xf03d5e68
102d4d80:	102da2a0 	.word	0x102da2a0
102d4d84:	f03de52c 	.word	0xf03de52c
102d4d88:	102e597c 	.word	0x102e597c
102d4d8c:	f03d20b4 	.word	0xf03d20b4
102d4d90:	f03db8f0 	.word	0xf03db8f0
102d4d94:	102e4130 	.word	0x102e4130
102d4d98:	f03da500 	.word	0xf03da500

102d4d9c <RIL_HTTPS_QSSLCFG>:
//5 : Update Failed
//6 : Update Successful & Rebooting


s32 RIL_HTTPS_QSSLCFG()
{
102d4d9c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

	//Enable Https
	if(ret == RIL_AT_SUCCESS)
	{
		Ql_memset(strAT, 0, sizeof(strAT));
		Ql_sprintf(strAT, "AT+QSSLCFG=\"https\",1\n");
102d4da0:	e59f70a8 	ldr	r7, [pc, #168]	; 102d4e50 <RIL_HTTPS_QSSLCFG+0xb4>
//5 : Update Failed
//6 : Update Successful & Rebooting


s32 RIL_HTTPS_QSSLCFG()
{
102d4da4:	e24dd040 	sub	sp, sp, #64	; 0x40
	char strAT[50];

	//Enable Https
	if(ret == RIL_AT_SUCCESS)
	{
		Ql_memset(strAT, 0, sizeof(strAT));
102d4da8:	e3a02032 	mov	r2, #50	; 0x32
102d4dac:	e3a01000 	mov	r1, #0
102d4db0:	e28d000c 	add	r0, sp, #12
102d4db4:	e59f8098 	ldr	r8, [pc, #152]	; 102d4e54 <RIL_HTTPS_QSSLCFG+0xb8>
102d4db8:	e12fff38 	blx	r8
		Ql_sprintf(strAT, "AT+QSSLCFG=\"https\",1\n");
102d4dbc:	e59f1094 	ldr	r1, [pc, #148]	; 102d4e58 <RIL_HTTPS_QSSLCFG+0xbc>
102d4dc0:	e5973000 	ldr	r3, [r7]
102d4dc4:	e28d000c 	add	r0, sp, #12
102d4dc8:	e12fff33 	blx	r3

		ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102d4dcc:	e59f6088 	ldr	r6, [pc, #136]	; 102d4e5c <RIL_HTTPS_QSSLCFG+0xc0>
102d4dd0:	e28d000c 	add	r0, sp, #12
102d4dd4:	e12fff36 	blx	r6
102d4dd8:	e3a03000 	mov	r3, #0
102d4ddc:	e1a02003 	mov	r2, r3
102d4de0:	e58d3000 	str	r3, [sp]
102d4de4:	e59f5074 	ldr	r5, [pc, #116]	; 102d4e60 <RIL_HTTPS_QSSLCFG+0xc4>
102d4de8:	e1a01000 	mov	r1, r0
102d4dec:	e28d000c 	add	r0, sp, #12
102d4df0:	e12fff35 	blx	r5
		}
#endif
	}

	//Set Cid for FOTA URL connection
	if(ret == RIL_AT_SUCCESS)
102d4df4:	e2504000 	subs	r4, r0, #0
102d4df8:	1a000011 	bne	102d4e44 <RIL_HTTPS_QSSLCFG+0xa8>
	{
		Ql_memset(strAT, 0, sizeof(strAT));
102d4dfc:	e1a01004 	mov	r1, r4
102d4e00:	e3a02032 	mov	r2, #50	; 0x32
102d4e04:	e28d000c 	add	r0, sp, #12
102d4e08:	e12fff38 	blx	r8
		Ql_sprintf(strAT, "AT+QSSLCFG=\"httpsctxi\",%d\n",CID_HOST_FOTA);
102d4e0c:	e59f1050 	ldr	r1, [pc, #80]	; 102d4e64 <RIL_HTTPS_QSSLCFG+0xc8>
102d4e10:	e3a02001 	mov	r2, #1
102d4e14:	e5973000 	ldr	r3, [r7]
102d4e18:	e28d000c 	add	r0, sp, #12
102d4e1c:	e12fff33 	blx	r3

		ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102d4e20:	e28d000c 	add	r0, sp, #12
102d4e24:	e12fff36 	blx	r6
102d4e28:	e1a02004 	mov	r2, r4
102d4e2c:	e58d4000 	str	r4, [sp]
102d4e30:	e1a03004 	mov	r3, r4
102d4e34:	e1a01000 	mov	r1, r0
102d4e38:	e28d000c 	add	r0, sp, #12
102d4e3c:	e12fff35 	blx	r5
102d4e40:	e1a04000 	mov	r4, r0
		}
#endif
	}

	return ret;
}
102d4e44:	e1a00004 	mov	r0, r4
102d4e48:	e28dd040 	add	sp, sp, #64	; 0x40
102d4e4c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102d4e50:	f03de540 	.word	0xf03de540
102d4e54:	102e58f4 	.word	0x102e58f4
102d4e58:	102ef524 	.word	0x102ef524
102d4e5c:	102e57a4 	.word	0x102e57a4
102d4e60:	102e5168 	.word	0x102e5168
102d4e64:	102ef53c 	.word	0x102ef53c

102d4e68 <FIRMWARE_Download>:

s32 FIRMWARE_Download()
{
102d4e68:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s32 ret = -1;
	g_rcvdDataLen = 0;
	u8 Fota_Download_retry_count;
	bool FOTA_DOWNLOAD_SUCCESS = FALSE;
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
102d4e6c:	e59f3144 	ldr	r3, [pc, #324]	; 102d4fb8 <FIRMWARE_Download+0x150>
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
102d4e70:	e3a0000a 	mov	r0, #10

	return ret;
}

s32 FIRMWARE_Download()
{
102d4e74:	e24dd00c 	sub	sp, sp, #12
	s32 ret = -1;
	g_rcvdDataLen = 0;
102d4e78:	e59f113c 	ldr	r1, [pc, #316]	; 102d4fbc <FIRMWARE_Download+0x154>
102d4e7c:	e59f713c 	ldr	r7, [pc, #316]	; 102d4fc0 <FIRMWARE_Download+0x158>
102d4e80:	e59f613c 	ldr	r6, [pc, #316]	; 102d4fc4 <FIRMWARE_Download+0x15c>
		}
#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS FOTA SET SERVER URL  %s-->\r\n",FOTA_URL);
#endif
		// Send HTTP GET Request
		ret = RIL_HTTP_RequestToGet(60);
102d4e84:	e59f813c 	ldr	r8, [pc, #316]	; 102d4fc8 <FIRMWARE_Download+0x160>
#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS GET REQUEST -->\r\n");
#endif
		/*---- Read File From Server ----*/
		// Set Filesystem
		fileSys_SetFileSystem(FALSE);	// False means No filesystem Formate.
102d4e88:	e59f913c 	ldr	r9, [pc, #316]	; 102d4fcc <FIRMWARE_Download+0x164>

		// Create File to store
		ret = fileSys_OpenOrCreateFile((u8 *)File_FotaAppBin);
102d4e8c:	e59f513c 	ldr	r5, [pc, #316]	; 102d4fd0 <FIRMWARE_Download+0x168>
102d4e90:	e59fa13c 	ldr	sl, [pc, #316]	; 102d4fd4 <FIRMWARE_Download+0x16c>
{
	s32 ret = -1;
	g_rcvdDataLen = 0;
	u8 Fota_Download_retry_count;
	bool FOTA_DOWNLOAD_SUCCESS = FALSE;
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
102d4e94:	e3a02001 	mov	r2, #1
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
102d4e98:	e58d0004 	str	r0, [sp, #4]
}

s32 FIRMWARE_Download()
{
	s32 ret = -1;
	g_rcvdDataLen = 0;
102d4e9c:	e3a00000 	mov	r0, #0
102d4ea0:	e5810200 	str	r0, [r1, #512]	; 0x200
	u8 Fota_Download_retry_count;
	bool FOTA_DOWNLOAD_SUCCESS = FALSE;
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
102d4ea4:	e5c32021 	strb	r2, [r3, #33]	; 0x21
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
102d4ea8:	e5c32022 	strb	r2, [r3, #34]	; 0x22
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
	{
		// Set HTTP server address (URL)
		ret = RIL_HTTP_SetServerURL((char *)FOTA_URL, Ql_strlen((char *)FOTA_URL));
102d4eac:	e59f0124 	ldr	r0, [pc, #292]	; 102d4fd8 <FIRMWARE_Download+0x170>
102d4eb0:	e12fff37 	blx	r7
			return ret;
		}
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- File (%s) Created -->\r\n", File_FotaAppBin);
#endif
		g_Handle_File_FotaAppBin = ret;//Get file handle (Global Variable)
102d4eb4:	e59f4120 	ldr	r4, [pc, #288]	; 102d4fdc <FIRMWARE_Download+0x174>
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
	{
		// Set HTTP server address (URL)
		ret = RIL_HTTP_SetServerURL((char *)FOTA_URL, Ql_strlen((char *)FOTA_URL));
102d4eb8:	e1a01800 	lsl	r1, r0, #16
102d4ebc:	e1a01821 	lsr	r1, r1, #16
102d4ec0:	e59f0110 	ldr	r0, [pc, #272]	; 102d4fd8 <FIRMWARE_Download+0x170>
102d4ec4:	e12fff36 	blx	r6
		if(ret < 0)
102d4ec8:	e2503000 	subs	r3, r0, #0
		}
#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS FOTA SET SERVER URL  %s-->\r\n",FOTA_URL);
#endif
		// Send HTTP GET Request
		ret = RIL_HTTP_RequestToGet(60);
102d4ecc:	e3a0003c 	mov	r0, #60	; 0x3c
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
	{
		// Set HTTP server address (URL)
		ret = RIL_HTTP_SetServerURL((char *)FOTA_URL, Ql_strlen((char *)FOTA_URL));
		if(ret < 0)
102d4ed0:	ba000028 	blt	102d4f78 <FIRMWARE_Download+0x110>
		}
#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS FOTA SET SERVER URL  %s-->\r\n",FOTA_URL);
#endif
		// Send HTTP GET Request
		ret = RIL_HTTP_RequestToGet(60);
102d4ed4:	e12fff38 	blx	r8
		if(ret < 0)
102d4ed8:	e2503000 	subs	r3, r0, #0
#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS GET REQUEST -->\r\n");
#endif
		/*---- Read File From Server ----*/
		// Set Filesystem
		fileSys_SetFileSystem(FALSE);	// False means No filesystem Formate.
102d4edc:	e3a00000 	mov	r0, #0
#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS FOTA SET SERVER URL  %s-->\r\n",FOTA_URL);
#endif
		// Send HTTP GET Request
		ret = RIL_HTTP_RequestToGet(60);
		if(ret < 0)
102d4ee0:	ba000028 	blt	102d4f88 <FIRMWARE_Download+0x120>
#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS GET REQUEST -->\r\n");
#endif
		/*---- Read File From Server ----*/
		// Set Filesystem
		fileSys_SetFileSystem(FALSE);	// False means No filesystem Formate.
102d4ee4:	e12fff39 	blx	r9

		// Create File to store
		ret = fileSys_OpenOrCreateFile((u8 *)File_FotaAppBin);
102d4ee8:	e5950000 	ldr	r0, [r5]
102d4eec:	e12fff3a 	blx	sl
		// Read HTTP File Data and write to File
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- START RECEIVING FOTA FILE FROM SERVER -->\r\n");
#endif

		ret = RIL_HTTP_ReadResponse(30, Callback_HTTPS_RcvData);
102d4ef0:	e59f10e8 	ldr	r1, [pc, #232]	; 102d4fe0 <FIRMWARE_Download+0x178>
		// Set Filesystem
		fileSys_SetFileSystem(FALSE);	// False means No filesystem Formate.

		// Create File to store
		ret = fileSys_OpenOrCreateFile((u8 *)File_FotaAppBin);
		if(ret < 0)
102d4ef4:	e2503000 	subs	r3, r0, #0
		// Read HTTP File Data and write to File
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- START RECEIVING FOTA FILE FROM SERVER -->\r\n");
#endif

		ret = RIL_HTTP_ReadResponse(30, Callback_HTTPS_RcvData);
102d4ef8:	e3a0001e 	mov	r0, #30
		// Set Filesystem
		fileSys_SetFileSystem(FALSE);	// False means No filesystem Formate.

		// Create File to store
		ret = fileSys_OpenOrCreateFile((u8 *)File_FotaAppBin);
		if(ret < 0)
102d4efc:	ba000025 	blt	102d4f98 <FIRMWARE_Download+0x130>
			return ret;
		}
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- File (%s) Created -->\r\n", File_FotaAppBin);
#endif
		g_Handle_File_FotaAppBin = ret;//Get file handle (Global Variable)
102d4f00:	e5843004 	str	r3, [r4, #4]
		// Read HTTP File Data and write to File
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- START RECEIVING FOTA FILE FROM SERVER -->\r\n");
#endif

		ret = RIL_HTTP_ReadResponse(30, Callback_HTTPS_RcvData);
102d4f04:	e59f30d8 	ldr	r3, [pc, #216]	; 102d4fe4 <FIRMWARE_Download+0x17c>
102d4f08:	e12fff33 	blx	r3

		Ql_FS_Close(g_Handle_File_FotaAppBin);
102d4f0c:	e59f20d4 	ldr	r2, [pc, #212]	; 102d4fe8 <FIRMWARE_Download+0x180>
		// Read HTTP File Data and write to File
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- START RECEIVING FOTA FILE FROM SERVER -->\r\n");
#endif

		ret = RIL_HTTP_ReadResponse(30, Callback_HTTPS_RcvData);
102d4f10:	e1a0b000 	mov	fp, r0

		Ql_FS_Close(g_Handle_File_FotaAppBin);
102d4f14:	e5940004 	ldr	r0, [r4, #4]
102d4f18:	e12fff32 	blx	r2
		g_rcvdDataLen = 0;
102d4f1c:	e59f2098 	ldr	r2, [pc, #152]	; 102d4fbc <FIRMWARE_Download+0x154>
102d4f20:	e3a03000 	mov	r3, #0
		if(ret < 0)
102d4f24:	e35b0000 	cmp	fp, #0
#endif

		ret = RIL_HTTP_ReadResponse(30, Callback_HTTPS_RcvData);

		Ql_FS_Close(g_Handle_File_FotaAppBin);
		g_rcvdDataLen = 0;
102d4f28:	e5823200 	str	r3, [r2, #512]	; 0x200
		if(ret < 0)
102d4f2c:	ba000002 	blt	102d4f3c <FIRMWARE_Download+0xd4>
	else
	{
		Fota_Fail_Reason_Code = 8;
		return -1;
	}
}
102d4f30:	e1a00003 	mov	r0, r3
102d4f34:	e28dd00c 	add	sp, sp, #12
102d4f38:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		{
#ifdef FOTA_MSG
			APP_DEBUG("\r\n<-- ERROR : FOTA FILE CURRUPT WHILE DOWNLOAD!!! (ret = %d) -->\r\n", ret);
#endif
			// Delete Curreupt File
			ret = fileSys_deleteFile((u8 *)File_FotaAppBin);
102d4f3c:	e59f30a8 	ldr	r3, [pc, #168]	; 102d4fec <FIRMWARE_Download+0x184>
102d4f40:	e5950000 	ldr	r0, [r5]
102d4f44:	e12fff33 	blx	r3
102d4f48:	e59d3004 	ldr	r3, [sp, #4]
102d4f4c:	e2432001 	sub	r2, r3, #1
			if(ret < 0)
102d4f50:	e2503000 	subs	r3, r0, #0
102d4f54:	ba000013 	blt	102d4fa8 <FIRMWARE_Download+0x140>
	g_rcvdDataLen = 0;
	u8 Fota_Download_retry_count;
	bool FOTA_DOWNLOAD_SUCCESS = FALSE;
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
102d4f58:	e21220ff 	ands	r2, r2, #255	; 0xff
102d4f5c:	e58d2004 	str	r2, [sp, #4]
102d4f60:	1affffd1 	bne	102d4eac <FIRMWARE_Download+0x44>
	//Return either sucess of fail due to max attempts
	if(FOTA_DOWNLOAD_SUCCESS == TRUE)
		return 0;
	else
	{
		Fota_Fail_Reason_Code = 8;
102d4f64:	e59f2084 	ldr	r2, [pc, #132]	; 102d4ff0 <FIRMWARE_Download+0x188>
102d4f68:	e3a01008 	mov	r1, #8
		return -1;
102d4f6c:	e3e03000 	mvn	r3, #0
	//Return either sucess of fail due to max attempts
	if(FOTA_DOWNLOAD_SUCCESS == TRUE)
		return 0;
	else
	{
		Fota_Fail_Reason_Code = 8;
102d4f70:	e5c21000 	strb	r1, [r2]
		return -1;
102d4f74:	eaffffed 	b	102d4f30 <FIRMWARE_Download+0xc8>
		if(ret < 0)
		{
#ifdef FOTA_MSG
			APP_DEBUG("<-- ERROR : HTTPS FOTA SET SERVER URL (ret = %d) -->\r\n", ret);
#endif
			Fota_Fail_Reason_Code = 4;
102d4f78:	e59f2070 	ldr	r2, [pc, #112]	; 102d4ff0 <FIRMWARE_Download+0x188>
102d4f7c:	e3a01004 	mov	r1, #4
102d4f80:	e5c21000 	strb	r1, [r2]
			return ret;
102d4f84:	eaffffe9 	b	102d4f30 <FIRMWARE_Download+0xc8>
		if(ret < 0)
		{
#ifdef FOTA_MSG
			APP_DEBUG("<-- ERROR : HTTPS GET REQUEST Failed (ret = %d) -->\r\n", ret);
#endif
			Fota_Fail_Reason_Code = 5;
102d4f88:	e59f2060 	ldr	r2, [pc, #96]	; 102d4ff0 <FIRMWARE_Download+0x188>
102d4f8c:	e3a01005 	mov	r1, #5
102d4f90:	e5c21000 	strb	r1, [r2]
			return ret;
102d4f94:	eaffffe5 	b	102d4f30 <FIRMWARE_Download+0xc8>
		{
			//Open file failed.
#ifdef FOTA_MSG
			APP_DEBUG("<-- Failed to Create File (%s) ret=%d -->\r\n", File_FotaAppBin, ret);
#endif
			Fota_Fail_Reason_Code = 6;
102d4f98:	e59f2050 	ldr	r2, [pc, #80]	; 102d4ff0 <FIRMWARE_Download+0x188>
102d4f9c:	e3a01006 	mov	r1, #6
102d4fa0:	e5c21000 	strb	r1, [r2]
			return ret;
102d4fa4:	eaffffe1 	b	102d4f30 <FIRMWARE_Download+0xc8>
			if(ret < 0)
			{
#ifdef FOTA_MSG
				APP_DEBUG("<-- ERROR : Deleting Currupt File (%s), (ret = %d) -->\r\n", File_FotaAppBin, ret);
#endif
				Fota_Fail_Reason_Code = 7;
102d4fa8:	e59f2040 	ldr	r2, [pc, #64]	; 102d4ff0 <FIRMWARE_Download+0x188>
102d4fac:	e3a01007 	mov	r1, #7
102d4fb0:	e5c21000 	strb	r1, [r2]
				return ret;
102d4fb4:	eaffffdd 	b	102d4f30 <FIRMWARE_Download+0xc8>
102d4fb8:	f03da5f0 	.word	0xf03da5f0
102d4fbc:	f03d5e68 	.word	0xf03d5e68
102d4fc0:	102e57a4 	.word	0x102e57a4
102d4fc4:	102ca6d0 	.word	0x102ca6d0
102d4fc8:	102ca788 	.word	0x102ca788
102d4fcc:	102d2cb0 	.word	0x102d2cb0
102d4fd0:	f03d20b0 	.word	0xf03d20b0
102d4fd4:	102d2e00 	.word	0x102d2e00
102d4fd8:	f03d6168 	.word	0xf03d6168
102d4fdc:	f03d20b4 	.word	0xf03d20b4
102d4fe0:	102d4b94 	.word	0x102d4b94
102d4fe4:	102ca8d4 	.word	0x102ca8d4
102d4fe8:	102e426c 	.word	0x102e426c
102d4fec:	102d2fb0 	.word	0x102d2fb0
102d4ff0:	f03de528 	.word	0xf03de528

102d4ff4 <FIRMWARE_Update>:
		return -1;
	}
}

s32 FIRMWARE_Update()
{
102d4ff4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

	static int s_iSizeRem = 0;


#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Update in progress !!! -->\r\n");
102d4ff8:	e59f63b8 	ldr	r6, [pc, #952]	; 102d53b8 <FIRMWARE_Update+0x3c4>
s32 FIRMWARE_Update()
{
	int ret=-1;
	int FileSize = 0;
	int ReadSize = 0;
	int ReadLen = 0;
102d4ffc:	e3a05000 	mov	r5, #0
		return -1;
	}
}

s32 FIRMWARE_Update()
{
102d5000:	e24ddf83 	sub	sp, sp, #524	; 0x20c

	static int s_iSizeRem = 0;


#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Update in progress !!! -->\r\n");
102d5004:	e1a01005 	mov	r1, r5
102d5008:	e3a02c02 	mov	r2, #512	; 0x200
102d500c:	e59f73a8 	ldr	r7, [pc, #936]	; 102d53bc <FIRMWARE_Update+0x3c8>
102d5010:	e1a00006 	mov	r0, r6
s32 FIRMWARE_Update()
{
	int ret=-1;
	int FileSize = 0;
	int ReadSize = 0;
	int ReadLen = 0;
102d5014:	e58d5004 	str	r5, [sp, #4]

	static int s_iSizeRem = 0;


#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Update in progress !!! -->\r\n");
102d5018:	e12fff37 	blx	r7
102d501c:	e59f239c 	ldr	r2, [pc, #924]	; 102d53c0 <FIRMWARE_Update+0x3cc>
102d5020:	e59f139c 	ldr	r1, [pc, #924]	; 102d53c4 <FIRMWARE_Update+0x3d0>
102d5024:	e5923000 	ldr	r3, [r2]
102d5028:	e1a00006 	mov	r0, r6
102d502c:	e12fff33 	blx	r3
102d5030:	e59f3390 	ldr	r3, [pc, #912]	; 102d53c8 <FIRMWARE_Update+0x3d4>
102d5034:	e1a00006 	mov	r0, r6
102d5038:	e12fff33 	blx	r3
102d503c:	e59f3388 	ldr	r3, [pc, #904]	; 102d53cc <FIRMWARE_Update+0x3d8>
102d5040:	e1a01006 	mov	r1, r6
	FotaConfig.Q_feed_interval1 = 100;
	FotaConfig.Q_gpio_pin2 = 26;
	FotaConfig.Q_feed_interval2 = 500;

	//2. Begin, check the Bin file.
	ret = fileSys_getFileSize(File_FotaAppBin); //Get the size of upgrade file from file system
102d5044:	e59f4384 	ldr	r4, [pc, #900]	; 102d53d0 <FIRMWARE_Update+0x3dc>

	static int s_iSizeRem = 0;


#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Update in progress !!! -->\r\n");
102d5048:	e1a02000 	mov	r2, r0
102d504c:	e3a0000a 	mov	r0, #10
102d5050:	e12fff33 	blx	r3
#endif
	Ql_strcpy(RP_FW_Upgrade_status,"3");// Report "Update in progress"
102d5054:	e59f1378 	ldr	r1, [pc, #888]	; 102d53d4 <FIRMWARE_Update+0x3e0>
102d5058:	e59f2378 	ldr	r2, [pc, #888]	; 102d53d8 <FIRMWARE_Update+0x3e4>
102d505c:	e59f0378 	ldr	r0, [pc, #888]	; 102d53dc <FIRMWARE_Update+0x3e8>
102d5060:	e12fff32 	blx	r2
	Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d5064:	e59f2374 	ldr	r2, [pc, #884]	; 102d53e0 <FIRMWARE_Update+0x3ec>
	publish_data(MQTT_TWIN_REPORTED);
102d5068:	e3a00041 	mov	r0, #65	; 0x41

#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Update in progress !!! -->\r\n");
#endif
	Ql_strcpy(RP_FW_Upgrade_status,"3");// Report "Update in progress"
	Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d506c:	e5923000 	ldr	r3, [r2]
102d5070:	e3833c01 	orr	r3, r3, #256	; 0x100
102d5074:	e5823000 	str	r3, [r2]
	publish_data(MQTT_TWIN_REPORTED);
102d5078:	e59f3364 	ldr	r3, [pc, #868]	; 102d53e4 <FIRMWARE_Update+0x3f0>
102d507c:	e12fff33 	blx	r3

	//1. Init FOFA param.
	Ql_memset((void *)(&FotaConfig), 0, sizeof(ST_FotaConfig)); //Do not enable watch_dog
102d5080:	e1a01005 	mov	r1, r5
102d5084:	e3a02010 	mov	r2, #16
102d5088:	e2860fe6 	add	r0, r6, #920	; 0x398
102d508c:	e12fff37 	blx	r7
	FotaConfig.Q_gpio_pin1 = 0;
102d5090:	e3a03fe6 	mov	r3, #920	; 0x398
102d5094:	e18650b3 	strh	r5, [r6, r3]
	FotaConfig.Q_feed_interval1 = 100;
102d5098:	e3a02064 	mov	r2, #100	; 0x64
102d509c:	e2833002 	add	r3, r3, #2
102d50a0:	e18620b3 	strh	r2, [r6, r3]
	FotaConfig.Q_gpio_pin2 = 26;
102d50a4:	e3a0201a 	mov	r2, #26
102d50a8:	e3a03fe7 	mov	r3, #924	; 0x39c
102d50ac:	e18620b3 	strh	r2, [r6, r3]
	FotaConfig.Q_feed_interval2 = 500;
102d50b0:	e3a02f7d 	mov	r2, #500	; 0x1f4
102d50b4:	e2833002 	add	r3, r3, #2
102d50b8:	e18620b3 	strh	r2, [r6, r3]

	//2. Begin, check the Bin file.
	ret = fileSys_getFileSize(File_FotaAppBin); //Get the size of upgrade file from file system
102d50bc:	e5940000 	ldr	r0, [r4]
102d50c0:	e59f3320 	ldr	r3, [pc, #800]	; 102d53e8 <FIRMWARE_Update+0x3f4>
102d50c4:	e12fff33 	blx	r3
	if(ret < QL_RET_OK)
102d50c8:	e2505000 	subs	r5, r0, #0
102d50cc:	ba0000b4 	blt	102d53a4 <FIRMWARE_Update+0x3b0>
#ifdef FOTA_MSG
	APP_DEBUG("\r\n<-- FOTA File (%s) Present File Size:.%d Bytes -->\r\n", File_FotaAppBin, FileSize);
	APP_DEBUG("<-- Downloaded file size: %d -->\r\n", total_size );
#endif

	if(total_size != FileSize)	//Comapare Downloaded File size with new Final downloaded file size , if mismatch then there is Error.Fota Success but it restarts with Previous Firmware(FOTA failure)
102d50d0:	e59f3314 	ldr	r3, [pc, #788]	; 102d53ec <FIRMWARE_Update+0x3f8>
102d50d4:	e5933000 	ldr	r3, [r3]
102d50d8:	e1550003 	cmp	r5, r3
102d50dc:	1a00009c 	bne	102d5354 <FIRMWARE_Update+0x360>
#endif
		Fota_Fail_Reason_Code = 10;
		return -1;
	}

	ret = fileSys_OpenOrCreateFile((u8 *)File_FotaAppBin);
102d50e0:	e5940000 	ldr	r0, [r4]
102d50e4:	e59f3304 	ldr	r3, [pc, #772]	; 102d53f0 <FIRMWARE_Update+0x3fc>
102d50e8:	e12fff33 	blx	r3
	if(ret < 0)
102d50ec:	e2508000 	subs	r8, r0, #0
102d50f0:	ba0000a1 	blt	102d537c <FIRMWARE_Update+0x388>
		return -1;
	}
	Handle_File = ret; //Get file handle

	//Write App bin to flash
	ret = Ql_FOTA_Init(&FotaConfig); //Initialise the upgrade operation
102d50f4:	e2860fe6 	add	r0, r6, #920	; 0x398
102d50f8:	e59f32f4 	ldr	r3, [pc, #756]	; 102d53f4 <FIRMWARE_Update+0x400>
102d50fc:	e12fff33 	blx	r3
	if(QL_RET_OK !=ret)
102d5100:	e3500000 	cmp	r0, #0
102d5104:	1a000097 	bne	102d5368 <FIRMWARE_Update+0x374>
#endif
		Fota_Fail_Reason_Code = 12;
		return -1;
	}

	while(FileSize > 0)
102d5108:	e3550000 	cmp	r5, #0
102d510c:	0a000025 	beq	102d51a8 <FIRMWARE_Update+0x1b4>
102d5110:	e59fa2e0 	ldr	sl, [pc, #736]	; 102d53f8 <FIRMWARE_Update+0x404>
			Fota_Fail_Reason_Code = 13;
			return -1;
		}

		//Write upgrade data to FOTA Cache region
		ret=Ql_FOTA_WriteData(ReadSize,(s8*)buf);
102d5114:	e59f92e0 	ldr	r9, [pc, #736]	; 102d53fc <FIRMWARE_Update+0x408>
		{
			s_iSizeRem +=ReadSize;
		}
		FileSize -= ReadLen;

		Ql_Sleep(5); //Sleep 5 ms for outputing catcher log!!!
102d5118:	e59fb2e0 	ldr	fp, [pc, #736]	; 102d5400 <FIRMWARE_Update+0x40c>
102d511c:	ea00000b 	b	102d5150 <FIRMWARE_Update+0x15c>
			Fota_Fail_Reason_Code = 13;
			return -1;
		}

		//Write upgrade data to FOTA Cache region
		ret=Ql_FOTA_WriteData(ReadSize,(s8*)buf);
102d5120:	e12fff39 	blx	r9

		if(QL_RET_OK != ret)
102d5124:	e3500000 	cmp	r0, #0
		{
			s_iSizeRem +=ReadSize;
		}
		FileSize -= ReadLen;

		Ql_Sleep(5); //Sleep 5 ms for outputing catcher log!!!
102d5128:	e3a00005 	mov	r0, #5
		}

		//Write upgrade data to FOTA Cache region
		ret=Ql_FOTA_WriteData(ReadSize,(s8*)buf);

		if(QL_RET_OK != ret)
102d512c:	1a000083 	bne	102d5340 <FIRMWARE_Update+0x34c>
#endif
			Fota_Fail_Reason_Code = 14;
			return -1;
		}else
		{
			s_iSizeRem +=ReadSize;
102d5130:	e59633a8 	ldr	r3, [r6, #936]	; 0x3a8
102d5134:	e0834004 	add	r4, r3, r4
		}
		FileSize -= ReadLen;
102d5138:	e59d3004 	ldr	r3, [sp, #4]
#endif
			Fota_Fail_Reason_Code = 14;
			return -1;
		}else
		{
			s_iSizeRem +=ReadSize;
102d513c:	e58643a8 	str	r4, [r6, #936]	; 0x3a8
		}
		FileSize -= ReadLen;
102d5140:	e0635005 	rsb	r5, r3, r5

		Ql_Sleep(5); //Sleep 5 ms for outputing catcher log!!!
102d5144:	e12fff3b 	blx	fp
#endif
		Fota_Fail_Reason_Code = 12;
		return -1;
	}

	while(FileSize > 0)
102d5148:	e3550000 	cmp	r5, #0
102d514c:	da000015 	ble	102d51a8 <FIRMWARE_Update+0x1b4>
102d5150:	e3550c02 	cmp	r5, #512	; 0x200
102d5154:	b1a04005 	movlt	r4, r5
102d5158:	a3a04c02 	movge	r4, #512	; 0x200
	{
		Ql_memset(buf, 0, sizeof(buf));
102d515c:	e3a01000 	mov	r1, #0
102d5160:	e3a02c02 	mov	r2, #512	; 0x200
102d5164:	e28d0008 	add	r0, sp, #8
102d5168:	e12fff37 	blx	r7
		else
		{
			ReadSize = READ_SIZE;
		}

		ret = Ql_FS_Read(Handle_File, (u8 *)buf, ReadSize, (u32 *)&ReadLen); //read upgrade data from file system
102d516c:	e28d1008 	add	r1, sp, #8
102d5170:	e1a02004 	mov	r2, r4
102d5174:	e28d3004 	add	r3, sp, #4
102d5178:	e1a00008 	mov	r0, r8
102d517c:	e12fff3a 	blx	sl
			Fota_Fail_Reason_Code = 13;
			return -1;
		}

		//Write upgrade data to FOTA Cache region
		ret=Ql_FOTA_WriteData(ReadSize,(s8*)buf);
102d5180:	e28d1008 	add	r1, sp, #8
		{
			ReadSize = READ_SIZE;
		}

		ret = Ql_FS_Read(Handle_File, (u8 *)buf, ReadSize, (u32 *)&ReadLen); //read upgrade data from file system
		if(QL_RET_OK != ret)
102d5184:	e3500000 	cmp	r0, #0
			Fota_Fail_Reason_Code = 13;
			return -1;
		}

		//Write upgrade data to FOTA Cache region
		ret=Ql_FOTA_WriteData(ReadSize,(s8*)buf);
102d5188:	e1a00004 	mov	r0, r4
		{
			ReadSize = READ_SIZE;
		}

		ret = Ql_FS_Read(Handle_File, (u8 *)buf, ReadSize, (u32 *)&ReadLen); //read upgrade data from file system
		if(QL_RET_OK != ret)
102d518c:	0affffe3 	beq	102d5120 <FIRMWARE_Update+0x12c>
		{
#ifdef FOTA_MSG
			APP_DEBUG("\r\n<-- ERROR : FOTA File Read Failed (ret = %x) -->\r\n", ret);
#endif
			Fota_Fail_Reason_Code = 13;
102d5190:	e59f326c 	ldr	r3, [pc, #620]	; 102d5404 <FIRMWARE_Update+0x410>
102d5194:	e3a0200d 	mov	r2, #13
			return -1;
102d5198:	e3e00000 	mvn	r0, #0
		if(QL_RET_OK != ret)
		{
#ifdef FOTA_MSG
			APP_DEBUG("\r\n<-- ERROR : FOTA File Read Failed (ret = %x) -->\r\n", ret);
#endif
			Fota_Fail_Reason_Code = 13;
102d519c:	e5c32000 	strb	r2, [r3]
			return -1;
		}
		return 0;
	}

}
102d51a0:	e28ddf83 	add	sp, sp, #524	; 0x20c
102d51a4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		FileSize -= ReadLen;

		Ql_Sleep(5); //Sleep 5 ms for outputing catcher log!!!
	}
	Ql_FS_Close(Handle_File);
102d51a8:	e1a00008 	mov	r0, r8
102d51ac:	e59f3254 	ldr	r3, [pc, #596]	; 102d5408 <FIRMWARE_Update+0x414>
102d51b0:	e12fff33 	blx	r3

	ret = Ql_FOTA_Finish(); //Finish the upgrade operation ending with calling this API
102d51b4:	e59f3250 	ldr	r3, [pc, #592]	; 102d540c <FIRMWARE_Update+0x418>
102d51b8:	e12fff33 	blx	r3

	if(QL_RET_OK != ret)//added for testing purpuse
102d51bc:	e2504000 	subs	r4, r0, #0
102d51c0:	1a000072 	bne	102d5390 <FIRMWARE_Update+0x39c>
		return -1;
	}
	else
	{
#ifdef DEBUG_MSG
		APP_DEBUG("\r\n<-- SUCCESS : UPLOADING FOTA File to Core -->\r\n");
102d51c4:	e3a02c02 	mov	r2, #512	; 0x200
102d51c8:	e1a01004 	mov	r1, r4
102d51cc:	e59f01e4 	ldr	r0, [pc, #484]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d51d0:	e12fff37 	blx	r7
102d51d4:	e59f21e4 	ldr	r2, [pc, #484]	; 102d53c0 <FIRMWARE_Update+0x3cc>
102d51d8:	e59f1230 	ldr	r1, [pc, #560]	; 102d5410 <FIRMWARE_Update+0x41c>
102d51dc:	e5923000 	ldr	r3, [r2]
102d51e0:	e59f01d0 	ldr	r0, [pc, #464]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d51e4:	e12fff33 	blx	r3
102d51e8:	e59f31d8 	ldr	r3, [pc, #472]	; 102d53c8 <FIRMWARE_Update+0x3d4>
102d51ec:	e59f01c4 	ldr	r0, [pc, #452]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d51f0:	e12fff33 	blx	r3
102d51f4:	e59f31d0 	ldr	r3, [pc, #464]	; 102d53cc <FIRMWARE_Update+0x3d8>
102d51f8:	e59f11b8 	ldr	r1, [pc, #440]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d51fc:	e1a02000 	mov	r2, r0
102d5200:	e3a0000a 	mov	r0, #10
102d5204:	e12fff33 	blx	r3
		APP_DEBUG("\r\n<-- TWIN FOTA Status : Update Success !!! -->\r\n");
102d5208:	e3a02c02 	mov	r2, #512	; 0x200
102d520c:	e1a01004 	mov	r1, r4
102d5210:	e59f01a0 	ldr	r0, [pc, #416]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d5214:	e12fff37 	blx	r7
102d5218:	e59f21a0 	ldr	r2, [pc, #416]	; 102d53c0 <FIRMWARE_Update+0x3cc>
102d521c:	e59f11f0 	ldr	r1, [pc, #496]	; 102d5414 <FIRMWARE_Update+0x420>
102d5220:	e5923000 	ldr	r3, [r2]
102d5224:	e59f018c 	ldr	r0, [pc, #396]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d5228:	e12fff33 	blx	r3
102d522c:	e59f3194 	ldr	r3, [pc, #404]	; 102d53c8 <FIRMWARE_Update+0x3d4>
102d5230:	e59f0180 	ldr	r0, [pc, #384]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d5234:	e12fff33 	blx	r3
102d5238:	e59f318c 	ldr	r3, [pc, #396]	; 102d53cc <FIRMWARE_Update+0x3d8>
102d523c:	e59f1174 	ldr	r1, [pc, #372]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d5240:	e1a02000 	mov	r2, r0
102d5244:	e3a0000a 	mov	r0, #10
102d5248:	e12fff33 	blx	r3
#endif
		Ql_strcpy(RP_FW_Upgrade_status,"4");// Report "Update Success"
102d524c:	e59f11c4 	ldr	r1, [pc, #452]	; 102d5418 <FIRMWARE_Update+0x424>
102d5250:	e59f2180 	ldr	r2, [pc, #384]	; 102d53d8 <FIRMWARE_Update+0x3e4>
102d5254:	e59f0180 	ldr	r0, [pc, #384]	; 102d53dc <FIRMWARE_Update+0x3e8>
102d5258:	e12fff32 	blx	r2
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d525c:	e59f217c 	ldr	r2, [pc, #380]	; 102d53e0 <FIRMWARE_Update+0x3ec>
		publish_data(MQTT_TWIN_REPORTED);
102d5260:	e3a00041 	mov	r0, #65	; 0x41
#ifdef DEBUG_MSG
		APP_DEBUG("\r\n<-- SUCCESS : UPLOADING FOTA File to Core -->\r\n");
		APP_DEBUG("\r\n<-- TWIN FOTA Status : Update Success !!! -->\r\n");
#endif
		Ql_strcpy(RP_FW_Upgrade_status,"4");// Report "Update Success"
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d5264:	e5923000 	ldr	r3, [r2]
102d5268:	e3833c01 	orr	r3, r3, #256	; 0x100
102d526c:	e5823000 	str	r3, [r2]
		publish_data(MQTT_TWIN_REPORTED);
102d5270:	e59f316c 	ldr	r3, [pc, #364]	; 102d53e4 <FIRMWARE_Update+0x3f0>
102d5274:	e12fff33 	blx	r3
		//Force Backup at Control module
		configuration_Data_Write[CONFIG_DATA0] = 0x76;
102d5278:	e59f319c 	ldr	r3, [pc, #412]	; 102d541c <FIRMWARE_Update+0x428>
102d527c:	e3a02076 	mov	r2, #118	; 0x76
102d5280:	e5c32001 	strb	r2, [r3, #1]
		configuration_Data_Write[CONFIG_DATA1] = 0xC0;
102d5284:	e3e0203f 	mvn	r2, #63	; 0x3f
102d5288:	e5c32002 	strb	r2, [r3, #2]
		Send_IPC_Command(PID_INITIATE_POWER_CYCLE);
102d528c:	e3a0000d 	mov	r0, #13
102d5290:	e59f3188 	ldr	r3, [pc, #392]	; 102d5420 <FIRMWARE_Update+0x42c>
102d5294:	e12fff33 	blx	r3
		display_on_tftlcd(TFT_STATE_FOTA_SUCCESS);	//Display "SUCCESS" on LCD when Fota file downloading is Success.
102d5298:	e3a00027 	mov	r0, #39	; 0x27
102d529c:	e59f3180 	ldr	r3, [pc, #384]	; 102d5424 <FIRMWARE_Update+0x430>
102d52a0:	e12fff33 	blx	r3
		Ql_Sleep(2000); //Added delay to enable con module process the backup request.
102d52a4:	e59f3154 	ldr	r3, [pc, #340]	; 102d5400 <FIRMWARE_Update+0x40c>
102d52a8:	e3a00e7d 	mov	r0, #2000	; 0x7d0
102d52ac:	e12fff33 	blx	r3

#ifdef DEBUG_MSG
		APP_DEBUG("\r\n<-- TWIN FOTA Status : Update Success & rebooting!!! -->\r\n");
102d52b0:	e3a02c02 	mov	r2, #512	; 0x200
102d52b4:	e1a01004 	mov	r1, r4
102d52b8:	e59f00f8 	ldr	r0, [pc, #248]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d52bc:	e12fff37 	blx	r7
102d52c0:	e59f20f8 	ldr	r2, [pc, #248]	; 102d53c0 <FIRMWARE_Update+0x3cc>
102d52c4:	e59f115c 	ldr	r1, [pc, #348]	; 102d5428 <FIRMWARE_Update+0x434>
102d52c8:	e5923000 	ldr	r3, [r2]
102d52cc:	e59f00e4 	ldr	r0, [pc, #228]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d52d0:	e12fff33 	blx	r3
102d52d4:	e59f30ec 	ldr	r3, [pc, #236]	; 102d53c8 <FIRMWARE_Update+0x3d4>
102d52d8:	e59f00d8 	ldr	r0, [pc, #216]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d52dc:	e12fff33 	blx	r3
102d52e0:	e59f30e4 	ldr	r3, [pc, #228]	; 102d53cc <FIRMWARE_Update+0x3d8>
102d52e4:	e59f10cc 	ldr	r1, [pc, #204]	; 102d53b8 <FIRMWARE_Update+0x3c4>
102d52e8:	e1a02000 	mov	r2, r0
102d52ec:	e3a0000a 	mov	r0, #10
102d52f0:	e12fff33 	blx	r3
#endif
		Ql_strcpy(RP_FW_Upgrade_status,"6");// Report "update success and rebooting"
102d52f4:	e59f1130 	ldr	r1, [pc, #304]	; 102d542c <FIRMWARE_Update+0x438>
102d52f8:	e59f20d8 	ldr	r2, [pc, #216]	; 102d53d8 <FIRMWARE_Update+0x3e4>
102d52fc:	e59f00d8 	ldr	r0, [pc, #216]	; 102d53dc <FIRMWARE_Update+0x3e8>
102d5300:	e12fff32 	blx	r2
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d5304:	e59f20d4 	ldr	r2, [pc, #212]	; 102d53e0 <FIRMWARE_Update+0x3ec>
		publish_data(MQTT_TWIN_REPORTED);
102d5308:	e3a00041 	mov	r0, #65	; 0x41

#ifdef DEBUG_MSG
		APP_DEBUG("\r\n<-- TWIN FOTA Status : Update Success & rebooting!!! -->\r\n");
#endif
		Ql_strcpy(RP_FW_Upgrade_status,"6");// Report "update success and rebooting"
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d530c:	e5923000 	ldr	r3, [r2]
102d5310:	e3833c01 	orr	r3, r3, #256	; 0x100
102d5314:	e5823000 	str	r3, [r2]
		publish_data(MQTT_TWIN_REPORTED);
102d5318:	e59f30c4 	ldr	r3, [pc, #196]	; 102d53e4 <FIRMWARE_Update+0x3f0>
102d531c:	e12fff33 	blx	r3
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- SUCCESS : FOTA File Finish SUCCESS  (ret = %x) -->\r\n", ret);
		APP_DEBUG("\r\n<-- MODULE WILL RESTART AUTOMATICALLY ON SUCCESS -->\r\n");
#endif
		ret = Ql_FOTA_Update(); //Update flag fields in the FOTA Cache.If this function successes then it RESTARTS device automatically.
102d5320:	e59f3108 	ldr	r3, [pc, #264]	; 102d5430 <FIRMWARE_Update+0x43c>
102d5324:	e12fff33 	blx	r3
		
		//Code below will not execute if FOTA is successfull!!!  Module will restart..
		//code will come back to this line only if FOTA update fails..
		if(QL_RET_OK != ret) //If this function succeeds, the module will automatically restart
102d5328:	e3500000 	cmp	r0, #0
		{
#ifdef FOTA_MSG
			APP_DEBUG("\r\n<-- ERROR : FOTA UPDATE FAILED (ret = %d) -->\r\n", ret);
#endif
			Fota_Fail_Reason_Code = 16;
102d532c:	159f30d0 	ldrne	r3, [pc, #208]	; 102d5404 <FIRMWARE_Update+0x410>
102d5330:	13a02010 	movne	r2, #16
102d5334:	15c32000 	strbne	r2, [r3]
			return -1;
102d5338:	13e00000 	mvnne	r0, #0
102d533c:	eaffff97 	b	102d51a0 <FIRMWARE_Update+0x1ac>
		if(QL_RET_OK != ret)
		{
#ifdef FOTA_MSG
			APP_DEBUG("\r\n<-- ERROR : FOTA File Write Failed (ret = %d) -->\r\n", ret);
#endif
			Fota_Fail_Reason_Code = 14;
102d5340:	e59f30bc 	ldr	r3, [pc, #188]	; 102d5404 <FIRMWARE_Update+0x410>
102d5344:	e3a0200e 	mov	r2, #14
102d5348:	e5c32000 	strb	r2, [r3]
			return -1;
102d534c:	e3e00000 	mvn	r0, #0
102d5350:	eaffff92 	b	102d51a0 <FIRMWARE_Update+0x1ac>
	if(total_size != FileSize)	//Comapare Downloaded File size with new Final downloaded file size , if mismatch then there is Error.Fota Success but it restarts with Previous Firmware(FOTA failure)
	{
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- ERROR : Downloaded file size is mismatch  -->\r\n");
#endif
		Fota_Fail_Reason_Code = 10;
102d5354:	e59f30a8 	ldr	r3, [pc, #168]	; 102d5404 <FIRMWARE_Update+0x410>
102d5358:	e3a0200a 	mov	r2, #10
102d535c:	e5c32000 	strb	r2, [r3]
		return -1;
102d5360:	e3e00000 	mvn	r0, #0
102d5364:	eaffff8d 	b	102d51a0 <FIRMWARE_Update+0x1ac>
	if(QL_RET_OK !=ret)
	{
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- ERROR : FOTA INIT -->\r\n");
#endif
		Fota_Fail_Reason_Code = 12;
102d5368:	e59f3094 	ldr	r3, [pc, #148]	; 102d5404 <FIRMWARE_Update+0x410>
102d536c:	e3a0200c 	mov	r2, #12
102d5370:	e5c32000 	strb	r2, [r3]
		return -1;
102d5374:	e3e00000 	mvn	r0, #0
102d5378:	eaffff88 	b	102d51a0 <FIRMWARE_Update+0x1ac>
	{
		//Open file failed.
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- ERROR : File Open/Create : %s -->\r\n", filePath);
#endif
		Fota_Fail_Reason_Code = 11;
102d537c:	e59f3080 	ldr	r3, [pc, #128]	; 102d5404 <FIRMWARE_Update+0x410>
102d5380:	e3a0200b 	mov	r2, #11
102d5384:	e5c32000 	strb	r2, [r3]
		return -1;
102d5388:	e3e00000 	mvn	r0, #0
102d538c:	eaffff83 	b	102d51a0 <FIRMWARE_Update+0x1ac>
	if(QL_RET_OK != ret)//added for testing purpuse
	{
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- ERROR : FOTA File Finish -->\r\n");//added for testing purpuse
#endif
		Fota_Fail_Reason_Code = 15;
102d5390:	e59f306c 	ldr	r3, [pc, #108]	; 102d5404 <FIRMWARE_Update+0x410>
102d5394:	e3a0200f 	mov	r2, #15
102d5398:	e5c32000 	strb	r2, [r3]
		return -1;
102d539c:	e3e00000 	mvn	r0, #0
102d53a0:	eaffff7e 	b	102d51a0 <FIRMWARE_Update+0x1ac>
	{
		//The file does not exist
#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- FOTA File (%s) Not Present (ret = %d) -->\r\n", File_FotaAppBin, ret);
#endif
		Fota_Fail_Reason_Code = 9;
102d53a4:	e59f3058 	ldr	r3, [pc, #88]	; 102d5404 <FIRMWARE_Update+0x410>
102d53a8:	e3a02009 	mov	r2, #9
102d53ac:	e5c32000 	strb	r2, [r3]
		return -1;
102d53b0:	e3e00000 	mvn	r0, #0
102d53b4:	eaffff79 	b	102d51a0 <FIRMWARE_Update+0x1ac>
102d53b8:	f03d5e68 	.word	0xf03d5e68
102d53bc:	102e58f4 	.word	0x102e58f4
102d53c0:	f03de540 	.word	0xf03de540
102d53c4:	102ef558 	.word	0x102ef558
102d53c8:	102e57a4 	.word	0x102e57a4
102d53cc:	102e6230 	.word	0x102e6230
102d53d0:	f03d20b0 	.word	0xf03d20b0
102d53d4:	102ef590 	.word	0x102ef590
102d53d8:	102e55fc 	.word	0x102e55fc
102d53dc:	f03d5ba4 	.word	0xf03d5ba4
102d53e0:	f03d5aa0 	.word	0xf03d5aa0
102d53e4:	102df20c 	.word	0x102df20c
102d53e8:	102d3014 	.word	0x102d3014
102d53ec:	f03de52c 	.word	0xf03de52c
102d53f0:	102d2e00 	.word	0x102d2e00
102d53f4:	102e45e8 	.word	0x102e45e8
102d53f8:	102e40b8 	.word	0x102e40b8
102d53fc:	102e4648 	.word	0x102e4648
102d5400:	102e5b10 	.word	0x102e5b10
102d5404:	f03de528 	.word	0xf03de528
102d5408:	102e426c 	.word	0x102e426c
102d540c:	102e46b0 	.word	0x102e46b0
102d5410:	102ef594 	.word	0x102ef594
102d5414:	102ef5c8 	.word	0x102ef5c8
102d5418:	102eeb30 	.word	0x102eeb30
102d541c:	f03de538 	.word	0xf03de538
102d5420:	102dd394 	.word	0x102dd394
102d5424:	102da2a0 	.word	0x102da2a0
102d5428:	102ef5fc 	.word	0x102ef5fc
102d542c:	102eee6c 	.word	0x102eee6c
102d5430:	102e4708 	.word	0x102e4708

102d5434 <FOTA_INIT>:
	}

}

s32 FOTA_INIT()
{
102d5434:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s32 ret = -1;
	Fota_Fail_Reason_Code =0;
102d5438:	e3a03000 	mov	r3, #0
102d543c:	e59fa278 	ldr	sl, [pc, #632]	; 102d56bc <FOTA_INIT+0x288>
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- FOTA INITIATED !!! -->\r\n");
102d5440:	e59f5278 	ldr	r5, [pc, #632]	; 102d56c0 <FOTA_INIT+0x28c>
	}

}

s32 FOTA_INIT()
{
102d5444:	e24dd00c 	sub	sp, sp, #12
	s32 ret = -1;
	Fota_Fail_Reason_Code =0;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- FOTA INITIATED !!! -->\r\n");
102d5448:	e3a02c02 	mov	r2, #512	; 0x200
102d544c:	e1a01003 	mov	r1, r3
102d5450:	e59f026c 	ldr	r0, [pc, #620]	; 102d56c4 <FOTA_INIT+0x290>
102d5454:	e59f726c 	ldr	r7, [pc, #620]	; 102d56c8 <FOTA_INIT+0x294>
}

s32 FOTA_INIT()
{
	s32 ret = -1;
	Fota_Fail_Reason_Code =0;
102d5458:	e5ca3000 	strb	r3, [sl]
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- FOTA INITIATED !!! -->\r\n");
102d545c:	e12fff37 	blx	r7
102d5460:	e5953000 	ldr	r3, [r5]
102d5464:	e59f1260 	ldr	r1, [pc, #608]	; 102d56cc <FOTA_INIT+0x298>
102d5468:	e59f0254 	ldr	r0, [pc, #596]	; 102d56c4 <FOTA_INIT+0x290>
102d546c:	e12fff33 	blx	r3
102d5470:	e59f6258 	ldr	r6, [pc, #600]	; 102d56d0 <FOTA_INIT+0x29c>
102d5474:	e59f0248 	ldr	r0, [pc, #584]	; 102d56c4 <FOTA_INIT+0x290>
102d5478:	e12fff36 	blx	r6
102d547c:	e59f8250 	ldr	r8, [pc, #592]	; 102d56d4 <FOTA_INIT+0x2a0>
102d5480:	e59f123c 	ldr	r1, [pc, #572]	; 102d56c4 <FOTA_INIT+0x290>
#endif

	FLAG.SUSPEND_IPC_COMMUNICATION = TRUE;
102d5484:	e59f924c 	ldr	r9, [pc, #588]	; 102d56d8 <FOTA_INIT+0x2a4>
	Store_Persistent_Data();
	Write_Error_Messages();
	//Check FOTA.bin File is present or not: If present then delete file and check free space
	ret = fileSys_checkFile((u8*)File_FotaAppBin);		//To Check file FOTA.bin is available or not
102d5488:	e59f424c 	ldr	r4, [pc, #588]	; 102d56dc <FOTA_INIT+0x2a8>
s32 FOTA_INIT()
{
	s32 ret = -1;
	Fota_Fail_Reason_Code =0;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- FOTA INITIATED !!! -->\r\n");
102d548c:	e1a02000 	mov	r2, r0
102d5490:	e3a0000a 	mov	r0, #10
102d5494:	e12fff38 	blx	r8
#endif

	FLAG.SUSPEND_IPC_COMMUNICATION = TRUE;
102d5498:	e3a03001 	mov	r3, #1
102d549c:	e5c9301d 	strb	r3, [r9, #29]
	Store_Persistent_Data();
102d54a0:	e59f3238 	ldr	r3, [pc, #568]	; 102d56e0 <FOTA_INIT+0x2ac>
102d54a4:	e12fff33 	blx	r3
	Write_Error_Messages();
102d54a8:	e59f3234 	ldr	r3, [pc, #564]	; 102d56e4 <FOTA_INIT+0x2b0>
102d54ac:	e12fff33 	blx	r3
	//Check FOTA.bin File is present or not: If present then delete file and check free space
	ret = fileSys_checkFile((u8*)File_FotaAppBin);		//To Check file FOTA.bin is available or not
102d54b0:	e5940000 	ldr	r0, [r4]
102d54b4:	e59f322c 	ldr	r3, [pc, #556]	; 102d56e8 <FOTA_INIT+0x2b4>
102d54b8:	e12fff33 	blx	r3
	if(ret == QL_RET_OK)		//If FOTA.bin file is available then delete file
102d54bc:	e3500000 	cmp	r0, #0
102d54c0:	1a000006 	bne	102d54e0 <FOTA_INIT+0xac>
	{
		ret = fileSys_deleteFile((u8*)File_FotaAppBin);		//Delete FOTA.bin file
102d54c4:	e59f3220 	ldr	r3, [pc, #544]	; 102d56ec <FOTA_INIT+0x2b8>
102d54c8:	e5940000 	ldr	r0, [r4]
102d54cc:	e12fff33 	blx	r3
		if(ret < 0)
102d54d0:	e2503000 	subs	r3, r0, #0
		{
#ifdef FOTA_MSG
			APP_DEBUG("<-- ERROR : Deleting Existing FOTA File (%s), (ret = %d) -->\r\n", File_FotaAppBin, ret);
#endif
			Fota_Fail_Reason_Code = 2;
102d54d4:	b3a02002 	movlt	r2, #2
102d54d8:	b5ca2000 	strblt	r2, [sl]
	//Check FOTA.bin File is present or not: If present then delete file and check free space
	ret = fileSys_checkFile((u8*)File_FotaAppBin);		//To Check file FOTA.bin is available or not
	if(ret == QL_RET_OK)		//If FOTA.bin file is available then delete file
	{
		ret = fileSys_deleteFile((u8*)File_FotaAppBin);		//Delete FOTA.bin file
		if(ret < 0)
102d54dc:	ba00004c 	blt	102d5614 <FOTA_INIT+0x1e0>
	}
#ifdef FOTA_MSG
	APP_DEBUG("<-- Memory Free Space  : %lld Byte's -->\r\n",Ql_FS_GetFreeSpace(storage));		//Print free space debug message on screen
#endif
	//Display "UPDATING..." on LCD when FOTA is Initiated.
	Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_FOTA_UPDATE);
102d54e0:	e59fc208 	ldr	ip, [pc, #520]	; 102d56f0 <FOTA_INIT+0x2bc>
102d54e4:	e3a03025 	mov	r3, #37	; 0x25
102d54e8:	e59f1204 	ldr	r1, [pc, #516]	; 102d56f4 <FOTA_INIT+0x2c0>
102d54ec:	e3a02002 	mov	r2, #2
102d54f0:	e3a00003 	mov	r0, #3
102d54f4:	e12fff3c 	blx	ip

	//Report to twin properties
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Updating !!! -->\r\n");
102d54f8:	e3a02c02 	mov	r2, #512	; 0x200
102d54fc:	e3a01000 	mov	r1, #0
102d5500:	e59f01bc 	ldr	r0, [pc, #444]	; 102d56c4 <FOTA_INIT+0x290>
102d5504:	e12fff37 	blx	r7
102d5508:	e5953000 	ldr	r3, [r5]
102d550c:	e59f11e4 	ldr	r1, [pc, #484]	; 102d56f8 <FOTA_INIT+0x2c4>
102d5510:	e59f01ac 	ldr	r0, [pc, #428]	; 102d56c4 <FOTA_INIT+0x290>
102d5514:	e12fff33 	blx	r3
102d5518:	e59f01a4 	ldr	r0, [pc, #420]	; 102d56c4 <FOTA_INIT+0x290>
102d551c:	e12fff36 	blx	r6
#endif
	Ql_strcpy(RP_FW_Upgrade_status,"1");// Report "Downloading"
	Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d5520:	e59f41d4 	ldr	r4, [pc, #468]	; 102d56fc <FOTA_INIT+0x2c8>
	//Display "UPDATING..." on LCD when FOTA is Initiated.
	Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_FOTA_UPDATE);

	//Report to twin properties
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Updating !!! -->\r\n");
102d5524:	e59f1198 	ldr	r1, [pc, #408]	; 102d56c4 <FOTA_INIT+0x290>
#endif
	Ql_strcpy(RP_FW_Upgrade_status,"1");// Report "Downloading"
102d5528:	e59fb1d0 	ldr	fp, [pc, #464]	; 102d5700 <FOTA_INIT+0x2cc>
	//Display "UPDATING..." on LCD when FOTA is Initiated.
	Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_FOTA_UPDATE);

	//Report to twin properties
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Updating !!! -->\r\n");
102d552c:	e1a02000 	mov	r2, r0
102d5530:	e3a0000a 	mov	r0, #10
102d5534:	e12fff38 	blx	r8
#endif
	Ql_strcpy(RP_FW_Upgrade_status,"1");// Report "Downloading"
102d5538:	e59f11c4 	ldr	r1, [pc, #452]	; 102d5704 <FOTA_INIT+0x2d0>
102d553c:	e59f01c4 	ldr	r0, [pc, #452]	; 102d5708 <FOTA_INIT+0x2d4>
102d5540:	e12fff3b 	blx	fp
	Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d5544:	e5943000 	ldr	r3, [r4]
	publish_data(MQTT_TWIN_REPORTED);
102d5548:	e59f21bc 	ldr	r2, [pc, #444]	; 102d570c <FOTA_INIT+0x2d8>
	//Report to twin properties
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Updating !!! -->\r\n");
#endif
	Ql_strcpy(RP_FW_Upgrade_status,"1");// Report "Downloading"
	Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d554c:	e3833c01 	orr	r3, r3, #256	; 0x100
	publish_data(MQTT_TWIN_REPORTED);
102d5550:	e3a00041 	mov	r0, #65	; 0x41
	//Report to twin properties
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Updating !!! -->\r\n");
#endif
	Ql_strcpy(RP_FW_Upgrade_status,"1");// Report "Downloading"
	Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d5554:	e5843000 	str	r3, [r4]
	publish_data(MQTT_TWIN_REPORTED);
102d5558:	e12fff32 	blx	r2

	// Confugure for HTTPS
	ret = RIL_HTTPS_QSSLCFG();
102d555c:	ebfffe0e 	bl	102d4d9c <RIL_HTTPS_QSSLCFG>
	if(ret < 0)
102d5560:	e2503000 	subs	r3, r0, #0
	{
#ifdef FOTA_MSG
		APP_DEBUG("<-- HTTPS Config Fail ret=%d -->\r\n", ret);
#endif
		Fota_Fail_Reason_Code = 1;
102d5564:	b3a02001 	movlt	r2, #1
102d5568:	b5ca2000 	strblt	r2, [sl]
	Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
	publish_data(MQTT_TWIN_REPORTED);

	// Confugure for HTTPS
	ret = RIL_HTTPS_QSSLCFG();
	if(ret < 0)
102d556c:	ba00002e 	blt	102d562c <FOTA_INIT+0x1f8>
#endif
		Fota_Fail_Reason_Code = 1;
	}
	else
	{
		ret = FIRMWARE_Download();
102d5570:	ebfffe3c 	bl	102d4e68 <FIRMWARE_Download>
		if(ret < 0)
102d5574:	e2503000 	subs	r3, r0, #0
102d5578:	ba00002b 	blt	102d562c <FOTA_INIT+0x1f8>
			APP_DEBUG("\r\n<-- FIRMWARE DOWNLOAD FAIL!!! -->\r\n");
#endif
		}
		else
		{
			if((FLAG.FOTA_FILE_COM_FW_INVALID == TRUE) || (FLAG.FOTA_FILE_CON_FW_INVALID == TRUE))// Check if the FOTA file is of correct parameters..
102d557c:	e5d93021 	ldrb	r3, [r9, #33]	; 0x21
102d5580:	e3530001 	cmp	r3, #1
102d5584:	0a000025 	beq	102d5620 <FOTA_INIT+0x1ec>
102d5588:	e59f3148 	ldr	r3, [pc, #328]	; 102d56d8 <FOTA_INIT+0x2a4>
102d558c:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
102d5590:	e3530001 	cmp	r3, #1
102d5594:	0a000021 	beq	102d5620 <FOTA_INIT+0x1ec>

	// Start Firmware Update.. only if previous operation is SUCCESS
	if(ret >= 0)
	{
#ifdef DEBUG_MSG
		APP_DEBUG("\r\n<-- TWIN FOTA Status : Down load complete !!! -->\r\n");
102d5598:	e3a02c02 	mov	r2, #512	; 0x200
102d559c:	e3a01000 	mov	r1, #0
102d55a0:	e59f3120 	ldr	r3, [pc, #288]	; 102d56c8 <FOTA_INIT+0x294>
102d55a4:	e59f0118 	ldr	r0, [pc, #280]	; 102d56c4 <FOTA_INIT+0x290>
102d55a8:	e12fff33 	blx	r3
102d55ac:	e59f310c 	ldr	r3, [pc, #268]	; 102d56c0 <FOTA_INIT+0x28c>
102d55b0:	e59f1158 	ldr	r1, [pc, #344]	; 102d5710 <FOTA_INIT+0x2dc>
102d55b4:	e5933000 	ldr	r3, [r3]
102d55b8:	e59f0104 	ldr	r0, [pc, #260]	; 102d56c4 <FOTA_INIT+0x290>
102d55bc:	e12fff33 	blx	r3
102d55c0:	e59f3108 	ldr	r3, [pc, #264]	; 102d56d0 <FOTA_INIT+0x29c>
102d55c4:	e59f00f8 	ldr	r0, [pc, #248]	; 102d56c4 <FOTA_INIT+0x290>
102d55c8:	e12fff33 	blx	r3
102d55cc:	e59f3100 	ldr	r3, [pc, #256]	; 102d56d4 <FOTA_INIT+0x2a0>
102d55d0:	e59f10ec 	ldr	r1, [pc, #236]	; 102d56c4 <FOTA_INIT+0x290>
102d55d4:	e1a02000 	mov	r2, r0
102d55d8:	e3a0000a 	mov	r0, #10
102d55dc:	e12fff33 	blx	r3
#endif
		Ql_strcpy(RP_FW_Upgrade_status,"2");// Report "Download complete"
102d55e0:	e59f112c 	ldr	r1, [pc, #300]	; 102d5714 <FOTA_INIT+0x2e0>
102d55e4:	e59f011c 	ldr	r0, [pc, #284]	; 102d5708 <FOTA_INIT+0x2d4>
102d55e8:	e12fff3b 	blx	fp
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d55ec:	e5943000 	ldr	r3, [r4]
		publish_data(MQTT_TWIN_REPORTED);
102d55f0:	e3a00041 	mov	r0, #65	; 0x41
	{
#ifdef DEBUG_MSG
		APP_DEBUG("\r\n<-- TWIN FOTA Status : Down load complete !!! -->\r\n");
#endif
		Ql_strcpy(RP_FW_Upgrade_status,"2");// Report "Download complete"
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d55f4:	e3833c01 	orr	r3, r3, #256	; 0x100
102d55f8:	e5843000 	str	r3, [r4]
		publish_data(MQTT_TWIN_REPORTED);
102d55fc:	e59f3108 	ldr	r3, [pc, #264]	; 102d570c <FOTA_INIT+0x2d8>
102d5600:	e12fff33 	blx	r3

		ret = FIRMWARE_Update();
102d5604:	ebfffe7a 	bl	102d4ff4 <FIRMWARE_Update>
#endif

		}
	}
	//Send final response return from this function
	if(ret < 0)
102d5608:	e2503000 	subs	r3, r0, #0
102d560c:	ba000006 	blt	102d562c <FOTA_INIT+0x1f8>
		return ret;
	}
	else
	{

		return 0;
102d5610:	e3a03000 	mov	r3, #0
	}

}
102d5614:	e1a00003 	mov	r0, r3
102d5618:	e28dd00c 	add	sp, sp, #12
102d561c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		else
		{
			if((FLAG.FOTA_FILE_COM_FW_INVALID == TRUE) || (FLAG.FOTA_FILE_CON_FW_INVALID == TRUE))// Check if the FOTA file is of correct parameters..
			{
				Fota_Fail_Reason_Code = 3;
102d5620:	e3a02003 	mov	r2, #3
				ret = -1;
102d5624:	e3e03000 	mvn	r3, #0
		}
		else
		{
			if((FLAG.FOTA_FILE_COM_FW_INVALID == TRUE) || (FLAG.FOTA_FILE_CON_FW_INVALID == TRUE))// Check if the FOTA file is of correct parameters..
			{
				Fota_Fail_Reason_Code = 3;
102d5628:	e5ca2000 	strb	r2, [sl]
	}
	//Send final response return from this function
	if(ret < 0)
	{
#ifdef DEBUG_MSG
		APP_DEBUG("\r\n<-- TWIN FOTA Status : Update Failed !!! -->\r\n");
102d562c:	e3a02c02 	mov	r2, #512	; 0x200
102d5630:	e3a01000 	mov	r1, #0
102d5634:	e59f0088 	ldr	r0, [pc, #136]	; 102d56c4 <FOTA_INIT+0x290>
102d5638:	e58d3004 	str	r3, [sp, #4]
102d563c:	e12fff37 	blx	r7
102d5640:	e59f10d0 	ldr	r1, [pc, #208]	; 102d5718 <FOTA_INIT+0x2e4>
102d5644:	e5952000 	ldr	r2, [r5]
102d5648:	e59f0074 	ldr	r0, [pc, #116]	; 102d56c4 <FOTA_INIT+0x290>
102d564c:	e12fff32 	blx	r2
102d5650:	e59f006c 	ldr	r0, [pc, #108]	; 102d56c4 <FOTA_INIT+0x290>
102d5654:	e12fff36 	blx	r6
102d5658:	e59f1064 	ldr	r1, [pc, #100]	; 102d56c4 <FOTA_INIT+0x290>
102d565c:	e1a02000 	mov	r2, r0
102d5660:	e3a0000a 	mov	r0, #10
102d5664:	e12fff38 	blx	r8
#endif
		Ql_strcpy(RP_FW_Upgrade_status,"5");// Report "Download complete"
102d5668:	e59f10ac 	ldr	r1, [pc, #172]	; 102d571c <FOTA_INIT+0x2e8>
102d566c:	e59f0094 	ldr	r0, [pc, #148]	; 102d5708 <FOTA_INIT+0x2d4>
102d5670:	e12fff3b 	blx	fp
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d5674:	e5942000 	ldr	r2, [r4]
		publish_data(MQTT_TWIN_REPORTED);
102d5678:	e3a00041 	mov	r0, #65	; 0x41
	{
#ifdef DEBUG_MSG
		APP_DEBUG("\r\n<-- TWIN FOTA Status : Update Failed !!! -->\r\n");
#endif
		Ql_strcpy(RP_FW_Upgrade_status,"5");// Report "Download complete"
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
102d567c:	e3822c01 	orr	r2, r2, #256	; 0x100
102d5680:	e5842000 	str	r2, [r4]
		publish_data(MQTT_TWIN_REPORTED);
102d5684:	e59f2080 	ldr	r2, [pc, #128]	; 102d570c <FOTA_INIT+0x2d8>
102d5688:	e12fff32 	blx	r2

		display_on_tftlcd(TFT_STATE_FOTA_FAIL);	//Display "FAIL" on LCD when Fota file downloading becomes Failed.
102d568c:	e3a00026 	mov	r0, #38	; 0x26
102d5690:	e59f2088 	ldr	r2, [pc, #136]	; 102d5720 <FOTA_INIT+0x2ec>
102d5694:	e12fff32 	blx	r2
		Ql_Sleep(2000); //Added delay to enable user to read "FAIL" message before device re-start.
102d5698:	e59f2084 	ldr	r2, [pc, #132]	; 102d5724 <FOTA_INIT+0x2f0>
102d569c:	e3a00e7d 	mov	r0, #2000	; 0x7d0
102d56a0:	e12fff32 	blx	r2
		IPC_CMD_REQ_source |= SCHEDULE_POWER_DOWN_WITH_BACKUP;
102d56a4:	e59f207c 	ldr	r2, [pc, #124]	; 102d5728 <FOTA_INIT+0x2f4>
		return ret;
102d56a8:	e59d3004 	ldr	r3, [sp, #4]
		Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
		publish_data(MQTT_TWIN_REPORTED);

		display_on_tftlcd(TFT_STATE_FOTA_FAIL);	//Display "FAIL" on LCD when Fota file downloading becomes Failed.
		Ql_Sleep(2000); //Added delay to enable user to read "FAIL" message before device re-start.
		IPC_CMD_REQ_source |= SCHEDULE_POWER_DOWN_WITH_BACKUP;
102d56ac:	e5921000 	ldr	r1, [r2]
102d56b0:	e3811a01 	orr	r1, r1, #4096	; 0x1000
102d56b4:	e5821000 	str	r1, [r2]
		return ret;
102d56b8:	eaffffd5 	b	102d5614 <FOTA_INIT+0x1e0>
102d56bc:	f03de528 	.word	0xf03de528
102d56c0:	f03de540 	.word	0xf03de540
102d56c4:	f03d5e68 	.word	0xf03d5e68
102d56c8:	102e58f4 	.word	0x102e58f4
102d56cc:	102ef63c 	.word	0x102ef63c
102d56d0:	102e57a4 	.word	0x102e57a4
102d56d4:	102e6230 	.word	0x102e6230
102d56d8:	f03da5f0 	.word	0xf03da5f0
102d56dc:	f03d20b0 	.word	0xf03d20b0
102d56e0:	102d3078 	.word	0x102d3078
102d56e4:	102d4270 	.word	0x102d4270
102d56e8:	102d2f38 	.word	0x102d2f38
102d56ec:	102d2fb0 	.word	0x102d2fb0
102d56f0:	102e5cb4 	.word	0x102e5cb4
102d56f4:	000010c8 	.word	0x000010c8
102d56f8:	102ef65c 	.word	0x102ef65c
102d56fc:	f03d5aa0 	.word	0xf03d5aa0
102d5700:	102e55fc 	.word	0x102e55fc
102d5704:	102ee9e0 	.word	0x102ee9e0
102d5708:	f03d5ba4 	.word	0xf03d5ba4
102d570c:	102df20c 	.word	0x102df20c
102d5710:	102ef6c0 	.word	0x102ef6c0
102d5714:	102eebe0 	.word	0x102eebe0
102d5718:	102ef688 	.word	0x102ef688
102d571c:	102ef6bc 	.word	0x102ef6bc
102d5720:	102da2a0 	.word	0x102da2a0
102d5724:	102e5b10 	.word	0x102e5b10
102d5728:	f03da514 	.word	0xf03da514

102d572c <LICENSE_Download>:




s32 LICENSE_Download()
{
102d572c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102d5730:	e59fb350 	ldr	fp, [pc, #848]	; 102d5a88 <LICENSE_Download+0x35c>
	s32 ret = -1;
	g_rcvdDataLen = 0;
	u8 Fota_Download_retry_count;
	bool FOTA_DOWNLOAD_SUCCESS = FALSE;
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
102d5734:	e59f3350 	ldr	r3, [pc, #848]	; 102d5a8c <LICENSE_Download+0x360>
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
102d5738:	e3a0000a 	mov	r0, #10




s32 LICENSE_Download()
{
102d573c:	e24dd00c 	sub	sp, sp, #12
	s32 ret = -1;
	g_rcvdDataLen = 0;
102d5740:	e59f1348 	ldr	r1, [pc, #840]	; 102d5a90 <LICENSE_Download+0x364>
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
	{
		// Set HTTP server address (URL)
		ret = RIL_HTTP_SetServerURL((char *)HTTP_LICENSE_URL_ADDR, Ql_strlen((char *)HTTP_LICENSE_URL_ADDR));
102d5744:	e59f5348 	ldr	r5, [pc, #840]	; 102d5a94 <LICENSE_Download+0x368>
//#endif
			Fota_Fail_Reason_Code = 4;
			return ret;
		}
//#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS FOTA SET SERVER URL  %s-->\r\n",FOTA_URL);
102d5748:	e59f7348 	ldr	r7, [pc, #840]	; 102d5a98 <LICENSE_Download+0x36c>
{
	s32 ret = -1;
	g_rcvdDataLen = 0;
	u8 Fota_Download_retry_count;
	bool FOTA_DOWNLOAD_SUCCESS = FALSE;
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
102d574c:	e3a02001 	mov	r2, #1
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
102d5750:	e58d0004 	str	r0, [sp, #4]
//#endif
			Fota_Fail_Reason_Code = 4;
			return ret;
		}
//#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS FOTA SET SERVER URL  %s-->\r\n",FOTA_URL);
102d5754:	e1a0600b 	mov	r6, fp


s32 LICENSE_Download()
{
	s32 ret = -1;
	g_rcvdDataLen = 0;
102d5758:	e3a00000 	mov	r0, #0
102d575c:	e5810200 	str	r0, [r1, #512]	; 0x200
	u8 Fota_Download_retry_count;
	bool FOTA_DOWNLOAD_SUCCESS = FALSE;
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
102d5760:	e5c32021 	strb	r2, [r3, #33]	; 0x21
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
102d5764:	e5c32022 	strb	r2, [r3, #34]	; 0x22
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
	{
		// Set HTTP server address (URL)
		ret = RIL_HTTP_SetServerURL((char *)HTTP_LICENSE_URL_ADDR, Ql_strlen((char *)HTTP_LICENSE_URL_ADDR));
102d5768:	e59f2324 	ldr	r2, [pc, #804]	; 102d5a94 <LICENSE_Download+0x368>
102d576c:	e59f0328 	ldr	r0, [pc, #808]	; 102d5a9c <LICENSE_Download+0x370>
102d5770:	e12fff32 	blx	r2
102d5774:	e59f3324 	ldr	r3, [pc, #804]	; 102d5aa0 <LICENSE_Download+0x374>
102d5778:	e1a01800 	lsl	r1, r0, #16
102d577c:	e1a01821 	lsr	r1, r1, #16
102d5780:	e59f0314 	ldr	r0, [pc, #788]	; 102d5a9c <LICENSE_Download+0x370>
102d5784:	e12fff33 	blx	r3
		if(ret < 0)
		{
//#ifdef FOTA_MSG
			APP_DEBUG("<-- ERROR : HTTPS FOTA SET SERVER URL (ret = %d) -->\r\n", ret);
102d5788:	e3a01000 	mov	r1, #0
102d578c:	e3a02c02 	mov	r2, #512	; 0x200
102d5790:	e59f3300 	ldr	r3, [pc, #768]	; 102d5a98 <LICENSE_Download+0x36c>
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
	{
		// Set HTTP server address (URL)
		ret = RIL_HTTP_SetServerURL((char *)HTTP_LICENSE_URL_ADDR, Ql_strlen((char *)HTTP_LICENSE_URL_ADDR));
		if(ret < 0)
102d5794:	e2509000 	subs	r9, r0, #0
		{
//#ifdef FOTA_MSG
			APP_DEBUG("<-- ERROR : HTTPS FOTA SET SERVER URL (ret = %d) -->\r\n", ret);
102d5798:	e59f02f0 	ldr	r0, [pc, #752]	; 102d5a90 <LICENSE_Download+0x364>
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
	{
		// Set HTTP server address (URL)
		ret = RIL_HTTP_SetServerURL((char *)HTTP_LICENSE_URL_ADDR, Ql_strlen((char *)HTTP_LICENSE_URL_ADDR));
		if(ret < 0)
102d579c:	ba000089 	blt	102d59c8 <LICENSE_Download+0x29c>
//#endif
			Fota_Fail_Reason_Code = 4;
			return ret;
		}
//#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS FOTA SET SERVER URL  %s-->\r\n",FOTA_URL);
102d57a0:	e12fff33 	blx	r3
102d57a4:	e59f02e4 	ldr	r0, [pc, #740]	; 102d5a90 <LICENSE_Download+0x364>
102d57a8:	e59f12f4 	ldr	r1, [pc, #756]	; 102d5aa4 <LICENSE_Download+0x378>
102d57ac:	e2802c03 	add	r2, r0, #768	; 0x300
102d57b0:	e59b3000 	ldr	r3, [fp]
102d57b4:	e12fff33 	blx	r3
102d57b8:	e59f02d0 	ldr	r0, [pc, #720]	; 102d5a90 <LICENSE_Download+0x364>
102d57bc:	e12fff35 	blx	r5
102d57c0:	e59f12c8 	ldr	r1, [pc, #712]	; 102d5a90 <LICENSE_Download+0x364>
102d57c4:	e59f32dc 	ldr	r3, [pc, #732]	; 102d5aa8 <LICENSE_Download+0x37c>
102d57c8:	e59f42d8 	ldr	r4, [pc, #728]	; 102d5aa8 <LICENSE_Download+0x37c>
102d57cc:	e1a02000 	mov	r2, r0
102d57d0:	e3a0000a 	mov	r0, #10
102d57d4:	e12fff33 	blx	r3
//#endif
		// Send HTTP GET Request
		ret = RIL_HTTP_RequestToGet(60);
102d57d8:	e3a0003c 	mov	r0, #60	; 0x3c
102d57dc:	e59f32c8 	ldr	r3, [pc, #712]	; 102d5aac <LICENSE_Download+0x380>
102d57e0:	e12fff33 	blx	r3
		if(ret < 0)
102d57e4:	e2509000 	subs	r9, r0, #0
102d57e8:	ba000088 	blt	102d5a10 <LICENSE_Download+0x2e4>
//#endif
			Fota_Fail_Reason_Code = 5;
			return ret;
		}
//#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS GET REQUEST -->\r\n");
102d57ec:	e3a02c02 	mov	r2, #512	; 0x200
102d57f0:	e3a01000 	mov	r1, #0
102d57f4:	e59f0294 	ldr	r0, [pc, #660]	; 102d5a90 <LICENSE_Download+0x364>
102d57f8:	e12fff37 	blx	r7
102d57fc:	e5963000 	ldr	r3, [r6]
102d5800:	e59f12a8 	ldr	r1, [pc, #680]	; 102d5ab0 <LICENSE_Download+0x384>
102d5804:	e59f0284 	ldr	r0, [pc, #644]	; 102d5a90 <LICENSE_Download+0x364>
102d5808:	e12fff33 	blx	r3
102d580c:	e59f027c 	ldr	r0, [pc, #636]	; 102d5a90 <LICENSE_Download+0x364>
102d5810:	e12fff35 	blx	r5
		/*---- Read File From Server ----*/
		// Set Filesystem
		fileSys_SetFileSystem(FALSE);	// False means No filesystem Formate.

		// Create File to store
		ret = fileSys_OpenOrCreateFile((u8 *)File_Licensepem);
102d5814:	e59fa298 	ldr	sl, [pc, #664]	; 102d5ab4 <LICENSE_Download+0x388>
//#endif
			Fota_Fail_Reason_Code = 5;
			return ret;
		}
//#ifdef FOTA_MSG
		APP_DEBUG("<-- SUCCESS : HTTPS GET REQUEST -->\r\n");
102d5818:	e59f1270 	ldr	r1, [pc, #624]	; 102d5a90 <LICENSE_Download+0x364>
102d581c:	e1a02000 	mov	r2, r0
102d5820:	e3a0000a 	mov	r0, #10
102d5824:	e12fff34 	blx	r4
//#endif
		/*---- Read File From Server ----*/
		// Set Filesystem
		fileSys_SetFileSystem(FALSE);	// False means No filesystem Formate.
102d5828:	e59f3288 	ldr	r3, [pc, #648]	; 102d5ab8 <LICENSE_Download+0x38c>
102d582c:	e3a00000 	mov	r0, #0
102d5830:	e12fff33 	blx	r3

		// Create File to store
		ret = fileSys_OpenOrCreateFile((u8 *)File_Licensepem);
102d5834:	e59a0000 	ldr	r0, [sl]
102d5838:	e59f327c 	ldr	r3, [pc, #636]	; 102d5abc <LICENSE_Download+0x390>
102d583c:	e12fff33 	blx	r3
		if(ret < 0)
102d5840:	e2509000 	subs	r9, r0, #0
102d5844:	ba000087 	blt	102d5a68 <LICENSE_Download+0x33c>
#endif
			Fota_Fail_Reason_Code = 6;
			return ret;
		}
//#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- File (%s) Created -->\r\n", File_FotaAppBin);
102d5848:	e3a01000 	mov	r1, #0
102d584c:	e3a02c02 	mov	r2, #512	; 0x200
102d5850:	e59f0238 	ldr	r0, [pc, #568]	; 102d5a90 <LICENSE_Download+0x364>
102d5854:	e12fff37 	blx	r7
102d5858:	e59f3260 	ldr	r3, [pc, #608]	; 102d5ac0 <LICENSE_Download+0x394>
102d585c:	e59f1260 	ldr	r1, [pc, #608]	; 102d5ac4 <LICENSE_Download+0x398>
102d5860:	e5932000 	ldr	r2, [r3]
102d5864:	e59f0224 	ldr	r0, [pc, #548]	; 102d5a90 <LICENSE_Download+0x364>
102d5868:	e5963000 	ldr	r3, [r6]
102d586c:	e12fff33 	blx	r3
102d5870:	e59f0218 	ldr	r0, [pc, #536]	; 102d5a90 <LICENSE_Download+0x364>
102d5874:	e12fff35 	blx	r5
//#endif
		g_Handle_File_LICENSEPEM = ret;//Get file handle (Global Variable)
102d5878:	e59f8248 	ldr	r8, [pc, #584]	; 102d5ac8 <LICENSE_Download+0x39c>
#endif
			Fota_Fail_Reason_Code = 6;
			return ret;
		}
//#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- File (%s) Created -->\r\n", File_FotaAppBin);
102d587c:	e59f120c 	ldr	r1, [pc, #524]	; 102d5a90 <LICENSE_Download+0x364>
102d5880:	e1a02000 	mov	r2, r0
102d5884:	e3a0000a 	mov	r0, #10
102d5888:	e12fff34 	blx	r4
//#endif
		g_Handle_File_LICENSEPEM = ret;//Get file handle (Global Variable)

		// Read HTTP File Data and write to File
//#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- START RECEIVING FOTA FILE FROM SERVER -->\r\n");
102d588c:	e3a02c02 	mov	r2, #512	; 0x200
102d5890:	e3a01000 	mov	r1, #0
102d5894:	e59f01f4 	ldr	r0, [pc, #500]	; 102d5a90 <LICENSE_Download+0x364>
			return ret;
		}
//#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- File (%s) Created -->\r\n", File_FotaAppBin);
//#endif
		g_Handle_File_LICENSEPEM = ret;//Get file handle (Global Variable)
102d5898:	e5889000 	str	r9, [r8]

		// Read HTTP File Data and write to File
//#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- START RECEIVING FOTA FILE FROM SERVER -->\r\n");
102d589c:	e12fff37 	blx	r7
102d58a0:	e5963000 	ldr	r3, [r6]
102d58a4:	e59f1220 	ldr	r1, [pc, #544]	; 102d5acc <LICENSE_Download+0x3a0>
102d58a8:	e59f01e0 	ldr	r0, [pc, #480]	; 102d5a90 <LICENSE_Download+0x364>
102d58ac:	e12fff33 	blx	r3
102d58b0:	e59f01d8 	ldr	r0, [pc, #472]	; 102d5a90 <LICENSE_Download+0x364>
102d58b4:	e12fff35 	blx	r5
102d58b8:	e59f11d0 	ldr	r1, [pc, #464]	; 102d5a90 <LICENSE_Download+0x364>
102d58bc:	e1a02000 	mov	r2, r0
102d58c0:	e3a0000a 	mov	r0, #10
102d58c4:	e12fff34 	blx	r4
//#endif

		ret = RIL_HTTP_ReadResponse(30, Callback_HTTPS_RecvData);
102d58c8:	e59f1200 	ldr	r1, [pc, #512]	; 102d5ad0 <LICENSE_Download+0x3a4>
102d58cc:	e59f3200 	ldr	r3, [pc, #512]	; 102d5ad4 <LICENSE_Download+0x3a8>
102d58d0:	e3a0001e 	mov	r0, #30
102d58d4:	e12fff33 	blx	r3

		Ql_FS_Close(g_Handle_File_LICENSEPEM);
102d58d8:	e59f31f8 	ldr	r3, [pc, #504]	; 102d5ad8 <LICENSE_Download+0x3ac>
		// Read HTTP File Data and write to File
//#ifdef FOTA_MSG
		APP_DEBUG("\r\n<-- START RECEIVING FOTA FILE FROM SERVER -->\r\n");
//#endif

		ret = RIL_HTTP_ReadResponse(30, Callback_HTTPS_RecvData);
102d58dc:	e1a09000 	mov	r9, r0

		Ql_FS_Close(g_Handle_File_LICENSEPEM);
102d58e0:	e5980000 	ldr	r0, [r8]
102d58e4:	e12fff33 	blx	r3
		g_rcvdDataLen = 0;
102d58e8:	e3a08000 	mov	r8, #0
102d58ec:	e59f319c 	ldr	r3, [pc, #412]	; 102d5a90 <LICENSE_Download+0x364>
		if(ret < 0)
102d58f0:	e1590008 	cmp	r9, r8
//#endif

		ret = RIL_HTTP_ReadResponse(30, Callback_HTTPS_RecvData);

		Ql_FS_Close(g_Handle_File_LICENSEPEM);
		g_rcvdDataLen = 0;
102d58f4:	e5838200 	str	r8, [r3, #512]	; 0x200
		if(ret < 0)
102d58f8:	ba000014 	blt	102d5950 <LICENSE_Download+0x224>
		}
		else
		{
			FOTA_DOWNLOAD_SUCCESS = TRUE; //Get out of the the for loop
//#ifdef FOTA_MSG
			APP_DEBUG("\r\n<-- SUCCESS : FOTA FILE DOWNLOAD FROM HTTPS Server!!! -->\r\n");
102d58fc:	e3a02c02 	mov	r2, #512	; 0x200
102d5900:	e1a01008 	mov	r1, r8
102d5904:	e59f318c 	ldr	r3, [pc, #396]	; 102d5a98 <LICENSE_Download+0x36c>
102d5908:	e59f0180 	ldr	r0, [pc, #384]	; 102d5a90 <LICENSE_Download+0x364>
102d590c:	e12fff33 	blx	r3
102d5910:	e59f0170 	ldr	r0, [pc, #368]	; 102d5a88 <LICENSE_Download+0x35c>
102d5914:	e59f11c0 	ldr	r1, [pc, #448]	; 102d5adc <LICENSE_Download+0x3b0>
102d5918:	e5903000 	ldr	r3, [r0]
102d591c:	e59f016c 	ldr	r0, [pc, #364]	; 102d5a90 <LICENSE_Download+0x364>
102d5920:	e12fff33 	blx	r3
102d5924:	e59f2168 	ldr	r2, [pc, #360]	; 102d5a94 <LICENSE_Download+0x368>
102d5928:	e59f0160 	ldr	r0, [pc, #352]	; 102d5a90 <LICENSE_Download+0x364>
102d592c:	e12fff32 	blx	r2
102d5930:	e59f1158 	ldr	r1, [pc, #344]	; 102d5a90 <LICENSE_Download+0x364>
		}
	}

	//Return either sucess of fail due to max attempts
	if(FOTA_DOWNLOAD_SUCCESS == TRUE)
		return 0;
102d5934:	e1a09008 	mov	r9, r8
		}
		else
		{
			FOTA_DOWNLOAD_SUCCESS = TRUE; //Get out of the the for loop
//#ifdef FOTA_MSG
			APP_DEBUG("\r\n<-- SUCCESS : FOTA FILE DOWNLOAD FROM HTTPS Server!!! -->\r\n");
102d5938:	e1a02000 	mov	r2, r0
102d593c:	e3a0000a 	mov	r0, #10
102d5940:	e12fff34 	blx	r4
	else
	{
		Fota_Fail_Reason_Code = 8;
		return -1;
	}
}
102d5944:	e1a00009 	mov	r0, r9
102d5948:	e28dd00c 	add	sp, sp, #12
102d594c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Ql_FS_Close(g_Handle_File_LICENSEPEM);
		g_rcvdDataLen = 0;
		if(ret < 0)
		{
//#ifdef FOTA_MSG
			APP_DEBUG("\r\n<-- ERROR : FOTA FILE CURRUPT WHILE DOWNLOAD!!! (ret = %d) -->\r\n", ret);
102d5950:	e1a01008 	mov	r1, r8
102d5954:	e3a02c02 	mov	r2, #512	; 0x200
102d5958:	e1a00003 	mov	r0, r3
102d595c:	e12fff37 	blx	r7
102d5960:	e1a02009 	mov	r2, r9
102d5964:	e5963000 	ldr	r3, [r6]
102d5968:	e59f1170 	ldr	r1, [pc, #368]	; 102d5ae0 <LICENSE_Download+0x3b4>
102d596c:	e59f011c 	ldr	r0, [pc, #284]	; 102d5a90 <LICENSE_Download+0x364>
102d5970:	e12fff33 	blx	r3
102d5974:	e59f0114 	ldr	r0, [pc, #276]	; 102d5a90 <LICENSE_Download+0x364>
102d5978:	e12fff35 	blx	r5
102d597c:	e59f110c 	ldr	r1, [pc, #268]	; 102d5a90 <LICENSE_Download+0x364>
102d5980:	e1a02000 	mov	r2, r0
102d5984:	e3a0000a 	mov	r0, #10
102d5988:	e12fff34 	blx	r4
//#endif
			// Delete Curreupt File
			ret = fileSys_deleteFile((u8 *)File_Licensepem);
102d598c:	e59a0000 	ldr	r0, [sl]
102d5990:	e59f314c 	ldr	r3, [pc, #332]	; 102d5ae4 <LICENSE_Download+0x3b8>
102d5994:	e12fff33 	blx	r3
			if(ret < 0)
102d5998:	e2509000 	subs	r9, r0, #0
102d599c:	ba000035 	blt	102d5a78 <LICENSE_Download+0x34c>
102d59a0:	e59d0004 	ldr	r0, [sp, #4]
102d59a4:	e2403001 	sub	r3, r0, #1
	g_rcvdDataLen = 0;
	u8 Fota_Download_retry_count;
	bool FOTA_DOWNLOAD_SUCCESS = FALSE;
	FLAG.FOTA_FILE_COM_FW_INVALID = TRUE; //Set the flag as invalid state..
	FLAG.FOTA_FILE_CON_FW_INVALID = TRUE; //Set the flag as invalid state..
	for(Fota_Download_retry_count = 0 ; Fota_Download_retry_count < 10  && FOTA_DOWNLOAD_SUCCESS == FALSE; Fota_Download_retry_count++)
102d59a8:	e21330ff 	ands	r3, r3, #255	; 0xff
102d59ac:	e58d3004 	str	r3, [sp, #4]
102d59b0:	1affff6c 	bne	102d5768 <LICENSE_Download+0x3c>
	//Return either sucess of fail due to max attempts
	if(FOTA_DOWNLOAD_SUCCESS == TRUE)
		return 0;
	else
	{
		Fota_Fail_Reason_Code = 8;
102d59b4:	e59f312c 	ldr	r3, [pc, #300]	; 102d5ae8 <LICENSE_Download+0x3bc>
102d59b8:	e3a02008 	mov	r2, #8
		return -1;
102d59bc:	e3e09000 	mvn	r9, #0
	//Return either sucess of fail due to max attempts
	if(FOTA_DOWNLOAD_SUCCESS == TRUE)
		return 0;
	else
	{
		Fota_Fail_Reason_Code = 8;
102d59c0:	e5c32000 	strb	r2, [r3]
		return -1;
102d59c4:	eaffffde 	b	102d5944 <LICENSE_Download+0x218>
		// Set HTTP server address (URL)
		ret = RIL_HTTP_SetServerURL((char *)HTTP_LICENSE_URL_ADDR, Ql_strlen((char *)HTTP_LICENSE_URL_ADDR));
		if(ret < 0)
		{
//#ifdef FOTA_MSG
			APP_DEBUG("<-- ERROR : HTTPS FOTA SET SERVER URL (ret = %d) -->\r\n", ret);
102d59c8:	e12fff33 	blx	r3
102d59cc:	e59f1118 	ldr	r1, [pc, #280]	; 102d5aec <LICENSE_Download+0x3c0>
102d59d0:	e59b3000 	ldr	r3, [fp]
102d59d4:	e1a02009 	mov	r2, r9
102d59d8:	e59f00b0 	ldr	r0, [pc, #176]	; 102d5a90 <LICENSE_Download+0x364>
102d59dc:	e12fff33 	blx	r3
102d59e0:	e59f20ac 	ldr	r2, [pc, #172]	; 102d5a94 <LICENSE_Download+0x368>
102d59e4:	e59f00a4 	ldr	r0, [pc, #164]	; 102d5a90 <LICENSE_Download+0x364>
102d59e8:	e12fff32 	blx	r2
102d59ec:	e59f30b4 	ldr	r3, [pc, #180]	; 102d5aa8 <LICENSE_Download+0x37c>
102d59f0:	e59f1098 	ldr	r1, [pc, #152]	; 102d5a90 <LICENSE_Download+0x364>
102d59f4:	e1a02000 	mov	r2, r0
102d59f8:	e3a0000a 	mov	r0, #10
102d59fc:	e12fff33 	blx	r3
//#endif
			Fota_Fail_Reason_Code = 4;
102d5a00:	e59f30e0 	ldr	r3, [pc, #224]	; 102d5ae8 <LICENSE_Download+0x3bc>
102d5a04:	e3a02004 	mov	r2, #4
102d5a08:	e5c32000 	strb	r2, [r3]
			return ret;
102d5a0c:	eaffffcc 	b	102d5944 <LICENSE_Download+0x218>
		// Send HTTP GET Request
		ret = RIL_HTTP_RequestToGet(60);
		if(ret < 0)
		{
//#ifdef FOTA_MSG
			APP_DEBUG("<-- ERROR : HTTPS GET REQUEST Failed (ret = %d) -->\r\n", ret);
102d5a10:	e3a01000 	mov	r1, #0
102d5a14:	e3a02c02 	mov	r2, #512	; 0x200
102d5a18:	e59f3078 	ldr	r3, [pc, #120]	; 102d5a98 <LICENSE_Download+0x36c>
102d5a1c:	e59f006c 	ldr	r0, [pc, #108]	; 102d5a90 <LICENSE_Download+0x364>
102d5a20:	e12fff33 	blx	r3
102d5a24:	e59f005c 	ldr	r0, [pc, #92]	; 102d5a88 <LICENSE_Download+0x35c>
102d5a28:	e59f10c0 	ldr	r1, [pc, #192]	; 102d5af0 <LICENSE_Download+0x3c4>
102d5a2c:	e5903000 	ldr	r3, [r0]
102d5a30:	e1a02009 	mov	r2, r9
102d5a34:	e59f0054 	ldr	r0, [pc, #84]	; 102d5a90 <LICENSE_Download+0x364>
102d5a38:	e12fff33 	blx	r3
102d5a3c:	e59f2050 	ldr	r2, [pc, #80]	; 102d5a94 <LICENSE_Download+0x368>
102d5a40:	e59f0048 	ldr	r0, [pc, #72]	; 102d5a90 <LICENSE_Download+0x364>
102d5a44:	e12fff32 	blx	r2
102d5a48:	e59f1040 	ldr	r1, [pc, #64]	; 102d5a90 <LICENSE_Download+0x364>
102d5a4c:	e1a02000 	mov	r2, r0
102d5a50:	e3a0000a 	mov	r0, #10
102d5a54:	e12fff34 	blx	r4
//#endif
			Fota_Fail_Reason_Code = 5;
102d5a58:	e59f3088 	ldr	r3, [pc, #136]	; 102d5ae8 <LICENSE_Download+0x3bc>
102d5a5c:	e3a02005 	mov	r2, #5
102d5a60:	e5c32000 	strb	r2, [r3]
			return ret;
102d5a64:	eaffffb6 	b	102d5944 <LICENSE_Download+0x218>
		{
			//Open file failed.
#ifdef FOTA_MSG
			APP_DEBUG("<-- Failed to Create File (%s) ret=%d -->\r\n", File_Licensepem, ret);
#endif
			Fota_Fail_Reason_Code = 6;
102d5a68:	e59f3078 	ldr	r3, [pc, #120]	; 102d5ae8 <LICENSE_Download+0x3bc>
102d5a6c:	e3a02006 	mov	r2, #6
102d5a70:	e5c32000 	strb	r2, [r3]
			return ret;
102d5a74:	eaffffb2 	b	102d5944 <LICENSE_Download+0x218>
			if(ret < 0)
			{
#ifdef FOTA_MSG
				APP_DEBUG("<-- ERROR : Deleting Currupt File (%s), (ret = %d) -->\r\n", File_Licensepem, ret);
#endif
				Fota_Fail_Reason_Code = 7;
102d5a78:	e59f3068 	ldr	r3, [pc, #104]	; 102d5ae8 <LICENSE_Download+0x3bc>
102d5a7c:	e3a02007 	mov	r2, #7
102d5a80:	e5c32000 	strb	r2, [r3]
				return ret;
102d5a84:	eaffffae 	b	102d5944 <LICENSE_Download+0x218>
102d5a88:	f03de540 	.word	0xf03de540
102d5a8c:	f03da5f0 	.word	0xf03da5f0
102d5a90:	f03d5e68 	.word	0xf03d5e68
102d5a94:	102e57a4 	.word	0x102e57a4
102d5a98:	102e58f4 	.word	0x102e58f4
102d5a9c:	f03d6214 	.word	0xf03d6214
102d5aa0:	102ca6d0 	.word	0x102ca6d0
102d5aa4:	102ef730 	.word	0x102ef730
102d5aa8:	102e6230 	.word	0x102e6230
102d5aac:	102ca788 	.word	0x102ca788
102d5ab0:	102ef79c 	.word	0x102ef79c
102d5ab4:	f03d20ac 	.word	0xf03d20ac
102d5ab8:	102d2cb0 	.word	0x102d2cb0
102d5abc:	102d2e00 	.word	0x102d2e00
102d5ac0:	f03d20b0 	.word	0xf03d20b0
102d5ac4:	102ef7c4 	.word	0x102ef7c4
102d5ac8:	f03d20b4 	.word	0xf03d20b4
102d5acc:	102ef7e4 	.word	0x102ef7e4
102d5ad0:	102d4a6c 	.word	0x102d4a6c
102d5ad4:	102ca8d4 	.word	0x102ca8d4
102d5ad8:	102e426c 	.word	0x102e426c
102d5adc:	102ef85c 	.word	0x102ef85c
102d5ae0:	102ef818 	.word	0x102ef818
102d5ae4:	102d2fb0 	.word	0x102d2fb0
102d5ae8:	f03de528 	.word	0xf03de528
102d5aec:	102ef6f8 	.word	0x102ef6f8
102d5af0:	102ef764 	.word	0x102ef764

102d5af4 <LICENSE_INIT>:
}



s32 LICENSE_INIT()
{
102d5af4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	s32 ret = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- LICENSE DOWNLOAD INITIATED !!! -->\r\n");
102d5af8:	e59f6134 	ldr	r6, [pc, #308]	; 102d5c34 <LICENSE_INIT+0x140>
102d5afc:	e3a02c02 	mov	r2, #512	; 0x200
102d5b00:	e3a01000 	mov	r1, #0
102d5b04:	e59f012c 	ldr	r0, [pc, #300]	; 102d5c38 <LICENSE_INIT+0x144>
102d5b08:	e59f712c 	ldr	r7, [pc, #300]	; 102d5c3c <LICENSE_INIT+0x148>
102d5b0c:	e12fff37 	blx	r7
102d5b10:	e5963000 	ldr	r3, [r6]
102d5b14:	e59f1124 	ldr	r1, [pc, #292]	; 102d5c40 <LICENSE_INIT+0x14c>
102d5b18:	e59f0118 	ldr	r0, [pc, #280]	; 102d5c38 <LICENSE_INIT+0x144>
102d5b1c:	e12fff33 	blx	r3
102d5b20:	e59f511c 	ldr	r5, [pc, #284]	; 102d5c44 <LICENSE_INIT+0x150>
102d5b24:	e59f010c 	ldr	r0, [pc, #268]	; 102d5c38 <LICENSE_INIT+0x144>
102d5b28:	e12fff35 	blx	r5
102d5b2c:	e59f4114 	ldr	r4, [pc, #276]	; 102d5c48 <LICENSE_INIT+0x154>
102d5b30:	e59f1100 	ldr	r1, [pc, #256]	; 102d5c38 <LICENSE_INIT+0x144>
#endif

	Store_Persistent_Data();
	Write_Error_Messages();
	//Check LICENSE.pem File is present or not: If present then delete file and check free space
	ret = fileSys_checkFile((u8*)File_Licensepem);		//To Check file FOTA.bin is available or not
102d5b34:	e59f8110 	ldr	r8, [pc, #272]	; 102d5c4c <LICENSE_INIT+0x158>

s32 LICENSE_INIT()
{
	s32 ret = -1;
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- LICENSE DOWNLOAD INITIATED !!! -->\r\n");
102d5b38:	e1a02000 	mov	r2, r0
102d5b3c:	e3a0000a 	mov	r0, #10
102d5b40:	e12fff34 	blx	r4
#endif

	Store_Persistent_Data();
102d5b44:	e59f3104 	ldr	r3, [pc, #260]	; 102d5c50 <LICENSE_INIT+0x15c>
102d5b48:	e12fff33 	blx	r3
	Write_Error_Messages();
102d5b4c:	e59f3100 	ldr	r3, [pc, #256]	; 102d5c54 <LICENSE_INIT+0x160>
102d5b50:	e12fff33 	blx	r3
	//Check LICENSE.pem File is present or not: If present then delete file and check free space
	ret = fileSys_checkFile((u8*)File_Licensepem);		//To Check file FOTA.bin is available or not
102d5b54:	e5980000 	ldr	r0, [r8]
102d5b58:	e59f30f8 	ldr	r3, [pc, #248]	; 102d5c58 <LICENSE_INIT+0x164>
102d5b5c:	e12fff33 	blx	r3
	if(ret == QL_RET_OK)		//If FOTA.bin file is available then delete file
102d5b60:	e3500000 	cmp	r0, #0
102d5b64:	1a000004 	bne	102d5b7c <LICENSE_INIT+0x88>
	{
		ret = fileSys_deleteFile((u8*)File_Licensepem);		//Delete FOTA.bin file
102d5b68:	e5980000 	ldr	r0, [r8]
102d5b6c:	e59f30e8 	ldr	r3, [pc, #232]	; 102d5c5c <LICENSE_INIT+0x168>
102d5b70:	e12fff33 	blx	r3
		if(ret < 0)
102d5b74:	e3500000 	cmp	r0, #0
102d5b78:	ba000029 	blt	102d5c24 <LICENSE_INIT+0x130>
	}
#ifdef FOTA_MSG
	APP_DEBUG("<-- Memory Free Space  : %lld Byte's -->\r\n",Ql_FS_GetFreeSpace(storage));		//Print free space debug message on screen
#endif
	//Display "UPDATING..." on LCD when FOTA is Initiated.
	Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_FOTA_UPDATE);
102d5b7c:	e59fc0dc 	ldr	ip, [pc, #220]	; 102d5c60 <LICENSE_INIT+0x16c>
102d5b80:	e3a03025 	mov	r3, #37	; 0x25
102d5b84:	e59f10d8 	ldr	r1, [pc, #216]	; 102d5c64 <LICENSE_INIT+0x170>
102d5b88:	e3a02002 	mov	r2, #2
102d5b8c:	e3a00003 	mov	r0, #3
102d5b90:	e12fff3c 	blx	ip

	//Report to twin properties
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- TWIN FOTA Status : Updating !!! -->\r\n");
102d5b94:	e3a02c02 	mov	r2, #512	; 0x200
102d5b98:	e3a01000 	mov	r1, #0
102d5b9c:	e59f0094 	ldr	r0, [pc, #148]	; 102d5c38 <LICENSE_INIT+0x144>
102d5ba0:	e12fff37 	blx	r7
102d5ba4:	e5963000 	ldr	r3, [r6]
102d5ba8:	e59f10b8 	ldr	r1, [pc, #184]	; 102d5c68 <LICENSE_INIT+0x174>
102d5bac:	e59f0084 	ldr	r0, [pc, #132]	; 102d5c38 <LICENSE_INIT+0x144>
102d5bb0:	e12fff33 	blx	r3
102d5bb4:	e59f007c 	ldr	r0, [pc, #124]	; 102d5c38 <LICENSE_INIT+0x144>
102d5bb8:	e12fff35 	blx	r5
102d5bbc:	e59f1074 	ldr	r1, [pc, #116]	; 102d5c38 <LICENSE_INIT+0x144>
102d5bc0:	e1a02000 	mov	r2, r0
102d5bc4:	e3a0000a 	mov	r0, #10
102d5bc8:	e12fff34 	blx	r4
	//Ql_strcpy(RP_FW_Upgrade_status,"1");// Report "Downloading"
	//Process_TWIN_PROPERTY_CHANGE |= REPORT_TWIN_CNTL_FW_UPDTAE_STATUS;
	//publish_data(MQTT_TWIN_REPORTED);

	// Confugure for HTTPS
	ret = RIL_HTTPS_QSSLCFG();
102d5bcc:	ebfffc72 	bl	102d4d9c <RIL_HTTPS_QSSLCFG>
	if(ret < 0)
102d5bd0:	e3500000 	cmp	r0, #0
102d5bd4:	ba00000e 	blt	102d5c14 <LICENSE_INIT+0x120>
#endif
		Fota_Fail_Reason_Code = 1;
	}
	else
	{
		ret = LICENSE_Download();
102d5bd8:	ebfffed3 	bl	102d572c <LICENSE_Download>
		if(ret < 0)
102d5bdc:	e3500000 	cmp	r0, #0
102d5be0:	ba000006 	blt	102d5c00 <LICENSE_INIT+0x10c>
			APP_DEBUG("\r\n<-- FIRMWARE DOWNLOAD FAIL!!! -->\r\n");
#endif
		}
		else
		{
			if((FLAG.FOTA_FILE_COM_FW_INVALID == TRUE) || (FLAG.FOTA_FILE_CON_FW_INVALID == TRUE))// Check if the FOTA file is of correct parameters..
102d5be4:	e59f3080 	ldr	r3, [pc, #128]	; 102d5c6c <LICENSE_INIT+0x178>
102d5be8:	e5d32021 	ldrb	r2, [r3, #33]	; 0x21
102d5bec:	e3520001 	cmp	r2, #1
102d5bf0:	0a000003 	beq	102d5c04 <LICENSE_INIT+0x110>
102d5bf4:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
102d5bf8:	e3530001 	cmp	r3, #1
102d5bfc:	0a000000 	beq	102d5c04 <LICENSE_INIT+0x110>
				ret = -1;
			}
		}
	}

}
102d5c00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		}
		else
		{
			if((FLAG.FOTA_FILE_COM_FW_INVALID == TRUE) || (FLAG.FOTA_FILE_CON_FW_INVALID == TRUE))// Check if the FOTA file is of correct parameters..
			{
				Fota_Fail_Reason_Code = 3;
102d5c04:	e59f3064 	ldr	r3, [pc, #100]	; 102d5c70 <LICENSE_INIT+0x17c>
102d5c08:	e3a02003 	mov	r2, #3
102d5c0c:	e5c32000 	strb	r2, [r3]
				ret = -1;
			}
		}
	}

}
102d5c10:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	if(ret < 0)
	{
#ifdef FOTA_MSG
		APP_DEBUG("<-- HTTPS Config Fail ret=%d -->\r\n", ret);
#endif
		Fota_Fail_Reason_Code = 1;
102d5c14:	e59f3054 	ldr	r3, [pc, #84]	; 102d5c70 <LICENSE_INIT+0x17c>
102d5c18:	e3a02001 	mov	r2, #1
102d5c1c:	e5c32000 	strb	r2, [r3]
				ret = -1;
			}
		}
	}

}
102d5c20:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		if(ret < 0)
		{
#ifdef FOTA_MSG
			APP_DEBUG("<-- ERROR : Deleting Existing FOTA File (%s), (ret = %d) -->\r\n", File_FotaAppBin, ret);
#endif
			Fota_Fail_Reason_Code = 2;
102d5c24:	e59f3044 	ldr	r3, [pc, #68]	; 102d5c70 <LICENSE_INIT+0x17c>
102d5c28:	e3a02002 	mov	r2, #2
102d5c2c:	e5c32000 	strb	r2, [r3]
102d5c30:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102d5c34:	f03de540 	.word	0xf03de540
102d5c38:	f03d5e68 	.word	0xf03d5e68
102d5c3c:	102e58f4 	.word	0x102e58f4
102d5c40:	102ef89c 	.word	0x102ef89c
102d5c44:	102e57a4 	.word	0x102e57a4
102d5c48:	102e6230 	.word	0x102e6230
102d5c4c:	f03d20ac 	.word	0xf03d20ac
102d5c50:	102d3078 	.word	0x102d3078
102d5c54:	102d4270 	.word	0x102d4270
102d5c58:	102d2f38 	.word	0x102d2f38
102d5c5c:	102d2fb0 	.word	0x102d2fb0
102d5c60:	102e5cb4 	.word	0x102e5cb4
102d5c64:	000010c8 	.word	0x000010c8
102d5c68:	102ef65c 	.word	0x102ef65c
102d5c6c:	f03da5f0 	.word	0xf03da5f0
102d5c70:	f03de528 	.word	0xf03de528

102d5c74 <_sbrk>:
	unsigned char *prev_heap;

	if (heap == NULL) {
//		heap = (unsigned char *)&__HEAP_START;
	}
	prev_heap = heap;
102d5c74:	e59f2010 	ldr	r2, [pc, #16]	; 102d5c8c <_sbrk+0x18>
102d5c78:	e5923000 	ldr	r3, [r2]
	/* check removed to show basic approach*/
	heap += incr;
102d5c7c:	e0830000 	add	r0, r3, r0
102d5c80:	e5820000 	str	r0, [r2]

	return (caddr_t) prev_heap;
}
102d5c84:	e1a00003 	mov	r0, r3
102d5c88:	e12fff1e 	bx	lr
102d5c8c:	f03d62ac 	.word	0xf03d62ac

102d5c90 <cJSON_strcasecmp>:
}

/* case insensitive strcmp */
static int cJSON_strcasecmp(const unsigned char *s1, const unsigned char *s2)
{
    if (!s1)
102d5c90:	e3500000 	cmp	r0, #0
    return version;
}

/* case insensitive strcmp */
static int cJSON_strcasecmp(const unsigned char *s1, const unsigned char *s2)
{
102d5c94:	e92d00f0 	push	{r4, r5, r6, r7}
    if (!s1)
102d5c98:	0a00001f 	beq	102d5d1c <cJSON_strcasecmp+0x8c>
    {
        return (s1 == s2) ? 0 : 1; /* both NULL? */
    }
    if (!s2)
102d5c9c:	e3510000 	cmp	r1, #0
102d5ca0:	0a000020 	beq	102d5d28 <cJSON_strcasecmp+0x98>
102d5ca4:	e59f3084 	ldr	r3, [pc, #132]	; 102d5d30 <cJSON_strcasecmp+0xa0>

    return version;
}

/* case insensitive strcmp */
static int cJSON_strcasecmp(const unsigned char *s1, const unsigned char *s2)
102d5ca8:	e2405001 	sub	r5, r0, #1
102d5cac:	e5934000 	ldr	r4, [r3]
102d5cb0:	e2411001 	sub	r1, r1, #1
102d5cb4:	ea000001 	b	102d5cc0 <cJSON_strcasecmp+0x30>
    {
        return 1;
    }
    for(; tolower(*s1) == tolower(*s2); (void)++s1, ++s2)
    {
        if (*s1 == '\0')
102d5cb8:	e3500000 	cmp	r0, #0
102d5cbc:	0a000014 	beq	102d5d14 <cJSON_strcasecmp+0x84>
    }
    if (!s2)
    {
        return 1;
    }
    for(; tolower(*s1) == tolower(*s2); (void)++s1, ++s2)
102d5cc0:	e5f50001 	ldrb	r0, [r5, #1]!
102d5cc4:	e0843000 	add	r3, r4, r0
102d5cc8:	e5d37001 	ldrb	r7, [r3, #1]
102d5ccc:	e5f13001 	ldrb	r3, [r1, #1]!
102d5cd0:	e2077003 	and	r7, r7, #3
102d5cd4:	e0842003 	add	r2, r4, r3
102d5cd8:	e5d26001 	ldrb	r6, [r2, #1]
102d5cdc:	e3570001 	cmp	r7, #1
102d5ce0:	e2066003 	and	r6, r6, #3
102d5ce4:	e1a0c000 	mov	ip, r0
102d5ce8:	0280c020 	addeq	ip, r0, #32
102d5cec:	e3560001 	cmp	r6, #1
102d5cf0:	e1a02003 	mov	r2, r3
102d5cf4:	02832020 	addeq	r2, r3, #32
102d5cf8:	e15c0002 	cmp	ip, r2
102d5cfc:	0affffed 	beq	102d5cb8 <cJSON_strcasecmp+0x28>
        {
            return 0;
        }
    }

    return tolower(*s1) - tolower(*s2);
102d5d00:	e3570001 	cmp	r7, #1
102d5d04:	02800020 	addeq	r0, r0, #32
102d5d08:	e3560001 	cmp	r6, #1
102d5d0c:	02833020 	addeq	r3, r3, #32
102d5d10:	e0630000 	rsb	r0, r3, r0
}
102d5d14:	e8bd00f0 	pop	{r4, r5, r6, r7}
102d5d18:	e12fff1e 	bx	lr
/* case insensitive strcmp */
static int cJSON_strcasecmp(const unsigned char *s1, const unsigned char *s2)
{
    if (!s1)
    {
        return (s1 == s2) ? 0 : 1; /* both NULL? */
102d5d1c:	e2910000 	adds	r0, r1, #0
102d5d20:	13a00001 	movne	r0, #1
102d5d24:	eafffffa 	b	102d5d14 <cJSON_strcasecmp+0x84>
    }
    if (!s2)
    {
        return 1;
102d5d28:	e3a00001 	mov	r0, #1
102d5d2c:	eafffff8 	b	102d5d14 <cJSON_strcasecmp+0x84>
102d5d30:	f03d4764 	.word	0xf03d4764

102d5d34 <parse_hex4>:
static unsigned parse_hex4(const unsigned char * const input)
{
    unsigned int h = 0;
    size_t i = 0;

    for (i = 0; i < 4; i++)
102d5d34:	e3a02000 	mov	r2, #0
    return true;
}

/* parse 4 digit hexadecimal number */
static unsigned parse_hex4(const unsigned char * const input)
{
102d5d38:	e92d0070 	push	{r4, r5, r6}
    unsigned int h = 0;
102d5d3c:	e1a01002 	mov	r1, r2
    return true;
}

/* parse 4 digit hexadecimal number */
static unsigned parse_hex4(const unsigned char * const input)
{
102d5d40:	e1a06000 	mov	r6, r0
    size_t i = 0;

    for (i = 0; i < 4; i++)
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
102d5d44:	e7d63002 	ldrb	r3, [r6, r2]
        {
            h += (unsigned int) input[i] - '0';
102d5d48:	e241c030 	sub	ip, r1, #48	; 0x30
    size_t i = 0;

    for (i = 0; i < 4; i++)
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
102d5d4c:	e2434030 	sub	r4, r3, #48	; 0x30
102d5d50:	e3540009 	cmp	r4, #9
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
102d5d54:	e2435041 	sub	r5, r3, #65	; 0x41
    for (i = 0; i < 4; i++)
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
        {
            h += (unsigned int) input[i] - '0';
102d5d58:	e08c0003 	add	r0, ip, r3
    size_t i = 0;

    for (i = 0; i < 4; i++)
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
102d5d5c:	9a000008 	bls	102d5d84 <parse_hex4+0x50>
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        {
            h += (unsigned int) 10 + input[i] - 'A';
102d5d60:	e2410037 	sub	r0, r1, #55	; 0x37
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
102d5d64:	e3550005 	cmp	r5, #5
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
102d5d68:	e243c061 	sub	ip, r3, #97	; 0x61
        {
            h += (unsigned int) 10 + input[i] - 'a';
102d5d6c:	e2411057 	sub	r1, r1, #87	; 0x57
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        {
            h += (unsigned int) 10 + input[i] - 'A';
102d5d70:	e0800003 	add	r0, r0, r3
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
102d5d74:	9a000002 	bls	102d5d84 <parse_hex4+0x50>
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
102d5d78:	e35c0005 	cmp	ip, #5
        {
            h += (unsigned int) 10 + input[i] - 'a';
102d5d7c:	e0810003 	add	r0, r1, r3
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
102d5d80:	8a000005 	bhi	102d5d9c <parse_hex4+0x68>
        else /* invalid */
        {
            return 0;
        }

        if (i < 3)
102d5d84:	e3520003 	cmp	r2, #3
        {
            /* shift left to make place for the next nibble */
            h = h << 4;
102d5d88:	e1a01200 	lsl	r1, r0, #4
static unsigned parse_hex4(const unsigned char * const input)
{
    unsigned int h = 0;
    size_t i = 0;

    for (i = 0; i < 4; i++)
102d5d8c:	e2822001 	add	r2, r2, #1
        else /* invalid */
        {
            return 0;
        }

        if (i < 3)
102d5d90:	1affffeb 	bne	102d5d44 <parse_hex4+0x10>
            h = h << 4;
        }
    }

    return h;
}
102d5d94:	e8bd0070 	pop	{r4, r5, r6}
102d5d98:	e12fff1e 	bx	lr
        {
            h += (unsigned int) 10 + input[i] - 'a';
        }
        else /* invalid */
        {
            return 0;
102d5d9c:	e3a00000 	mov	r0, #0
102d5da0:	eafffffb 	b	102d5d94 <parse_hex4+0x60>

102d5da4 <DetachItemFromArray>:
    cJSON_AddItemToObject(object, string, create_reference(item, &global_hooks));
}

static cJSON *DetachItemFromArray(cJSON *array, size_t which)
{
    cJSON *c = array->child;
102d5da4:	e590c008 	ldr	ip, [r0, #8]
    while (c && (which > 0))
102d5da8:	e3510000 	cmp	r1, #0
102d5dac:	135c0000 	cmpne	ip, #0
102d5db0:	e1a0300c 	mov	r3, ip
102d5db4:	0a000008 	beq	102d5ddc <DetachItemFromArray+0x38>
102d5db8:	e2511001 	subs	r1, r1, #1
    {
        c = c->next;
102d5dbc:	e5933000 	ldr	r3, [r3]
}

static cJSON *DetachItemFromArray(cJSON *array, size_t which)
{
    cJSON *c = array->child;
    while (c && (which > 0))
102d5dc0:	03a02000 	moveq	r2, #0
102d5dc4:	13a02001 	movne	r2, #1
102d5dc8:	e3530000 	cmp	r3, #0
102d5dcc:	03a02000 	moveq	r2, #0
102d5dd0:	12022001 	andne	r2, r2, #1
102d5dd4:	e3520000 	cmp	r2, #0
102d5dd8:	1afffff6 	bne	102d5db8 <DetachItemFromArray+0x14>
    {
        c = c->next;
        which--;
    }
    if (!c)
102d5ddc:	e3530000 	cmp	r3, #0
102d5de0:	0a00000b 	beq	102d5e14 <DetachItemFromArray+0x70>
    {
        /* item doesn't exist */
        return NULL;
    }
    if (c->prev)
102d5de4:	e5932004 	ldr	r2, [r3, #4]
102d5de8:	e3520000 	cmp	r2, #0
    {
        /* not the first element */
        c->prev->next = c->next;
102d5dec:	15931000 	ldrne	r1, [r3]
102d5df0:	15821000 	strne	r1, [r2]
    }
    if (c->next)
102d5df4:	e5931000 	ldr	r1, [r3]
102d5df8:	e3510000 	cmp	r1, #0
    {
        c->next->prev = c->prev;
102d5dfc:	15812004 	strne	r2, [r1, #4]
    if (c==array->child)
    {
        array->child = c->next;
    }
    /* make sure the detached item doesn't point anywhere anymore */
    c->prev = c->next = NULL;
102d5e00:	e3a02000 	mov	r2, #0
    }
    if (c->next)
    {
        c->next->prev = c->prev;
    }
    if (c==array->child)
102d5e04:	e153000c 	cmp	r3, ip
    {
        array->child = c->next;
102d5e08:	05801008 	streq	r1, [r0, #8]
    }
    /* make sure the detached item doesn't point anywhere anymore */
    c->prev = c->next = NULL;
102d5e0c:	e5832000 	str	r2, [r3]
102d5e10:	e5832004 	str	r2, [r3, #4]

    return c;
}
102d5e14:	e1a00003 	mov	r0, r3
102d5e18:	e12fff1e 	bx	lr

102d5e1c <update_offset>:
	#endif
}

/* calculate the new length of the string in a printbuffer and update the offset */
static void update_offset(printbuffer * const buffer)
{
102d5e1c:	e92d4038 	push	{r3, r4, r5, lr}
    const unsigned char *buffer_pointer = NULL;
    if ((buffer == NULL) || (buffer->buffer == NULL))
102d5e20:	e2504000 	subs	r4, r0, #0
102d5e24:	08bd8038 	popeq	{r3, r4, r5, pc}
102d5e28:	e5940000 	ldr	r0, [r4]
102d5e2c:	e3500000 	cmp	r0, #0
102d5e30:	08bd8038 	popeq	{r3, r4, r5, pc}
    {
        return;
    }
    buffer_pointer = buffer->buffer + buffer->offset;
102d5e34:	e5945008 	ldr	r5, [r4, #8]

    buffer->offset += Ql_strlen((const char*)buffer_pointer);
102d5e38:	e59f3010 	ldr	r3, [pc, #16]	; 102d5e50 <update_offset+0x34>
102d5e3c:	e0800005 	add	r0, r0, r5
102d5e40:	e12fff33 	blx	r3
102d5e44:	e0800005 	add	r0, r0, r5
102d5e48:	e5840008 	str	r0, [r4, #8]
102d5e4c:	e8bd8038 	pop	{r3, r4, r5, pc}
102d5e50:	102e57a4 	.word	0x102e57a4

102d5e54 <ensure.isra.0>:
#endif

    return x + 1;
}
/* realloc printbuffer if necessary to have at least "needed" bytes more */
static unsigned char* ensure(printbuffer * const p, size_t needed, const internal_hooks * const hooks)
102d5e54:	e92d4070 	push	{r4, r5, r6, lr}
{
	
	char *newbuffer = NULL;
    int newsize = 0;
    if (!p || !p->buffer)
102d5e58:	e2504000 	subs	r4, r0, #0
102d5e5c:	0a000024 	beq	102d5ef4 <ensure.isra.0+0xa0>
102d5e60:	e5940000 	ldr	r0, [r4]
102d5e64:	e3500000 	cmp	r0, #0
102d5e68:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
        return NULL;
    }
    needed += p->offset;
    if (needed <= p->length)
102d5e6c:	e994000c 	ldmib	r4, {r2, r3}
    int newsize = 0;
    if (!p || !p->buffer)
    {
        return NULL;
    }
    needed += p->offset;
102d5e70:	e0811003 	add	r1, r1, r3
    if (needed <= p->length)
102d5e74:	e1510002 	cmp	r1, r2
102d5e78:	9a000019 	bls	102d5ee4 <ensure.isra.0+0x90>
    {
        return p->buffer + p->offset;
    }

    if (p->noalloc) {
102d5e7c:	e594300c 	ldr	r3, [r4, #12]
102d5e80:	e3530000 	cmp	r3, #0
102d5e84:	1a000018 	bne	102d5eec <ensure.isra.0+0x98>
} printbuffer;


static int pow2gt(int x)
{
    --x;
102d5e88:	e2410001 	sub	r0, r1, #1

    x |= x >> 1;
102d5e8c:	e18000c0 	orr	r0, r0, r0, asr #1
    x |= x >> 2;
102d5e90:	e1800140 	orr	r0, r0, r0, asr #2
    x |= x >> 4;
102d5e94:	e1800240 	orr	r0, r0, r0, asr #4
#if INTEGER_SIZE & 0x1110 /* at least 16 bit */
    x |= x >> 8;
102d5e98:	e1800440 	orr	r0, r0, r0, asr #8
#endif
#if INTEGER_SIZE & 0x1100 /* at least 32 bit */
    x |= x >> 16;
102d5e9c:	e1800840 	orr	r0, r0, r0, asr #16
#endif
#if INT_SIZE & 0x1000 /* 64 bit */
    x |= x >> 32;
#endif

    return x + 1;
102d5ea0:	e2805001 	add	r5, r0, #1
    if (p->noalloc) {
        return NULL;
    }

    newsize = pow2gt(needed);
    newbuffer = (char*)cJSON_malloc(newsize);
102d5ea4:	e1a00005 	mov	r0, r5
102d5ea8:	e59f3068 	ldr	r3, [pc, #104]	; 102d5f18 <ensure.isra.0+0xc4>
102d5eac:	e12fff33 	blx	r3
    if (!newbuffer)
102d5eb0:	e2506000 	subs	r6, r0, #0
102d5eb4:	0a000010 	beq	102d5efc <ensure.isra.0+0xa8>

        return NULL;
    }
    if (newbuffer)
    {
        memcpy(newbuffer, p->buffer, p->length);
102d5eb8:	e8940006 	ldm	r4, {r1, r2}
102d5ebc:	e59f3058 	ldr	r3, [pc, #88]	; 102d5f1c <ensure.isra.0+0xc8>
102d5ec0:	e12fff33 	blx	r3
    }
    cJSON_free(p->buffer);
102d5ec4:	e5940000 	ldr	r0, [r4]
102d5ec8:	e59f3050 	ldr	r3, [pc, #80]	; 102d5f20 <ensure.isra.0+0xcc>
102d5ecc:	e12fff33 	blx	r3
    p->length = newsize;
    p->buffer = newbuffer;

    return newbuffer + p->offset;
102d5ed0:	e5940008 	ldr	r0, [r4, #8]
    if (newbuffer)
    {
        memcpy(newbuffer, p->buffer, p->length);
    }
    cJSON_free(p->buffer);
    p->length = newsize;
102d5ed4:	e5845004 	str	r5, [r4, #4]
    p->buffer = newbuffer;
102d5ed8:	e5846000 	str	r6, [r4]

    return newbuffer + p->offset;
102d5edc:	e0860000 	add	r0, r6, r0
102d5ee0:	e8bd8070 	pop	{r4, r5, r6, pc}
        return NULL;
    }
    needed += p->offset;
    if (needed <= p->length)
    {
        return p->buffer + p->offset;
102d5ee4:	e0800003 	add	r0, r0, r3
102d5ee8:	e8bd8070 	pop	{r4, r5, r6, pc}
	
	char *newbuffer = NULL;
    int newsize = 0;
    if (!p || !p->buffer)
    {
        return NULL;
102d5eec:	e3a00000 	mov	r0, #0
    p->length = newsize;
    p->buffer = newbuffer;
	//APP_DEBUG("inside hooks\r\n");
    return newbuffer + p->offset;
	#endif
}
102d5ef0:	e8bd8070 	pop	{r4, r5, r6, pc}
	
	char *newbuffer = NULL;
    int newsize = 0;
    if (!p || !p->buffer)
    {
        return NULL;
102d5ef4:	e1a00004 	mov	r0, r4
102d5ef8:	e8bd8070 	pop	{r4, r5, r6, pc}

    newsize = pow2gt(needed);
    newbuffer = (char*)cJSON_malloc(newsize);
    if (!newbuffer)
    {
        cJSON_free(p->buffer);
102d5efc:	e5940000 	ldr	r0, [r4]
102d5f00:	e59f3018 	ldr	r3, [pc, #24]	; 102d5f20 <ensure.isra.0+0xcc>
102d5f04:	e12fff33 	blx	r3
        p->length = 0;
102d5f08:	e5846004 	str	r6, [r4, #4]
        p->buffer = NULL;
102d5f0c:	e5846000 	str	r6, [r4]

        return NULL;
102d5f10:	e1a00006 	mov	r0, r6
102d5f14:	e8bd8070 	pop	{r4, r5, r6, pc}
102d5f18:	102e4840 	.word	0x102e4840
102d5f1c:	102df8c9 	.word	0x102df8c9
102d5f20:	102e48b8 	.word	0x102e48b8

102d5f24 <print_string_ptr.isra.2>:

    return NULL;
}

/* Render the cstring provided to an escaped version that can be printed. */
static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer, const internal_hooks * const hooks)
102d5f24:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    unsigned char *output_pointer = NULL;
    size_t output_length = 0;
    /* numbers of additional characters needed for escaping */
    size_t escape_characters = 0;

    if (output_buffer == NULL)
102d5f28:	e2518000 	subs	r8, r1, #0

    return NULL;
}

/* Render the cstring provided to an escaped version that can be printed. */
static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer, const internal_hooks * const hooks)
102d5f2c:	e24dd00c 	sub	sp, sp, #12
102d5f30:	e1a0a000 	mov	sl, r0
    unsigned char *output_pointer = NULL;
    size_t output_length = 0;
    /* numbers of additional characters needed for escaping */
    size_t escape_characters = 0;

    if (output_buffer == NULL)
102d5f34:	0a00006e 	beq	102d60f4 <print_string_ptr.isra.2+0x1d0>
    {
        return false;
    }

    /* empty string */
    if (input == NULL)
102d5f38:	e3500000 	cmp	r0, #0
102d5f3c:	0a000067 	beq	102d60e0 <print_string_ptr.isra.2+0x1bc>

        return true;
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
102d5f40:	e5d04000 	ldrb	r4, [r0]
102d5f44:	e3540000 	cmp	r4, #0
102d5f48:	0a00006b 	beq	102d60fc <print_string_ptr.isra.2+0x1d8>

    return NULL;
}

/* Render the cstring provided to an escaped version that can be printed. */
static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer, const internal_hooks * const hooks)
102d5f4c:	e2806001 	add	r6, r0, #1
102d5f50:	e59f9200 	ldr	r9, [pc, #512]	; 102d6158 <print_string_ptr.isra.2+0x234>
102d5f54:	e1a05006 	mov	r5, r6
102d5f58:	e3a07000 	mov	r7, #0
102d5f5c:	ea000003 	b	102d5f70 <print_string_ptr.isra.2+0x4c>

        return true;
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
102d5f60:	e1a03005 	mov	r3, r5
102d5f64:	e4d54001 	ldrb	r4, [r5], #1
102d5f68:	e3540000 	cmp	r4, #0
102d5f6c:	0a00000b 	beq	102d5fa0 <print_string_ptr.isra.2+0x7c>
    {
        if (strchr("\"\\\b\f\n\r\t", *input_pointer))
102d5f70:	e1a01004 	mov	r1, r4
102d5f74:	e59f01e0 	ldr	r0, [pc, #480]	; 102d615c <print_string_ptr.isra.2+0x238>
102d5f78:	e12fff39 	blx	r9
102d5f7c:	e3500000 	cmp	r0, #0
        {
            /* one character escape sequence */
            escape_characters++;
102d5f80:	12877001 	addne	r7, r7, #1
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
    {
        if (strchr("\"\\\b\f\n\r\t", *input_pointer))
102d5f84:	1afffff5 	bne	102d5f60 <print_string_ptr.isra.2+0x3c>
        {
            /* one character escape sequence */
            escape_characters++;
        }
        else if (*input_pointer < 32)
102d5f88:	e354001f 	cmp	r4, #31

        return true;
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
102d5f8c:	e1a03005 	mov	r3, r5
102d5f90:	e4d54001 	ldrb	r4, [r5], #1
            escape_characters++;
        }
        else if (*input_pointer < 32)
        {
            /* UTF-16 escape sequence uXXXX */
            escape_characters += 5;
102d5f94:	92877005 	addls	r7, r7, #5

        return true;
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
102d5f98:	e3540000 	cmp	r4, #0
102d5f9c:	1afffff3 	bne	102d5f70 <print_string_ptr.isra.2+0x4c>
        {
            /* UTF-16 escape sequence uXXXX */
            escape_characters += 5;
        }
    }
    output_length = (size_t)(input_pointer - input) + escape_characters;
102d5fa0:	e06a4003 	rsb	r4, sl, r3
102d5fa4:	e0844007 	add	r4, r4, r7

    output = ensure(output_buffer, output_length + sizeof("\"\""), hooks);
102d5fa8:	e1a00008 	mov	r0, r8
102d5fac:	e2841003 	add	r1, r4, #3
102d5fb0:	ebffffa7 	bl	102d5e54 <ensure.isra.0>
    if (output == NULL)
102d5fb4:	e2508000 	subs	r8, r0, #0
102d5fb8:	0a00004d 	beq	102d60f4 <print_string_ptr.isra.2+0x1d0>
    {
        return false;
    }

    /* no characters have to be escaped */
    if (escape_characters == 0)
102d5fbc:	e3570000 	cmp	r7, #0
102d5fc0:	0a000052 	beq	102d6110 <print_string_ptr.isra.2+0x1ec>
        output[output_length + 2] = '\0';

        return true;
    }

    output[0] = '\"';
102d5fc4:	e3a03022 	mov	r3, #34	; 0x22
102d5fc8:	e1a05008 	mov	r5, r8
102d5fcc:	e4c53001 	strb	r3, [r5], #1
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
102d5fd0:	e5da3000 	ldrb	r3, [sl]
102d5fd4:	e3530000 	cmp	r3, #0
102d5fd8:	0a000028 	beq	102d6080 <print_string_ptr.isra.2+0x15c>
                case '\t':
                    *output_pointer = 't';
                    break;
                default:
                    /* escape and print as unicode codepoint */
                    Ql_sprintf((char*)output_pointer, "u%04x", *input_pointer);
102d5fdc:	e59fc17c 	ldr	ip, [pc, #380]	; 102d6160 <print_string_ptr.isra.2+0x23c>
            *output_pointer = *input_pointer;
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
102d5fe0:	e3a0705c 	mov	r7, #92	; 0x5c
                    break;
                case '\b':
                    *output_pointer = 'b';
                    break;
                case '\f':
                    *output_pointer = 'f';
102d5fe4:	e3a0b066 	mov	fp, #102	; 0x66
                    break;
                case '\n':
                    *output_pointer = 'n';
                    break;
                case '\r':
                    *output_pointer = 'r';
102d5fe8:	e3a09072 	mov	r9, #114	; 0x72
                    break;
                case '\t':
                    *output_pointer = 't';
102d5fec:	e3a0a074 	mov	sl, #116	; 0x74
102d5ff0:	ea000007 	b	102d6014 <print_string_ptr.isra.2+0xf0>
    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
    {
        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
102d5ff4:	e353005c 	cmp	r3, #92	; 0x5c
102d5ff8:	0a000008 	beq	102d6020 <print_string_ptr.isra.2+0xfc>
        {
            /* normal character, copy */
            *output_pointer = *input_pointer;
102d5ffc:	e1a00005 	mov	r0, r5
102d6000:	e5c53000 	strb	r3, [r5]
    }

    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
102d6004:	e4d63001 	ldrb	r3, [r6], #1
102d6008:	e2805001 	add	r5, r0, #1
102d600c:	e3530000 	cmp	r3, #0
102d6010:	0a00001a 	beq	102d6080 <print_string_ptr.isra.2+0x15c>
    {
        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
102d6014:	e3530022 	cmp	r3, #34	; 0x22
102d6018:	1353001f 	cmpne	r3, #31
102d601c:	8afffff4 	bhi	102d5ff4 <print_string_ptr.isra.2+0xd0>
            *output_pointer = *input_pointer;
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
102d6020:	e1a00005 	mov	r0, r5
102d6024:	e4c07001 	strb	r7, [r0], #1
            switch (*input_pointer)
102d6028:	e5562001 	ldrb	r2, [r6, #-1]
102d602c:	e352000c 	cmp	r2, #12
                    break;
                case '\b':
                    *output_pointer = 'b';
                    break;
                case '\f':
                    *output_pointer = 'f';
102d6030:	05c5b001 	strbeq	fp, [r5, #1]
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
            switch (*input_pointer)
102d6034:	0afffff2 	beq	102d6004 <print_string_ptr.isra.2+0xe0>
102d6038:	8a000018 	bhi	102d60a0 <print_string_ptr.isra.2+0x17c>
102d603c:	e3520009 	cmp	r2, #9
                    break;
                case '\r':
                    *output_pointer = 'r';
                    break;
                case '\t':
                    *output_pointer = 't';
102d6040:	05c5a001 	strbeq	sl, [r5, #1]
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
            switch (*input_pointer)
102d6044:	0affffee 	beq	102d6004 <print_string_ptr.isra.2+0xe0>
102d6048:	e352000a 	cmp	r2, #10
102d604c:	0a000020 	beq	102d60d4 <print_string_ptr.isra.2+0x1b0>
102d6050:	e3520008 	cmp	r2, #8
102d6054:	0a00001b 	beq	102d60c8 <print_string_ptr.isra.2+0x1a4>
                case '\t':
                    *output_pointer = 't';
                    break;
                default:
                    /* escape and print as unicode codepoint */
                    Ql_sprintf((char*)output_pointer, "u%04x", *input_pointer);
102d6058:	e59c3000 	ldr	r3, [ip]
102d605c:	e59f1100 	ldr	r1, [pc, #256]	; 102d6164 <print_string_ptr.isra.2+0x240>
102d6060:	e58dc004 	str	ip, [sp, #4]
102d6064:	e12fff33 	blx	r3
    }

    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
102d6068:	e4d63001 	ldrb	r3, [r6], #1
                    *output_pointer = 't';
                    break;
                default:
                    /* escape and print as unicode codepoint */
                    Ql_sprintf((char*)output_pointer, "u%04x", *input_pointer);
                    output_pointer += 4;
102d606c:	e2850005 	add	r0, r5, #5
    }

    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
102d6070:	e3530000 	cmp	r3, #0
                    *output_pointer = 't';
                    break;
                default:
                    /* escape and print as unicode codepoint */
                    Ql_sprintf((char*)output_pointer, "u%04x", *input_pointer);
                    output_pointer += 4;
102d6074:	e59dc004 	ldr	ip, [sp, #4]
    }

    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
102d6078:	e2805001 	add	r5, r0, #1
102d607c:	1affffe4 	bne	102d6014 <print_string_ptr.isra.2+0xf0>
                    output_pointer += 4;
                    break;
            }
        }
    }
    output[output_length + 1] = '\"';
102d6080:	e0884004 	add	r4, r8, r4
102d6084:	e3a03022 	mov	r3, #34	; 0x22
102d6088:	e5c43001 	strb	r3, [r4, #1]
    output[output_length + 2] = '\0';

    return true;
102d608c:	e3a00001 	mov	r0, #1
                    break;
            }
        }
    }
    output[output_length + 1] = '\"';
    output[output_length + 2] = '\0';
102d6090:	e3a03000 	mov	r3, #0
102d6094:	e5c43002 	strb	r3, [r4, #2]

    return true;
}
102d6098:	e28dd00c 	add	sp, sp, #12
102d609c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
            switch (*input_pointer)
102d60a0:	e3520022 	cmp	r2, #34	; 0x22
102d60a4:	0a000005 	beq	102d60c0 <print_string_ptr.isra.2+0x19c>
102d60a8:	e352005c 	cmp	r2, #92	; 0x5c
102d60ac:	0a000003 	beq	102d60c0 <print_string_ptr.isra.2+0x19c>
102d60b0:	e352000d 	cmp	r2, #13
102d60b4:	1affffe7 	bne	102d6058 <print_string_ptr.isra.2+0x134>
                    break;
                case '\n':
                    *output_pointer = 'n';
                    break;
                case '\r':
                    *output_pointer = 'r';
102d60b8:	e5c59001 	strb	r9, [r5, #1]
102d60bc:	eaffffd0 	b	102d6004 <print_string_ptr.isra.2+0xe0>
            {
                case '\\':
                    *output_pointer = '\\';
                    break;
                case '\"':
                    *output_pointer = '\"';
102d60c0:	e5c52001 	strb	r2, [r5, #1]
102d60c4:	eaffffce 	b	102d6004 <print_string_ptr.isra.2+0xe0>
                    break;
                case '\b':
                    *output_pointer = 'b';
102d60c8:	e3a03062 	mov	r3, #98	; 0x62
102d60cc:	e5c53001 	strb	r3, [r5, #1]
102d60d0:	eaffffcb 	b	102d6004 <print_string_ptr.isra.2+0xe0>
                    break;
                case '\f':
                    *output_pointer = 'f';
                    break;
                case '\n':
                    *output_pointer = 'n';
102d60d4:	e3a0306e 	mov	r3, #110	; 0x6e
102d60d8:	e5c53001 	strb	r3, [r5, #1]
102d60dc:	eaffffc8 	b	102d6004 <print_string_ptr.isra.2+0xe0>
    }

    /* empty string */
    if (input == NULL)
    {
        output = ensure(output_buffer, sizeof("\"\""), hooks);
102d60e0:	e1a00008 	mov	r0, r8
102d60e4:	e3a01003 	mov	r1, #3
102d60e8:	ebffff59 	bl	102d5e54 <ensure.isra.0>
        if (output == NULL)
102d60ec:	e3500000 	cmp	r0, #0
102d60f0:	1a000013 	bne	102d6144 <print_string_ptr.isra.2+0x220>
    /* numbers of additional characters needed for escaping */
    size_t escape_characters = 0;

    if (output_buffer == NULL)
    {
        return false;
102d60f4:	e3a00000 	mov	r0, #0
102d60f8:	eaffffe6 	b	102d6098 <print_string_ptr.isra.2+0x174>
            escape_characters += 5;
        }
    }
    output_length = (size_t)(input_pointer - input) + escape_characters;

    output = ensure(output_buffer, output_length + sizeof("\"\""), hooks);
102d60fc:	e1a00008 	mov	r0, r8
102d6100:	e3a01003 	mov	r1, #3
102d6104:	ebffff52 	bl	102d5e54 <ensure.isra.0>
    if (output == NULL)
102d6108:	e2508000 	subs	r8, r0, #0
102d610c:	0afffff8 	beq	102d60f4 <print_string_ptr.isra.2+0x1d0>
    }

    /* no characters have to be escaped */
    if (escape_characters == 0)
    {
        output[0] = '\"';
102d6110:	e3a05022 	mov	r5, #34	; 0x22
102d6114:	e1a00008 	mov	r0, r8
        Ql_memcpy(output + 1, input, output_length);
102d6118:	e1a02004 	mov	r2, r4
102d611c:	e59f3044 	ldr	r3, [pc, #68]	; 102d6168 <print_string_ptr.isra.2+0x244>
    }

    /* no characters have to be escaped */
    if (escape_characters == 0)
    {
        output[0] = '\"';
102d6120:	e4c05001 	strb	r5, [r0], #1
        Ql_memcpy(output + 1, input, output_length);
102d6124:	e1a0100a 	mov	r1, sl
102d6128:	e12fff33 	blx	r3
        output[output_length + 1] = '\"';
102d612c:	e0884004 	add	r4, r8, r4
        output[output_length + 2] = '\0';
102d6130:	e3a03000 	mov	r3, #0
    /* no characters have to be escaped */
    if (escape_characters == 0)
    {
        output[0] = '\"';
        Ql_memcpy(output + 1, input, output_length);
        output[output_length + 1] = '\"';
102d6134:	e5c45001 	strb	r5, [r4, #1]
        output[output_length + 2] = '\0';
102d6138:	e5c43002 	strb	r3, [r4, #2]

        return true;
102d613c:	e3a00001 	mov	r0, #1
102d6140:	eaffffd4 	b	102d6098 <print_string_ptr.isra.2+0x174>
        output = ensure(output_buffer, sizeof("\"\""), hooks);
        if (output == NULL)
        {
            return false;
        }
        Ql_strcpy((char*)output, "\"\"");
102d6144:	e59f1020 	ldr	r1, [pc, #32]	; 102d616c <print_string_ptr.isra.2+0x248>
102d6148:	e59f3020 	ldr	r3, [pc, #32]	; 102d6170 <print_string_ptr.isra.2+0x24c>
102d614c:	e12fff33 	blx	r3

        return true;
102d6150:	e3a00001 	mov	r0, #1
102d6154:	eaffffcf 	b	102d6098 <print_string_ptr.isra.2+0x174>
102d6158:	102dfe6d 	.word	0x102dfe6d
102d615c:	102ef8cc 	.word	0x102ef8cc
102d6160:	f03de540 	.word	0xf03de540
102d6164:	102ef8d4 	.word	0x102ef8d4
102d6168:	102e597c 	.word	0x102e597c
102d616c:	102ef8c8 	.word	0x102ef8c8
102d6170:	102e55fc 	.word	0x102e55fc

102d6174 <print_value.constprop.8>:
/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, const size_t depth, const cJSON_bool format,  printbuffer * const output_buffer, const internal_hooks * const hooks)
{
    unsigned char *output = NULL;
	//APP_DEBUG("\r--> INSIDE FUN : %s\r\n",__FUNCTION__);
    if ((item == NULL) || (output_buffer == NULL))
102d6174:	e3500000 	cmp	r0, #0
102d6178:	13530000 	cmpne	r3, #0
    *error_pointer = input;
    return NULL;
}

/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, const size_t depth, const cJSON_bool format,  printbuffer * const output_buffer, const internal_hooks * const hooks)
102d617c:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
    unsigned char *output = NULL;
	//APP_DEBUG("\r--> INSIDE FUN : %s\r\n",__FUNCTION__);
    if ((item == NULL) || (output_buffer == NULL))
102d6180:	e1a0b003 	mov	fp, r3
102d6184:	e1a05000 	mov	r5, r0
102d6188:	13a06000 	movne	r6, #0
102d618c:	03a06001 	moveq	r6, #1
    *error_pointer = input;
    return NULL;
}

/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, const size_t depth, const cJSON_bool format,  printbuffer * const output_buffer, const internal_hooks * const hooks)
102d6190:	e1a0a001 	mov	sl, r1
102d6194:	e1a04002 	mov	r4, r2
{
    unsigned char *output = NULL;
	//APP_DEBUG("\r--> INSIDE FUN : %s\r\n",__FUNCTION__);
    if ((item == NULL) || (output_buffer == NULL))
102d6198:	0a00002a 	beq	102d6248 <print_value.constprop.8+0xd4>
    {
    	APP_DEBUG("\r(item == NULL) || (output_buffer == NULL)\r\n");
        return false;
    }

    switch ((item->type) & 0xFF)
102d619c:	e5d0700c 	ldrb	r7, [r0, #12]
102d61a0:	e3570008 	cmp	r7, #8
102d61a4:	0a0000fd 	beq	102d65a0 <print_value.constprop.8+0x42c>
102d61a8:	da000016 	ble	102d6208 <print_value.constprop.8+0x94>
102d61ac:	e3570020 	cmp	r7, #32
102d61b0:	0a000048 	beq	102d62d8 <print_value.constprop.8+0x164>
102d61b4:	da000037 	ble	102d6298 <print_value.constprop.8+0x124>
102d61b8:	e3570040 	cmp	r7, #64	; 0x40
102d61bc:	0a000080 	beq	102d63c4 <print_value.constprop.8+0x250>
102d61c0:	e3570080 	cmp	r7, #128	; 0x80
102d61c4:	1a000031 	bne	102d6290 <print_value.constprop.8+0x11c>
            return print_number(item, output_buffer, hooks);

        case cJSON_Raw:
        {
            size_t raw_length = 0;
            if (item->valuestring == NULL)
102d61c8:	e5900010 	ldr	r0, [r0, #16]
102d61cc:	e3500000 	cmp	r0, #0
102d61d0:	0a000145 	beq	102d66ec <print_value.constprop.8+0x578>
                }
            	//APP_DEBUG("\r Error 1: in cJSON_Raw\r\n");
                return false;
            }

            raw_length = Ql_strlen(item->valuestring) + sizeof('\0');
102d61d4:	e59f3610 	ldr	r3, [pc, #1552]	; 102d67ec <print_value.constprop.8+0x678>
102d61d8:	e12fff33 	blx	r3
102d61dc:	e2804004 	add	r4, r0, #4
            output = ensure(output_buffer, raw_length, hooks);
102d61e0:	e1a01004 	mov	r1, r4
102d61e4:	e1a0000b 	mov	r0, fp
102d61e8:	ebffff19 	bl	102d5e54 <ensure.isra.0>
            if (output == NULL)
102d61ec:	e3500000 	cmp	r0, #0
102d61f0:	0a000026 	beq	102d6290 <print_value.constprop.8+0x11c>
            {
            	//APP_DEBUG("\r Error 1: in cJSON_Raw\r\n");
                return false;
            }
            Ql_memcpy(output, item->valuestring, raw_length);
102d61f4:	e5951010 	ldr	r1, [r5, #16]
102d61f8:	e1a02004 	mov	r2, r4
102d61fc:	e59f35ec 	ldr	r3, [pc, #1516]	; 102d67f0 <print_value.constprop.8+0x67c>
102d6200:	e12fff33 	blx	r3
102d6204:	ea00012f 	b	102d66c8 <print_value.constprop.8+0x554>
    {
    	APP_DEBUG("\r(item == NULL) || (output_buffer == NULL)\r\n");
        return false;
    }

    switch ((item->type) & 0xFF)
102d6208:	e3570002 	cmp	r7, #2
102d620c:	0a0000d9 	beq	102d6578 <print_value.constprop.8+0x404>
102d6210:	e3570004 	cmp	r7, #4
102d6214:	0a000025 	beq	102d62b0 <print_value.constprop.8+0x13c>
102d6218:	e3570001 	cmp	r7, #1
102d621c:	1a00001b 	bne	102d6290 <print_value.constprop.8+0x11c>
            }
            Ql_strcpy((char*)output, "null");
            return true;

        case cJSON_False:
            output = ensure(output_buffer, 6, hooks);
102d6220:	e1a00003 	mov	r0, r3
102d6224:	e3a01006 	mov	r1, #6
102d6228:	ebffff09 	bl	102d5e54 <ensure.isra.0>
            if (output == NULL)
102d622c:	e3500000 	cmp	r0, #0
102d6230:	0a000016 	beq	102d6290 <print_value.constprop.8+0x11c>
            {
            //	APP_DEBUG("\r Error : in cJSON_False\r\n");
                return false;
            }
            Ql_strcpy((char*)output, "false");
102d6234:	e59f15b8 	ldr	r1, [pc, #1464]	; 102d67f4 <print_value.constprop.8+0x680>
102d6238:	e59f35b8 	ldr	r3, [pc, #1464]	; 102d67f8 <print_value.constprop.8+0x684>
102d623c:	e12fff33 	blx	r3
            return true;
102d6240:	e1a00007 	mov	r0, r7
102d6244:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
    unsigned char *output = NULL;
	//APP_DEBUG("\r--> INSIDE FUN : %s\r\n",__FUNCTION__);
    if ((item == NULL) || (output_buffer == NULL))
    {
    	APP_DEBUG("\r(item == NULL) || (output_buffer == NULL)\r\n");
102d6248:	e3a02c02 	mov	r2, #512	; 0x200
102d624c:	e3a01000 	mov	r1, #0
102d6250:	e59f35a4 	ldr	r3, [pc, #1444]	; 102d67fc <print_value.constprop.8+0x688>
102d6254:	e59f05a4 	ldr	r0, [pc, #1444]	; 102d6800 <print_value.constprop.8+0x68c>
102d6258:	e12fff33 	blx	r3
102d625c:	e59f35a0 	ldr	r3, [pc, #1440]	; 102d6804 <print_value.constprop.8+0x690>
102d6260:	e59f15a0 	ldr	r1, [pc, #1440]	; 102d6808 <print_value.constprop.8+0x694>
102d6264:	e5933000 	ldr	r3, [r3]
102d6268:	e59f0590 	ldr	r0, [pc, #1424]	; 102d6800 <print_value.constprop.8+0x68c>
102d626c:	e12fff33 	blx	r3
102d6270:	e59f3574 	ldr	r3, [pc, #1396]	; 102d67ec <print_value.constprop.8+0x678>
102d6274:	e59f0584 	ldr	r0, [pc, #1412]	; 102d6800 <print_value.constprop.8+0x68c>
102d6278:	e12fff33 	blx	r3
102d627c:	e59f157c 	ldr	r1, [pc, #1404]	; 102d6800 <print_value.constprop.8+0x68c>
102d6280:	e59f3584 	ldr	r3, [pc, #1412]	; 102d680c <print_value.constprop.8+0x698>
102d6284:	e1a02000 	mov	r2, r0
102d6288:	e3a0000a 	mov	r0, #10
102d628c:	e12fff33 	blx	r3
        return false;
102d6290:	e3a00000 	mov	r0, #0
102d6294:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }

    switch ((item->type) & 0xFF)
102d6298:	e3570010 	cmp	r7, #16
102d629c:	1afffffb 	bne	102d6290 <print_value.constprop.8+0x11c>
}

/* Invoke print_string_ptr (which is useful) on an item. */
static cJSON_bool print_string(const cJSON * const item, printbuffer * const p, const internal_hooks * const hooks)
{
    return print_string_ptr((unsigned char*)item->valuestring, p, hooks);
102d62a0:	e1a01003 	mov	r1, r3
102d62a4:	e5900010 	ldr	r0, [r0, #16]

        default:
        	//APP_DEBUG("\r Error : default\r\n");
            return false;
    }
}
102d62a8:	e8bd4ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
}

/* Invoke print_string_ptr (which is useful) on an item. */
static cJSON_bool print_string(const cJSON * const item, printbuffer * const p, const internal_hooks * const hooks)
{
    return print_string_ptr((unsigned char*)item->valuestring, p, hooks);
102d62ac:	eaffff1c 	b	102d5f24 <print_string_ptr.isra.2>
    }

    switch ((item->type) & 0xFF)
    {
        case cJSON_NULL:
            output = ensure(output_buffer, 5, hooks);
102d62b0:	e1a00003 	mov	r0, r3
102d62b4:	e3a01005 	mov	r1, #5
102d62b8:	ebfffee5 	bl	102d5e54 <ensure.isra.0>
            if (output == NULL)
102d62bc:	e3500000 	cmp	r0, #0
102d62c0:	0afffff2 	beq	102d6290 <print_value.constprop.8+0x11c>
            {
            //	APP_DEBUG("\r Error : in cJSON_NULL\r\n");
                return false;
            }
            Ql_strcpy((char*)output, "null");
102d62c4:	e59f1544 	ldr	r1, [pc, #1348]	; 102d6810 <print_value.constprop.8+0x69c>
102d62c8:	e59f3528 	ldr	r3, [pc, #1320]	; 102d67f8 <print_value.constprop.8+0x684>
102d62cc:	e12fff33 	blx	r3
            return true;
102d62d0:	e3a00001 	mov	r0, #1
102d62d4:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return false;
    }

    /* Compose the output array. */
    /* opening square bracket */
    output_pointer = ensure(output_buffer, 1, hooks);
102d62d8:	e1a00003 	mov	r0, r3
102d62dc:	e3a01001 	mov	r1, #1
/* Render an array to text */
static cJSON_bool print_array(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks)
{
    unsigned char *output_pointer = NULL;
    size_t length = 0;
    cJSON *current_element = item->child;
102d62e0:	e5955008 	ldr	r5, [r5, #8]
        return false;
    }

    /* Compose the output array. */
    /* opening square bracket */
    output_pointer = ensure(output_buffer, 1, hooks);
102d62e4:	ebfffeda 	bl	102d5e54 <ensure.isra.0>
    if (output_pointer == NULL)
102d62e8:	e3500000 	cmp	r0, #0
102d62ec:	0affffe7 	beq	102d6290 <print_value.constprop.8+0x11c>
    {
        return false;
    }

    *output_pointer = '[';
102d62f0:	e3a0305b 	mov	r3, #91	; 0x5b
102d62f4:	e5c03000 	strb	r3, [r0]
    output_buffer->offset++;
102d62f8:	e59b3008 	ldr	r3, [fp, #8]

    while (current_element != NULL)
102d62fc:	e3550000 	cmp	r5, #0
    {
        return false;
    }

    *output_pointer = '[';
    output_buffer->offset++;
102d6300:	e2833001 	add	r3, r3, #1
102d6304:	e58b3008 	str	r3, [fp, #8]
102d6308:	128aa001 	addne	sl, sl, #1
            output_pointer = ensure(output_buffer, length + 1, hooks);
            if (output_pointer == NULL)
            {
                return false;
            }
            *output_pointer++ = ',';
102d630c:	13a0902c 	movne	r9, #44	; 0x2c
    }

    *output_pointer = '[';
    output_buffer->offset++;

    while (current_element != NULL)
102d6310:	0a000020 	beq	102d6398 <print_value.constprop.8+0x224>
    {
        if (!print_value(current_element, depth + 1, format, output_buffer, hooks))
102d6314:	e1a0100a 	mov	r1, sl
102d6318:	e1a02004 	mov	r2, r4
102d631c:	e1a0300b 	mov	r3, fp
102d6320:	e1a00005 	mov	r0, r5
102d6324:	ebffff92 	bl	102d6174 <print_value.constprop.8>
102d6328:	e3500000 	cmp	r0, #0
        {
            return false;
        }
        update_offset(output_buffer);
102d632c:	e1a0000b 	mov	r0, fp
    *output_pointer = '[';
    output_buffer->offset++;

    while (current_element != NULL)
    {
        if (!print_value(current_element, depth + 1, format, output_buffer, hooks))
102d6330:	0affffd6 	beq	102d6290 <print_value.constprop.8+0x11c>
        {
            return false;
        }
        update_offset(output_buffer);
102d6334:	ebfffeb8 	bl	102d5e1c <update_offset>
        if (current_element->next)
102d6338:	e5953000 	ldr	r3, [r5]
        {
            length = format ? 2 : 1;
            output_pointer = ensure(output_buffer, length + 1, hooks);
102d633c:	e1a0000b 	mov	r0, fp
        if (!print_value(current_element, depth + 1, format, output_buffer, hooks))
        {
            return false;
        }
        update_offset(output_buffer);
        if (current_element->next)
102d6340:	e3530000 	cmp	r3, #0
102d6344:	0a000013 	beq	102d6398 <print_value.constprop.8+0x224>
        {
            length = format ? 2 : 1;
102d6348:	e3540000 	cmp	r4, #0
            output_pointer = ensure(output_buffer, length + 1, hooks);
102d634c:	03a01002 	moveq	r1, #2
102d6350:	13a01003 	movne	r1, #3
            return false;
        }
        update_offset(output_buffer);
        if (current_element->next)
        {
            length = format ? 2 : 1;
102d6354:	03a08001 	moveq	r8, #1
102d6358:	13a08002 	movne	r8, #2
            output_pointer = ensure(output_buffer, length + 1, hooks);
102d635c:	ebfffebc 	bl	102d5e54 <ensure.isra.0>
            if (output_pointer == NULL)
102d6360:	e3500000 	cmp	r0, #0
            {
                return false;
            }
            *output_pointer++ = ',';
102d6364:	e2803001 	add	r3, r0, #1
        update_offset(output_buffer);
        if (current_element->next)
        {
            length = format ? 2 : 1;
            output_pointer = ensure(output_buffer, length + 1, hooks);
            if (output_pointer == NULL)
102d6368:	0affffc8 	beq	102d6290 <print_value.constprop.8+0x11c>
            {
                return false;
            }
            *output_pointer++ = ',';
            if(format)
102d636c:	e3540000 	cmp	r4, #0
            {
                *output_pointer++ = ' ';
102d6370:	12803002 	addne	r3, r0, #2
102d6374:	15c07001 	strbne	r7, [r0, #1]
            output_pointer = ensure(output_buffer, length + 1, hooks);
            if (output_pointer == NULL)
            {
                return false;
            }
            *output_pointer++ = ',';
102d6378:	e5c09000 	strb	r9, [r0]
            if(format)
            {
                *output_pointer++ = ' ';
            }
            *output_pointer = '\0';
102d637c:	e5c36000 	strb	r6, [r3]
            output_buffer->offset += length;
102d6380:	e59b3008 	ldr	r3, [fp, #8]
        }
        current_element = current_element->next;
102d6384:	e5955000 	ldr	r5, [r5]
            if(format)
            {
                *output_pointer++ = ' ';
            }
            *output_pointer = '\0';
            output_buffer->offset += length;
102d6388:	e0838008 	add	r8, r3, r8
    }

    *output_pointer = '[';
    output_buffer->offset++;

    while (current_element != NULL)
102d638c:	e3550000 	cmp	r5, #0
            if(format)
            {
                *output_pointer++ = ' ';
            }
            *output_pointer = '\0';
            output_buffer->offset += length;
102d6390:	e58b8008 	str	r8, [fp, #8]
    }

    *output_pointer = '[';
    output_buffer->offset++;

    while (current_element != NULL)
102d6394:	1affffde 	bne	102d6314 <print_value.constprop.8+0x1a0>
            output_buffer->offset += length;
        }
        current_element = current_element->next;
    }

    output_pointer = ensure(output_buffer, 2, hooks);
102d6398:	e1a0000b 	mov	r0, fp
102d639c:	e3a01002 	mov	r1, #2
102d63a0:	ebfffeab 	bl	102d5e54 <ensure.isra.0>
    if (output_pointer == NULL)
102d63a4:	e3500000 	cmp	r0, #0
102d63a8:	0affffb8 	beq	102d6290 <print_value.constprop.8+0x11c>
    {
        return false;
    }
    *output_pointer++ = ']';
102d63ac:	e3a0305d 	mov	r3, #93	; 0x5d
102d63b0:	e5c03000 	strb	r3, [r0]
    *output_pointer = '\0';
102d63b4:	e3a03000 	mov	r3, #0
102d63b8:	e5c03001 	strb	r3, [r0, #1]

    return true;
102d63bc:	e3a00001 	mov	r0, #1
102d63c0:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
        return false;
    }

    /* Compose the output: */
    length = format ? 2 : 1; /* fmt: {\n */
102d63c4:	e3520000 	cmp	r2, #0
    output_pointer = ensure(output_buffer, length + 1, hooks);
102d63c8:	03a01002 	moveq	r1, #2
102d63cc:	13a01003 	movne	r1, #3
102d63d0:	e1a00003 	mov	r0, r3
    {
        return false;
    }

    /* Compose the output: */
    length = format ? 2 : 1; /* fmt: {\n */
102d63d4:	03a06001 	moveq	r6, #1
102d63d8:	13a06002 	movne	r6, #2
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks)
{
	//APP_DEBUG("inside cJSON_Object\r\n");
    unsigned char *output_pointer = NULL;
    size_t length = 0;
    cJSON *current_item = item->child;
102d63dc:	e5955008 	ldr	r5, [r5, #8]
        return false;
    }

    /* Compose the output: */
    length = format ? 2 : 1; /* fmt: {\n */
    output_pointer = ensure(output_buffer, length + 1, hooks);
102d63e0:	ebfffe9b 	bl	102d5e54 <ensure.isra.0>
    if (output_pointer == NULL)
102d63e4:	e3500000 	cmp	r0, #0
102d63e8:	0affffa8 	beq	102d6290 <print_value.constprop.8+0x11c>
    {
        return false;
    }
	//APP_DEBUG("inside output_pointer\r\n");
    *output_pointer++ = '{';
102d63ec:	e3a0307b 	mov	r3, #123	; 0x7b
    if (format)
102d63f0:	e3540000 	cmp	r4, #0
    if (output_pointer == NULL)
    {
        return false;
    }
	//APP_DEBUG("inside output_pointer\r\n");
    *output_pointer++ = '{';
102d63f4:	e5c03000 	strb	r3, [r0]
    if (format)
    {
        *output_pointer++ = '\n';
102d63f8:	13a0300a 	movne	r3, #10
102d63fc:	15c03001 	strbne	r3, [r0, #1]
    }
    output_buffer->offset += length;
102d6400:	e59b3008 	ldr	r3, [fp, #8]

    while (current_item)
102d6404:	e3550000 	cmp	r5, #0
    *output_pointer++ = '{';
    if (format)
    {
        *output_pointer++ = '\n';
    }
    output_buffer->offset += length;
102d6408:	e0836006 	add	r6, r3, r6
102d640c:	e58b6008 	str	r6, [fp, #8]
    {
        if (format)
        {
			//APP_DEBUG("format\r\n");
            size_t i;
            output_pointer = ensure(output_buffer, depth + 1, hooks);
102d6410:	128a8001 	addne	r8, sl, #1
            {
                return false;
            }
            for (i = 0; i < depth + 1; i++)
            {
                *output_pointer++ = '\t';
102d6414:	13a06009 	movne	r6, #9
    {
        *output_pointer++ = '\n';
    }
    output_buffer->offset += length;

    while (current_item)
102d6418:	0a000049 	beq	102d6544 <print_value.constprop.8+0x3d0>
    {
        if (format)
102d641c:	e3540000 	cmp	r4, #0
102d6420:	0a00000e 	beq	102d6460 <print_value.constprop.8+0x2ec>
        {
			//APP_DEBUG("format\r\n");
            size_t i;
            output_pointer = ensure(output_buffer, depth + 1, hooks);
102d6424:	e1a0000b 	mov	r0, fp
102d6428:	e1a01008 	mov	r1, r8
102d642c:	ebfffe88 	bl	102d5e54 <ensure.isra.0>
            if (output_pointer == NULL)
102d6430:	e3500000 	cmp	r0, #0
102d6434:	0affff95 	beq	102d6290 <print_value.constprop.8+0x11c>
            {
                return false;
            }
            for (i = 0; i < depth + 1; i++)
102d6438:	e3580000 	cmp	r8, #0
    *error_pointer = input;
    return NULL;
}

/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, const size_t depth, const cJSON_bool format,  printbuffer * const output_buffer, const internal_hooks * const hooks)
102d643c:	10803008 	addne	r3, r0, r8
            output_pointer = ensure(output_buffer, depth + 1, hooks);
            if (output_pointer == NULL)
            {
                return false;
            }
            for (i = 0; i < depth + 1; i++)
102d6440:	0a000002 	beq	102d6450 <print_value.constprop.8+0x2dc>
            {
                *output_pointer++ = '\t';
102d6444:	e4c06001 	strb	r6, [r0], #1
            output_pointer = ensure(output_buffer, depth + 1, hooks);
            if (output_pointer == NULL)
            {
                return false;
            }
            for (i = 0; i < depth + 1; i++)
102d6448:	e1500003 	cmp	r0, r3
102d644c:	1afffffc 	bne	102d6444 <print_value.constprop.8+0x2d0>
            {
                *output_pointer++ = '\t';
            }
            output_buffer->offset += depth + 1;
102d6450:	e59b3008 	ldr	r3, [fp, #8]
102d6454:	e2833001 	add	r3, r3, #1
102d6458:	e083300a 	add	r3, r3, sl
102d645c:	e58b3008 	str	r3, [fp, #8]
        }
		
        /* print key */
        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer, hooks))
102d6460:	e5950020 	ldr	r0, [r5, #32]
102d6464:	e1a0100b 	mov	r1, fp
102d6468:	ebfffead 	bl	102d5f24 <print_string_ptr.isra.2>
102d646c:	e3500000 	cmp	r0, #0
102d6470:	0affff86 	beq	102d6290 <print_value.constprop.8+0x11c>
        {
            return false;
        }
        update_offset(output_buffer);

        length = format ? 2 : 1;
102d6474:	e3540000 	cmp	r4, #0
102d6478:	03a07001 	moveq	r7, #1
102d647c:	13a07002 	movne	r7, #2
        /* print key */
        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer, hooks))
        {
            return false;
        }
        update_offset(output_buffer);
102d6480:	e1a0000b 	mov	r0, fp
102d6484:	ebfffe64 	bl	102d5e1c <update_offset>

        length = format ? 2 : 1;
        output_pointer = ensure(output_buffer, length, hooks);
102d6488:	e1a0000b 	mov	r0, fp
102d648c:	e1a01007 	mov	r1, r7
102d6490:	ebfffe6f 	bl	102d5e54 <ensure.isra.0>
        if (output_pointer == NULL)
102d6494:	e3500000 	cmp	r0, #0
102d6498:	0affff7c 	beq	102d6290 <print_value.constprop.8+0x11c>
        {
            return false;
        }
        *output_pointer++ = ':';
102d649c:	e3a0303a 	mov	r3, #58	; 0x3a
102d64a0:	e5c03000 	strb	r3, [r0]
        if (format)
102d64a4:	e3540000 	cmp	r4, #0
        {
            *output_pointer++ = '\t';
102d64a8:	15c06001 	strbne	r6, [r0, #1]
        }
        output_buffer->offset += length;
102d64ac:	e59b3008 	ldr	r3, [fp, #8]

        /* print value */
        if (!print_value(current_item, depth + 1, format, output_buffer, hooks))
102d64b0:	e1a00005 	mov	r0, r5
        *output_pointer++ = ':';
        if (format)
        {
            *output_pointer++ = '\t';
        }
        output_buffer->offset += length;
102d64b4:	e0837007 	add	r7, r3, r7
102d64b8:	e58b7008 	str	r7, [fp, #8]

        /* print value */
        if (!print_value(current_item, depth + 1, format, output_buffer, hooks))
102d64bc:	e1a01008 	mov	r1, r8
102d64c0:	e1a02004 	mov	r2, r4
102d64c4:	e1a0300b 	mov	r3, fp
102d64c8:	ebffff29 	bl	102d6174 <print_value.constprop.8>
102d64cc:	e3500000 	cmp	r0, #0
102d64d0:	0affff6e 	beq	102d6290 <print_value.constprop.8+0x11c>
        {
            return false;
        }
        update_offset(output_buffer);
102d64d4:	e1a0000b 	mov	r0, fp
102d64d8:	ebfffe4f 	bl	102d5e1c <update_offset>

        /* print comma if not last */
        length = (size_t) (format ? 1 : 0) + (current_item->next ? 1 : 0);
102d64dc:	e2949000 	adds	r9, r4, #0
102d64e0:	e5957000 	ldr	r7, [r5]
102d64e4:	13a09001 	movne	r9, #1
102d64e8:	e3570000 	cmp	r7, #0
102d64ec:	01a07009 	moveq	r7, r9
102d64f0:	12897001 	addne	r7, r9, #1
        output_pointer = ensure(output_buffer, length + 1, hooks);
102d64f4:	e1a0000b 	mov	r0, fp
102d64f8:	e2871001 	add	r1, r7, #1
102d64fc:	ebfffe54 	bl	102d5e54 <ensure.isra.0>
        if (output_pointer == NULL)
102d6500:	e3500000 	cmp	r0, #0
102d6504:	0affff61 	beq	102d6290 <print_value.constprop.8+0x11c>
        {
            return false;
        }
        if (current_item->next)
102d6508:	e5953000 	ldr	r3, [r5]
102d650c:	e3530000 	cmp	r3, #0
        {
            *output_pointer++ = ',';
102d6510:	13a0302c 	movne	r3, #44	; 0x2c
102d6514:	14c03001 	strbne	r3, [r0], #1
        }

        if (format)
102d6518:	e3590000 	cmp	r9, #0
        {
            *output_pointer++ = '\n';
102d651c:	13a0300a 	movne	r3, #10
102d6520:	14c03001 	strbne	r3, [r0], #1
        }
        *output_pointer = '\0';
102d6524:	e3a03000 	mov	r3, #0
102d6528:	e5c03000 	strb	r3, [r0]
        output_buffer->offset += length;
102d652c:	e59b3008 	ldr	r3, [fp, #8]

        current_item = current_item->next;
102d6530:	e5955000 	ldr	r5, [r5]
        if (format)
        {
            *output_pointer++ = '\n';
        }
        *output_pointer = '\0';
        output_buffer->offset += length;
102d6534:	e0837007 	add	r7, r3, r7
    {
        *output_pointer++ = '\n';
    }
    output_buffer->offset += length;

    while (current_item)
102d6538:	e3550000 	cmp	r5, #0
        if (format)
        {
            *output_pointer++ = '\n';
        }
        *output_pointer = '\0';
        output_buffer->offset += length;
102d653c:	e58b7008 	str	r7, [fp, #8]
    {
        *output_pointer++ = '\n';
    }
    output_buffer->offset += length;

    while (current_item)
102d6540:	1affffb5 	bne	102d641c <print_value.constprop.8+0x2a8>
        output_buffer->offset += length;

        current_item = current_item->next;
    }
	//APP_DEBUG("OUT format\r\n");
    output_pointer = ensure(output_buffer, format ? (depth + 2) : 2, hooks);
102d6544:	e3540000 	cmp	r4, #0
102d6548:	1a000090 	bne	102d6790 <print_value.constprop.8+0x61c>
102d654c:	e1a0000b 	mov	r0, fp
102d6550:	e3a01002 	mov	r1, #2
102d6554:	ebfffe3e 	bl	102d5e54 <ensure.isra.0>
    if (output_pointer == NULL)
102d6558:	e3500000 	cmp	r0, #0
102d655c:	0affff4b 	beq	102d6290 <print_value.constprop.8+0x11c>
        {
            *output_pointer++ = '\t';
        }
    }
	//APP_DEBUG("out format2\r\n");
    *output_pointer++ = '}';
102d6560:	e3a0307d 	mov	r3, #125	; 0x7d
102d6564:	e5c03000 	strb	r3, [r0]
    *output_pointer = '\0';
102d6568:	e3a03000 	mov	r3, #0
102d656c:	e5c03001 	strb	r3, [r0, #1]
	//APP_DEBUG("out\r\n");
    return true;
102d6570:	e3a00001 	mov	r0, #1
102d6574:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            }
            Ql_strcpy((char*)output, "false");
            return true;

        case cJSON_True:
            output = ensure(output_buffer, 5, hooks);
102d6578:	e1a00003 	mov	r0, r3
102d657c:	e3a01005 	mov	r1, #5
102d6580:	ebfffe33 	bl	102d5e54 <ensure.isra.0>
            if (output == NULL)
102d6584:	e3500000 	cmp	r0, #0
102d6588:	0affff40 	beq	102d6290 <print_value.constprop.8+0x11c>
            {
            //   	APP_DEBUG("\r Error : in cJSON_True\r\n");
                return false;
            }
            Ql_strcpy((char*)output, "true");
102d658c:	e59f1280 	ldr	r1, [pc, #640]	; 102d6814 <print_value.constprop.8+0x6a0>
102d6590:	e59f3260 	ldr	r3, [pc, #608]	; 102d67f8 <print_value.constprop.8+0x684>
102d6594:	e12fff33 	blx	r3
            return true;
102d6598:	e3a00001 	mov	r0, #1
102d659c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
        return false;
    }

    /* This is a nice tradeoff. */
    output_pointer = ensure(output_buffer, 64, hooks);
102d65a0:	e1a00003 	mov	r0, r3
102d65a4:	e3a01040 	mov	r1, #64	; 0x40

/* Render the number nicely from the given item into a string. */
static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer, const internal_hooks * const hooks)
{
    unsigned char *output_pointer = NULL;
    double d = item->valuedouble;
102d65a8:	e5957018 	ldr	r7, [r5, #24]
102d65ac:	e595801c 	ldr	r8, [r5, #28]
    {
        return false;
    }

    /* This is a nice tradeoff. */
    output_pointer = ensure(output_buffer, 64, hooks);
102d65b0:	ebfffe27 	bl	102d5e54 <ensure.isra.0>
    if (output_pointer == NULL)
102d65b4:	e250a000 	subs	sl, r0, #0
102d65b8:	0affff34 	beq	102d6290 <print_value.constprop.8+0x11c>
    {
        return false;
    }

    /* This checks for NaN and Infinity */
    if ((d * 0) != 0)
102d65bc:	e3a02000 	mov	r2, #0
102d65c0:	e3a03000 	mov	r3, #0
102d65c4:	e59f424c 	ldr	r4, [pc, #588]	; 102d6818 <print_value.constprop.8+0x6a4>
102d65c8:	e1a00007 	mov	r0, r7
102d65cc:	e1a01008 	mov	r1, r8
102d65d0:	e12fff34 	blx	r4
102d65d4:	e3a02000 	mov	r2, #0
102d65d8:	e3a03000 	mov	r3, #0
102d65dc:	e59f4238 	ldr	r4, [pc, #568]	; 102d681c <print_value.constprop.8+0x6a8>
102d65e0:	e12fff34 	blx	r4
102d65e4:	e3500000 	cmp	r0, #0
102d65e8:	0a000038 	beq	102d66d0 <print_value.constprop.8+0x55c>
    {
        length = Ql_sprintf((char*)output_pointer, "null");
    }
    else if ((fabs(floor(d) - d) <= DBL_EPSILON) && (fabs(d) < 1.0e60))
102d65ec:	e59f322c 	ldr	r3, [pc, #556]	; 102d6820 <print_value.constprop.8+0x6ac>
102d65f0:	e1a00007 	mov	r0, r7
102d65f4:	e1a01008 	mov	r1, r8
102d65f8:	e12fff33 	blx	r3
102d65fc:	e59f4220 	ldr	r4, [pc, #544]	; 102d6824 <print_value.constprop.8+0x6b0>
102d6600:	e1a02007 	mov	r2, r7
102d6604:	e1a03008 	mov	r3, r8
102d6608:	e12fff34 	blx	r4
102d660c:	e3a02000 	mov	r2, #0
102d6610:	e59f3210 	ldr	r3, [pc, #528]	; 102d6828 <print_value.constprop.8+0x6b4>
102d6614:	e59f4210 	ldr	r4, [pc, #528]	; 102d682c <print_value.constprop.8+0x6b8>
102d6618:	e3c15102 	bic	r5, r1, #-2147483648	; 0x80000000
102d661c:	e1a01005 	mov	r1, r5
102d6620:	e12fff34 	blx	r4
102d6624:	e3500000 	cmp	r0, #0
102d6628:	0a000038 	beq	102d6710 <print_value.constprop.8+0x59c>
102d662c:	e3c84102 	bic	r4, r8, #-2147483648	; 0x80000000
102d6630:	e1a00007 	mov	r0, r7
102d6634:	e1a01004 	mov	r1, r4
102d6638:	e59f51f0 	ldr	r5, [pc, #496]	; 102d6830 <print_value.constprop.8+0x6bc>
102d663c:	e59f21f0 	ldr	r2, [pc, #496]	; 102d6834 <print_value.constprop.8+0x6c0>
102d6640:	e59f31f0 	ldr	r3, [pc, #496]	; 102d6838 <print_value.constprop.8+0x6c4>
102d6644:	e12fff35 	blx	r5
102d6648:	e3500000 	cmp	r0, #0
102d664c:	1a00005c 	bne	102d67c4 <print_value.constprop.8+0x650>
    {
        /* integer */
        length = Ql_sprintf((char*)output_pointer, "%.0f", d);
        trim_zeroes = false; /* don't remove zeroes for "big integers" */
    }
    else if ((fabs(d) < 1.0e-6) || (fabs(d) > 1.0e9))
102d6650:	e1a00007 	mov	r0, r7
102d6654:	e1a01004 	mov	r1, r4
102d6658:	e59f21dc 	ldr	r2, [pc, #476]	; 102d683c <print_value.constprop.8+0x6c8>
102d665c:	e59f31dc 	ldr	r3, [pc, #476]	; 102d6840 <print_value.constprop.8+0x6cc>
102d6660:	e12fff35 	blx	r5
102d6664:	e3500000 	cmp	r0, #0
102d6668:	1a000007 	bne	102d668c <print_value.constprop.8+0x518>
102d666c:	e1a01004 	mov	r1, r4
102d6670:	e1a00007 	mov	r0, r7
102d6674:	e3a02000 	mov	r2, #0
102d6678:	e59f31c4 	ldr	r3, [pc, #452]	; 102d6844 <print_value.constprop.8+0x6d0>
102d667c:	e59f41c4 	ldr	r4, [pc, #452]	; 102d6848 <print_value.constprop.8+0x6d4>
102d6680:	e12fff34 	blx	r4
102d6684:	e3500000 	cmp	r0, #0
102d6688:	0a000037 	beq	102d676c <print_value.constprop.8+0x5f8>
    {
        length = Ql_sprintf((char*)output_pointer, "%e", d);
102d668c:	e59f1170 	ldr	r1, [pc, #368]	; 102d6804 <print_value.constprop.8+0x690>
102d6690:	e1a02007 	mov	r2, r7
102d6694:	e5914000 	ldr	r4, [r1]
102d6698:	e1a03008 	mov	r3, r8
102d669c:	e1a0000a 	mov	r0, sl
102d66a0:	e59f11a4 	ldr	r1, [pc, #420]	; 102d684c <print_value.constprop.8+0x6d8>
102d66a4:	e12fff34 	blx	r4
        trim_zeroes = false; /* don't remove zeroes in engineering notation */
102d66a8:	e3a06000 	mov	r6, #0
    {
        length = Ql_sprintf((char*)output_pointer, "%f", d);
    }

    /* Ql_sprintf failed */
    if (length < 0)
102d66ac:	e3500000 	cmp	r0, #0
102d66b0:	bafffef6 	blt	102d6290 <print_value.constprop.8+0x11c>
    {
        return false;
    }

    output_buffer->offset += (size_t)length;
102d66b4:	e59b3008 	ldr	r3, [fp, #8]

    if (trim_zeroes)
102d66b8:	e3560000 	cmp	r6, #0
    if (length < 0)
    {
        return false;
    }

    output_buffer->offset += (size_t)length;
102d66bc:	e0800003 	add	r0, r0, r3
102d66c0:	e58b0008 	str	r0, [fp, #8]

    if (trim_zeroes)
102d66c4:	1a000014 	bne	102d671c <print_value.constprop.8+0x5a8>
            {
            	//APP_DEBUG("\r Error 1: in cJSON_Raw\r\n");
                return false;
            }
            Ql_memcpy(output, item->valuestring, raw_length);
            return true;
102d66c8:	e3a00001 	mov	r0, #1
102d66cc:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }

    /* This checks for NaN and Infinity */
    if ((d * 0) != 0)
    {
        length = Ql_sprintf((char*)output_pointer, "null");
102d66d0:	e59f312c 	ldr	r3, [pc, #300]	; 102d6804 <print_value.constprop.8+0x690>
102d66d4:	e1a0000a 	mov	r0, sl
102d66d8:	e5933000 	ldr	r3, [r3]
102d66dc:	e59f112c 	ldr	r1, [pc, #300]	; 102d6810 <print_value.constprop.8+0x69c>
102d66e0:	e12fff33 	blx	r3
static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer, const internal_hooks * const hooks)
{
    unsigned char *output_pointer = NULL;
    double d = item->valuedouble;
    int length = 0;
    cJSON_bool trim_zeroes = true; /* should at the end be removed? */
102d66e4:	e3a06001 	mov	r6, #1
102d66e8:	eaffffef 	b	102d66ac <print_value.constprop.8+0x538>
        case cJSON_Raw:
        {
            size_t raw_length = 0;
            if (item->valuestring == NULL)
            {
                if (!output_buffer->noalloc)
102d66ec:	e593700c 	ldr	r7, [r3, #12]
102d66f0:	e3570000 	cmp	r7, #0
102d66f4:	1afffee5 	bne	102d6290 <print_value.constprop.8+0x11c>
                {
                    hooks->deallocate(output_buffer->buffer);
102d66f8:	e5930000 	ldr	r0, [r3]
102d66fc:	e59f314c 	ldr	r3, [pc, #332]	; 102d6850 <print_value.constprop.8+0x6dc>
102d6700:	e5933004 	ldr	r3, [r3, #4]
102d6704:	e12fff33 	blx	r3
                }
            	//APP_DEBUG("\r Error 1: in cJSON_Raw\r\n");
                return false;
102d6708:	e1a00007 	mov	r0, r7
102d670c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102d6710:	e59f5118 	ldr	r5, [pc, #280]	; 102d6830 <print_value.constprop.8+0x6bc>
102d6714:	e3c84102 	bic	r4, r8, #-2147483648	; 0x80000000
102d6718:	eaffffcc 	b	102d6650 <print_value.constprop.8+0x4dc>
static cJSON_bool trim_trailing_zeroes(printbuffer * const buffer)
{
    size_t offset = 0;
    unsigned char *content = NULL;

    if ((buffer == NULL) || (buffer->buffer == NULL) || (buffer->offset < 1))
102d671c:	e59b1000 	ldr	r1, [fp]
102d6720:	e3510000 	cmp	r1, #0
102d6724:	0afffed9 	beq	102d6290 <print_value.constprop.8+0x11c>
102d6728:	e3500000 	cmp	r0, #0
102d672c:	08bd8ff8 	popeq	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }

    offset = buffer->offset - 1;
    content = buffer->buffer;

    while ((offset > 0) && (content[offset] == '0'))
102d6730:	e2503001 	subs	r3, r0, #1
102d6734:	1a000002 	bne	102d6744 <print_value.constprop.8+0x5d0>
102d6738:	ea000029 	b	102d67e4 <print_value.constprop.8+0x670>
102d673c:	e2533001 	subs	r3, r3, #1
102d6740:	0a000027 	beq	102d67e4 <print_value.constprop.8+0x670>
102d6744:	e7d12003 	ldrb	r2, [r1, r3]
102d6748:	e3520030 	cmp	r2, #48	; 0x30
102d674c:	0afffffa 	beq	102d673c <print_value.constprop.8+0x5c8>
    {
        offset--;
    }
    if ((offset > 0) && (content[offset] == '.'))
102d6750:	e352002e 	cmp	r2, #46	; 0x2e
102d6754:	12833001 	addne	r3, r3, #1
    {
        offset--;
    }

    offset++;
    content[offset] = '\0';
102d6758:	e3a02000 	mov	r2, #0
102d675c:	e7c12003 	strb	r2, [r1, r3]

    buffer->offset = offset;

    return true;
102d6760:	e3a00001 	mov	r0, #1
    }

    offset++;
    content[offset] = '\0';

    buffer->offset = offset;
102d6764:	e58b3008 	str	r3, [fp, #8]
102d6768:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        length = Ql_sprintf((char*)output_pointer, "%e", d);
        trim_zeroes = false; /* don't remove zeroes in engineering notation */
    }
    else
    {
        length = Ql_sprintf((char*)output_pointer, "%f", d);
102d676c:	e59f1090 	ldr	r1, [pc, #144]	; 102d6804 <print_value.constprop.8+0x690>
102d6770:	e1a02007 	mov	r2, r7
102d6774:	e5914000 	ldr	r4, [r1]
102d6778:	e1a03008 	mov	r3, r8
102d677c:	e1a0000a 	mov	r0, sl
102d6780:	e59f10cc 	ldr	r1, [pc, #204]	; 102d6854 <print_value.constprop.8+0x6e0>
102d6784:	e12fff34 	blx	r4
static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer, const internal_hooks * const hooks)
{
    unsigned char *output_pointer = NULL;
    double d = item->valuedouble;
    int length = 0;
    cJSON_bool trim_zeroes = true; /* should at the end be removed? */
102d6788:	e3a06001 	mov	r6, #1
102d678c:	eaffffc6 	b	102d66ac <print_value.constprop.8+0x538>
        output_buffer->offset += length;

        current_item = current_item->next;
    }
	//APP_DEBUG("OUT format\r\n");
    output_pointer = ensure(output_buffer, format ? (depth + 2) : 2, hooks);
102d6790:	e1a0000b 	mov	r0, fp
102d6794:	e28a1002 	add	r1, sl, #2
102d6798:	ebfffdad 	bl	102d5e54 <ensure.isra.0>
    if (output_pointer == NULL)
102d679c:	e3500000 	cmp	r0, #0
102d67a0:	0afffeba 	beq	102d6290 <print_value.constprop.8+0x11c>
    }
    if (format)
    {
		//APP_DEBUG("format2\r\n");
        size_t i;
        for (i = 0; i < (depth); i++)
102d67a4:	e35a0000 	cmp	sl, #0
102d67a8:	0affff6c 	beq	102d6560 <print_value.constprop.8+0x3ec>
    *error_pointer = input;
    return NULL;
}

/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, const size_t depth, const cJSON_bool format,  printbuffer * const output_buffer, const internal_hooks * const hooks)
102d67ac:	e080a00a 	add	sl, r0, sl
    {
		//APP_DEBUG("format2\r\n");
        size_t i;
        for (i = 0; i < (depth); i++)
        {
            *output_pointer++ = '\t';
102d67b0:	e3a03009 	mov	r3, #9
102d67b4:	e4c03001 	strb	r3, [r0], #1
    }
    if (format)
    {
		//APP_DEBUG("format2\r\n");
        size_t i;
        for (i = 0; i < (depth); i++)
102d67b8:	e150000a 	cmp	r0, sl
102d67bc:	1afffffc 	bne	102d67b4 <print_value.constprop.8+0x640>
102d67c0:	eaffff66 	b	102d6560 <print_value.constprop.8+0x3ec>
        length = Ql_sprintf((char*)output_pointer, "null");
    }
    else if ((fabs(floor(d) - d) <= DBL_EPSILON) && (fabs(d) < 1.0e60))
    {
        /* integer */
        length = Ql_sprintf((char*)output_pointer, "%.0f", d);
102d67c4:	e59f1038 	ldr	r1, [pc, #56]	; 102d6804 <print_value.constprop.8+0x690>
102d67c8:	e1a02007 	mov	r2, r7
102d67cc:	e5914000 	ldr	r4, [r1]
102d67d0:	e1a03008 	mov	r3, r8
102d67d4:	e1a0000a 	mov	r0, sl
102d67d8:	e59f1078 	ldr	r1, [pc, #120]	; 102d6858 <print_value.constprop.8+0x6e4>
102d67dc:	e12fff34 	blx	r4
102d67e0:	eaffffb1 	b	102d66ac <print_value.constprop.8+0x538>
    }

    offset = buffer->offset - 1;
    content = buffer->buffer;

    while ((offset > 0) && (content[offset] == '0'))
102d67e4:	e3a03001 	mov	r3, #1
102d67e8:	eaffffda 	b	102d6758 <print_value.constprop.8+0x5e4>
102d67ec:	102e57a4 	.word	0x102e57a4
102d67f0:	102e597c 	.word	0x102e597c
102d67f4:	102ef914 	.word	0x102ef914
102d67f8:	102e55fc 	.word	0x102e55fc
102d67fc:	102e58f4 	.word	0x102e58f4
102d6800:	f03d62b0 	.word	0xf03d62b0
102d6804:	f03de540 	.word	0xf03de540
102d6808:	102ef8dc 	.word	0x102ef8dc
102d680c:	102e6230 	.word	0x102e6230
102d6810:	102ef90c 	.word	0x102ef90c
102d6814:	102ef91c 	.word	0x102ef91c
102d6818:	102e3320 	.word	0x102e3320
102d681c:	102e3888 	.word	0x102e3888
102d6820:	102df769 	.word	0x102df769
102d6824:	102e2f0c 	.word	0x102e2f0c
102d6828:	3cb00000 	.word	0x3cb00000
102d682c:	102e38b8 	.word	0x102e38b8
102d6830:	102e38a0 	.word	0x102e38a0
102d6834:	e4c2f344 	.word	0xe4c2f344
102d6838:	4c63e9e4 	.word	0x4c63e9e4
102d683c:	a0b5ed8d 	.word	0xa0b5ed8d
102d6840:	3eb0c6f7 	.word	0x3eb0c6f7
102d6844:	41cdcd65 	.word	0x41cdcd65
102d6848:	102e38e8 	.word	0x102e38e8
102d684c:	102ef92c 	.word	0x102ef92c
102d6850:	f03d20bc 	.word	0xf03d20bc
102d6854:	102ef930 	.word	0x102ef930
102d6858:	102ef924 	.word	0x102ef924

102d685c <print.constprop.7>:
    return cJSON_ParseWithOpts(value, 0, 0);
}

#define min(a, b) ((a < b) ? a : b)

static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
102d685c:	e92d4070 	push	{r4, r5, r6, lr}
    unsigned char *printed = NULL;

    Ql_memset(buffer, 0, sizeof(buffer));

    /* create buffer */
    buffer->buffer = (unsigned char*) hooks->allocate(256);
102d6860:	e59f40cc 	ldr	r4, [pc, #204]	; 102d6934 <print.constprop.7+0xd8>
    return cJSON_ParseWithOpts(value, 0, 0);
}

#define min(a, b) ((a < b) ? a : b)

static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
102d6864:	e24dd010 	sub	sp, sp, #16

//	APP_DEBUG("\r\n<-- Entering : %s -->\r\n",__FUNCTION__);
    printbuffer buffer[1];
    unsigned char *printed = NULL;

    Ql_memset(buffer, 0, sizeof(buffer));
102d6868:	e3a02010 	mov	r2, #16
102d686c:	e59f30c4 	ldr	r3, [pc, #196]	; 102d6938 <print.constprop.7+0xdc>
    return cJSON_ParseWithOpts(value, 0, 0);
}

#define min(a, b) ((a < b) ? a : b)

static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
102d6870:	e1a06000 	mov	r6, r0
102d6874:	e1a05001 	mov	r5, r1

//	APP_DEBUG("\r\n<-- Entering : %s -->\r\n",__FUNCTION__);
    printbuffer buffer[1];
    unsigned char *printed = NULL;

    Ql_memset(buffer, 0, sizeof(buffer));
102d6878:	e1a0000d 	mov	r0, sp
102d687c:	e3a01000 	mov	r1, #0
102d6880:	e12fff33 	blx	r3

    /* create buffer */
    buffer->buffer = (unsigned char*) hooks->allocate(256);
102d6884:	e5943000 	ldr	r3, [r4]
102d6888:	e3a00c01 	mov	r0, #256	; 0x100
102d688c:	e12fff33 	blx	r3
    if (buffer->buffer == NULL)
102d6890:	e3500000 	cmp	r0, #0
    unsigned char *printed = NULL;

    Ql_memset(buffer, 0, sizeof(buffer));

    /* create buffer */
    buffer->buffer = (unsigned char*) hooks->allocate(256);
102d6894:	e58d0000 	str	r0, [sp]
    if (buffer->buffer == NULL)
102d6898:	0a00000b 	beq	102d68cc <print.constprop.7+0x70>
    {
        goto fail;
    }

    /* print the value */
    if (!print_value(item, 0, format, buffer, hooks))
102d689c:	e1a00006 	mov	r0, r6
102d68a0:	e3a01000 	mov	r1, #0
102d68a4:	e1a02005 	mov	r2, r5
102d68a8:	e1a0300d 	mov	r3, sp
102d68ac:	ebfffe30 	bl	102d6174 <print_value.constprop.8>
102d68b0:	e3500000 	cmp	r0, #0
102d68b4:	1a000008 	bne	102d68dc <print.constprop.7+0x80>
   // APP_DEBUG("\r<-- Exiting : %s -->\r\n\n",__FUNCTION__);
    return printed;

fail:
	//APP_DEBUG("cJSON_Print fail\r\n");
    if (buffer->buffer != NULL)
102d68b8:	e59d0000 	ldr	r0, [sp]
102d68bc:	e3500000 	cmp	r0, #0
102d68c0:	0a000001 	beq	102d68cc <print.constprop.7+0x70>
    {
        hooks->deallocate(buffer->buffer);
102d68c4:	e5943004 	ldr	r3, [r4, #4]
102d68c8:	e12fff33 	blx	r3
    if (printed != NULL)
    {
        hooks->deallocate(printed);
    }
  //  APP_DEBUG("\r<-- Exiting : %s -->\r\n\n",__FUNCTION__);
    return NULL;
102d68cc:	e3a05000 	mov	r5, #0
}
102d68d0:	e1a00005 	mov	r0, r5
102d68d4:	e28dd010 	add	sp, sp, #16
102d68d8:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (!print_value(item, 0, format, buffer, hooks))
    {
    	//APP_DEBUG("\r--> Error : print_value -->\r\n");
        goto fail;
    }
    update_offset(buffer);
102d68dc:	e1a0000d 	mov	r0, sp
102d68e0:	ebfffd4d 	bl	102d5e1c <update_offset>

    /* copy the buffer over to a new one */
    printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
102d68e4:	e59d0008 	ldr	r0, [sp, #8]
102d68e8:	e5943000 	ldr	r3, [r4]
102d68ec:	e2800001 	add	r0, r0, #1
102d68f0:	e12fff33 	blx	r3
    if (printed == NULL)
102d68f4:	e2505000 	subs	r5, r0, #0
102d68f8:	0affffee 	beq	102d68b8 <print.constprop.7+0x5c>
    {
    	//APP_DEBUG("\r--> Error : printed == NULL -->\r\n");
        goto fail;
    }
    Ql_strncpy((char*)printed, (char*)buffer->buffer, min(buffer->length, buffer->offset + 1));
102d68fc:	e59d2008 	ldr	r2, [sp, #8]
102d6900:	e89d000a 	ldm	sp, {r1, r3}
102d6904:	e2822001 	add	r2, r2, #1
102d6908:	e1520003 	cmp	r2, r3
102d690c:	21a02003 	movcs	r2, r3
102d6910:	e59f3024 	ldr	r3, [pc, #36]	; 102d693c <print.constprop.7+0xe0>
102d6914:	e12fff33 	blx	r3
    printed[buffer->offset] = '\0'; /* just to be sure */
102d6918:	e59d3008 	ldr	r3, [sp, #8]
102d691c:	e3a02000 	mov	r2, #0
102d6920:	e7c52003 	strb	r2, [r5, r3]

    /* free the buffer */
    hooks->deallocate(buffer->buffer);
102d6924:	e59d0000 	ldr	r0, [sp]
102d6928:	e5943004 	ldr	r3, [r4, #4]
102d692c:	e12fff33 	blx	r3
102d6930:	eaffffe6 	b	102d68d0 <print.constprop.7+0x74>
102d6934:	f03d20bc 	.word	0xf03d20bc
102d6938:	102e58f4 	.word	0x102e58f4
102d693c:	102e569c 	.word	0x102e569c

102d6940 <parse_string.constprop.15>:
fail:
    return 0;
}

/* Parse the input text into an unescaped cinput, and populate item. */
static const unsigned char *parse_string(cJSON * const item, const unsigned char* const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d6940:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    const unsigned char *input_end = input + 1;
    unsigned char *output_pointer = NULL;
    unsigned char *output = NULL;

    /* not a string */
    if (*input != '\"')
102d6944:	e5d13000 	ldrb	r3, [r1]
fail:
    return 0;
}

/* Parse the input text into an unescaped cinput, and populate item. */
static const unsigned char *parse_string(cJSON * const item, const unsigned char* const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d6948:	e24dd014 	sub	sp, sp, #20
    const unsigned char *input_end = input + 1;
    unsigned char *output_pointer = NULL;
    unsigned char *output = NULL;

    /* not a string */
    if (*input != '\"')
102d694c:	e3530022 	cmp	r3, #34	; 0x22
fail:
    return 0;
}

/* Parse the input text into an unescaped cinput, and populate item. */
static const unsigned char *parse_string(cJSON * const item, const unsigned char* const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d6950:	e1a07000 	mov	r7, r0
    unsigned char *output = NULL;

    /* not a string */
    if (*input != '\"')
    {
        *error_pointer = input;
102d6954:	15821000 	strne	r1, [r2]
    const unsigned char *input_end = input + 1;
    unsigned char *output_pointer = NULL;
    unsigned char *output = NULL;

    /* not a string */
    if (*input != '\"')
102d6958:	0a000002 	beq	102d6968 <parse_string.constprop.15+0x28>
    if (output != NULL)
    {
        hooks->deallocate(output);
    }

    return NULL;
102d695c:	e3a00000 	mov	r0, #0
}
102d6960:	e28dd014 	add	sp, sp, #20
102d6964:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    {
        /* calculate approximate size of the output (overestimate) */
        size_t allocation_length = 0;
        size_t skipped_bytes = 0;
        while ((*input_end != '\"') && (*input_end != '\0'))
102d6968:	e5d13001 	ldrb	r3, [r1, #1]

/* Parse the input text into an unescaped cinput, and populate item. */
static const unsigned char *parse_string(cJSON * const item, const unsigned char* const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
{
	////APP_DEBUG("parse_string1 = %c\r\n",*input);
    const unsigned char *input_pointer = input + 1;
102d696c:	e2815001 	add	r5, r1, #1

    {
        /* calculate approximate size of the output (overestimate) */
        size_t allocation_length = 0;
        size_t skipped_bytes = 0;
        while ((*input_end != '\"') && (*input_end != '\0'))
102d6970:	e3530022 	cmp	r3, #34	; 0x22
102d6974:	13530000 	cmpne	r3, #0
102d6978:	03a0c000 	moveq	ip, #0
102d697c:	13a0c001 	movne	ip, #1
102d6980:	e1a04005 	mov	r4, r5
102d6984:	13a0c000 	movne	ip, #0
102d6988:	1a000005 	bne	102d69a4 <parse_string.constprop.15+0x64>
102d698c:	ea00000d 	b	102d69c8 <parse_string.constprop.15+0x88>
102d6990:	e5d03001 	ldrb	r3, [r0, #1]
                    goto fail;
                }
                skipped_bytes++;
                input_end++;
            }
            input_end++;
102d6994:	e2804001 	add	r4, r0, #1

    {
        /* calculate approximate size of the output (overestimate) */
        size_t allocation_length = 0;
        size_t skipped_bytes = 0;
        while ((*input_end != '\"') && (*input_end != '\0'))
102d6998:	e3530000 	cmp	r3, #0
102d699c:	13530022 	cmpne	r3, #34	; 0x22
102d69a0:	0a000008 	beq	102d69c8 <parse_string.constprop.15+0x88>
        {
            /* is escape sequence */
            if (input_end[0] == '\\')
102d69a4:	e353005c 	cmp	r3, #92	; 0x5c
102d69a8:	e1a00004 	mov	r0, r4
102d69ac:	1afffff7 	bne	102d6990 <parse_string.constprop.15+0x50>
            {
                if (input_end[1] == '\0')
102d69b0:	e5d43001 	ldrb	r3, [r4, #1]
                {
                    /* prevent buffer overflow when last input character is a backslash */
                    goto fail;
                }
                skipped_bytes++;
102d69b4:	e28cc001 	add	ip, ip, #1
        while ((*input_end != '\"') && (*input_end != '\0'))
        {
            /* is escape sequence */
            if (input_end[0] == '\\')
            {
                if (input_end[1] == '\0')
102d69b8:	e3530000 	cmp	r3, #0
                {
                    /* prevent buffer overflow when last input character is a backslash */
                    goto fail;
                }
                skipped_bytes++;
                input_end++;
102d69bc:	e2840001 	add	r0, r4, #1
        while ((*input_end != '\"') && (*input_end != '\0'))
        {
            /* is escape sequence */
            if (input_end[0] == '\\')
            {
                if (input_end[1] == '\0')
102d69c0:	1afffff2 	bne	102d6990 <parse_string.constprop.15+0x50>
102d69c4:	eaffffe4 	b	102d695c <parse_string.constprop.15+0x1c>
                skipped_bytes++;
                input_end++;
            }
            input_end++;
        }
        if (*input_end == '\0')
102d69c8:	e3530000 	cmp	r3, #0
102d69cc:	0affffe2 	beq	102d695c <parse_string.constprop.15+0x1c>
            goto fail; /* string ended unexpectedly */
        }

        /* This is at most how much we need for the output */
        allocation_length = (size_t) (input_end - input) - skipped_bytes;
        output = (unsigned char*)hooks->allocate(allocation_length + sizeof('\0'));
102d69d0:	e59fa3a0 	ldr	sl, [pc, #928]	; 102d6d78 <parse_string.constprop.15+0x438>
        {
            goto fail; /* string ended unexpectedly */
        }

        /* This is at most how much we need for the output */
        allocation_length = (size_t) (input_end - input) - skipped_bytes;
102d69d4:	e26c0004 	rsb	r0, ip, #4
102d69d8:	e0611004 	rsb	r1, r1, r4
        output = (unsigned char*)hooks->allocate(allocation_length + sizeof('\0'));
102d69dc:	e58d2004 	str	r2, [sp, #4]
102d69e0:	e59a3000 	ldr	r3, [sl]
102d69e4:	e0800001 	add	r0, r0, r1
102d69e8:	e12fff33 	blx	r3
        if (output == NULL)
102d69ec:	e59d2004 	ldr	r2, [sp, #4]
102d69f0:	e2509000 	subs	r9, r0, #0
102d69f4:	0affffd8 	beq	102d695c <parse_string.constprop.15+0x1c>
        }
    }
	////APP_DEBUG("parse_string2 = %c\r\n",*input);
    output_pointer = output;
    /* loop through the string literal */
    while (input_pointer < input_end)
102d69f8:	e1550004 	cmp	r5, r4
102d69fc:	2a0000c4 	bcs	102d6d14 <parse_string.constprop.15+0x3d4>

    /* get the first utf16 sequence */
    first_code = parse_hex4(first_sequence + 2);

    /* check that the code is valid */
    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)) || (first_code == 0))
102d6a00:	e59fc374 	ldr	ip, [pc, #884]	; 102d6d7c <parse_string.constprop.15+0x43c>
        }
    }
	////APP_DEBUG("parse_string2 = %c\r\n",*input);
    output_pointer = output;
    /* loop through the string literal */
    while (input_pointer < input_end)
102d6a04:	e1a06009 	mov	r6, r9
    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
    {
        const unsigned char *second_sequence = first_sequence + 6;
        unsigned int second_code = 0;
        sequence_length = 12; /* \uXXXX\uXXXX */
102d6a08:	e1a0b002 	mov	fp, r2
102d6a0c:	ea000003 	b	102d6a20 <parse_string.constprop.15+0xe0>
    /* loop through the string literal */
    while (input_pointer < input_end)
    {
        if (*input_pointer != '\\')
        {
            *output_pointer++ = *input_pointer++;
102d6a10:	e2855001 	add	r5, r5, #1
102d6a14:	e4c63001 	strb	r3, [r6], #1
        }
    }
	////APP_DEBUG("parse_string2 = %c\r\n",*input);
    output_pointer = output;
    /* loop through the string literal */
    while (input_pointer < input_end)
102d6a18:	e1550004 	cmp	r5, r4
102d6a1c:	2a0000bd 	bcs	102d6d18 <parse_string.constprop.15+0x3d8>
    {
        if (*input_pointer != '\\')
102d6a20:	e5d53000 	ldrb	r3, [r5]
102d6a24:	e353005c 	cmp	r3, #92	; 0x5c
102d6a28:	1afffff8 	bne	102d6a10 <parse_string.constprop.15+0xd0>
        /* escape sequence */
        else
        {
			////APP_DEBUG("parse_string3 = %c\r\n",*input);
            unsigned char sequence_length = 2;
            switch (input_pointer[1])
102d6a2c:	e5d52001 	ldrb	r2, [r5, #1]
102d6a30:	e2423022 	sub	r3, r2, #34	; 0x22
102d6a34:	e3530053 	cmp	r3, #83	; 0x53
102d6a38:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
102d6a3c:	ea000053 	b	102d6b90 <parse_string.constprop.15+0x250>
102d6a40:	102d6cd8 	.word	0x102d6cd8
102d6a44:	102d6b90 	.word	0x102d6b90
102d6a48:	102d6b90 	.word	0x102d6b90
102d6a4c:	102d6b90 	.word	0x102d6b90
102d6a50:	102d6b90 	.word	0x102d6b90
102d6a54:	102d6b90 	.word	0x102d6b90
102d6a58:	102d6b90 	.word	0x102d6b90
102d6a5c:	102d6b90 	.word	0x102d6b90
102d6a60:	102d6b90 	.word	0x102d6b90
102d6a64:	102d6b90 	.word	0x102d6b90
102d6a68:	102d6b90 	.word	0x102d6b90
102d6a6c:	102d6b90 	.word	0x102d6b90
102d6a70:	102d6b90 	.word	0x102d6b90
102d6a74:	102d6cd8 	.word	0x102d6cd8
102d6a78:	102d6b90 	.word	0x102d6b90
102d6a7c:	102d6b90 	.word	0x102d6b90
102d6a80:	102d6b90 	.word	0x102d6b90
102d6a84:	102d6b90 	.word	0x102d6b90
102d6a88:	102d6b90 	.word	0x102d6b90
102d6a8c:	102d6b90 	.word	0x102d6b90
102d6a90:	102d6b90 	.word	0x102d6b90
102d6a94:	102d6b90 	.word	0x102d6b90
102d6a98:	102d6b90 	.word	0x102d6b90
102d6a9c:	102d6b90 	.word	0x102d6b90
102d6aa0:	102d6b90 	.word	0x102d6b90
102d6aa4:	102d6b90 	.word	0x102d6b90
102d6aa8:	102d6b90 	.word	0x102d6b90
102d6aac:	102d6b90 	.word	0x102d6b90
102d6ab0:	102d6b90 	.word	0x102d6b90
102d6ab4:	102d6b90 	.word	0x102d6b90
102d6ab8:	102d6b90 	.word	0x102d6b90
102d6abc:	102d6b90 	.word	0x102d6b90
102d6ac0:	102d6b90 	.word	0x102d6b90
102d6ac4:	102d6b90 	.word	0x102d6b90
102d6ac8:	102d6b90 	.word	0x102d6b90
102d6acc:	102d6b90 	.word	0x102d6b90
102d6ad0:	102d6b90 	.word	0x102d6b90
102d6ad4:	102d6b90 	.word	0x102d6b90
102d6ad8:	102d6b90 	.word	0x102d6b90
102d6adc:	102d6b90 	.word	0x102d6b90
102d6ae0:	102d6b90 	.word	0x102d6b90
102d6ae4:	102d6b90 	.word	0x102d6b90
102d6ae8:	102d6b90 	.word	0x102d6b90
102d6aec:	102d6b90 	.word	0x102d6b90
102d6af0:	102d6b90 	.word	0x102d6b90
102d6af4:	102d6b90 	.word	0x102d6b90
102d6af8:	102d6b90 	.word	0x102d6b90
102d6afc:	102d6b90 	.word	0x102d6b90
102d6b00:	102d6b90 	.word	0x102d6b90
102d6b04:	102d6b90 	.word	0x102d6b90
102d6b08:	102d6b90 	.word	0x102d6b90
102d6b0c:	102d6b90 	.word	0x102d6b90
102d6b10:	102d6b90 	.word	0x102d6b90
102d6b14:	102d6b90 	.word	0x102d6b90
102d6b18:	102d6b90 	.word	0x102d6b90
102d6b1c:	102d6b90 	.word	0x102d6b90
102d6b20:	102d6b90 	.word	0x102d6b90
102d6b24:	102d6b90 	.word	0x102d6b90
102d6b28:	102d6cd8 	.word	0x102d6cd8
102d6b2c:	102d6b90 	.word	0x102d6b90
102d6b30:	102d6b90 	.word	0x102d6b90
102d6b34:	102d6b90 	.word	0x102d6b90
102d6b38:	102d6b90 	.word	0x102d6b90
102d6b3c:	102d6b90 	.word	0x102d6b90
102d6b40:	102d6cc8 	.word	0x102d6cc8
102d6b44:	102d6b90 	.word	0x102d6b90
102d6b48:	102d6b90 	.word	0x102d6b90
102d6b4c:	102d6b90 	.word	0x102d6b90
102d6b50:	102d6cf4 	.word	0x102d6cf4
102d6b54:	102d6b90 	.word	0x102d6b90
102d6b58:	102d6b90 	.word	0x102d6b90
102d6b5c:	102d6b90 	.word	0x102d6b90
102d6b60:	102d6b90 	.word	0x102d6b90
102d6b64:	102d6b90 	.word	0x102d6b90
102d6b68:	102d6b90 	.word	0x102d6b90
102d6b6c:	102d6b90 	.word	0x102d6b90
102d6b70:	102d6ce4 	.word	0x102d6ce4
102d6b74:	102d6b90 	.word	0x102d6b90
102d6b78:	102d6b90 	.word	0x102d6b90
102d6b7c:	102d6b90 	.word	0x102d6b90
102d6b80:	102d6d04 	.word	0x102d6d04
102d6b84:	102d6b90 	.word	0x102d6b90
102d6b88:	102d6cb4 	.word	0x102d6cb4
102d6b8c:	102d6ba8 	.word	0x102d6ba8
                        goto fail;
                    }
                    break;

                default:
                    *error_pointer = input_pointer;
102d6b90:	e58b5000 	str	r5, [fp]
    return input_end + 1;

fail:
    if (output != NULL)
    {
        hooks->deallocate(output);
102d6b94:	e1a00009 	mov	r0, r9
102d6b98:	e59a3004 	ldr	r3, [sl, #4]
102d6b9c:	e12fff33 	blx	r3
    }

    return NULL;
102d6ba0:	e3a00000 	mov	r0, #0
102d6ba4:	eaffff6d 	b	102d6960 <parse_string.constprop.15+0x20>
    unsigned char utf8_length = 0;
    unsigned char utf8_position = 0;
    unsigned char sequence_length = 0;
    unsigned char first_byte_mark = 0;

    if ((input_end - first_sequence) < 6)
102d6ba8:	e0653004 	rsb	r3, r5, r4
102d6bac:	e3530005 	cmp	r3, #5
102d6bb0:	dafffff6 	ble	102d6b90 <parse_string.constprop.15+0x250>
        *error_pointer = first_sequence;
        goto fail;
    }

    /* get the first utf16 sequence */
    first_code = parse_hex4(first_sequence + 2);
102d6bb4:	e2850002 	add	r0, r5, #2
102d6bb8:	e58dc004 	str	ip, [sp, #4]
102d6bbc:	ebfffc5c 	bl	102d5d34 <parse_hex4>

    /* check that the code is valid */
    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)) || (first_code == 0))
102d6bc0:	e59dc004 	ldr	ip, [sp, #4]
102d6bc4:	e2403b37 	sub	r3, r0, #56320	; 0xdc00
102d6bc8:	e3500000 	cmp	r0, #0
102d6bcc:	1153000c 	cmpne	r3, ip
        *error_pointer = first_sequence;
        goto fail;
    }

    /* get the first utf16 sequence */
    first_code = parse_hex4(first_sequence + 2);
102d6bd0:	e1a08000 	mov	r8, r0

    /* check that the code is valid */
    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)) || (first_code == 0))
102d6bd4:	9affffed 	bls	102d6b90 <parse_string.constprop.15+0x250>
        *error_pointer = first_sequence;
        goto fail;
    }

    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
102d6bd8:	e2403b36 	sub	r3, r0, #55296	; 0xd800
102d6bdc:	e153000c 	cmp	r3, ip
102d6be0:	8a000053 	bhi	102d6d34 <parse_string.constprop.15+0x3f4>
    {
        const unsigned char *second_sequence = first_sequence + 6;
102d6be4:	e2853006 	add	r3, r5, #6
        unsigned int second_code = 0;
        sequence_length = 12; /* \uXXXX\uXXXX */

        if ((input_end - second_sequence) < 6)
102d6be8:	e0633004 	rsb	r3, r3, r4
102d6bec:	e3530005 	cmp	r3, #5
102d6bf0:	daffffe6 	ble	102d6b90 <parse_string.constprop.15+0x250>
            /* input ends unexpectedly */
            *error_pointer = first_sequence;
            goto fail;
        }

        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
102d6bf4:	e5d53006 	ldrb	r3, [r5, #6]
102d6bf8:	e353005c 	cmp	r3, #92	; 0x5c
102d6bfc:	1affffe3 	bne	102d6b90 <parse_string.constprop.15+0x250>
102d6c00:	e5d53007 	ldrb	r3, [r5, #7]
102d6c04:	e3530075 	cmp	r3, #117	; 0x75
102d6c08:	1affffe0 	bne	102d6b90 <parse_string.constprop.15+0x250>
            *error_pointer = first_sequence;
            goto fail;
        }

        /* get the second utf16 sequence */
        second_code = parse_hex4(second_sequence + 2);
102d6c0c:	e2850008 	add	r0, r5, #8
102d6c10:	e58dc004 	str	ip, [sp, #4]
102d6c14:	ebfffc46 	bl	102d5d34 <parse_hex4>
        /* check that the code is valid */
        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
102d6c18:	e59dc004 	ldr	ip, [sp, #4]
102d6c1c:	e2403b37 	sub	r3, r0, #56320	; 0xdc00
102d6c20:	e153000c 	cmp	r3, ip
102d6c24:	8affffd9 	bhi	102d6b90 <parse_string.constprop.15+0x250>
            goto fail;
        }


        /* calculate the unicode codepoint from the surrogate pair */
        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
102d6c28:	e1a03b08 	lsl	r3, r8, #22
102d6c2c:	e1a03623 	lsr	r3, r3, #12
102d6c30:	e1a00b00 	lsl	r0, r0, #22
102d6c34:	e1838b20 	orr	r8, r3, r0, lsr #22
102d6c38:	e2888801 	add	r8, r8, #65536	; 0x10000
    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
    {
        const unsigned char *second_sequence = first_sequence + 6;
        unsigned int second_code = 0;
        sequence_length = 12; /* \uXXXX\uXXXX */
102d6c3c:	e3a0300c 	mov	r3, #12
102d6c40:	e58d300c 	str	r3, [sp, #12]
    }

    /* encode as UTF-8
     * takes at maximum 4 bytes to encode:
     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    if (codepoint < 0x80)
102d6c44:	e358007f 	cmp	r8, #127	; 0x7f
102d6c48:	9a00003c 	bls	102d6d40 <parse_string.constprop.15+0x400>
    {
        /* normal ascii, encoding 0xxxxxxx */
        utf8_length = 1;
    }
    else if (codepoint < 0x800)
102d6c4c:	e59f312c 	ldr	r3, [pc, #300]	; 102d6d80 <parse_string.constprop.15+0x440>
102d6c50:	e1580003 	cmp	r8, r3
102d6c54:	9a00003d 	bls	102d6d50 <parse_string.constprop.15+0x410>
    {
        /* two bytes, encoding 110xxxxx 10xxxxxx */
        utf8_length = 2;
        first_byte_mark = 0xC0; /* 11000000 */
    }
    else if (codepoint < 0x10000)
102d6c58:	e59f1124 	ldr	r1, [pc, #292]	; 102d6d84 <parse_string.constprop.15+0x444>
102d6c5c:	e1580001 	cmp	r8, r1
102d6c60:	9a00003f 	bls	102d6d64 <parse_string.constprop.15+0x424>
    {
        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        utf8_length = 3;
        first_byte_mark = 0xE0; /* 11100000 */
    }
    else if (codepoint <= 0x10FFFF)
102d6c64:	e59f311c 	ldr	r3, [pc, #284]	; 102d6d88 <parse_string.constprop.15+0x448>
102d6c68:	e1580003 	cmp	r8, r3
102d6c6c:	8affffc7 	bhi	102d6b90 <parse_string.constprop.15+0x250>
    {
        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        utf8_length = 4;
        first_byte_mark = 0xF0; /* 11110000 */
102d6c70:	e3a010f0 	mov	r1, #240	; 0xf0
    {
        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        utf8_length = 3;
        first_byte_mark = 0xE0; /* 11100000 */
    }
    else if (codepoint <= 0x10FFFF)
102d6c74:	e3a02004 	mov	r2, #4
102d6c78:	e3a03003 	mov	r3, #3
    {
        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        utf8_length = 4;
        first_byte_mark = 0xF0; /* 11110000 */
102d6c7c:	e58d1008 	str	r1, [sp, #8]

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
    {
        /* 10xxxxxx */
        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
102d6c80:	e208003f 	and	r0, r8, #63	; 0x3f
102d6c84:	e3800080 	orr	r0, r0, #128	; 0x80
        *error_pointer = first_sequence;
        goto fail;
    }

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
102d6c88:	e2431001 	sub	r1, r3, #1
    {
        /* 10xxxxxx */
        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
102d6c8c:	e7c60003 	strb	r0, [r6, r3]
        *error_pointer = first_sequence;
        goto fail;
    }

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
102d6c90:	e21130ff 	ands	r3, r1, #255	; 0xff
    {
        /* 10xxxxxx */
        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
        codepoint >>= 6;
102d6c94:	e1a08328 	lsr	r8, r8, #6
        *error_pointer = first_sequence;
        goto fail;
    }

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
102d6c98:	1afffff8 	bne	102d6c80 <parse_string.constprop.15+0x340>
        codepoint >>= 6;
    }
    /* encode first byte */
    if (utf8_length > 1)
    {
        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
102d6c9c:	e59d1008 	ldr	r1, [sp, #8]
102d6ca0:	e1818008 	orr	r8, r1, r8
102d6ca4:	e5c68000 	strb	r8, [r6]
    else
    {
        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
    }

    *output_pointer += utf8_length;
102d6ca8:	e0866002 	add	r6, r6, r2
102d6cac:	e59d300c 	ldr	r3, [sp, #12]
102d6cb0:	ea000002 	b	102d6cc0 <parse_string.constprop.15+0x380>
                    break;
                case 'r':
                    *output_pointer++ = '\r';
                    break;
                case 't':
                    *output_pointer++ = '\t';
102d6cb4:	e3a03009 	mov	r3, #9
102d6cb8:	e4c63001 	strb	r3, [r6], #1
102d6cbc:	e3a03002 	mov	r3, #2

                default:
                    *error_pointer = input_pointer;
                    goto fail;
            }
            input_pointer += sequence_length;
102d6cc0:	e0855003 	add	r5, r5, r3
102d6cc4:	eaffff53 	b	102d6a18 <parse_string.constprop.15+0xd8>
			////APP_DEBUG("parse_string3 = %c\r\n",*input);
            unsigned char sequence_length = 2;
            switch (input_pointer[1])
            {
                case 'b':
                    *output_pointer++ = '\b';
102d6cc8:	e3a03008 	mov	r3, #8
102d6ccc:	e4c63001 	strb	r3, [r6], #1
102d6cd0:	e3a03002 	mov	r3, #2
102d6cd4:	eafffff9 	b	102d6cc0 <parse_string.constprop.15+0x380>
                    *output_pointer++ = '\t';
                    break;
                case '\"':
                case '\\':
                case '/':
                    *output_pointer++ = input_pointer[1];
102d6cd8:	e4c62001 	strb	r2, [r6], #1
102d6cdc:	e3a03002 	mov	r3, #2
102d6ce0:	eafffff6 	b	102d6cc0 <parse_string.constprop.15+0x380>
                    break;
                case 'f':
                    *output_pointer++ = '\f';
                    break;
                case 'n':
                    *output_pointer++ = '\n';
102d6ce4:	e3a0300a 	mov	r3, #10
102d6ce8:	e4c63001 	strb	r3, [r6], #1
102d6cec:	e3a03002 	mov	r3, #2
102d6cf0:	eafffff2 	b	102d6cc0 <parse_string.constprop.15+0x380>
            {
                case 'b':
                    *output_pointer++ = '\b';
                    break;
                case 'f':
                    *output_pointer++ = '\f';
102d6cf4:	e3a0100c 	mov	r1, #12
102d6cf8:	e4c61001 	strb	r1, [r6], #1
102d6cfc:	e3a03002 	mov	r3, #2
102d6d00:	eaffffee 	b	102d6cc0 <parse_string.constprop.15+0x380>
                    break;
                case 'n':
                    *output_pointer++ = '\n';
                    break;
                case 'r':
                    *output_pointer++ = '\r';
102d6d04:	e3a0300d 	mov	r3, #13
102d6d08:	e4c63001 	strb	r3, [r6], #1
102d6d0c:	e3a03002 	mov	r3, #2
102d6d10:	eaffffea 	b	102d6cc0 <parse_string.constprop.15+0x380>
        }
    }
	////APP_DEBUG("parse_string2 = %c\r\n",*input);
    output_pointer = output;
    /* loop through the string literal */
    while (input_pointer < input_end)
102d6d14:	e1a06009 	mov	r6, r9
            input_pointer += sequence_length;
        }
    }

    /* zero terminate the output */
    *output_pointer = '\0';
102d6d18:	e3a03000 	mov	r3, #0
102d6d1c:	e5c63000 	strb	r3, [r6]

    item->type = cJSON_String;
102d6d20:	e3a03010 	mov	r3, #16
    item->valuestring = (char*)output;
	////APP_DEBUG("parse_string4 = %s\r\n",item->valuestring);
    return input_end + 1;
102d6d24:	e2840001 	add	r0, r4, #1
    }

    /* zero terminate the output */
    *output_pointer = '\0';

    item->type = cJSON_String;
102d6d28:	e587300c 	str	r3, [r7, #12]
    item->valuestring = (char*)output;
102d6d2c:	e5879010 	str	r9, [r7, #16]
102d6d30:	eaffff0a 	b	102d6960 <parse_string.constprop.15+0x20>
        /* calculate the unicode codepoint from the surrogate pair */
        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
    }
    else
    {
        sequence_length = 6; /* \uXXXX */
102d6d34:	e3a01006 	mov	r1, #6
102d6d38:	e58d100c 	str	r1, [sp, #12]
102d6d3c:	eaffffc0 	b	102d6c44 <parse_string.constprop.15+0x304>
    {
        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
    }
    else
    {
        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
102d6d40:	e208807f 	and	r8, r8, #127	; 0x7f
102d6d44:	e5c68000 	strb	r8, [r6]
102d6d48:	e3a02001 	mov	r2, #1
102d6d4c:	eaffffd5 	b	102d6ca8 <parse_string.constprop.15+0x368>
    }
    else if (codepoint < 0x800)
    {
        /* two bytes, encoding 110xxxxx 10xxxxxx */
        utf8_length = 2;
        first_byte_mark = 0xC0; /* 11000000 */
102d6d50:	e3a010c0 	mov	r1, #192	; 0xc0
    if (codepoint < 0x80)
    {
        /* normal ascii, encoding 0xxxxxxx */
        utf8_length = 1;
    }
    else if (codepoint < 0x800)
102d6d54:	e3a02002 	mov	r2, #2
102d6d58:	e3a03001 	mov	r3, #1
    {
        /* two bytes, encoding 110xxxxx 10xxxxxx */
        utf8_length = 2;
        first_byte_mark = 0xC0; /* 11000000 */
102d6d5c:	e58d1008 	str	r1, [sp, #8]
102d6d60:	eaffffc6 	b	102d6c80 <parse_string.constprop.15+0x340>
    }
    else if (codepoint < 0x10000)
    {
        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        utf8_length = 3;
        first_byte_mark = 0xE0; /* 11100000 */
102d6d64:	e3a010e0 	mov	r1, #224	; 0xe0
    {
        /* two bytes, encoding 110xxxxx 10xxxxxx */
        utf8_length = 2;
        first_byte_mark = 0xC0; /* 11000000 */
    }
    else if (codepoint < 0x10000)
102d6d68:	e3a02003 	mov	r2, #3
102d6d6c:	e3a03002 	mov	r3, #2
    {
        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        utf8_length = 3;
        first_byte_mark = 0xE0; /* 11100000 */
102d6d70:	e58d1008 	str	r1, [sp, #8]
102d6d74:	eaffffc1 	b	102d6c80 <parse_string.constprop.15+0x340>
102d6d78:	f03d20bc 	.word	0xf03d20bc
102d6d7c:	000003ff 	.word	0x000003ff
102d6d80:	000007ff 	.word	0x000007ff
102d6d84:	0000ffff 	.word	0x0000ffff
102d6d88:	0010ffff 	.word	0x0010ffff

102d6d8c <cJSON_New_Item.constprop.16>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(const internal_hooks* const hooks)
{
    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
102d6d8c:	e59f302c 	ldr	r3, [pc, #44]	; 102d6dc0 <cJSON_New_Item.constprop.16+0x34>
        global_hooks.reallocate = realloc;
    }
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(const internal_hooks* const hooks)
102d6d90:	e92d4010 	push	{r4, lr}
{
    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
102d6d94:	e3a00028 	mov	r0, #40	; 0x28
102d6d98:	e5933000 	ldr	r3, [r3]
102d6d9c:	e12fff33 	blx	r3
    if (node)
102d6da0:	e2504000 	subs	r4, r0, #0
102d6da4:	0a000003 	beq	102d6db8 <cJSON_New_Item.constprop.16+0x2c>
    {
        Ql_memset(node, '\0', sizeof(cJSON));
102d6da8:	e3a01000 	mov	r1, #0
102d6dac:	e3a02028 	mov	r2, #40	; 0x28
102d6db0:	e59f300c 	ldr	r3, [pc, #12]	; 102d6dc4 <cJSON_New_Item.constprop.16+0x38>
102d6db4:	e12fff33 	blx	r3
    }

    return node;
}
102d6db8:	e1a00004 	mov	r0, r4
102d6dbc:	e8bd8010 	pop	{r4, pc}
102d6dc0:	f03d20bc 	.word	0xf03d20bc
102d6dc4:	102e58f4 	.word	0x102e58f4

102d6dc8 <create_reference.constprop.6>:
    prev->next = item;
    item->prev = prev;
}

/* Utility for handling references. */
static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
102d6dc8:	e92d4038 	push	{r3, r4, r5, lr}
102d6dcc:	e1a05000 	mov	r5, r0
{
    cJSON *ref = cJSON_New_Item(hooks);
102d6dd0:	ebffffed 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if (!ref)
102d6dd4:	e2504000 	subs	r4, r0, #0
102d6dd8:	0a00000a 	beq	102d6e08 <create_reference.constprop.6+0x40>
    {
        return NULL;
    }
    Ql_memcpy(ref, item, sizeof(cJSON));
102d6ddc:	e3a02028 	mov	r2, #40	; 0x28
102d6de0:	e59f3028 	ldr	r3, [pc, #40]	; 102d6e10 <create_reference.constprop.6+0x48>
102d6de4:	e1a01005 	mov	r1, r5
102d6de8:	e12fff33 	blx	r3
    ref->string = NULL;
    ref->type |= cJSON_IsReference;
102d6dec:	e594200c 	ldr	r2, [r4, #12]
    if (!ref)
    {
        return NULL;
    }
    Ql_memcpy(ref, item, sizeof(cJSON));
    ref->string = NULL;
102d6df0:	e3a03000 	mov	r3, #0
    ref->type |= cJSON_IsReference;
102d6df4:	e3822c01 	orr	r2, r2, #256	; 0x100
    if (!ref)
    {
        return NULL;
    }
    Ql_memcpy(ref, item, sizeof(cJSON));
    ref->string = NULL;
102d6df8:	e5843020 	str	r3, [r4, #32]
    ref->type |= cJSON_IsReference;
102d6dfc:	e584200c 	str	r2, [r4, #12]
    ref->next = ref->prev = NULL;
102d6e00:	e5843004 	str	r3, [r4, #4]
102d6e04:	e5843000 	str	r3, [r4]
    return ref;
}
102d6e08:	e1a00004 	mov	r0, r4
102d6e0c:	e8bd8038 	pop	{r3, r4, r5, pc}
102d6e10:	102e597c 	.word	0x102e597c

102d6e14 <cJSON_strdup.constprop.17>:
    void *(*reallocate)(void *pointer, size_t size);
} internal_hooks;

static internal_hooks global_hooks = { Ql_MEM_Alloc, Ql_MEM_Free, realloc };

static unsigned char* cJSON_strdup(const unsigned char* str, const internal_hooks * const hooks)
102d6e14:	e92d4070 	push	{r4, r5, r6, lr}
{
    size_t len = 0;
    unsigned char *copy = NULL;

    if (str == NULL)
102d6e18:	e2506000 	subs	r6, r0, #0
102d6e1c:	0a00000e 	beq	102d6e5c <cJSON_strdup.constprop.17+0x48>
    {
        return NULL;
    }

    len = Ql_strlen((const char*)str) + 1;
102d6e20:	e59f303c 	ldr	r3, [pc, #60]	; 102d6e64 <cJSON_strdup.constprop.17+0x50>
102d6e24:	e12fff33 	blx	r3
    if (!(copy = (unsigned char*)hooks->allocate(len)))
102d6e28:	e59f3038 	ldr	r3, [pc, #56]	; 102d6e68 <cJSON_strdup.constprop.17+0x54>
102d6e2c:	e5933000 	ldr	r3, [r3]
    if (str == NULL)
    {
        return NULL;
    }

    len = Ql_strlen((const char*)str) + 1;
102d6e30:	e2804001 	add	r4, r0, #1
    if (!(copy = (unsigned char*)hooks->allocate(len)))
102d6e34:	e1a00004 	mov	r0, r4
102d6e38:	e12fff33 	blx	r3
102d6e3c:	e2505000 	subs	r5, r0, #0
102d6e40:	0a000005 	beq	102d6e5c <cJSON_strdup.constprop.17+0x48>
    {
        return NULL;
    }
    Ql_memcpy(copy, str, len);
102d6e44:	e1a01006 	mov	r1, r6
102d6e48:	e1a02004 	mov	r2, r4
102d6e4c:	e59f3018 	ldr	r3, [pc, #24]	; 102d6e6c <cJSON_strdup.constprop.17+0x58>
102d6e50:	e12fff33 	blx	r3

    return copy;
}
102d6e54:	e1a00005 	mov	r0, r5
102d6e58:	e8bd8070 	pop	{r4, r5, r6, pc}
    size_t len = 0;
    unsigned char *copy = NULL;

    if (str == NULL)
    {
        return NULL;
102d6e5c:	e3a05000 	mov	r5, #0
102d6e60:	eafffffb 	b	102d6e54 <cJSON_strdup.constprop.17+0x40>
102d6e64:	102e57a4 	.word	0x102e57a4
102d6e68:	f03d20bc 	.word	0xf03d20bc
102d6e6c:	102e597c 	.word	0x102e597c

102d6e70 <cJSON_GetErrorPtr>:
static const unsigned char *global_ep = NULL;
static void *(*cJSON_malloc)(size_t sz) = Ql_MEM_Alloc;
static void (*cJSON_free)(void *ptr) = Ql_MEM_Free;
CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
{
    return (const char*) global_ep;
102d6e70:	e59f3004 	ldr	r3, [pc, #4]	; 102d6e7c <cJSON_GetErrorPtr+0xc>
}
102d6e74:	e5930200 	ldr	r0, [r3, #512]	; 0x200
102d6e78:	e12fff1e 	bx	lr
102d6e7c:	f03d62b0 	.word	0xf03d62b0

102d6e80 <cJSON_Version>:
#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 4) || (CJSON_VERSION_PATCH != 2)
    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
#endif

CJSON_PUBLIC(const char*) cJSON_Version(void)
{
102d6e80:	e92d4010 	push	{r4, lr}
    static char version[15];
    Ql_sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
102d6e84:	e3a03002 	mov	r3, #2
#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 4) || (CJSON_VERSION_PATCH != 2)
    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
#endif

CJSON_PUBLIC(const char*) cJSON_Version(void)
{
102d6e88:	e24dd008 	sub	sp, sp, #8
    static char version[15];
    Ql_sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
102d6e8c:	e58d3000 	str	r3, [sp]
102d6e90:	e59f4024 	ldr	r4, [pc, #36]	; 102d6ebc <cJSON_Version+0x3c>
102d6e94:	e59f3024 	ldr	r3, [pc, #36]	; 102d6ec0 <cJSON_Version+0x40>
102d6e98:	e1a00004 	mov	r0, r4
102d6e9c:	e593c000 	ldr	ip, [r3]
102d6ea0:	e59f101c 	ldr	r1, [pc, #28]	; 102d6ec4 <cJSON_Version+0x44>
102d6ea4:	e3a02001 	mov	r2, #1
102d6ea8:	e3a03004 	mov	r3, #4
102d6eac:	e12fff3c 	blx	ip

    return version;
}
102d6eb0:	e1a00004 	mov	r0, r4
102d6eb4:	e28dd008 	add	sp, sp, #8
102d6eb8:	e8bd8010 	pop	{r4, pc}
102d6ebc:	f03d64b4 	.word	0xf03d64b4
102d6ec0:	f03de540 	.word	0xf03de540
102d6ec4:	102ef934 	.word	0x102ef934

102d6ec8 <cJSON_InitHooks>:
    return copy;
}

CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
{
    if (hooks == NULL)
102d6ec8:	e3500000 	cmp	r0, #0

    return copy;
}

CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
{
102d6ecc:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    if (hooks == NULL)
102d6ed0:	0a000018 	beq	102d6f38 <cJSON_InitHooks+0x70>
        global_hooks.reallocate = realloc;
        return;
    }

    global_hooks.allocate = Ql_MEM_Alloc;
    if (hooks->malloc_fn != NULL)
102d6ed4:	e5902000 	ldr	r2, [r0]
        global_hooks.deallocate = Ql_MEM_Free;
        global_hooks.reallocate = realloc;
        return;
    }

    global_hooks.allocate = Ql_MEM_Alloc;
102d6ed8:	e59f3078 	ldr	r3, [pc, #120]	; 102d6f58 <cJSON_InitHooks+0x90>
102d6edc:	e59f1078 	ldr	r1, [pc, #120]	; 102d6f5c <cJSON_InitHooks+0x94>
    {
        global_hooks.allocate = hooks->malloc_fn;
    }

    global_hooks.deallocate = Ql_MEM_Free;
    if (hooks->free_fn != NULL)
102d6ee0:	e5900004 	ldr	r0, [r0, #4]
        global_hooks.reallocate = realloc;
        return;
    }

    global_hooks.allocate = Ql_MEM_Alloc;
    if (hooks->malloc_fn != NULL)
102d6ee4:	e3520000 	cmp	r2, #0
102d6ee8:	01a02001 	moveq	r2, r1
        global_hooks.deallocate = Ql_MEM_Free;
        global_hooks.reallocate = realloc;
        return;
    }

    global_hooks.allocate = Ql_MEM_Alloc;
102d6eec:	e5831000 	str	r1, [r3]
    if (hooks->malloc_fn != NULL)
    {
        global_hooks.allocate = hooks->malloc_fn;
102d6ef0:	15832000 	strne	r2, [r3]
    }

    global_hooks.deallocate = Ql_MEM_Free;
    if (hooks->free_fn != NULL)
102d6ef4:	e3500000 	cmp	r0, #0
    {
        global_hooks.deallocate = hooks->free_fn;
102d6ef8:	159f4058 	ldrne	r4, [pc, #88]	; 102d6f58 <cJSON_InitHooks+0x90>
    if (hooks->malloc_fn != NULL)
    {
        global_hooks.allocate = hooks->malloc_fn;
    }

    global_hooks.deallocate = Ql_MEM_Free;
102d6efc:	e59fc05c 	ldr	ip, [pc, #92]	; 102d6f60 <cJSON_InitHooks+0x98>
102d6f00:	e583c004 	str	ip, [r3, #4]
    if (hooks->free_fn != NULL)
    {
        global_hooks.deallocate = hooks->free_fn;
102d6f04:	15840004 	strne	r0, [r4, #4]
    }

    /* use realloc only if both free and malloc are used */
    global_hooks.reallocate = NULL;
    if ((global_hooks.allocate == Ql_MEM_Alloc) && (global_hooks.deallocate == Ql_MEM_Free))
102d6f08:	e1520001 	cmp	r2, r1
    {
        global_hooks.deallocate = hooks->free_fn;
    }

    /* use realloc only if both free and malloc are used */
    global_hooks.reallocate = NULL;
102d6f0c:	e3a02000 	mov	r2, #0
102d6f10:	e59f1040 	ldr	r1, [pc, #64]	; 102d6f58 <cJSON_InitHooks+0x90>
102d6f14:	e5832008 	str	r2, [r3, #8]
    if ((global_hooks.allocate == Ql_MEM_Alloc) && (global_hooks.deallocate == Ql_MEM_Free))
102d6f18:	0a000001 	beq	102d6f24 <cJSON_InitHooks+0x5c>
    {
        global_hooks.reallocate = realloc;
    }
}
102d6f1c:	e8bd0010 	ldmfd	sp!, {r4}
102d6f20:	e12fff1e 	bx	lr
        global_hooks.deallocate = hooks->free_fn;
    }

    /* use realloc only if both free and malloc are used */
    global_hooks.reallocate = NULL;
    if ((global_hooks.allocate == Ql_MEM_Alloc) && (global_hooks.deallocate == Ql_MEM_Free))
102d6f24:	e5913004 	ldr	r3, [r1, #4]
102d6f28:	e153000c 	cmp	r3, ip
    {
        global_hooks.reallocate = realloc;
102d6f2c:	059f3030 	ldreq	r3, [pc, #48]	; 102d6f64 <cJSON_InitHooks+0x9c>
102d6f30:	05813008 	streq	r3, [r1, #8]
102d6f34:	eafffff8 	b	102d6f1c <cJSON_InitHooks+0x54>
CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
{
    if (hooks == NULL)
    {
        /* Reset hooks */
        global_hooks.allocate = Ql_MEM_Alloc;
102d6f38:	e59f3018 	ldr	r3, [pc, #24]	; 102d6f58 <cJSON_InitHooks+0x90>
102d6f3c:	e59f2018 	ldr	r2, [pc, #24]	; 102d6f5c <cJSON_InitHooks+0x94>
102d6f40:	e5832000 	str	r2, [r3]
        global_hooks.deallocate = Ql_MEM_Free;
102d6f44:	e59f2014 	ldr	r2, [pc, #20]	; 102d6f60 <cJSON_InitHooks+0x98>
102d6f48:	e5832004 	str	r2, [r3, #4]
        global_hooks.reallocate = realloc;
102d6f4c:	e59f2010 	ldr	r2, [pc, #16]	; 102d6f64 <cJSON_InitHooks+0x9c>
102d6f50:	e5832008 	str	r2, [r3, #8]
        return;
102d6f54:	eafffff0 	b	102d6f1c <cJSON_InitHooks+0x54>
102d6f58:	f03d20bc 	.word	0xf03d20bc
102d6f5c:	102e4840 	.word	0x102e4840
102d6f60:	102e48b8 	.word	0x102e48b8
102d6f64:	102dfa71 	.word	0x102dfa71

102d6f68 <cJSON_Delete>:
    return node;
}

/* Delete a cJSON structure. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *c)
{
102d6f68:	e92d4070 	push	{r4, r5, r6, lr}
    cJSON *next = NULL;
    while (c)
102d6f6c:	e2504000 	subs	r4, r0, #0
102d6f70:	08bd8070 	popeq	{r4, r5, r6, pc}
102d6f74:	e59f6088 	ldr	r6, [pc, #136]	; 102d7004 <cJSON_Delete+0x9c>
102d6f78:	ea00000e 	b	102d6fb8 <cJSON_Delete+0x50>
        {
            cJSON_Delete(c->child);
        }
        if (!(c->type & cJSON_IsReference) && c->valuestring)
        {
            global_hooks.deallocate(c->valuestring);
102d6f7c:	e5963004 	ldr	r3, [r6, #4]
102d6f80:	e12fff33 	blx	r3
102d6f84:	e594200c 	ldr	r2, [r4, #12]
        }
        if (!(c->type & cJSON_StringIsConst) && c->string)
102d6f88:	e3120c02 	tst	r2, #512	; 0x200
102d6f8c:	1a000004 	bne	102d6fa4 <cJSON_Delete+0x3c>
102d6f90:	e5940020 	ldr	r0, [r4, #32]
102d6f94:	e3500000 	cmp	r0, #0
102d6f98:	0a000001 	beq	102d6fa4 <cJSON_Delete+0x3c>
        {
            global_hooks.deallocate(c->string);
102d6f9c:	e5963004 	ldr	r3, [r6, #4]
102d6fa0:	e12fff33 	blx	r3
        }
        global_hooks.deallocate(c);
102d6fa4:	e1a00004 	mov	r0, r4
102d6fa8:	e5963004 	ldr	r3, [r6, #4]
102d6fac:	e12fff33 	blx	r3

/* Delete a cJSON structure. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *c)
{
    cJSON *next = NULL;
    while (c)
102d6fb0:	e2554000 	subs	r4, r5, #0
102d6fb4:	0a000011 	beq	102d7000 <cJSON_Delete+0x98>
    {
        next = c->next;
        if (!(c->type & cJSON_IsReference) && c->child)
102d6fb8:	e594300c 	ldr	r3, [r4, #12]
CJSON_PUBLIC(void) cJSON_Delete(cJSON *c)
{
    cJSON *next = NULL;
    while (c)
    {
        next = c->next;
102d6fbc:	e5945000 	ldr	r5, [r4]
        if (!(c->type & cJSON_IsReference) && c->child)
102d6fc0:	e3130c01 	tst	r3, #256	; 0x100
102d6fc4:	e1a02003 	mov	r2, r3
102d6fc8:	1affffee 	bne	102d6f88 <cJSON_Delete+0x20>
102d6fcc:	e5940008 	ldr	r0, [r4, #8]
102d6fd0:	e3500000 	cmp	r0, #0
102d6fd4:	0a000004 	beq	102d6fec <cJSON_Delete+0x84>
        {
            cJSON_Delete(c->child);
102d6fd8:	ebffffe2 	bl	102d6f68 <cJSON_Delete>
        }
        if (!(c->type & cJSON_IsReference) && c->valuestring)
102d6fdc:	e594300c 	ldr	r3, [r4, #12]
102d6fe0:	e3130c01 	tst	r3, #256	; 0x100
102d6fe4:	e1a02003 	mov	r2, r3
102d6fe8:	1affffe6 	bne	102d6f88 <cJSON_Delete+0x20>
102d6fec:	e5940010 	ldr	r0, [r4, #16]
102d6ff0:	e3500000 	cmp	r0, #0
102d6ff4:	1affffe0 	bne	102d6f7c <cJSON_Delete+0x14>
102d6ff8:	e1a02003 	mov	r2, r3
102d6ffc:	eaffffe1 	b	102d6f88 <cJSON_Delete+0x20>
102d7000:	e8bd8070 	pop	{r4, r5, r6, pc}
102d7004:	f03d20bc 	.word	0xf03d20bc

102d7008 <ReplaceItemInArray>:
        newitem->prev->next = newitem;
    }
}

static void ReplaceItemInArray(cJSON *array, size_t which, cJSON *newitem)
{
102d7008:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    cJSON *c = array->child;
102d700c:	e5904008 	ldr	r4, [r0, #8]
    while (c && (which > 0))
102d7010:	e3510000 	cmp	r1, #0
102d7014:	13540000 	cmpne	r4, #0
102d7018:	e1a03004 	mov	r3, r4
102d701c:	0a000008 	beq	102d7044 <ReplaceItemInArray+0x3c>
102d7020:	e2511001 	subs	r1, r1, #1
    {
        c = c->next;
102d7024:	e5933000 	ldr	r3, [r3]
}

static void ReplaceItemInArray(cJSON *array, size_t which, cJSON *newitem)
{
    cJSON *c = array->child;
    while (c && (which > 0))
102d7028:	03a0c000 	moveq	ip, #0
102d702c:	13a0c001 	movne	ip, #1
102d7030:	e3530000 	cmp	r3, #0
102d7034:	03a0c000 	moveq	ip, #0
102d7038:	120cc001 	andne	ip, ip, #1
102d703c:	e35c0000 	cmp	ip, #0
102d7040:	1afffff6 	bne	102d7020 <ReplaceItemInArray+0x18>
    {
        c = c->next;
        which--;
    }
    if (!c)
102d7044:	e3530000 	cmp	r3, #0
102d7048:	0a00000d 	beq	102d7084 <ReplaceItemInArray+0x7c>
    {
        return;
    }
    newitem->next = c->next;
    newitem->prev = c->prev;
102d704c:	e8931002 	ldm	r3, {r1, ip}
    if (newitem->next)
102d7050:	e3510000 	cmp	r1, #0
    if (!c)
    {
        return;
    }
    newitem->next = c->next;
    newitem->prev = c->prev;
102d7054:	e8821002 	stm	r2, {r1, ip}
    if (newitem->next)
    {
        newitem->next->prev = newitem;
102d7058:	15812004 	strne	r2, [r1, #4]
    }
    if (c == array->child)
102d705c:	e1530004 	cmp	r3, r4
    {
        array->child = newitem;
    }
    else
    {
        newitem->prev->next = newitem;
102d7060:	15921004 	ldrne	r1, [r2, #4]
    {
        newitem->next->prev = newitem;
    }
    if (c == array->child)
    {
        array->child = newitem;
102d7064:	05802008 	streq	r2, [r0, #8]
    }
    else
    {
        newitem->prev->next = newitem;
102d7068:	15812000 	strne	r2, [r1]
    }
    c->next = c->prev = NULL;
    cJSON_Delete(c);
102d706c:	e1a00003 	mov	r0, r3
    }
    else
    {
        newitem->prev->next = newitem;
    }
    c->next = c->prev = NULL;
102d7070:	e3a02000 	mov	r2, #0
102d7074:	e5832004 	str	r2, [r3, #4]
102d7078:	e5832000 	str	r2, [r3]
    cJSON_Delete(c);
}
102d707c:	e8bd0010 	ldmfd	sp!, {r4}
    else
    {
        newitem->prev->next = newitem;
    }
    c->next = c->prev = NULL;
    cJSON_Delete(c);
102d7080:	eaffffb8 	b	102d6f68 <cJSON_Delete>
}
102d7084:	e8bd0010 	ldmfd	sp!, {r4}
102d7088:	e12fff1e 	bx	lr

102d708c <parse_value.constprop.11>:
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d708c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
{
    if (input == NULL)
102d7090:	e2516000 	subs	r6, r1, #0
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d7094:	e24dd008 	sub	sp, sp, #8
102d7098:	e1a08000 	mov	r8, r0
102d709c:	e1a05002 	mov	r5, r2
{
    if (input == NULL)
102d70a0:	0a000076 	beq	102d7280 <parse_value.constprop.11+0x1f4>
        return NULL; /* no input */
    }

    /* parse the different types of values */
    /* null */
    if (!Ql_strncmp((const char*)input, "null", 4))
102d70a4:	e1a00006 	mov	r0, r6
102d70a8:	e59f14f0 	ldr	r1, [pc, #1264]	; 102d75a0 <parse_value.constprop.11+0x514>
102d70ac:	e3a02004 	mov	r2, #4
102d70b0:	e59f44ec 	ldr	r4, [pc, #1260]	; 102d75a4 <parse_value.constprop.11+0x518>
102d70b4:	e12fff34 	blx	r4
102d70b8:	e3500000 	cmp	r0, #0
102d70bc:	1a000005 	bne	102d70d8 <parse_value.constprop.11+0x4c>
    {
        item->type = cJSON_NULL;
102d70c0:	e3a03004 	mov	r3, #4
        return input + 4;
102d70c4:	e0867003 	add	r7, r6, r3

    /* parse the different types of values */
    /* null */
    if (!Ql_strncmp((const char*)input, "null", 4))
    {
        item->type = cJSON_NULL;
102d70c8:	e588300c 	str	r3, [r8, #12]
    }

    /* failure. */
    *error_pointer = input;
    return NULL;
}
102d70cc:	e1a00007 	mov	r0, r7
102d70d0:	e28dd008 	add	sp, sp, #8
102d70d4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    {
        item->type = cJSON_NULL;
        return input + 4;
    }
    /* false */
    if (!Ql_strncmp((const char*)input, "false", 5))
102d70d8:	e1a00006 	mov	r0, r6
102d70dc:	e59f14c4 	ldr	r1, [pc, #1220]	; 102d75a8 <parse_value.constprop.11+0x51c>
102d70e0:	e3a02005 	mov	r2, #5
102d70e4:	e12fff34 	blx	r4
102d70e8:	e3500000 	cmp	r0, #0
    {
        item->type = cJSON_False;
102d70ec:	03a03001 	moveq	r3, #1
102d70f0:	0588300c 	streq	r3, [r8, #12]
        return input + 5;
102d70f4:	02867005 	addeq	r7, r6, #5
102d70f8:	0afffff3 	beq	102d70cc <parse_value.constprop.11+0x40>
    }
    /* true */
    if (!Ql_strncmp((const char*)input, "true", 4))
102d70fc:	e1a00006 	mov	r0, r6
102d7100:	e59f14a4 	ldr	r1, [pc, #1188]	; 102d75ac <parse_value.constprop.11+0x520>
102d7104:	e3a02004 	mov	r2, #4
102d7108:	e12fff34 	blx	r4
102d710c:	e3500000 	cmp	r0, #0
102d7110:	0a000054 	beq	102d7268 <parse_value.constprop.11+0x1dc>
        item->type = cJSON_True;
        item->valueint = 1;
        return input + 4;
    }
    /* string */
    if (*input == '\"')
102d7114:	e5d63000 	ldrb	r3, [r6]
102d7118:	e3530022 	cmp	r3, #34	; 0x22
102d711c:	0a0000b5 	beq	102d73f8 <parse_value.constprop.11+0x36c>
    {
        return parse_string(item, input, error_pointer, hooks);
    }
    /* number */
    if ((*input == '-') || ((*input >= '0') && (*input <= '9')))
102d7120:	e2437030 	sub	r7, r3, #48	; 0x30
102d7124:	e353002d 	cmp	r3, #45	; 0x2d
102d7128:	13570009 	cmpne	r7, #9
102d712c:	83a07000 	movhi	r7, #0
102d7130:	93a07001 	movls	r7, #1
102d7134:	9a00007f 	bls	102d7338 <parse_value.constprop.11+0x2ac>
    {
        return parse_number(item, input);
    }
    /* array */
    if (*input == '[')
102d7138:	e353005b 	cmp	r3, #91	; 0x5b
102d713c:	0a0000b7 	beq	102d7420 <parse_value.constprop.11+0x394>
    {
        return parse_array(item, input, error_pointer, hooks);
    }
    /* object */
    if (*input == '{')
102d7140:	e353007b 	cmp	r3, #123	; 0x7b
    {
        return parse_object(item, input, error_pointer, hooks);
    }

    /* failure. */
    *error_pointer = input;
102d7144:	15856000 	strne	r6, [r5]
    if (*input == '[')
    {
        return parse_array(item, input, error_pointer, hooks);
    }
    /* object */
    if (*input == '{')
102d7148:	1affffdf 	bne	102d70cc <parse_value.constprop.11+0x40>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d714c:	e2967001 	adds	r7, r6, #1
102d7150:	e5d63001 	ldrb	r3, [r6, #1]
102d7154:	0a00000d 	beq	102d7190 <parse_value.constprop.11+0x104>
102d7158:	e3530000 	cmp	r3, #0
102d715c:	0a00000d 	beq	102d7198 <parse_value.constprop.11+0x10c>
102d7160:	e3530020 	cmp	r3, #32
102d7164:	8a000009 	bhi	102d7190 <parse_value.constprop.11+0x104>
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d7168:	e2866002 	add	r6, r6, #2
102d716c:	ea000004 	b	102d7184 <parse_value.constprop.11+0xf8>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7170:	e4d63001 	ldrb	r3, [r6], #1
102d7174:	e3530000 	cmp	r3, #0
102d7178:	0a000006 	beq	102d7198 <parse_value.constprop.11+0x10c>
102d717c:	e3530020 	cmp	r3, #32
102d7180:	8a000002 	bhi	102d7190 <parse_value.constprop.11+0x104>
102d7184:	e2567000 	subs	r7, r6, #0
102d7188:	1afffff8 	bne	102d7170 <parse_value.constprop.11+0xe4>
102d718c:	e5d73000 	ldrb	r3, [r7]
        *error_pointer = input;
        goto fail; /* not an object */
    }

    input = skip_whitespace(input + 1);
    if (*input == '}')
102d7190:	e353007d 	cmp	r3, #125	; 0x7d
102d7194:	0a00009f 	beq	102d7418 <parse_value.constprop.11+0x38c>

/* Build an object from the text. */
static const unsigned char *parse_object(cJSON * const item, const unsigned char *input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
{
    cJSON *head = NULL; /* linked list head */
    cJSON *current_item = NULL;
102d7198:	e3a09000 	mov	r9, #0
    {
        goto success; /* empty object */
    }

    /* step back to character in front of the first element */
    input--;
102d719c:	e2477001 	sub	r7, r7, #1
}

/* Build an object from the text. */
static const unsigned char *parse_object(cJSON * const item, const unsigned char *input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
{
    cJSON *head = NULL; /* linked list head */
102d71a0:	e1a04009 	mov	r4, r9
            goto fail; /* faile to parse name */
        }

        /* swap valuestring and string, because we parsed the name */
        current_item->string = current_item->valuestring;
        current_item->valuestring = NULL;
102d71a4:	e1a06009 	mov	r6, r9
    input--;
    /* loop through the comma separated array elements */
    do
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(hooks);
102d71a8:	ebfffef7 	bl	102d6d8c <cJSON_New_Item.constprop.16>
        if (new_item == NULL)
102d71ac:	e250a000 	subs	sl, r0, #0
102d71b0:	0a0000f6 	beq	102d7590 <parse_value.constprop.11+0x504>
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
102d71b4:	e3540000 	cmp	r4, #0
            current_item = head = new_item;
        }
        else
        {
            /* add to the end and advance */
            current_item->next = new_item;
102d71b8:	1589a000 	strne	sl, [r9]
            new_item->prev = current_item;
102d71bc:	158a9004 	strne	r9, [sl, #4]
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
102d71c0:	01a0400a 	moveq	r4, sl
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d71c4:	e2971001 	adds	r1, r7, #1
102d71c8:	0a00000e 	beq	102d7208 <parse_value.constprop.11+0x17c>
102d71cc:	e5d73001 	ldrb	r3, [r7, #1]
102d71d0:	e3530000 	cmp	r3, #0
102d71d4:	0a00000b 	beq	102d7208 <parse_value.constprop.11+0x17c>
102d71d8:	e3530020 	cmp	r3, #32
102d71dc:	8a000009 	bhi	102d7208 <parse_value.constprop.11+0x17c>
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d71e0:	e2873002 	add	r3, r7, #2
102d71e4:	ea000004 	b	102d71fc <parse_value.constprop.11+0x170>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d71e8:	e4d32001 	ldrb	r2, [r3], #1
102d71ec:	e3520000 	cmp	r2, #0
102d71f0:	0a000004 	beq	102d7208 <parse_value.constprop.11+0x17c>
102d71f4:	e3520020 	cmp	r2, #32
102d71f8:	8a000002 	bhi	102d7208 <parse_value.constprop.11+0x17c>
102d71fc:	e3530000 	cmp	r3, #0
    {
        in++;
102d7200:	e1a01003 	mov	r1, r3
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7204:	1afffff7 	bne	102d71e8 <parse_value.constprop.11+0x15c>
            current_item = new_item;
        }

        /* parse the name of the child */
        input = skip_whitespace(input + 1);
        input = parse_string(current_item, input, error_pointer, hooks);
102d7208:	e1a0000a 	mov	r0, sl
102d720c:	e1a02005 	mov	r2, r5
102d7210:	ebfffdca 	bl	102d6940 <parse_string.constprop.15>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7214:	e3500000 	cmp	r0, #0
102d7218:	0a00000e 	beq	102d7258 <parse_value.constprop.11+0x1cc>
102d721c:	e5d03000 	ldrb	r3, [r0]
102d7220:	e3530000 	cmp	r3, #0
102d7224:	0a000017 	beq	102d7288 <parse_value.constprop.11+0x1fc>
102d7228:	e3530020 	cmp	r3, #32
102d722c:	8a000015 	bhi	102d7288 <parse_value.constprop.11+0x1fc>
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d7230:	e2803001 	add	r3, r0, #1
102d7234:	ea000004 	b	102d724c <parse_value.constprop.11+0x1c0>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7238:	e4d32001 	ldrb	r2, [r3], #1
102d723c:	e3520000 	cmp	r2, #0
102d7240:	0a000010 	beq	102d7288 <parse_value.constprop.11+0x1fc>
102d7244:	e3520020 	cmp	r2, #32
102d7248:	8a00000e 	bhi	102d7288 <parse_value.constprop.11+0x1fc>
102d724c:	e3530000 	cmp	r3, #0
    {
        in++;
102d7250:	e1a00003 	mov	r0, r3
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7254:	1afffff7 	bne	102d7238 <parse_value.constprop.11+0x1ac>
    return input + 1;

fail:
    if (head != NULL)
    {
        cJSON_Delete(head);
102d7258:	e1a00004 	mov	r0, r4
102d725c:	ebffff41 	bl	102d6f68 <cJSON_Delete>
    }

    return NULL;
102d7260:	e3a07000 	mov	r7, #0
102d7264:	eaffff98 	b	102d70cc <parse_value.constprop.11+0x40>
        return input + 5;
    }
    /* true */
    if (!Ql_strncmp((const char*)input, "true", 4))
    {
        item->type = cJSON_True;
102d7268:	e3a03002 	mov	r3, #2
102d726c:	e588300c 	str	r3, [r8, #12]
        item->valueint = 1;
102d7270:	e3a03001 	mov	r3, #1
102d7274:	e5883014 	str	r3, [r8, #20]
        return input + 4;
102d7278:	e2867004 	add	r7, r6, #4
102d727c:	eaffff92 	b	102d70cc <parse_value.constprop.11+0x40>
/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
{
    if (input == NULL)
    {
        return NULL; /* no input */
102d7280:	e1a07006 	mov	r7, r6
102d7284:	eaffff90 	b	102d70cc <parse_value.constprop.11+0x40>
        {
            goto fail; /* faile to parse name */
        }

        /* swap valuestring and string, because we parsed the name */
        current_item->string = current_item->valuestring;
102d7288:	e59a3010 	ldr	r3, [sl, #16]
102d728c:	e58a3020 	str	r3, [sl, #32]
        current_item->valuestring = NULL;
102d7290:	e58a6010 	str	r6, [sl, #16]

        if (*input != ':')
102d7294:	e5d03000 	ldrb	r3, [r0]
102d7298:	e353003a 	cmp	r3, #58	; 0x3a
102d729c:	1a0000b2 	bne	102d756c <parse_value.constprop.11+0x4e0>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d72a0:	e2901001 	adds	r1, r0, #1
102d72a4:	0a00000e 	beq	102d72e4 <parse_value.constprop.11+0x258>
102d72a8:	e5d03001 	ldrb	r3, [r0, #1]
102d72ac:	e3530000 	cmp	r3, #0
102d72b0:	0a00000b 	beq	102d72e4 <parse_value.constprop.11+0x258>
102d72b4:	e3530020 	cmp	r3, #32
102d72b8:	8a000009 	bhi	102d72e4 <parse_value.constprop.11+0x258>
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d72bc:	e2803002 	add	r3, r0, #2
102d72c0:	ea000004 	b	102d72d8 <parse_value.constprop.11+0x24c>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d72c4:	e4d32001 	ldrb	r2, [r3], #1
102d72c8:	e3520000 	cmp	r2, #0
102d72cc:	0a000004 	beq	102d72e4 <parse_value.constprop.11+0x258>
102d72d0:	e3520020 	cmp	r2, #32
102d72d4:	8a000002 	bhi	102d72e4 <parse_value.constprop.11+0x258>
102d72d8:	e3530000 	cmp	r3, #0
    {
        in++;
102d72dc:	e1a01003 	mov	r1, r3
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d72e0:	1afffff7 	bne	102d72c4 <parse_value.constprop.11+0x238>
            goto fail; /* invalid object */
        }

        /* parse the value */
        input = skip_whitespace(input + 1);
        input = parse_value(current_item, input, error_pointer, hooks);
102d72e4:	e1a0000a 	mov	r0, sl
102d72e8:	e1a02005 	mov	r2, r5
102d72ec:	ebffff66 	bl	102d708c <parse_value.constprop.11>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d72f0:	e2507000 	subs	r7, r0, #0
102d72f4:	0affffd7 	beq	102d7258 <parse_value.constprop.11+0x1cc>
102d72f8:	e5d72000 	ldrb	r2, [r7]
102d72fc:	e3520000 	cmp	r2, #0
102d7300:	0a000042 	beq	102d7410 <parse_value.constprop.11+0x384>
102d7304:	e3520020 	cmp	r2, #32
102d7308:	8a000030 	bhi	102d73d0 <parse_value.constprop.11+0x344>
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d730c:	e2871001 	add	r1, r7, #1
102d7310:	ea000004 	b	102d7328 <parse_value.constprop.11+0x29c>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7314:	e4d12001 	ldrb	r2, [r1], #1
102d7318:	e3520000 	cmp	r2, #0
102d731c:	0a00003b 	beq	102d7410 <parse_value.constprop.11+0x384>
102d7320:	e3520020 	cmp	r2, #32
102d7324:	8a000029 	bhi	102d73d0 <parse_value.constprop.11+0x344>
102d7328:	e3510000 	cmp	r1, #0
    {
        in++;
102d732c:	e1a07001 	mov	r7, r1
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7330:	1afffff7 	bne	102d7314 <parse_value.constprop.11+0x288>
102d7334:	eaffffc7 	b	102d7258 <parse_value.constprop.11+0x1cc>
/* Parse the input text to generate a number, and populate the result into item. */
static const unsigned char *parse_number(cJSON* const item, const unsigned char* const input)
{
	////APP_DEBUG("parse_number1 = %c\r\n",*input);
    double number = 0;
    unsigned char *after_end = NULL;
102d7338:	e28d1008 	add	r1, sp, #8
102d733c:	e3a0a000 	mov	sl, #0
102d7340:	e521a004 	str	sl, [r1, #-4]!
    if (input == NULL)
    {
        return NULL;
    }

    number = strtod((const char*)input, (char**)&after_end);
102d7344:	e1a00006 	mov	r0, r6
102d7348:	e59f3260 	ldr	r3, [pc, #608]	; 102d75b0 <parse_value.constprop.11+0x524>
102d734c:	e12fff33 	blx	r3
    if (input == after_end)
102d7350:	e59d7004 	ldr	r7, [sp, #4]
102d7354:	e1560007 	cmp	r6, r7
    if (input == NULL)
    {
        return NULL;
    }

    number = strtod((const char*)input, (char**)&after_end);
102d7358:	e1a04000 	mov	r4, r0
102d735c:	e1a05001 	mov	r5, r1
    if (input == after_end)
102d7360:	0a000083 	beq	102d7574 <parse_value.constprop.11+0x4e8>
    }
	////APP_DEBUG("parse_number2 = %c\r\n",*input);
    item->valuedouble = number;
	////APP_DEBUG("parse_number = %lld\r\n",item->valuedouble);
    /* use saturation in case of overflow */
    if (number >= INT_MAX)
102d7364:	e59f3248 	ldr	r3, [pc, #584]	; 102d75b4 <parse_value.constprop.11+0x528>
    {
		////APP_DEBUG("parse_number2 after end \r\n");
        return NULL; /* parse_error */
    }
	////APP_DEBUG("parse_number2 = %c\r\n",*input);
    item->valuedouble = number;
102d7368:	e1c841f8 	strd	r4, [r8, #24]
	////APP_DEBUG("parse_number = %lld\r\n",item->valuedouble);
    /* use saturation in case of overflow */
    if (number >= INT_MAX)
102d736c:	e59f2244 	ldr	r2, [pc, #580]	; 102d75b8 <parse_value.constprop.11+0x52c>
102d7370:	e59fc244 	ldr	ip, [pc, #580]	; 102d75bc <parse_value.constprop.11+0x530>
102d7374:	e12fff3c 	blx	ip
102d7378:	e150000a 	cmp	r0, sl
    {
        item->valueint = INT_MAX;
102d737c:	13e03102 	mvnne	r3, #-2147483648	; 0x80000000
102d7380:	15883014 	strne	r3, [r8, #20]
    }
	////APP_DEBUG("parse_number2 = %c\r\n",*input);
    item->valuedouble = number;
	////APP_DEBUG("parse_number = %lld\r\n",item->valuedouble);
    /* use saturation in case of overflow */
    if (number >= INT_MAX)
102d7384:	1a00000e 	bne	102d73c4 <parse_value.constprop.11+0x338>
    {
        item->valueint = INT_MAX;
    }
    else if (number <= INT_MIN)
102d7388:	e59f3230 	ldr	r3, [pc, #560]	; 102d75c0 <parse_value.constprop.11+0x534>
102d738c:	e1a00004 	mov	r0, r4
102d7390:	e1a01005 	mov	r1, r5
102d7394:	e3a02000 	mov	r2, #0
102d7398:	e59fc224 	ldr	ip, [pc, #548]	; 102d75c4 <parse_value.constprop.11+0x538>
102d739c:	e12fff3c 	blx	ip
102d73a0:	e3500000 	cmp	r0, #0
    {
        item->valueint = INT_MIN;
102d73a4:	13a03102 	movne	r3, #-2147483648	; 0x80000000
102d73a8:	15883014 	strne	r3, [r8, #20]
    /* use saturation in case of overflow */
    if (number >= INT_MAX)
    {
        item->valueint = INT_MAX;
    }
    else if (number <= INT_MIN)
102d73ac:	1a000004 	bne	102d73c4 <parse_value.constprop.11+0x338>
    {
        item->valueint = INT_MIN;
    }
    else
    {
        item->valueint = (int)number;
102d73b0:	e1a00004 	mov	r0, r4
102d73b4:	e1a01005 	mov	r1, r5
102d73b8:	e59f3208 	ldr	r3, [pc, #520]	; 102d75c8 <parse_value.constprop.11+0x53c>
102d73bc:	e12fff33 	blx	r3
102d73c0:	e5880014 	str	r0, [r8, #20]
    }

    item->type = cJSON_Number;
102d73c4:	e3a03008 	mov	r3, #8
102d73c8:	e588300c 	str	r3, [r8, #12]
102d73cc:	eaffff3e 	b	102d70cc <parse_value.constprop.11+0x40>
        if (input == NULL)
        {
            goto fail; /* failed to parse value */
        }
    }
    while (*input == ',');
102d73d0:	e352002c 	cmp	r2, #44	; 0x2c
102d73d4:	e1a0900a 	mov	r9, sl
102d73d8:	0affff72 	beq	102d71a8 <parse_value.constprop.11+0x11c>

    if (*input != '}')
102d73dc:	e352007d 	cmp	r2, #125	; 0x7d
102d73e0:	1a00000a 	bne	102d7410 <parse_value.constprop.11+0x384>
        *error_pointer = input;
        goto fail; /* expected end of object */
    }

success:
    item->type = cJSON_Object;
102d73e4:	e3a03040 	mov	r3, #64	; 0x40
102d73e8:	e588300c 	str	r3, [r8, #12]
    item->child = head;
102d73ec:	e5884008 	str	r4, [r8, #8]

    return input + 1;
102d73f0:	e2877001 	add	r7, r7, #1
102d73f4:	eaffff34 	b	102d70cc <parse_value.constprop.11+0x40>
        return input + 4;
    }
    /* string */
    if (*input == '\"')
    {
        return parse_string(item, input, error_pointer, hooks);
102d73f8:	e1a00008 	mov	r0, r8
102d73fc:	e1a01006 	mov	r1, r6
102d7400:	e1a02005 	mov	r2, r5
102d7404:	ebfffd4d 	bl	102d6940 <parse_string.constprop.15>
102d7408:	e1a07000 	mov	r7, r0
102d740c:	eaffff2e 	b	102d70cc <parse_value.constprop.11+0x40>
    }
    while (*input == ',');

    if (*input != '}')
    {
        *error_pointer = input;
102d7410:	e5857000 	str	r7, [r5]
102d7414:	eaffff8f 	b	102d7258 <parse_value.constprop.11+0x1cc>
}

/* Build an object from the text. */
static const unsigned char *parse_object(cJSON * const item, const unsigned char *input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
{
    cJSON *head = NULL; /* linked list head */
102d7418:	e3a04000 	mov	r4, #0
102d741c:	eafffff0 	b	102d73e4 <parse_value.constprop.11+0x358>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7420:	e2964001 	adds	r4, r6, #1
102d7424:	0a00000e 	beq	102d7464 <parse_value.constprop.11+0x3d8>
102d7428:	e5d63001 	ldrb	r3, [r6, #1]
102d742c:	e3530000 	cmp	r3, #0
102d7430:	0a00000e 	beq	102d7470 <parse_value.constprop.11+0x3e4>
102d7434:	e3530020 	cmp	r3, #32
102d7438:	8a000009 	bhi	102d7464 <parse_value.constprop.11+0x3d8>
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d743c:	e2866002 	add	r6, r6, #2
102d7440:	ea000004 	b	102d7458 <parse_value.constprop.11+0x3cc>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7444:	e4d63001 	ldrb	r3, [r6], #1
102d7448:	e3530000 	cmp	r3, #0
102d744c:	0a000007 	beq	102d7470 <parse_value.constprop.11+0x3e4>
102d7450:	e3530020 	cmp	r3, #32
102d7454:	8a000002 	bhi	102d7464 <parse_value.constprop.11+0x3d8>
102d7458:	e3560000 	cmp	r6, #0
    {
        in++;
102d745c:	e1a04006 	mov	r4, r6
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7460:	1afffff7 	bne	102d7444 <parse_value.constprop.11+0x3b8>
        *error_pointer = input;
        goto fail;
    }

    input = skip_whitespace(input + 1);
    if (*input == ']')
102d7464:	e5d43000 	ldrb	r3, [r4]
102d7468:	e353005d 	cmp	r3, #93	; 0x5d
102d746c:	0a000042 	beq	102d757c <parse_value.constprop.11+0x4f0>

/* Build an array from input text. */
static const unsigned char *parse_array(cJSON * const item, const unsigned char *input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
{
    cJSON *head = NULL; /* head of the linked list */
    cJSON *current_item = NULL;
102d7470:	e3a0a000 	mov	sl, #0
        /* empty array */
        goto success;
    }

    /* step back to character in front of the first element */
    input--;
102d7474:	e2444001 	sub	r4, r4, #1
}

/* Build an array from input text. */
static const unsigned char *parse_array(cJSON * const item, const unsigned char *input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
{
    cJSON *head = NULL; /* head of the linked list */
102d7478:	e1a0700a 	mov	r7, sl
    input--;
    /* loop through the comma separated array elements */
    do
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(hooks);
102d747c:	ebfffe42 	bl	102d6d8c <cJSON_New_Item.constprop.16>
        if (new_item == NULL)
102d7480:	e2506000 	subs	r6, r0, #0
102d7484:	0a00003e 	beq	102d7584 <parse_value.constprop.11+0x4f8>
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
102d7488:	e3570000 	cmp	r7, #0
            current_item = head = new_item;
        }
        else
        {
            /* add to the end and advance */
            current_item->next = new_item;
102d748c:	158a6000 	strne	r6, [sl]
            new_item->prev = current_item;
102d7490:	1586a004 	strne	sl, [r6, #4]
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
102d7494:	01a07006 	moveq	r7, r6
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7498:	e2941001 	adds	r1, r4, #1
102d749c:	0a00000e 	beq	102d74dc <parse_value.constprop.11+0x450>
102d74a0:	e5d43001 	ldrb	r3, [r4, #1]
102d74a4:	e3530000 	cmp	r3, #0
102d74a8:	0a00000b 	beq	102d74dc <parse_value.constprop.11+0x450>
102d74ac:	e3530020 	cmp	r3, #32
102d74b0:	8a000009 	bhi	102d74dc <parse_value.constprop.11+0x450>
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d74b4:	e2843002 	add	r3, r4, #2
102d74b8:	ea000004 	b	102d74d0 <parse_value.constprop.11+0x444>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d74bc:	e4d32001 	ldrb	r2, [r3], #1
102d74c0:	e3520000 	cmp	r2, #0
102d74c4:	0a000004 	beq	102d74dc <parse_value.constprop.11+0x450>
102d74c8:	e3520020 	cmp	r2, #32
102d74cc:	8a000002 	bhi	102d74dc <parse_value.constprop.11+0x450>
102d74d0:	e3530000 	cmp	r3, #0
    {
        in++;
102d74d4:	e1a01003 	mov	r1, r3
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d74d8:	1afffff7 	bne	102d74bc <parse_value.constprop.11+0x430>
            current_item = new_item;
        }

        /* parse next value */
        input = skip_whitespace(input + 1);
        input = parse_value(current_item, input, error_pointer, hooks);
102d74dc:	e1a00006 	mov	r0, r6
102d74e0:	e1a02005 	mov	r2, r5
102d74e4:	ebfffee8 	bl	102d708c <parse_value.constprop.11>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d74e8:	e2504000 	subs	r4, r0, #0
102d74ec:	0a00000e 	beq	102d752c <parse_value.constprop.11+0x4a0>
102d74f0:	e5d42000 	ldrb	r2, [r4]
102d74f4:	e3520000 	cmp	r2, #0
102d74f8:	0a000019 	beq	102d7564 <parse_value.constprop.11+0x4d8>
102d74fc:	e3520020 	cmp	r2, #32
102d7500:	8a00000d 	bhi	102d753c <parse_value.constprop.11+0x4b0>
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
}

/* Parser core - when encountering text, process appropriately. */
static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
102d7504:	e2843001 	add	r3, r4, #1
102d7508:	ea000004 	b	102d7520 <parse_value.constprop.11+0x494>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d750c:	e4d32001 	ldrb	r2, [r3], #1
102d7510:	e3520000 	cmp	r2, #0
102d7514:	0a000012 	beq	102d7564 <parse_value.constprop.11+0x4d8>
102d7518:	e3520020 	cmp	r2, #32
102d751c:	8a000006 	bhi	102d753c <parse_value.constprop.11+0x4b0>
102d7520:	e3530000 	cmp	r3, #0
    {
        in++;
102d7524:	e1a04003 	mov	r4, r3
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7528:	1afffff7 	bne	102d750c <parse_value.constprop.11+0x480>
    return input + 1;

fail:
    if (head != NULL)
    {
        cJSON_Delete(head);
102d752c:	e1a00007 	mov	r0, r7
102d7530:	ebfffe8c 	bl	102d6f68 <cJSON_Delete>
    }

    return NULL;
102d7534:	e3a07000 	mov	r7, #0
102d7538:	eafffee3 	b	102d70cc <parse_value.constprop.11+0x40>
        if (input == NULL)
        {
            goto fail; /* failed to parse value */
        }
    }
    while (*input == ',');
102d753c:	e352002c 	cmp	r2, #44	; 0x2c
102d7540:	e1a0a006 	mov	sl, r6
102d7544:	0affffcc 	beq	102d747c <parse_value.constprop.11+0x3f0>

    if (*input != ']')
102d7548:	e352005d 	cmp	r2, #93	; 0x5d
102d754c:	1a000004 	bne	102d7564 <parse_value.constprop.11+0x4d8>
        *error_pointer = input;
        goto fail; /* expected end of array */
    }

success:
    item->type = cJSON_Array;
102d7550:	e3a03020 	mov	r3, #32
    item->child = head;
102d7554:	e5887008 	str	r7, [r8, #8]
        *error_pointer = input;
        goto fail; /* expected end of array */
    }

success:
    item->type = cJSON_Array;
102d7558:	e588300c 	str	r3, [r8, #12]
    item->child = head;

    return input + 1;
102d755c:	e2847001 	add	r7, r4, #1
102d7560:	eafffed9 	b	102d70cc <parse_value.constprop.11+0x40>
    }
    while (*input == ',');

    if (*input != ']')
    {
        *error_pointer = input;
102d7564:	e5854000 	str	r4, [r5]
102d7568:	eaffffef 	b	102d752c <parse_value.constprop.11+0x4a0>
        current_item->string = current_item->valuestring;
        current_item->valuestring = NULL;

        if (*input != ':')
        {
            *error_pointer = input;
102d756c:	e5850000 	str	r0, [r5]
102d7570:	eaffff38 	b	102d7258 <parse_value.constprop.11+0x1cc>

    number = strtod((const char*)input, (char**)&after_end);
    if (input == after_end)
    {
		////APP_DEBUG("parse_number2 after end \r\n");
        return NULL; /* parse_error */
102d7574:	e1a0700a 	mov	r7, sl
102d7578:	eafffed3 	b	102d70cc <parse_value.constprop.11+0x40>
}

/* Build an array from input text. */
static const unsigned char *parse_array(cJSON * const item, const unsigned char *input, const unsigned char ** const error_pointer, const internal_hooks * const hooks)
{
    cJSON *head = NULL; /* head of the linked list */
102d757c:	e3a07000 	mov	r7, #0
102d7580:	eafffff2 	b	102d7550 <parse_value.constprop.11+0x4c4>
    item->child = head;

    return input + 1;

fail:
    if (head != NULL)
102d7584:	e3570000 	cmp	r7, #0
102d7588:	1affffe7 	bne	102d752c <parse_value.constprop.11+0x4a0>
102d758c:	eafffece 	b	102d70cc <parse_value.constprop.11+0x40>
    item->child = head;

    return input + 1;

fail:
    if (head != NULL)
102d7590:	e3540000 	cmp	r4, #0
    {
        cJSON_Delete(head);
    }

    return NULL;
102d7594:	01a07004 	moveq	r7, r4
    item->child = head;

    return input + 1;

fail:
    if (head != NULL)
102d7598:	1affff2e 	bne	102d7258 <parse_value.constprop.11+0x1cc>
102d759c:	eafffeca 	b	102d70cc <parse_value.constprop.11+0x40>
102d75a0:	102ef90c 	.word	0x102ef90c
102d75a4:	102e5884 	.word	0x102e5884
102d75a8:	102ef914 	.word	0x102ef914
102d75ac:	102ef91c 	.word	0x102ef91c
102d75b0:	102e0eb1 	.word	0x102e0eb1
102d75b4:	41dfffff 	.word	0x41dfffff
102d75b8:	ffc00000 	.word	0xffc00000
102d75bc:	102e38d0 	.word	0x102e38d0
102d75c0:	c1e00000 	.word	0xc1e00000
102d75c4:	102e38b8 	.word	0x102e38b8
102d75c8:	102e3900 	.word	0x102e3900

102d75cc <cJSON_SetNumberHelper>:
    return after_end;
}

/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
{
102d75cc:	e92d4070 	push	{r4, r5, r6, lr}
    if (number >= INT_MAX)
102d75d0:	e1a01003 	mov	r1, r3
    return after_end;
}

/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
{
102d75d4:	e1a06000 	mov	r6, r0
102d75d8:	e1a04002 	mov	r4, r2
    if (number >= INT_MAX)
102d75dc:	e1a00002 	mov	r0, r2
    return after_end;
}

/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
{
102d75e0:	e1a05003 	mov	r5, r3
    if (number >= INT_MAX)
102d75e4:	e59f2050 	ldr	r2, [pc, #80]	; 102d763c <cJSON_SetNumberHelper+0x70>
102d75e8:	e59f3050 	ldr	r3, [pc, #80]	; 102d7640 <cJSON_SetNumberHelper+0x74>
102d75ec:	e59fc050 	ldr	ip, [pc, #80]	; 102d7644 <cJSON_SetNumberHelper+0x78>
102d75f0:	e12fff3c 	blx	ip
102d75f4:	e3500000 	cmp	r0, #0
    {
        object->valueint = INT_MAX;
102d75f8:	13e03102 	mvnne	r3, #-2147483648	; 0x80000000
102d75fc:	15863014 	strne	r3, [r6, #20]
}

/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
{
    if (number >= INT_MAX)
102d7600:	1a000009 	bne	102d762c <cJSON_SetNumberHelper+0x60>
    {
        object->valueint = INT_MAX;
    }
    else if (number <= INT_MIN)
102d7604:	e59f303c 	ldr	r3, [pc, #60]	; 102d7648 <cJSON_SetNumberHelper+0x7c>
102d7608:	e1a00004 	mov	r0, r4
102d760c:	e1a01005 	mov	r1, r5
102d7610:	e3a02000 	mov	r2, #0
102d7614:	e59fc030 	ldr	ip, [pc, #48]	; 102d764c <cJSON_SetNumberHelper+0x80>
102d7618:	e12fff3c 	blx	ip
102d761c:	e3500000 	cmp	r0, #0
    {
        object->valueint = INT_MIN;
102d7620:	13a03102 	movne	r3, #-2147483648	; 0x80000000
    }
    else
    {
        object->valueint = cJSON_Number;
102d7624:	03a03008 	moveq	r3, #8
102d7628:	e5863014 	str	r3, [r6, #20]
    }

    return object->valuedouble = number;
102d762c:	e1c641f8 	strd	r4, [r6, #24]
}
102d7630:	e1a00004 	mov	r0, r4
102d7634:	e1a01005 	mov	r1, r5
102d7638:	e8bd8070 	pop	{r4, r5, r6, pc}
102d763c:	ffc00000 	.word	0xffc00000
102d7640:	41dfffff 	.word	0x41dfffff
102d7644:	102e38d0 	.word	0x102e38d0
102d7648:	c1e00000 	.word	0xc1e00000
102d764c:	102e38b8 	.word	0x102e38b8

102d7650 <cJSON_ParseWithOpts>:
    return in;
}

/* Parse an object - create a new root, and populate. */
CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
{
102d7650:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    const unsigned char *end = NULL;
    /* use global error pointer if no specific one was given */
    const unsigned char **ep = return_parse_end ? (const unsigned char**)return_parse_end : &global_ep;
102d7654:	e3510000 	cmp	r1, #0
102d7658:	e59f60ec 	ldr	r6, [pc, #236]	; 102d774c <cJSON_ParseWithOpts+0xfc>
102d765c:	e1a05001 	mov	r5, r1
102d7660:	11a06001 	movne	r6, r1
    return in;
}

/* Parse an object - create a new root, and populate. */
CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
{
102d7664:	e1a04000 	mov	r4, r0
102d7668:	e1a08002 	mov	r8, r2
    const unsigned char *end = NULL;
    /* use global error pointer if no specific one was given */
    const unsigned char **ep = return_parse_end ? (const unsigned char**)return_parse_end : &global_ep;
    cJSON *c = cJSON_New_Item(&global_hooks);
102d766c:	ebfffdc6 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    *ep = NULL;
102d7670:	e3a03000 	mov	r3, #0
102d7674:	e5863000 	str	r3, [r6]
    if (!c) /* memory fail */
102d7678:	e2507000 	subs	r7, r0, #0
102d767c:	0a000027 	beq	102d7720 <cJSON_ParseWithOpts+0xd0>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d7680:	e1540003 	cmp	r4, r3
102d7684:	0a00000e 	beq	102d76c4 <cJSON_ParseWithOpts+0x74>
102d7688:	e5d43000 	ldrb	r3, [r4]
102d768c:	e3530000 	cmp	r3, #0
102d7690:	0a00000b 	beq	102d76c4 <cJSON_ParseWithOpts+0x74>
102d7694:	e3530020 	cmp	r3, #32
102d7698:	8a000009 	bhi	102d76c4 <cJSON_ParseWithOpts+0x74>

    return in;
}

/* Parse an object - create a new root, and populate. */
CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
102d769c:	e2843001 	add	r3, r4, #1
102d76a0:	ea000004 	b	102d76b8 <cJSON_ParseWithOpts+0x68>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d76a4:	e4d3c001 	ldrb	ip, [r3], #1
102d76a8:	e35c0000 	cmp	ip, #0
102d76ac:	0a000004 	beq	102d76c4 <cJSON_ParseWithOpts+0x74>
102d76b0:	e35c0020 	cmp	ip, #32
102d76b4:	8a000002 	bhi	102d76c4 <cJSON_ParseWithOpts+0x74>
102d76b8:	e3530000 	cmp	r3, #0
    {
        in++;
102d76bc:	e1a04003 	mov	r4, r3
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d76c0:	1afffff7 	bne	102d76a4 <cJSON_ParseWithOpts+0x54>
    if (!c) /* memory fail */
    {
        return NULL;
    }

    end = parse_value(c, skip_whitespace((const unsigned char*)value), ep, &global_hooks);
102d76c4:	e1a01004 	mov	r1, r4
102d76c8:	e1a00007 	mov	r0, r7
102d76cc:	e1a02006 	mov	r2, r6
102d76d0:	ebfffe6d 	bl	102d708c <parse_value.constprop.11>
    if (!end)
102d76d4:	e2504000 	subs	r4, r0, #0
102d76d8:	0a000017 	beq	102d773c <cJSON_ParseWithOpts+0xec>
        cJSON_Delete(c);
        return NULL;
    }

    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
    if (require_null_terminated)
102d76dc:	e3580000 	cmp	r8, #0
102d76e0:	11a03004 	movne	r3, r4
102d76e4:	0a00000b 	beq	102d7718 <cJSON_ParseWithOpts+0xc8>
static cJSON_bool print_object(const cJSON * const item, const size_t depth, const cJSON_bool format, printbuffer * const output_buffer, const internal_hooks * const hooks);

/* Utility to jump whitespace and cr/lf */
static const unsigned char *skip_whitespace(const unsigned char *in)
{
    while (in && *in && (*in <= 32))
102d76e8:	e5d3c000 	ldrb	ip, [r3]
102d76ec:	e1a04003 	mov	r4, r3
102d76f0:	e35c0000 	cmp	ip, #0
102d76f4:	e2833001 	add	r3, r3, #1
102d76f8:	0a000006 	beq	102d7718 <cJSON_ParseWithOpts+0xc8>
102d76fc:	e35c0020 	cmp	ip, #32
102d7700:	8a000008 	bhi	102d7728 <cJSON_ParseWithOpts+0xd8>
102d7704:	e2534000 	subs	r4, r3, #0
102d7708:	1afffff6 	bne	102d76e8 <cJSON_ParseWithOpts+0x98>

    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
    if (require_null_terminated)
    {
        end = skip_whitespace(end);
        if (*end)
102d770c:	e5d43000 	ldrb	r3, [r4]
102d7710:	e3530000 	cmp	r3, #0
102d7714:	1a000003 	bne	102d7728 <cJSON_ParseWithOpts+0xd8>
            cJSON_Delete(c);
            *ep = end;
            return NULL;
        }
    }
    if (return_parse_end)
102d7718:	e3550000 	cmp	r5, #0
    {
        *return_parse_end = (const char*)end;
102d771c:	15854000 	strne	r4, [r5]
    }

    return c;
}
102d7720:	e1a00007 	mov	r0, r7
102d7724:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    if (require_null_terminated)
    {
        end = skip_whitespace(end);
        if (*end)
        {
            cJSON_Delete(c);
102d7728:	e1a00007 	mov	r0, r7
102d772c:	ebfffe0d 	bl	102d6f68 <cJSON_Delete>
            *ep = end;
            return NULL;
102d7730:	e3a07000 	mov	r7, #0
    {
        end = skip_whitespace(end);
        if (*end)
        {
            cJSON_Delete(c);
            *ep = end;
102d7734:	e5864000 	str	r4, [r6]
            return NULL;
102d7738:	eafffff8 	b	102d7720 <cJSON_ParseWithOpts+0xd0>

    end = parse_value(c, skip_whitespace((const unsigned char*)value), ep, &global_hooks);
    if (!end)
    {
        /* parse failure. ep is set. */
        cJSON_Delete(c);
102d773c:	e1a00007 	mov	r0, r7
102d7740:	ebfffe08 	bl	102d6f68 <cJSON_Delete>
        return NULL;
102d7744:	e1a07004 	mov	r7, r4
102d7748:	eafffff4 	b	102d7720 <cJSON_ParseWithOpts+0xd0>
102d774c:	f03d64b0 	.word	0xf03d64b0

102d7750 <cJSON_Parse>:
}

/* Default options for cJSON_Parse */
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
{
    return cJSON_ParseWithOpts(value, 0, 0);
102d7750:	e3a01000 	mov	r1, #0
102d7754:	e1a02001 	mov	r2, r1
102d7758:	eaffffbc 	b	102d7650 <cJSON_ParseWithOpts>

102d775c <cJSON_Print>:

/* Render a cJSON item/entity/structure to text. */
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
{
	//APP_DEBUG("inside cJSON_Print\r\n");
    return (char*)print(item, true, &global_hooks);
102d775c:	e3a01001 	mov	r1, #1
102d7760:	eafffc3d 	b	102d685c <print.constprop.7>

102d7764 <cJSON_PrintUnformatted>:
}

CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
{
    return (char*)print(item, false, &global_hooks);
102d7764:	e3a01000 	mov	r1, #0
102d7768:	eafffc3b 	b	102d685c <print.constprop.7>

102d776c <cJSON_PrintBuffered>:
}

CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
{
102d776c:	e92d4070 	push	{r4, r5, r6, lr}
    printbuffer p;

    if (prebuffer < 0)
102d7770:	e2514000 	subs	r4, r1, #0
{
    return (char*)print(item, false, &global_hooks);
}

CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
{
102d7774:	e24dd010 	sub	sp, sp, #16
102d7778:	e1a06000 	mov	r6, r0
102d777c:	e1a05002 	mov	r5, r2
    printbuffer p;

    if (prebuffer < 0)
102d7780:	ba000013 	blt	102d77d4 <cJSON_PrintBuffered+0x68>
    {
        return NULL;
    }

    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
102d7784:	e59f3050 	ldr	r3, [pc, #80]	; 102d77dc <cJSON_PrintBuffered+0x70>
102d7788:	e1a00004 	mov	r0, r4
102d778c:	e5933000 	ldr	r3, [r3]
102d7790:	e12fff33 	blx	r3
    if (!p.buffer)
102d7794:	e3500000 	cmp	r0, #0
    if (prebuffer < 0)
    {
        return NULL;
    }

    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
102d7798:	e58d0000 	str	r0, [sp]
    if (!p.buffer)
102d779c:	0a00000c 	beq	102d77d4 <cJSON_PrintBuffered+0x68>
    {
        return NULL;
    }

    p.length = (size_t)prebuffer;
    p.offset = 0;
102d77a0:	e3a0c000 	mov	ip, #0
    p.noalloc = false;

    if (!print_value(item, 0, fmt, &p, &global_hooks))
102d77a4:	e1a00006 	mov	r0, r6
102d77a8:	e1a0100c 	mov	r1, ip
102d77ac:	e1a02005 	mov	r2, r5
102d77b0:	e1a0300d 	mov	r3, sp
    {
        return NULL;
    }

    p.length = (size_t)prebuffer;
    p.offset = 0;
102d77b4:	e98d1010 	stmib	sp, {r4, ip}
    p.noalloc = false;
102d77b8:	e58dc00c 	str	ip, [sp, #12]

    if (!print_value(item, 0, fmt, &p, &global_hooks))
102d77bc:	ebfffa6c 	bl	102d6174 <print_value.constprop.8>
102d77c0:	e3500000 	cmp	r0, #0
102d77c4:	0a000002 	beq	102d77d4 <cJSON_PrintBuffered+0x68>
    {
        return NULL;
    }

    return (char*)p.buffer;
102d77c8:	e59d0000 	ldr	r0, [sp]
}
102d77cc:	e28dd010 	add	sp, sp, #16
102d77d0:	e8bd8070 	pop	{r4, r5, r6, pc}
{
    printbuffer p;

    if (prebuffer < 0)
    {
        return NULL;
102d77d4:	e3a00000 	mov	r0, #0
102d77d8:	eafffffb 	b	102d77cc <cJSON_PrintBuffered+0x60>
102d77dc:	f03d20bc 	.word	0xf03d20bc

102d77e0 <cJSON_PrintPreallocated>:

    return (char*)p.buffer;
}

CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)
{
102d77e0:	e92d4030 	push	{r4, r5, lr}
    printbuffer p;

    if (len < 0)
102d77e4:	e2524000 	subs	r4, r2, #0

    return (char*)p.buffer;
}

CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)
{
102d77e8:	e24dd014 	sub	sp, sp, #20
102d77ec:	e1a05001 	mov	r5, r1
    printbuffer p;

    if (len < 0)
    {
        return false;
102d77f0:	b3a00000 	movlt	r0, #0

CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)
{
    printbuffer p;

    if (len < 0)
102d77f4:	ba000008 	blt	102d781c <cJSON_PrintPreallocated+0x3c>
        return false;
    }

    p.buffer = (unsigned char*)buf;
    p.length = (size_t)len;
    p.offset = 0;
102d77f8:	e3a0c000 	mov	ip, #0
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
102d77fc:	e1a0100c 	mov	r1, ip
102d7800:	e1a02003 	mov	r2, r3
        return false;
    }

    p.buffer = (unsigned char*)buf;
    p.length = (size_t)len;
    p.offset = 0;
102d7804:	e98d1010 	stmib	sp, {r4, ip}
    p.noalloc = true;
    return print_value(item, 0, fmt, &p, &global_hooks);
102d7808:	e1a0300d 	mov	r3, sp
    }

    p.buffer = (unsigned char*)buf;
    p.length = (size_t)len;
    p.offset = 0;
    p.noalloc = true;
102d780c:	e3a0c001 	mov	ip, #1
    if (len < 0)
    {
        return false;
    }

    p.buffer = (unsigned char*)buf;
102d7810:	e58d5000 	str	r5, [sp]
    p.length = (size_t)len;
    p.offset = 0;
    p.noalloc = true;
102d7814:	e58dc00c 	str	ip, [sp, #12]
    return print_value(item, 0, fmt, &p, &global_hooks);
102d7818:	ebfffa55 	bl	102d6174 <print_value.constprop.8>
}
102d781c:	e28dd014 	add	sp, sp, #20
102d7820:	e8bd8030 	pop	{r4, r5, pc}

102d7824 <cJSON_GetArraySize>:
}

/* Get Array size/item / object item. */
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
{
    cJSON *c = array->child;
102d7824:	e5903008 	ldr	r3, [r0, #8]
    size_t i = 0;
    while(c)
102d7828:	e3530000 	cmp	r3, #0
102d782c:	0a000005 	beq	102d7848 <cJSON_GetArraySize+0x24>
102d7830:	e3a00000 	mov	r0, #0
    {
        i++;
        c = c->next;
102d7834:	e5933000 	ldr	r3, [r3]
{
    cJSON *c = array->child;
    size_t i = 0;
    while(c)
    {
        i++;
102d7838:	e2800001 	add	r0, r0, #1
/* Get Array size/item / object item. */
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
{
    cJSON *c = array->child;
    size_t i = 0;
    while(c)
102d783c:	e3530000 	cmp	r3, #0
102d7840:	1afffffb 	bne	102d7834 <cJSON_GetArraySize+0x10>
102d7844:	e12fff1e 	bx	lr
102d7848:	e1a00003 	mov	r0, r3
    }

    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */

    return (int)i;
}
102d784c:	e12fff1e 	bx	lr

102d7850 <cJSON_GetArrayItem>:

CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int item)
{
    cJSON *c = array ? array->child : NULL;
102d7850:	e3500000 	cmp	r0, #0
102d7854:	012fff1e 	bxeq	lr
102d7858:	e5900008 	ldr	r0, [r0, #8]
    while (c && item > 0)
102d785c:	e3500000 	cmp	r0, #0
102d7860:	13510000 	cmpne	r1, #0
102d7864:	d12fff1e 	bxle	lr
    {
        item--;
        c = c->next;
102d7868:	e5900000 	ldr	r0, [r0]
CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int item)
{
    cJSON *c = array ? array->child : NULL;
    while (c && item > 0)
    {
        item--;
102d786c:	e2411001 	sub	r1, r1, #1
}

CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int item)
{
    cJSON *c = array ? array->child : NULL;
    while (c && item > 0)
102d7870:	e3500000 	cmp	r0, #0
102d7874:	13510000 	cmpne	r1, #0
102d7878:	cafffffa 	bgt	102d7868 <cJSON_GetArrayItem+0x18>
        item--;
        c = c->next;
    }

    return c;
}
102d787c:	e12fff1e 	bx	lr

102d7880 <cJSON_GetObjectItem>:

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON *object, const char *string)
{
    cJSON *c = object ? object->child : NULL;
102d7880:	e3500000 	cmp	r0, #0

    return c;
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON *object, const char *string)
{
102d7884:	e92d4038 	push	{r3, r4, r5, lr}
102d7888:	e1a05001 	mov	r5, r1
    cJSON *c = object ? object->child : NULL;
102d788c:	01a04000 	moveq	r4, r0
102d7890:	0a00000b 	beq	102d78c4 <cJSON_GetObjectItem+0x44>
102d7894:	e5904008 	ldr	r4, [r0, #8]
    while (c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
102d7898:	e3540000 	cmp	r4, #0
102d789c:	1a000003 	bne	102d78b0 <cJSON_GetObjectItem+0x30>
102d78a0:	ea000007 	b	102d78c4 <cJSON_GetObjectItem+0x44>
    {
        c = c->next;
102d78a4:	e5944000 	ldr	r4, [r4]
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON *object, const char *string)
{
    cJSON *c = object ? object->child : NULL;
    while (c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
102d78a8:	e3540000 	cmp	r4, #0
102d78ac:	0a000004 	beq	102d78c4 <cJSON_GetObjectItem+0x44>
102d78b0:	e5940020 	ldr	r0, [r4, #32]
102d78b4:	e1a01005 	mov	r1, r5
102d78b8:	ebfff8f4 	bl	102d5c90 <cJSON_strcasecmp>
102d78bc:	e3500000 	cmp	r0, #0
102d78c0:	1afffff7 	bne	102d78a4 <cJSON_GetObjectItem+0x24>
    {
        c = c->next;
    }
    return c;
}
102d78c4:	e1a00004 	mov	r0, r4
102d78c8:	e8bd8038 	pop	{r3, r4, r5, pc}

102d78cc <cJSON_GetObjectItemCaseSensitive>:

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (string == NULL))
102d78cc:	e3500000 	cmp	r0, #0
102d78d0:	13510000 	cmpne	r1, #0
    }
    return c;
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
{
102d78d4:	e92d4070 	push	{r4, r5, r6, lr}
    cJSON *current_element = NULL;

    if ((object == NULL) || (string == NULL))
102d78d8:	e1a05001 	mov	r5, r1
102d78dc:	0a00000e 	beq	102d791c <cJSON_GetObjectItemCaseSensitive+0x50>
    {
        return NULL;
    }

    current_element = object->child;
102d78e0:	e5904008 	ldr	r4, [r0, #8]
    while ((current_element != NULL) && (strcmp(string, current_element->string) != 0))
102d78e4:	e3540000 	cmp	r4, #0
102d78e8:	0a000009 	beq	102d7914 <cJSON_GetObjectItemCaseSensitive+0x48>
102d78ec:	e59f6034 	ldr	r6, [pc, #52]	; 102d7928 <cJSON_GetObjectItemCaseSensitive+0x5c>
102d78f0:	ea000002 	b	102d7900 <cJSON_GetObjectItemCaseSensitive+0x34>
    {
        current_element = current_element->next;
102d78f4:	e5944000 	ldr	r4, [r4]
    {
        return NULL;
    }

    current_element = object->child;
    while ((current_element != NULL) && (strcmp(string, current_element->string) != 0))
102d78f8:	e3540000 	cmp	r4, #0
102d78fc:	0a000004 	beq	102d7914 <cJSON_GetObjectItemCaseSensitive+0x48>
102d7900:	e5941020 	ldr	r1, [r4, #32]
102d7904:	e1a00005 	mov	r0, r5
102d7908:	e12fff36 	blx	r6
102d790c:	e3500000 	cmp	r0, #0
102d7910:	1afffff7 	bne	102d78f4 <cJSON_GetObjectItemCaseSensitive+0x28>
    {
        current_element = current_element->next;
    }

    return current_element;
}
102d7914:	e1a00004 	mov	r0, r4
102d7918:	e8bd8070 	pop	{r4, r5, r6, pc}
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (string == NULL))
    {
        return NULL;
102d791c:	e3a04000 	mov	r4, #0
    {
        current_element = current_element->next;
    }

    return current_element;
}
102d7920:	e1a00004 	mov	r0, r4
102d7924:	e8bd8070 	pop	{r4, r5, r6, pc}
102d7928:	102dff41 	.word	0x102dff41

102d792c <cJSON_HasObjectItem>:

CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
{
102d792c:	e92d4008 	push	{r3, lr}
    return cJSON_GetObjectItem(object, string) ? 1 : 0;
102d7930:	ebffffd2 	bl	102d7880 <cJSON_GetObjectItem>
}
102d7934:	e2900000 	adds	r0, r0, #0
102d7938:	13a00001 	movne	r0, #1
102d793c:	e8bd8008 	pop	{r3, pc}

102d7940 <cJSON_AddItemToArray>:
/* Add item to array/object. */
CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
{
    cJSON *child = NULL;

    if ((item == NULL) || (array == NULL))
102d7940:	e3500000 	cmp	r0, #0
102d7944:	13510000 	cmpne	r1, #0
102d7948:	012fff1e 	bxeq	lr
    {
        return;
    }

    child = array->child;
102d794c:	e5902008 	ldr	r2, [r0, #8]

    if (child == NULL)
102d7950:	e3520000 	cmp	r2, #0
    {
        /* list is empty, start new one */
        array->child = item;
102d7954:	05801008 	streq	r1, [r0, #8]
        return;
    }

    child = array->child;

    if (child == NULL)
102d7958:	1a000001 	bne	102d7964 <cJSON_AddItemToArray+0x24>
102d795c:	e12fff1e 	bx	lr
    else
    {
        /* append to the end */
        while (child->next)
        {
            child = child->next;
102d7960:	e1a02003 	mov	r2, r3
        array->child = item;
    }
    else
    {
        /* append to the end */
        while (child->next)
102d7964:	e5923000 	ldr	r3, [r2]
102d7968:	e3530000 	cmp	r3, #0
102d796c:	1afffffb 	bne	102d7960 <cJSON_AddItemToArray+0x20>
}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev, cJSON *item)
{
    prev->next = item;
102d7970:	e5821000 	str	r1, [r2]
    item->prev = prev;
102d7974:	e5812004 	str	r2, [r1, #4]
102d7978:	e12fff1e 	bx	lr

102d797c <cJSON_AddItemToObjectCS>:
    item->type &= ~cJSON_StringIsConst;
}

/* Add an item to an object with constant string as key */
CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
{
102d797c:	e92d4070 	push	{r4, r5, r6, lr}
    if (!item)
102d7980:	e2524000 	subs	r4, r2, #0
    item->type &= ~cJSON_StringIsConst;
}

/* Add an item to an object with constant string as key */
CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
{
102d7984:	e1a05000 	mov	r5, r0
102d7988:	e1a06001 	mov	r6, r1
    if (!item)
102d798c:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
        return;
    }
    if (!(item->type & cJSON_StringIsConst) && item->string)
102d7990:	e594300c 	ldr	r3, [r4, #12]
102d7994:	e3130c02 	tst	r3, #512	; 0x200
102d7998:	1a000006 	bne	102d79b8 <cJSON_AddItemToObjectCS+0x3c>
102d799c:	e5940020 	ldr	r0, [r4, #32]
102d79a0:	e3500000 	cmp	r0, #0
102d79a4:	0a000003 	beq	102d79b8 <cJSON_AddItemToObjectCS+0x3c>
    {
        global_hooks.deallocate(item->string);
102d79a8:	e59f3024 	ldr	r3, [pc, #36]	; 102d79d4 <cJSON_AddItemToObjectCS+0x58>
102d79ac:	e5933004 	ldr	r3, [r3, #4]
102d79b0:	e12fff33 	blx	r3
102d79b4:	e594300c 	ldr	r3, [r4, #12]
    }
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
    item->string = (char*)string;
#pragma GCC diagnostic pop
    item->type |= cJSON_StringIsConst;
102d79b8:	e3833c02 	orr	r3, r3, #512	; 0x200
    cJSON_AddItemToArray(object, item);
102d79bc:	e1a00005 	mov	r0, r5
102d79c0:	e1a01004 	mov	r1, r4
    {
        global_hooks.deallocate(item->string);
    }
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
    item->string = (char*)string;
102d79c4:	e5846020 	str	r6, [r4, #32]
#pragma GCC diagnostic pop
    item->type |= cJSON_StringIsConst;
102d79c8:	e584300c 	str	r3, [r4, #12]
    cJSON_AddItemToArray(object, item);
}
102d79cc:	e8bd4070 	pop	{r4, r5, r6, lr}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
    item->string = (char*)string;
#pragma GCC diagnostic pop
    item->type |= cJSON_StringIsConst;
    cJSON_AddItemToArray(object, item);
102d79d0:	eaffffda 	b	102d7940 <cJSON_AddItemToArray>
102d79d4:	f03d20bc 	.word	0xf03d20bc

102d79d8 <cJSON_AddItemToObject>:
        suffix_object(child, item);
    }
}

CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
{
102d79d8:	e92d4038 	push	{r3, r4, r5, lr}
102d79dc:	e1a05000 	mov	r5, r0
    /* call cJSON_AddItemToObjectCS for code reuse */
    cJSON_AddItemToObjectCS(object, (char*)cJSON_strdup((const unsigned char*)string, &global_hooks), item);
102d79e0:	e1a00001 	mov	r0, r1
        suffix_object(child, item);
    }
}

CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
{
102d79e4:	e1a04002 	mov	r4, r2
    /* call cJSON_AddItemToObjectCS for code reuse */
    cJSON_AddItemToObjectCS(object, (char*)cJSON_strdup((const unsigned char*)string, &global_hooks), item);
102d79e8:	ebfffd09 	bl	102d6e14 <cJSON_strdup.constprop.17>
102d79ec:	e1a02004 	mov	r2, r4
102d79f0:	e1a01000 	mov	r1, r0
102d79f4:	e1a00005 	mov	r0, r5
102d79f8:	ebffffdf 	bl	102d797c <cJSON_AddItemToObjectCS>
    /* remove cJSON_StringIsConst flag */
    item->type &= ~cJSON_StringIsConst;
102d79fc:	e594300c 	ldr	r3, [r4, #12]
102d7a00:	e3c33c02 	bic	r3, r3, #512	; 0x200
102d7a04:	e584300c 	str	r3, [r4, #12]
102d7a08:	e8bd8038 	pop	{r3, r4, r5, pc}

102d7a0c <cJSON_AddItemReferenceToArray>:
    item->type |= cJSON_StringIsConst;
    cJSON_AddItemToArray(object, item);
}

CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
{
102d7a0c:	e92d4010 	push	{r4, lr}
102d7a10:	e1a04000 	mov	r4, r0
    cJSON_AddItemToArray(array, create_reference(item, &global_hooks));
102d7a14:	e1a00001 	mov	r0, r1
102d7a18:	ebfffcea 	bl	102d6dc8 <create_reference.constprop.6>
102d7a1c:	e1a01000 	mov	r1, r0
102d7a20:	e1a00004 	mov	r0, r4
}
102d7a24:	e8bd4010 	pop	{r4, lr}
    cJSON_AddItemToArray(object, item);
}

CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
{
    cJSON_AddItemToArray(array, create_reference(item, &global_hooks));
102d7a28:	eaffffc4 	b	102d7940 <cJSON_AddItemToArray>

102d7a2c <cJSON_AddItemReferenceToObject>:
}

CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
{
102d7a2c:	e92d4038 	push	{r3, r4, r5, lr}
102d7a30:	e1a04000 	mov	r4, r0
    cJSON_AddItemToObject(object, string, create_reference(item, &global_hooks));
102d7a34:	e1a00002 	mov	r0, r2
{
    cJSON_AddItemToArray(array, create_reference(item, &global_hooks));
}

CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
{
102d7a38:	e1a05001 	mov	r5, r1
    cJSON_AddItemToObject(object, string, create_reference(item, &global_hooks));
102d7a3c:	ebfffce1 	bl	102d6dc8 <create_reference.constprop.6>
102d7a40:	e1a01005 	mov	r1, r5
102d7a44:	e1a02000 	mov	r2, r0
102d7a48:	e1a00004 	mov	r0, r4
}
102d7a4c:	e8bd4038 	pop	{r3, r4, r5, lr}
    cJSON_AddItemToArray(array, create_reference(item, &global_hooks));
}

CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
{
    cJSON_AddItemToObject(object, string, create_reference(item, &global_hooks));
102d7a50:	eaffffe0 	b	102d79d8 <cJSON_AddItemToObject>

102d7a54 <cJSON_DetachItemFromArray>:

    return c;
}
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
{
    if (which < 0)
102d7a54:	e3510000 	cmp	r1, #0
102d7a58:	ba000000 	blt	102d7a60 <cJSON_DetachItemFromArray+0xc>
    {
        return NULL;
    }

    return DetachItemFromArray(array, (size_t)which);
102d7a5c:	eafff8d0 	b	102d5da4 <DetachItemFromArray>
}
102d7a60:	e3a00000 	mov	r0, #0
102d7a64:	e12fff1e 	bx	lr

102d7a68 <cJSON_DeleteItemFromArray>:

CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
{
102d7a68:	e92d4008 	push	{r3, lr}
    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
102d7a6c:	ebfffff8 	bl	102d7a54 <cJSON_DetachItemFromArray>
}
102d7a70:	e8bd4008 	pop	{r3, lr}
    return DetachItemFromArray(array, (size_t)which);
}

CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
{
    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
102d7a74:	eafffd3b 	b	102d6f68 <cJSON_Delete>

102d7a78 <cJSON_DetachItemFromObject>:
}

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
{
102d7a78:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    size_t i = 0;
    cJSON *c = object->child;
102d7a7c:	e5904008 	ldr	r4, [r0, #8]
{
    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
}

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
{
102d7a80:	e1a07000 	mov	r7, r0
    size_t i = 0;
    cJSON *c = object->child;
    while (c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
102d7a84:	e3540000 	cmp	r4, #0
{
    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
}

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
{
102d7a88:	e1a06001 	mov	r6, r1
    size_t i = 0;
    cJSON *c = object->child;
    while (c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
102d7a8c:	13a05000 	movne	r5, #0
102d7a90:	1a000004 	bne	102d7aa8 <cJSON_DetachItemFromObject+0x30>
102d7a94:	ea00000c 	b	102d7acc <cJSON_DetachItemFromObject+0x54>
    {
        i++;
        c = c->next;
102d7a98:	e5944000 	ldr	r4, [r4]
{
    size_t i = 0;
    cJSON *c = object->child;
    while (c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
    {
        i++;
102d7a9c:	e2855001 	add	r5, r5, #1

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
{
    size_t i = 0;
    cJSON *c = object->child;
    while (c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
102d7aa0:	e3540000 	cmp	r4, #0
102d7aa4:	0a000008 	beq	102d7acc <cJSON_DetachItemFromObject+0x54>
102d7aa8:	e5940020 	ldr	r0, [r4, #32]
102d7aac:	e1a01006 	mov	r1, r6
102d7ab0:	ebfff876 	bl	102d5c90 <cJSON_strcasecmp>
102d7ab4:	e3500000 	cmp	r0, #0
102d7ab8:	1afffff6 	bne	102d7a98 <cJSON_DetachItemFromObject+0x20>
        i++;
        c = c->next;
    }
    if (c)
    {
        return DetachItemFromArray(object, i);
102d7abc:	e1a00007 	mov	r0, r7
102d7ac0:	e1a01005 	mov	r1, r5
    }

    return NULL;
}
102d7ac4:	e8bd40f8 	pop	{r3, r4, r5, r6, r7, lr}
        i++;
        c = c->next;
    }
    if (c)
    {
        return DetachItemFromArray(object, i);
102d7ac8:	eafff8b5 	b	102d5da4 <DetachItemFromArray>
    }

    return NULL;
}
102d7acc:	e3a00000 	mov	r0, #0
102d7ad0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

102d7ad4 <cJSON_DeleteItemFromObject>:

CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
{
102d7ad4:	e92d4008 	push	{r3, lr}
    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
102d7ad8:	ebffffe6 	bl	102d7a78 <cJSON_DetachItemFromObject>
}
102d7adc:	e8bd4008 	pop	{r3, lr}
    return NULL;
}

CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
{
    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
102d7ae0:	eafffd20 	b	102d6f68 <cJSON_Delete>

102d7ae4 <cJSON_InsertItemInArray>:
}

/* Replace array/object items with new ones. */
CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
{
    cJSON *c = array->child;
102d7ae4:	e590c008 	ldr	ip, [r0, #8]
    while (c && (which > 0))
102d7ae8:	e35c0000 	cmp	ip, #0
102d7aec:	13510000 	cmpne	r1, #0
102d7af0:	e1a0300c 	mov	r3, ip
102d7af4:	da000004 	ble	102d7b0c <cJSON_InsertItemInArray+0x28>
    {
        c = c->next;
102d7af8:	e5933000 	ldr	r3, [r3]
        which--;
102d7afc:	e2411001 	sub	r1, r1, #1

/* Replace array/object items with new ones. */
CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
{
    cJSON *c = array->child;
    while (c && (which > 0))
102d7b00:	e3530000 	cmp	r3, #0
102d7b04:	13510000 	cmpne	r1, #0
102d7b08:	cafffffa 	bgt	102d7af8 <cJSON_InsertItemInArray+0x14>
    {
        c = c->next;
        which--;
    }
    if (!c)
102d7b0c:	e3530000 	cmp	r3, #0
102d7b10:	0a000008 	beq	102d7b38 <cJSON_InsertItemInArray+0x54>
    {
        cJSON_AddItemToArray(array, newitem);
        return;
    }
    newitem->next = c;
    newitem->prev = c->prev;
102d7b14:	e5931004 	ldr	r1, [r3, #4]
    c->prev = newitem;
    if (c == array->child)
102d7b18:	e153000c 	cmp	r3, ip
    {
        cJSON_AddItemToArray(array, newitem);
        return;
    }
    newitem->next = c;
    newitem->prev = c->prev;
102d7b1c:	e5821004 	str	r1, [r2, #4]
    if (!c)
    {
        cJSON_AddItemToArray(array, newitem);
        return;
    }
    newitem->next = c;
102d7b20:	e5823000 	str	r3, [r2]
    newitem->prev = c->prev;
    c->prev = newitem;
102d7b24:	e5832004 	str	r2, [r3, #4]
    {
        array->child = newitem;
    }
    else
    {
        newitem->prev->next = newitem;
102d7b28:	15923004 	ldrne	r3, [r2, #4]
    newitem->next = c;
    newitem->prev = c->prev;
    c->prev = newitem;
    if (c == array->child)
    {
        array->child = newitem;
102d7b2c:	05802008 	streq	r2, [r0, #8]
    }
    else
    {
        newitem->prev->next = newitem;
102d7b30:	15832000 	strne	r2, [r3]
102d7b34:	e12fff1e 	bx	lr
        c = c->next;
        which--;
    }
    if (!c)
    {
        cJSON_AddItemToArray(array, newitem);
102d7b38:	e1a01002 	mov	r1, r2
102d7b3c:	eaffff7f 	b	102d7940 <cJSON_AddItemToArray>

102d7b40 <cJSON_ReplaceItemInArray>:
    c->next = c->prev = NULL;
    cJSON_Delete(c);
}
CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
{
    if (which < 0)
102d7b40:	e3510000 	cmp	r1, #0
102d7b44:	b12fff1e 	bxlt	lr
    {
        return;
    }

    ReplaceItemInArray(array, (size_t)which, newitem);
102d7b48:	eafffd2e 	b	102d7008 <ReplaceItemInArray>

102d7b4c <cJSON_ReplaceItemInObject>:
}

CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
{
102d7b4c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    size_t i = 0;
    cJSON *c = object->child;
102d7b50:	e5904008 	ldr	r4, [r0, #8]

    ReplaceItemInArray(array, (size_t)which, newitem);
}

CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
{
102d7b54:	e1a08000 	mov	r8, r0
    size_t i = 0;
    cJSON *c = object->child;
    while(c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
102d7b58:	e3540000 	cmp	r4, #0

    ReplaceItemInArray(array, (size_t)which, newitem);
}

CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
{
102d7b5c:	e1a06001 	mov	r6, r1
102d7b60:	e1a07002 	mov	r7, r2
    size_t i = 0;
    cJSON *c = object->child;
    while(c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
102d7b64:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
102d7b68:	e3a05000 	mov	r5, #0
102d7b6c:	ea000003 	b	102d7b80 <cJSON_ReplaceItemInObject+0x34>
    {
        i++;
        c = c->next;
102d7b70:	e5944000 	ldr	r4, [r4]
{
    size_t i = 0;
    cJSON *c = object->child;
    while(c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
    {
        i++;
102d7b74:	e2855001 	add	r5, r5, #1

CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
{
    size_t i = 0;
    cJSON *c = object->child;
    while(c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
102d7b78:	e3540000 	cmp	r4, #0
102d7b7c:	0a000015 	beq	102d7bd8 <cJSON_ReplaceItemInObject+0x8c>
102d7b80:	e5940020 	ldr	r0, [r4, #32]
102d7b84:	e1a01006 	mov	r1, r6
102d7b88:	ebfff840 	bl	102d5c90 <cJSON_strcasecmp>
102d7b8c:	e3500000 	cmp	r0, #0
102d7b90:	1afffff6 	bne	102d7b70 <cJSON_ReplaceItemInObject+0x24>
        c = c->next;
    }
    if(c)
    {
        /* free the old string if not const */
        if (!(newitem->type & cJSON_StringIsConst) && newitem->string)
102d7b94:	e597300c 	ldr	r3, [r7, #12]
102d7b98:	e3130c02 	tst	r3, #512	; 0x200
102d7b9c:	1a000005 	bne	102d7bb8 <cJSON_ReplaceItemInObject+0x6c>
102d7ba0:	e5970020 	ldr	r0, [r7, #32]
102d7ba4:	e3500000 	cmp	r0, #0
102d7ba8:	0a000002 	beq	102d7bb8 <cJSON_ReplaceItemInObject+0x6c>
        {
             global_hooks.deallocate(newitem->string);
102d7bac:	e59f3028 	ldr	r3, [pc, #40]	; 102d7bdc <cJSON_ReplaceItemInObject+0x90>
102d7bb0:	e5933004 	ldr	r3, [r3, #4]
102d7bb4:	e12fff33 	blx	r3
        }

        newitem->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
102d7bb8:	e1a00006 	mov	r0, r6
102d7bbc:	ebfffc94 	bl	102d6e14 <cJSON_strdup.constprop.17>
        ReplaceItemInArray(object, i, newitem);
102d7bc0:	e1a01005 	mov	r1, r5
102d7bc4:	e1a02007 	mov	r2, r7
        if (!(newitem->type & cJSON_StringIsConst) && newitem->string)
        {
             global_hooks.deallocate(newitem->string);
        }

        newitem->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
102d7bc8:	e5870020 	str	r0, [r7, #32]
        ReplaceItemInArray(object, i, newitem);
102d7bcc:	e1a00008 	mov	r0, r8
    }
}
102d7bd0:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
        {
             global_hooks.deallocate(newitem->string);
        }

        newitem->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
        ReplaceItemInArray(object, i, newitem);
102d7bd4:	eafffd0b 	b	102d7008 <ReplaceItemInArray>
102d7bd8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102d7bdc:	f03d20bc 	.word	0xf03d20bc

102d7be0 <cJSON_CreateNull>:
    }
}

/* Create basic types: */
CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
{
102d7be0:	e92d4008 	push	{r3, lr}
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7be4:	ebfffc68 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if(item)
102d7be8:	e3500000 	cmp	r0, #0
    {
        item->type = cJSON_NULL;
102d7bec:	13a03004 	movne	r3, #4
102d7bf0:	1580300c 	strne	r3, [r0, #12]
    }

    return item;
}
102d7bf4:	e8bd8008 	pop	{r3, pc}

102d7bf8 <cJSON_CreateTrue>:

CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
{
102d7bf8:	e92d4008 	push	{r3, lr}
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7bfc:	ebfffc62 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if(item)
102d7c00:	e3500000 	cmp	r0, #0
    {
        item->type = cJSON_True;
102d7c04:	13a03002 	movne	r3, #2
102d7c08:	1580300c 	strne	r3, [r0, #12]
    }

    return item;
}
102d7c0c:	e8bd8008 	pop	{r3, pc}

102d7c10 <cJSON_CreateFalse>:

CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
{
102d7c10:	e92d4008 	push	{r3, lr}
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7c14:	ebfffc5c 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if(item)
102d7c18:	e3500000 	cmp	r0, #0
    {
        item->type = cJSON_False;
102d7c1c:	13a03001 	movne	r3, #1
102d7c20:	1580300c 	strne	r3, [r0, #12]
    }

    return item;
}
102d7c24:	e8bd8008 	pop	{r3, pc}

102d7c28 <cJSON_CreateBool>:

CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool b)
{
102d7c28:	e92d4010 	push	{r4, lr}
102d7c2c:	e1a04000 	mov	r4, r0
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7c30:	ebfffc55 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if(item)
102d7c34:	e3500000 	cmp	r0, #0
102d7c38:	08bd8010 	popeq	{r4, pc}
    {
        item->type = b ? cJSON_True : cJSON_False;
102d7c3c:	e3540000 	cmp	r4, #0
102d7c40:	03a04001 	moveq	r4, #1
102d7c44:	13a04002 	movne	r4, #2
102d7c48:	e580400c 	str	r4, [r0, #12]
    }

    return item;
}
102d7c4c:	e8bd8010 	pop	{r4, pc}

102d7c50 <cJSON_CreateNumber>:

CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
{
102d7c50:	e92d4070 	push	{r4, r5, r6, lr}
102d7c54:	e1a04000 	mov	r4, r0
102d7c58:	e1a05001 	mov	r5, r1
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7c5c:	ebfffc4a 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if(item)
102d7c60:	e2506000 	subs	r6, r0, #0
102d7c64:	0a00001b 	beq	102d7cd8 <cJSON_CreateNumber+0x88>
    {
        item->type = cJSON_Number;
102d7c68:	e3a03008 	mov	r3, #8
102d7c6c:	e586300c 	str	r3, [r6, #12]
        item->valuedouble = num;
102d7c70:	e1c641f8 	strd	r4, [r6, #24]

        /* use saturation in case of overflow */
        if (num >= INT_MAX)
102d7c74:	e59f3064 	ldr	r3, [pc, #100]	; 102d7ce0 <cJSON_CreateNumber+0x90>
102d7c78:	e1a00004 	mov	r0, r4
102d7c7c:	e1a01005 	mov	r1, r5
102d7c80:	e59f205c 	ldr	r2, [pc, #92]	; 102d7ce4 <cJSON_CreateNumber+0x94>
102d7c84:	e59fc05c 	ldr	ip, [pc, #92]	; 102d7ce8 <cJSON_CreateNumber+0x98>
102d7c88:	e12fff3c 	blx	ip
102d7c8c:	e3500000 	cmp	r0, #0
        {
            item->valueint = INT_MAX;
102d7c90:	13e03102 	mvnne	r3, #-2147483648	; 0x80000000
102d7c94:	15863014 	strne	r3, [r6, #20]
    {
        item->type = cJSON_Number;
        item->valuedouble = num;

        /* use saturation in case of overflow */
        if (num >= INT_MAX)
102d7c98:	1a00000e 	bne	102d7cd8 <cJSON_CreateNumber+0x88>
        {
            item->valueint = INT_MAX;
        }
        else if (num <= INT_MIN)
102d7c9c:	e59f3048 	ldr	r3, [pc, #72]	; 102d7cec <cJSON_CreateNumber+0x9c>
102d7ca0:	e1a00004 	mov	r0, r4
102d7ca4:	e1a01005 	mov	r1, r5
102d7ca8:	e3a02000 	mov	r2, #0
102d7cac:	e59fc03c 	ldr	ip, [pc, #60]	; 102d7cf0 <cJSON_CreateNumber+0xa0>
102d7cb0:	e12fff3c 	blx	ip
102d7cb4:	e3500000 	cmp	r0, #0
        {
            item->valueint = INT_MIN;
102d7cb8:	13a03102 	movne	r3, #-2147483648	; 0x80000000
102d7cbc:	15863014 	strne	r3, [r6, #20]
        /* use saturation in case of overflow */
        if (num >= INT_MAX)
        {
            item->valueint = INT_MAX;
        }
        else if (num <= INT_MIN)
102d7cc0:	1a000004 	bne	102d7cd8 <cJSON_CreateNumber+0x88>
        {
            item->valueint = INT_MIN;
        }
        else
        {
            item->valueint = (int)num;
102d7cc4:	e1a00004 	mov	r0, r4
102d7cc8:	e1a01005 	mov	r1, r5
102d7ccc:	e59f3020 	ldr	r3, [pc, #32]	; 102d7cf4 <cJSON_CreateNumber+0xa4>
102d7cd0:	e12fff33 	blx	r3
102d7cd4:	e5860014 	str	r0, [r6, #20]
        }
    }

    return item;
}
102d7cd8:	e1a00006 	mov	r0, r6
102d7cdc:	e8bd8070 	pop	{r4, r5, r6, pc}
102d7ce0:	41dfffff 	.word	0x41dfffff
102d7ce4:	ffc00000 	.word	0xffc00000
102d7ce8:	102e38d0 	.word	0x102e38d0
102d7cec:	c1e00000 	.word	0xc1e00000
102d7cf0:	102e38b8 	.word	0x102e38b8
102d7cf4:	102e3900 	.word	0x102e3900

102d7cf8 <cJSON_CreateString>:

CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
{
102d7cf8:	e92d4038 	push	{r3, r4, r5, lr}
102d7cfc:	e1a05000 	mov	r5, r0
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7d00:	ebfffc21 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if(item)
102d7d04:	e2504000 	subs	r4, r0, #0
102d7d08:	0a000007 	beq	102d7d2c <cJSON_CreateString+0x34>
    {
        item->type = cJSON_String;
102d7d0c:	e3a03010 	mov	r3, #16
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
102d7d10:	e1a00005 	mov	r0, r5
CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_String;
102d7d14:	e584300c 	str	r3, [r4, #12]
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
102d7d18:	ebfffc3d 	bl	102d6e14 <cJSON_strdup.constprop.17>
        if(!item->valuestring)
102d7d1c:	e3500000 	cmp	r0, #0
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_String;
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
102d7d20:	e1a05000 	mov	r5, r0
102d7d24:	e5840010 	str	r0, [r4, #16]
        if(!item->valuestring)
102d7d28:	0a000001 	beq	102d7d34 <cJSON_CreateString+0x3c>
            return NULL;
        }
    }

    return item;
}
102d7d2c:	e1a00004 	mov	r0, r4
102d7d30:	e8bd8038 	pop	{r3, r4, r5, pc}
    {
        item->type = cJSON_String;
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
        if(!item->valuestring)
        {
            cJSON_Delete(item);
102d7d34:	e1a00004 	mov	r0, r4
102d7d38:	ebfffc8a 	bl	102d6f68 <cJSON_Delete>
            return NULL;
102d7d3c:	e1a04005 	mov	r4, r5
102d7d40:	eafffff9 	b	102d7d2c <cJSON_CreateString+0x34>

102d7d44 <cJSON_CreateRaw>:

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
{
102d7d44:	e92d4038 	push	{r3, r4, r5, lr}
102d7d48:	e1a05000 	mov	r5, r0
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7d4c:	ebfffc0e 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if(item)
102d7d50:	e2504000 	subs	r4, r0, #0
102d7d54:	0a000007 	beq	102d7d78 <cJSON_CreateRaw+0x34>
    {
        item->type = cJSON_Raw;
102d7d58:	e3a03080 	mov	r3, #128	; 0x80
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
102d7d5c:	e1a00005 	mov	r0, r5
CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_Raw;
102d7d60:	e584300c 	str	r3, [r4, #12]
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
102d7d64:	ebfffc2a 	bl	102d6e14 <cJSON_strdup.constprop.17>
        if(!item->valuestring)
102d7d68:	e3500000 	cmp	r0, #0
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_Raw;
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
102d7d6c:	e1a05000 	mov	r5, r0
102d7d70:	e5840010 	str	r0, [r4, #16]
        if(!item->valuestring)
102d7d74:	0a000001 	beq	102d7d80 <cJSON_CreateRaw+0x3c>
            return NULL;
        }
    }

    return item;
}
102d7d78:	e1a00004 	mov	r0, r4
102d7d7c:	e8bd8038 	pop	{r3, r4, r5, pc}
    {
        item->type = cJSON_Raw;
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
        if(!item->valuestring)
        {
            cJSON_Delete(item);
102d7d80:	e1a00004 	mov	r0, r4
102d7d84:	ebfffc77 	bl	102d6f68 <cJSON_Delete>
            return NULL;
102d7d88:	e1a04005 	mov	r4, r5
102d7d8c:	eafffff9 	b	102d7d78 <cJSON_CreateRaw+0x34>

102d7d90 <cJSON_CreateArray>:

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
{
102d7d90:	e92d4008 	push	{r3, lr}
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7d94:	ebfffbfc 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if(item)
102d7d98:	e3500000 	cmp	r0, #0
    {
        item->type=cJSON_Array;
102d7d9c:	13a03020 	movne	r3, #32
102d7da0:	1580300c 	strne	r3, [r0, #12]
    }

    return item;
}
102d7da4:	e8bd8008 	pop	{r3, pc}

102d7da8 <cJSON_CreateObject>:

CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
{
102d7da8:	e92d4008 	push	{r3, lr}
    cJSON *item = cJSON_New_Item(&global_hooks);
102d7dac:	ebfffbf6 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if (item)
102d7db0:	e3500000 	cmp	r0, #0
    {
        item->type = cJSON_Object;
102d7db4:	13a03040 	movne	r3, #64	; 0x40
102d7db8:	1580300c 	strne	r3, [r0, #12]
    }

    return item;
}
102d7dbc:	e8bd8008 	pop	{r3, pc}

102d7dc0 <cJSON_CreateIntArray>:

/* Create Arrays: */
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
{
102d7dc0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
102d7dc4:	e2518000 	subs	r8, r1, #0
    return item;
}

/* Create Arrays: */
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
{
102d7dc8:	e1a06000 	mov	r6, r0
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
102d7dcc:	ba00001b 	blt	102d7e40 <cJSON_CreateIntArray+0x80>
    {
        return NULL;
    }

    a = cJSON_CreateArray();
102d7dd0:	ebffffee 	bl	102d7d90 <cJSON_CreateArray>
    for(i = 0; a && (i < (size_t)count); i++)
102d7dd4:	e3500000 	cmp	r0, #0
102d7dd8:	13580000 	cmpne	r8, #0
102d7ddc:	e1a09000 	mov	r9, r0
102d7de0:	0a000014 	beq	102d7e38 <cJSON_CreateIntArray+0x78>
/* Create Arrays: */
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
102d7de4:	e3a07000 	mov	r7, #0
102d7de8:	e59fa058 	ldr	sl, [pc, #88]	; 102d7e48 <cJSON_CreateIntArray+0x88>

    return item;
}

/* Create Arrays: */
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
102d7dec:	e2466004 	sub	r6, r6, #4
    {
        return NULL;
    }

    a = cJSON_CreateArray();
    for(i = 0; a && (i < (size_t)count); i++)
102d7df0:	e1a04007 	mov	r4, r7
102d7df4:	ea000007 	b	102d7e18 <cJSON_CreateIntArray+0x58>
        if (!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
102d7df8:	e3540000 	cmp	r4, #0
    {
        return NULL;
    }

    a = cJSON_CreateArray();
    for(i = 0; a && (i < (size_t)count); i++)
102d7dfc:	e2844001 	add	r4, r4, #1
}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev, cJSON *item)
{
    prev->next = item;
102d7e00:	15875000 	strne	r5, [r7]
    item->prev = prev;
102d7e04:	15857004 	strne	r7, [r5, #4]
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
102d7e08:	05895008 	streq	r5, [r9, #8]
    {
        return NULL;
    }

    a = cJSON_CreateArray();
    for(i = 0; a && (i < (size_t)count); i++)
102d7e0c:	e1540008 	cmp	r4, r8
102d7e10:	e1a07005 	mov	r7, r5
102d7e14:	2a000007 	bcs	102d7e38 <cJSON_CreateIntArray+0x78>
    {
        n = cJSON_CreateNumber(numbers[i]);
102d7e18:	e5b60004 	ldr	r0, [r6, #4]!
102d7e1c:	e12fff3a 	blx	sl
102d7e20:	ebffff8a 	bl	102d7c50 <cJSON_CreateNumber>
        if (!n)
102d7e24:	e2505000 	subs	r5, r0, #0
102d7e28:	1afffff2 	bne	102d7df8 <cJSON_CreateIntArray+0x38>
        {
            cJSON_Delete(a);
102d7e2c:	e1a00009 	mov	r0, r9
102d7e30:	ebfffc4c 	bl	102d6f68 <cJSON_Delete>
            return NULL;
102d7e34:	e1a09005 	mov	r9, r5
        }
        p = n;
    }

    return a;
}
102d7e38:	e1a00009 	mov	r0, r9
102d7e3c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
    {
        return NULL;
102d7e40:	e3a09000 	mov	r9, #0
102d7e44:	eafffffb 	b	102d7e38 <cJSON_CreateIntArray+0x78>
102d7e48:	102e3244 	.word	0x102e3244

102d7e4c <cJSON_CreateFloatArray>:

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
{
102d7e4c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
102d7e50:	e2518000 	subs	r8, r1, #0

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
{
102d7e54:	e1a06000 	mov	r6, r0
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
102d7e58:	ba00001b 	blt	102d7ecc <cJSON_CreateFloatArray+0x80>
    {
        return NULL;
    }

    a = cJSON_CreateArray();
102d7e5c:	ebffffcb 	bl	102d7d90 <cJSON_CreateArray>

    for(i = 0; a && (i < (size_t)count); i++)
102d7e60:	e3500000 	cmp	r0, #0
102d7e64:	13580000 	cmpne	r8, #0
102d7e68:	e1a09000 	mov	r9, r0
102d7e6c:	0a000014 	beq	102d7ec4 <cJSON_CreateFloatArray+0x78>

CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
102d7e70:	e3a07000 	mov	r7, #0
102d7e74:	e59fa058 	ldr	sl, [pc, #88]	; 102d7ed4 <cJSON_CreateFloatArray+0x88>
    }

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
102d7e78:	e2466004 	sub	r6, r6, #4
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0; a && (i < (size_t)count); i++)
102d7e7c:	e1a04007 	mov	r4, r7
102d7e80:	ea000007 	b	102d7ea4 <cJSON_CreateFloatArray+0x58>
        if(!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
102d7e84:	e3540000 	cmp	r4, #0
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0; a && (i < (size_t)count); i++)
102d7e88:	e2844001 	add	r4, r4, #1
}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev, cJSON *item)
{
    prev->next = item;
102d7e8c:	15875000 	strne	r5, [r7]
    item->prev = prev;
102d7e90:	15857004 	strne	r7, [r5, #4]
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
102d7e94:	05895008 	streq	r5, [r9, #8]
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0; a && (i < (size_t)count); i++)
102d7e98:	e1540008 	cmp	r4, r8
102d7e9c:	e1a07005 	mov	r7, r5
102d7ea0:	2a000007 	bcs	102d7ec4 <cJSON_CreateFloatArray+0x78>
    {
        n = cJSON_CreateNumber((double)numbers[i]);
102d7ea4:	e5b60004 	ldr	r0, [r6, #4]!
102d7ea8:	e12fff3a 	blx	sl
102d7eac:	ebffff67 	bl	102d7c50 <cJSON_CreateNumber>
        if(!n)
102d7eb0:	e2505000 	subs	r5, r0, #0
102d7eb4:	1afffff2 	bne	102d7e84 <cJSON_CreateFloatArray+0x38>
        {
            cJSON_Delete(a);
102d7eb8:	e1a00009 	mov	r0, r9
102d7ebc:	ebfffc29 	bl	102d6f68 <cJSON_Delete>
            return NULL;
102d7ec0:	e1a09005 	mov	r9, r5
        }
        p = n;
    }

    return a;
}
102d7ec4:	e1a00009 	mov	r0, r9
102d7ec8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
    {
        return NULL;
102d7ecc:	e3a09000 	mov	r9, #0
102d7ed0:	eafffffb 	b	102d7ec4 <cJSON_CreateFloatArray+0x78>
102d7ed4:	102e326c 	.word	0x102e326c

102d7ed8 <cJSON_CreateDoubleArray>:

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
{
102d7ed8:	e92d45f8 	push	{r3, r4, r5, r6, r7, r8, sl, lr}
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
102d7edc:	e2518000 	subs	r8, r1, #0

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
{
102d7ee0:	e1a06000 	mov	r6, r0
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
102d7ee4:	ba000019 	blt	102d7f50 <cJSON_CreateDoubleArray+0x78>
    {
        return NULL;
    }

    a = cJSON_CreateArray();
102d7ee8:	ebffffa8 	bl	102d7d90 <cJSON_CreateArray>

    for(i = 0;a && (i < (size_t)count); i++)
102d7eec:	e3500000 	cmp	r0, #0
102d7ef0:	13580000 	cmpne	r8, #0
102d7ef4:	e1a0a000 	mov	sl, r0
102d7ef8:	0a000012 	beq	102d7f48 <cJSON_CreateDoubleArray+0x70>

CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
102d7efc:	e3a07000 	mov	r7, #0
    }

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
102d7f00:	e2466008 	sub	r6, r6, #8
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0;a && (i < (size_t)count); i++)
102d7f04:	e1a04007 	mov	r4, r7
102d7f08:	ea000007 	b	102d7f2c <cJSON_CreateDoubleArray+0x54>
        if(!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
102d7f0c:	e3540000 	cmp	r4, #0
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0;a && (i < (size_t)count); i++)
102d7f10:	e2844001 	add	r4, r4, #1
}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev, cJSON *item)
{
    prev->next = item;
102d7f14:	15875000 	strne	r5, [r7]
    item->prev = prev;
102d7f18:	15857004 	strne	r7, [r5, #4]
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
102d7f1c:	058a5008 	streq	r5, [sl, #8]
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0;a && (i < (size_t)count); i++)
102d7f20:	e1540008 	cmp	r4, r8
102d7f24:	e1a07005 	mov	r7, r5
102d7f28:	2a000006 	bcs	102d7f48 <cJSON_CreateDoubleArray+0x70>
    {
        n = cJSON_CreateNumber(numbers[i]);
102d7f2c:	e1e600d8 	ldrd	r0, [r6, #8]!
102d7f30:	ebffff46 	bl	102d7c50 <cJSON_CreateNumber>
        if(!n)
102d7f34:	e2505000 	subs	r5, r0, #0
102d7f38:	1afffff3 	bne	102d7f0c <cJSON_CreateDoubleArray+0x34>
        {
            cJSON_Delete(a);
102d7f3c:	e1a0000a 	mov	r0, sl
102d7f40:	ebfffc08 	bl	102d6f68 <cJSON_Delete>
            return NULL;
102d7f44:	e1a0a005 	mov	sl, r5
        }
        p = n;
    }

    return a;
}
102d7f48:	e1a0000a 	mov	r0, sl
102d7f4c:	e8bd85f8 	pop	{r3, r4, r5, r6, r7, r8, sl, pc}
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
    {
        return NULL;
102d7f50:	e3a0a000 	mov	sl, #0
102d7f54:	eafffffb 	b	102d7f48 <cJSON_CreateDoubleArray+0x70>

102d7f58 <cJSON_CreateStringArray>:

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
{
102d7f58:	e92d45f8 	push	{r3, r4, r5, r6, r7, r8, sl, lr}
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
102d7f5c:	e2518000 	subs	r8, r1, #0

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
{
102d7f60:	e1a06000 	mov	r6, r0
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
102d7f64:	ba000019 	blt	102d7fd0 <cJSON_CreateStringArray+0x78>
    {
        return NULL;
    }

    a = cJSON_CreateArray();
102d7f68:	ebffff88 	bl	102d7d90 <cJSON_CreateArray>

    for (i = 0; a && (i < (size_t)count); i++)
102d7f6c:	e3500000 	cmp	r0, #0
102d7f70:	13580000 	cmpne	r8, #0
102d7f74:	e1a0a000 	mov	sl, r0
102d7f78:	0a000012 	beq	102d7fc8 <cJSON_CreateStringArray+0x70>

CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
102d7f7c:	e3a07000 	mov	r7, #0
    }

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
102d7f80:	e2466004 	sub	r6, r6, #4
        return NULL;
    }

    a = cJSON_CreateArray();

    for (i = 0; a && (i < (size_t)count); i++)
102d7f84:	e1a04007 	mov	r4, r7
102d7f88:	ea000007 	b	102d7fac <cJSON_CreateStringArray+0x54>
        if(!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
102d7f8c:	e3540000 	cmp	r4, #0
        return NULL;
    }

    a = cJSON_CreateArray();

    for (i = 0; a && (i < (size_t)count); i++)
102d7f90:	e2844001 	add	r4, r4, #1
}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev, cJSON *item)
{
    prev->next = item;
102d7f94:	15875000 	strne	r5, [r7]
    item->prev = prev;
102d7f98:	15857004 	strne	r7, [r5, #4]
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
102d7f9c:	058a5008 	streq	r5, [sl, #8]
        return NULL;
    }

    a = cJSON_CreateArray();

    for (i = 0; a && (i < (size_t)count); i++)
102d7fa0:	e1540008 	cmp	r4, r8
102d7fa4:	e1a07005 	mov	r7, r5
102d7fa8:	2a000006 	bcs	102d7fc8 <cJSON_CreateStringArray+0x70>
    {
        n = cJSON_CreateString(strings[i]);
102d7fac:	e5b60004 	ldr	r0, [r6, #4]!
102d7fb0:	ebffff50 	bl	102d7cf8 <cJSON_CreateString>
        if(!n)
102d7fb4:	e2505000 	subs	r5, r0, #0
102d7fb8:	1afffff3 	bne	102d7f8c <cJSON_CreateStringArray+0x34>
        {
            cJSON_Delete(a);
102d7fbc:	e1a0000a 	mov	r0, sl
102d7fc0:	ebfffbe8 	bl	102d6f68 <cJSON_Delete>
            return NULL;
102d7fc4:	e1a0a005 	mov	sl, r5
        }
        p = n;
    }

    return a;
}
102d7fc8:	e1a0000a 	mov	r0, sl
102d7fcc:	e8bd85f8 	pop	{r3, r4, r5, r6, r7, r8, sl, pc}
    cJSON *p = NULL;
    cJSON *a = NULL;

    if (count < 0)
    {
        return NULL;
102d7fd0:	e3a0a000 	mov	sl, #0
102d7fd4:	eafffffb 	b	102d7fc8 <cJSON_CreateStringArray+0x70>

102d7fd8 <cJSON_Duplicate>:
    return a;
}

/* Duplication */
CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
{
102d7fd8:	e92d4070 	push	{r4, r5, r6, lr}
    cJSON *child = NULL;
    cJSON *next = NULL;
    cJSON *newchild = NULL;

    /* Bail on bad ptr */
    if (!item)
102d7fdc:	e2504000 	subs	r4, r0, #0
    return a;
}

/* Duplication */
CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
{
102d7fe0:	e1a05001 	mov	r5, r1
    cJSON *child = NULL;
    cJSON *next = NULL;
    cJSON *newchild = NULL;

    /* Bail on bad ptr */
    if (!item)
102d7fe4:	0a000030 	beq	102d80ac <cJSON_Duplicate+0xd4>
    {
        goto fail;
    }
    /* Create new item */
    newitem = cJSON_New_Item(&global_hooks);
102d7fe8:	ebfffb67 	bl	102d6d8c <cJSON_New_Item.constprop.16>
    if (!newitem)
102d7fec:	e2506000 	subs	r6, r0, #0
102d7ff0:	0a00002d 	beq	102d80ac <cJSON_Duplicate+0xd4>
    {
        goto fail;
    }
    /* Copy over all vars */
    newitem->type = item->type & (~cJSON_IsReference);
102d7ff4:	e594c00c 	ldr	ip, [r4, #12]
    newitem->valueint = item->valueint;
    newitem->valuedouble = item->valuedouble;
    if (item->valuestring)
102d7ff8:	e5940010 	ldr	r0, [r4, #16]
        goto fail;
    }
    /* Copy over all vars */
    newitem->type = item->type & (~cJSON_IsReference);
    newitem->valueint = item->valueint;
    newitem->valuedouble = item->valuedouble;
102d7ffc:	e1c421d8 	ldrd	r2, [r4, #24]
    if (!newitem)
    {
        goto fail;
    }
    /* Copy over all vars */
    newitem->type = item->type & (~cJSON_IsReference);
102d8000:	e3cccc01 	bic	ip, ip, #256	; 0x100
    newitem->valueint = item->valueint;
102d8004:	e5941014 	ldr	r1, [r4, #20]
    newitem->valuedouble = item->valuedouble;
    if (item->valuestring)
102d8008:	e3500000 	cmp	r0, #0
    if (!newitem)
    {
        goto fail;
    }
    /* Copy over all vars */
    newitem->type = item->type & (~cJSON_IsReference);
102d800c:	e586c00c 	str	ip, [r6, #12]
    newitem->valueint = item->valueint;
102d8010:	e5861014 	str	r1, [r6, #20]
    newitem->valuedouble = item->valuedouble;
102d8014:	e1c621f8 	strd	r2, [r6, #24]
    if (item->valuestring)
102d8018:	0a000003 	beq	102d802c <cJSON_Duplicate+0x54>
    {
        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
102d801c:	ebfffb7c 	bl	102d6e14 <cJSON_strdup.constprop.17>
        if (!newitem->valuestring)
102d8020:	e3500000 	cmp	r0, #0
    newitem->type = item->type & (~cJSON_IsReference);
    newitem->valueint = item->valueint;
    newitem->valuedouble = item->valuedouble;
    if (item->valuestring)
    {
        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
102d8024:	e5860010 	str	r0, [r6, #16]
        if (!newitem->valuestring)
102d8028:	0a00001a 	beq	102d8098 <cJSON_Duplicate+0xc0>
        {
            goto fail;
        }
    }
    if (item->string)
102d802c:	e5940020 	ldr	r0, [r4, #32]
102d8030:	e3500000 	cmp	r0, #0
102d8034:	0a000003 	beq	102d8048 <cJSON_Duplicate+0x70>
    {
        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
102d8038:	e594300c 	ldr	r3, [r4, #12]
102d803c:	e3130c02 	tst	r3, #512	; 0x200
102d8040:	15860020 	strne	r0, [r6, #32]
102d8044:	0a00001b 	beq	102d80b8 <cJSON_Duplicate+0xe0>
        {
            goto fail;
        }
    }
    /* If non-recursive, then we're done! */
    if (!recurse)
102d8048:	e3550000 	cmp	r5, #0
102d804c:	0a000014 	beq	102d80a4 <cJSON_Duplicate+0xcc>
    {
        return newitem;
    }
    /* Walk the ->next chain for the child. */
    child = item->child;
102d8050:	e5944008 	ldr	r4, [r4, #8]
    while (child != NULL)
102d8054:	e3540000 	cmp	r4, #0
102d8058:	0a000011 	beq	102d80a4 <cJSON_Duplicate+0xcc>
102d805c:	e3a05000 	mov	r5, #0
102d8060:	ea000007 	b	102d8084 <cJSON_Duplicate+0xac>
        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
        if (!newchild)
        {
            goto fail;
        }
        if (next != NULL)
102d8064:	e3550000 	cmp	r5, #0
        {
            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
            next->next = newchild;
102d8068:	15850000 	strne	r0, [r5]
        {
            /* Set newitem->child and move to it */
            newitem->child = newchild;
            next = newchild;
        }
        child = child->next;
102d806c:	e5944000 	ldr	r4, [r4]
        }
        if (next != NULL)
        {
            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
            next->next = newchild;
            newchild->prev = next;
102d8070:	15805004 	strne	r5, [r0, #4]
            next = newchild;
        }
        else
        {
            /* Set newitem->child and move to it */
            newitem->child = newchild;
102d8074:	05860008 	streq	r0, [r6, #8]
    {
        return newitem;
    }
    /* Walk the ->next chain for the child. */
    child = item->child;
    while (child != NULL)
102d8078:	e3540000 	cmp	r4, #0
102d807c:	e1a05000 	mov	r5, r0
102d8080:	0a000007 	beq	102d80a4 <cJSON_Duplicate+0xcc>
    {
        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
102d8084:	e1a00004 	mov	r0, r4
102d8088:	e3a01001 	mov	r1, #1
102d808c:	ebffffd1 	bl	102d7fd8 <cJSON_Duplicate>
        if (!newchild)
102d8090:	e3500000 	cmp	r0, #0
102d8094:	1afffff2 	bne	102d8064 <cJSON_Duplicate+0x8c>
    return newitem;

fail:
    if (newitem != NULL)
    {
        cJSON_Delete(newitem);
102d8098:	e1a00006 	mov	r0, r6
102d809c:	ebfffbb1 	bl	102d6f68 <cJSON_Delete>
    }

    return NULL;
102d80a0:	e3a06000 	mov	r6, #0
}
102d80a4:	e1a00006 	mov	r0, r6
102d80a8:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (newitem != NULL)
    {
        cJSON_Delete(newitem);
    }

    return NULL;
102d80ac:	e3a06000 	mov	r6, #0
}
102d80b0:	e1a00006 	mov	r0, r6
102d80b4:	e8bd8070 	pop	{r4, r5, r6, pc}
            goto fail;
        }
    }
    if (item->string)
    {
        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
102d80b8:	ebfffb55 	bl	102d6e14 <cJSON_strdup.constprop.17>
        if (!newitem->string)
102d80bc:	e3500000 	cmp	r0, #0
            goto fail;
        }
    }
    if (item->string)
    {
        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
102d80c0:	e5860020 	str	r0, [r6, #32]
        if (!newitem->string)
102d80c4:	0afffff3 	beq	102d8098 <cJSON_Duplicate+0xc0>
102d80c8:	eaffffde 	b	102d8048 <cJSON_Duplicate+0x70>

102d80cc <cJSON_Minify>:

    return NULL;
}

CJSON_PUBLIC(void) cJSON_Minify(char *json)
{
102d80cc:	e5d03000 	ldrb	r3, [r0]
	//APP_DEBUG("\r\n<-- Entering : %s -->\r\n",__FUNCTION__);
    unsigned char *into = (unsigned char*)json;
    while (*json)
102d80d0:	e1a0c000 	mov	ip, r0
102d80d4:	e3530000 	cmp	r3, #0
102d80d8:	0a000010 	beq	102d8120 <cJSON_Minify+0x54>
    {
        if (*json == ' ')
102d80dc:	e3530020 	cmp	r3, #32
102d80e0:	0a000010 	beq	102d8128 <cJSON_Minify+0x5c>
        {
            json++;
        }
        else if (*json == '\t')
102d80e4:	e3530009 	cmp	r3, #9
102d80e8:	0a00000e 	beq	102d8128 <cJSON_Minify+0x5c>
        {
            /* Whitespace characters. */
            json++;
        }
        else if (*json == '\r')
102d80ec:	e353000d 	cmp	r3, #13
102d80f0:	0a00000c 	beq	102d8128 <cJSON_Minify+0x5c>
        {
            json++;
        }
        else if (*json=='\n')
102d80f4:	e353000a 	cmp	r3, #10
102d80f8:	0a00000a 	beq	102d8128 <cJSON_Minify+0x5c>
        {
            json++;
        }
        else if ((*json == '/') && (json[1] == '/'))
102d80fc:	e353002f 	cmp	r3, #47	; 0x2f
102d8100:	0a00000b 	beq	102d8134 <cJSON_Minify+0x68>
            {
                json++;
            }
            json += 2;
        }
        else if (*json == '\"')
102d8104:	e3530022 	cmp	r3, #34	; 0x22
102d8108:	0a000022 	beq	102d8198 <cJSON_Minify+0xcc>
            *into++ = (unsigned char)*json++;
        }
        else
        {
            /* All other characters. */
            *into++ = (unsigned char)*json++;
102d810c:	e2800001 	add	r0, r0, #1
102d8110:	e4cc3001 	strb	r3, [ip], #1
102d8114:	e5d03000 	ldrb	r3, [r0]

CJSON_PUBLIC(void) cJSON_Minify(char *json)
{
	//APP_DEBUG("\r\n<-- Entering : %s -->\r\n",__FUNCTION__);
    unsigned char *into = (unsigned char*)json;
    while (*json)
102d8118:	e3530000 	cmp	r3, #0
102d811c:	1affffee 	bne	102d80dc <cJSON_Minify+0x10>
            *into++ = (unsigned char)*json++;
        }
    }

    /* and null-terminate. */
    *into = '\0';
102d8120:	e5cc3000 	strb	r3, [ip]
102d8124:	e12fff1e 	bx	lr
102d8128:	e5d03001 	ldrb	r3, [r0, #1]
        {
            json++;
        }
        else if (*json=='\n')
        {
            json++;
102d812c:	e2800001 	add	r0, r0, #1
102d8130:	eaffffe7 	b	102d80d4 <cJSON_Minify+0x8>
        }
        else if ((*json == '/') && (json[1] == '/'))
102d8134:	e5d01001 	ldrb	r1, [r0, #1]
102d8138:	e351002f 	cmp	r1, #47	; 0x2f
102d813c:	0a00002a 	beq	102d81ec <cJSON_Minify+0x120>
            while (*json && (*json != '\n'))
            {
                json++;
            }
        }
        else if ((*json == '/') && (json[1] == '*'))
102d8140:	e351002a 	cmp	r1, #42	; 0x2a
102d8144:	01a02000 	moveq	r2, r0
102d8148:	01a03001 	moveq	r3, r1
102d814c:	1affffee 	bne	102d810c <cJSON_Minify+0x40>
        {
            /* multiline comments. */
            while (*json && !((*json == '*') && (json[1] == '/')))
102d8150:	e3530000 	cmp	r3, #0
            {
                json++;
102d8154:	e2801001 	add	r1, r0, #1
            }
        }
        else if ((*json == '/') && (json[1] == '*'))
        {
            /* multiline comments. */
            while (*json && !((*json == '*') && (json[1] == '/')))
102d8158:	1a00000b 	bne	102d818c <cJSON_Minify+0xc0>
102d815c:	e5d03003 	ldrb	r3, [r0, #3]
            {
                json++;
            }
            json += 2;
102d8160:	e2810002 	add	r0, r1, #2
102d8164:	eaffffda 	b	102d80d4 <cJSON_Minify+0x8>
            }
        }
        else if ((*json == '/') && (json[1] == '*'))
        {
            /* multiline comments. */
            while (*json && !((*json == '*') && (json[1] == '/')))
102d8168:	e5d13001 	ldrb	r3, [r1, #1]
102d816c:	e353002f 	cmp	r3, #47	; 0x2f
102d8170:	0afffff9 	beq	102d815c <cJSON_Minify+0x90>
102d8174:	e5d23002 	ldrb	r3, [r2, #2]
            {
                json++;
102d8178:	e1a00001 	mov	r0, r1
            }
        }
        else if ((*json == '/') && (json[1] == '*'))
        {
            /* multiline comments. */
            while (*json && !((*json == '*') && (json[1] == '/')))
102d817c:	e3530000 	cmp	r3, #0
102d8180:	e2822001 	add	r2, r2, #1
            {
                json++;
102d8184:	e2801001 	add	r1, r0, #1
            }
        }
        else if ((*json == '/') && (json[1] == '*'))
        {
            /* multiline comments. */
            while (*json && !((*json == '*') && (json[1] == '/')))
102d8188:	0afffff3 	beq	102d815c <cJSON_Minify+0x90>
102d818c:	e353002a 	cmp	r3, #42	; 0x2a
102d8190:	1afffff7 	bne	102d8174 <cJSON_Minify+0xa8>
102d8194:	eafffff3 	b	102d8168 <cJSON_Minify+0x9c>
            json += 2;
        }
        else if (*json == '\"')
        {
            /* string literals, which are \" sensitive. */
            *into++ = (unsigned char)*json++;
102d8198:	e4cc3001 	strb	r3, [ip], #1
            while (*json && (*json != '\"'))
102d819c:	e5d03001 	ldrb	r3, [r0, #1]
            json += 2;
        }
        else if (*json == '\"')
        {
            /* string literals, which are \" sensitive. */
            *into++ = (unsigned char)*json++;
102d81a0:	e2802001 	add	r2, r0, #1
            while (*json && (*json != '\"'))
102d81a4:	e3530000 	cmp	r3, #0
102d81a8:	13530022 	cmpne	r3, #34	; 0x22
102d81ac:	0a00000a 	beq	102d81dc <cJSON_Minify+0x110>
            {
                if (*json == '\\')
102d81b0:	e353005c 	cmp	r3, #92	; 0x5c
102d81b4:	e1a01002 	mov	r1, r2
                {
                    *into++ = (unsigned char)*json++;
102d81b8:	02821001 	addeq	r1, r2, #1
                }
                *into++ = (unsigned char)*json++;
102d81bc:	e1a02001 	mov	r2, r1
            *into++ = (unsigned char)*json++;
            while (*json && (*json != '\"'))
            {
                if (*json == '\\')
                {
                    *into++ = (unsigned char)*json++;
102d81c0:	04cc3001 	strbeq	r3, [ip], #1
                }
                *into++ = (unsigned char)*json++;
102d81c4:	e4d23001 	ldrb	r3, [r2], #1
102d81c8:	e4cc3001 	strb	r3, [ip], #1
        }
        else if (*json == '\"')
        {
            /* string literals, which are \" sensitive. */
            *into++ = (unsigned char)*json++;
            while (*json && (*json != '\"'))
102d81cc:	e5d13001 	ldrb	r3, [r1, #1]
102d81d0:	e3530022 	cmp	r3, #34	; 0x22
102d81d4:	13530000 	cmpne	r3, #0
102d81d8:	1afffff4 	bne	102d81b0 <cJSON_Minify+0xe4>
                {
                    *into++ = (unsigned char)*json++;
                }
                *into++ = (unsigned char)*json++;
            }
            *into++ = (unsigned char)*json++;
102d81dc:	e4cc3001 	strb	r3, [ip], #1
102d81e0:	e2820001 	add	r0, r2, #1
102d81e4:	e5d23001 	ldrb	r3, [r2, #1]
102d81e8:	eaffffb9 	b	102d80d4 <cJSON_Minify+0x8>
102d81ec:	e1a02000 	mov	r2, r0
102d81f0:	ea000001 	b	102d81fc <cJSON_Minify+0x130>
102d81f4:	e5d23002 	ldrb	r3, [r2, #2]
102d81f8:	e1a02001 	mov	r2, r1
    }

    return NULL;
}

CJSON_PUBLIC(void) cJSON_Minify(char *json)
102d81fc:	e2821001 	add	r1, r2, #1
            json++;
        }
        else if ((*json == '/') && (json[1] == '/'))
        {
            /* double-slash comments, to end of line. */
            while (*json && (*json != '\n'))
102d8200:	e353000a 	cmp	r3, #10
102d8204:	13530000 	cmpne	r3, #0
    }

    return NULL;
}

CJSON_PUBLIC(void) cJSON_Minify(char *json)
102d8208:	e1a00001 	mov	r0, r1
            json++;
        }
        else if ((*json == '/') && (json[1] == '/'))
        {
            /* double-slash comments, to end of line. */
            while (*json && (*json != '\n'))
102d820c:	1afffff8 	bne	102d81f4 <cJSON_Minify+0x128>
102d8210:	eaffffaf 	b	102d80d4 <cJSON_Minify+0x8>

102d8214 <cJSON_IsInvalid>:
   // APP_DEBUG("\r<-- Exiting : %s -->\r\n\n",__FUNCTION__);
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
{
    if (item == NULL)
102d8214:	e3500000 	cmp	r0, #0
102d8218:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Invalid;
102d821c:	e5d0000c 	ldrb	r0, [r0, #12]
102d8220:	e2700001 	rsbs	r0, r0, #1
102d8224:	33a00000 	movcc	r0, #0
}
102d8228:	e12fff1e 	bx	lr

102d822c <cJSON_IsFalse>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
{
    if (item == NULL)
102d822c:	e3500000 	cmp	r0, #0
102d8230:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_False;
102d8234:	e5d0000c 	ldrb	r0, [r0, #12]
102d8238:	e2503001 	subs	r3, r0, #1
102d823c:	e2730000 	rsbs	r0, r3, #0
102d8240:	e0b00003 	adcs	r0, r0, r3
}
102d8244:	e12fff1e 	bx	lr

102d8248 <cJSON_IsTrue>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
{
    if (item == NULL)
102d8248:	e3500000 	cmp	r0, #0
102d824c:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xff) == cJSON_True;
102d8250:	e5d0000c 	ldrb	r0, [r0, #12]
102d8254:	e2502002 	subs	r2, r0, #2
102d8258:	e2720000 	rsbs	r0, r2, #0
102d825c:	e0b00002 	adcs	r0, r0, r2
}
102d8260:	e12fff1e 	bx	lr

102d8264 <cJSON_IsBool>:


CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
{
    if (item == NULL)
102d8264:	e3500000 	cmp	r0, #0
102d8268:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & (cJSON_True | cJSON_False)) != 0;
102d826c:	e590000c 	ldr	r0, [r0, #12]
102d8270:	e2100003 	ands	r0, r0, #3
102d8274:	13a00001 	movne	r0, #1
}
102d8278:	e12fff1e 	bx	lr

102d827c <cJSON_IsNull>:
CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
{
    if (item == NULL)
102d827c:	e3500000 	cmp	r0, #0
102d8280:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_NULL;
102d8284:	e5d0000c 	ldrb	r0, [r0, #12]
102d8288:	e2501004 	subs	r1, r0, #4
102d828c:	e2710000 	rsbs	r0, r1, #0
102d8290:	e0b00001 	adcs	r0, r0, r1
}
102d8294:	e12fff1e 	bx	lr

102d8298 <cJSON_IsNumber>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
{
    if (item == NULL)
102d8298:	e3500000 	cmp	r0, #0
102d829c:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Number;
102d82a0:	e5d0000c 	ldrb	r0, [r0, #12]
102d82a4:	e250c008 	subs	ip, r0, #8
102d82a8:	e27c0000 	rsbs	r0, ip, #0
102d82ac:	e0b0000c 	adcs	r0, r0, ip
}
102d82b0:	e12fff1e 	bx	lr

102d82b4 <cJSON_IsString>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
{
    if (item == NULL)
102d82b4:	e3500000 	cmp	r0, #0
102d82b8:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_String;
102d82bc:	e5d0000c 	ldrb	r0, [r0, #12]
102d82c0:	e2503010 	subs	r3, r0, #16
102d82c4:	e2730000 	rsbs	r0, r3, #0
102d82c8:	e0b00003 	adcs	r0, r0, r3
}
102d82cc:	e12fff1e 	bx	lr

102d82d0 <cJSON_IsArray>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
{
    if (item == NULL)
102d82d0:	e3500000 	cmp	r0, #0
102d82d4:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Array;
102d82d8:	e5d0000c 	ldrb	r0, [r0, #12]
102d82dc:	e2502020 	subs	r2, r0, #32
102d82e0:	e2720000 	rsbs	r0, r2, #0
102d82e4:	e0b00002 	adcs	r0, r0, r2
}
102d82e8:	e12fff1e 	bx	lr

102d82ec <cJSON_IsObject>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
{
    if (item == NULL)
102d82ec:	e3500000 	cmp	r0, #0
102d82f0:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Object;
102d82f4:	e5d0000c 	ldrb	r0, [r0, #12]
102d82f8:	e2501040 	subs	r1, r0, #64	; 0x40
102d82fc:	e2710000 	rsbs	r0, r1, #0
102d8300:	e0b00001 	adcs	r0, r0, r1
}
102d8304:	e12fff1e 	bx	lr

102d8308 <cJSON_IsRaw>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
{
    if (item == NULL)
102d8308:	e3500000 	cmp	r0, #0
102d830c:	012fff1e 	bxeq	lr
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Raw;
102d8310:	e5d0000c 	ldrb	r0, [r0, #12]
102d8314:	e250c080 	subs	ip, r0, #128	; 0x80
102d8318:	e27c0000 	rsbs	r0, ip, #0
102d831c:	e0b0000c 	adcs	r0, r0, ip
}
102d8320:	e12fff1e 	bx	lr

102d8324 <write_spi_byte>:
		"SALDO"  , "TANGKI PENUH", "SALDO HABIS!", "SALDO RENDAH!","HARAP ISI ULANG" ,"HARAP TUNGGU", "PEMANAS MENYALA" , "AIR PANAS SIAP"
};


void write_spi_byte(unsigned char c)
{
102d8324:	e12fff1e 	bx	lr

102d8328 <writecommand>:
	 */
}


void writecommand(unsigned char cmd)
{
102d8328:	e92d4010 	push	{r4, lr}
102d832c:	e24dd008 	sub	sp, sp, #8
102d8330:	e28d4008 	add	r4, sp, #8
102d8334:	e5640001 	strb	r0, [r4, #-1]!
	/* LCD_RS = 0;
	LCD_CS = 0;
	write_spi_byte(c);
	LCD_CS = 1;
	 */
	Ql_GPIO_SetLevel(PINNAME_CTS, PINLEVEL_LOW); // D/C = 0
102d8338:	e3a01000 	mov	r1, #0
102d833c:	e59f3020 	ldr	r3, [pc, #32]	; 102d8364 <writecommand+0x3c>
102d8340:	e3a00004 	mov	r0, #4
102d8344:	e12fff33 	blx	r3
	Ql_SPI_Write(USR_SPI_CHANNAL, (u8 *)&cmd, 1);
102d8348:	e3a00001 	mov	r0, #1
102d834c:	e1a01004 	mov	r1, r4
102d8350:	e1a02000 	mov	r2, r0
102d8354:	e59f300c 	ldr	r3, [pc, #12]	; 102d8368 <writecommand+0x40>
102d8358:	e12fff33 	blx	r3
}
102d835c:	e28dd008 	add	sp, sp, #8
102d8360:	e8bd8010 	pop	{r4, pc}
102d8364:	102e47d8 	.word	0x102e47d8
102d8368:	102e54f4 	.word	0x102e54f4

102d836c <writedata>:

void writedata(unsigned char data)
{
102d836c:	e92d4010 	push	{r4, lr}
102d8370:	e24dd008 	sub	sp, sp, #8
102d8374:	e28d4008 	add	r4, sp, #8
102d8378:	e5640001 	strb	r0, [r4, #-1]!
	/* LCD_RS = 1;
	LCD_CS = 0;
	write_spi_byte(c);
	LCD_CS = 1;
	 */
	Ql_GPIO_SetLevel(PINNAME_CTS, PINLEVEL_HIGH); // D/C = 1
102d837c:	e3a01001 	mov	r1, #1
102d8380:	e59f3020 	ldr	r3, [pc, #32]	; 102d83a8 <writedata+0x3c>
102d8384:	e3a00004 	mov	r0, #4
102d8388:	e12fff33 	blx	r3
	Ql_SPI_Write(USR_SPI_CHANNAL, (u8 *)&data, 1);
102d838c:	e3a00001 	mov	r0, #1
102d8390:	e1a01004 	mov	r1, r4
102d8394:	e1a02000 	mov	r2, r0
102d8398:	e59f300c 	ldr	r3, [pc, #12]	; 102d83ac <writedata+0x40>
102d839c:	e12fff33 	blx	r3

}
102d83a0:	e28dd008 	add	sp, sp, #8
102d83a4:	e8bd8010 	pop	{r4, pc}
102d83a8:	102e47d8 	.word	0x102e47d8
102d83ac:	102e54f4 	.word	0x102e54f4

102d83b0 <writedata_16bit>:

void writedata_16bit(int value)
{
102d83b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102d83b4:	e1a03000 	mov	r3, r0
102d83b8:	e24dd00c 	sub	sp, sp, #12
	unsigned char buf[2];
	buf[0] = value >> 8;
102d83bc:	e1a02440 	asr	r2, r0, #8
	buf[1] = value;
102d83c0:	e5cd3005 	strb	r3, [sp, #5]
	/* LCD_RS = 1;
	LCD_CS = 0;
	write_spi_byte(c);
	LCD_CS = 1;
	 */
	Ql_GPIO_SetLevel(PINNAME_CTS, PINLEVEL_HIGH); // D/C = 1
102d83c4:	e3a01001 	mov	r1, #1
102d83c8:	e59f3024 	ldr	r3, [pc, #36]	; 102d83f4 <writedata_16bit+0x44>
102d83cc:	e3a00004 	mov	r0, #4
}

void writedata_16bit(int value)
{
	unsigned char buf[2];
	buf[0] = value >> 8;
102d83d0:	e5cd2004 	strb	r2, [sp, #4]
	/* LCD_RS = 1;
	LCD_CS = 0;
	write_spi_byte(c);
	LCD_CS = 1;
	 */
	Ql_GPIO_SetLevel(PINNAME_CTS, PINLEVEL_HIGH); // D/C = 1
102d83d4:	e12fff33 	blx	r3
	Ql_SPI_Write(USR_SPI_CHANNAL, (u8 *)&buf, 2);
102d83d8:	e28d1004 	add	r1, sp, #4
102d83dc:	e3a02002 	mov	r2, #2
102d83e0:	e59f3010 	ldr	r3, [pc, #16]	; 102d83f8 <writedata_16bit+0x48>
102d83e4:	e3a00001 	mov	r0, #1
102d83e8:	e12fff33 	blx	r3

}
102d83ec:	e28dd00c 	add	sp, sp, #12
102d83f0:	e8bd8000 	ldmfd	sp!, {pc}
102d83f4:	102e47d8 	.word	0x102e47d8
102d83f8:	102e54f4 	.word	0x102e54f4

102d83fc <setAddrWindow>:

void setAddrWindow(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1)
{
102d83fc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102d8400:	e1a04000 	mov	r4, r0
	writecommand(ST7735_CASET);  // column addr set
102d8404:	e3a0002a 	mov	r0, #42	; 0x2a
	Ql_SPI_Write(USR_SPI_CHANNAL, (u8 *)&buf, 2);

}

void setAddrWindow(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1)
{
102d8408:	e1a05001 	mov	r5, r1
102d840c:	e1a06002 	mov	r6, r2
102d8410:	e1a07003 	mov	r7, r3
	writecommand(ST7735_CASET);  // column addr set
102d8414:	ebffffc3 	bl	102d8328 <writecommand>
	writedata(0x00);
102d8418:	e3a00000 	mov	r0, #0
102d841c:	ebffffd2 	bl	102d836c <writedata>
	writedata(x0+0);   // XSTART
102d8420:	e1a00004 	mov	r0, r4
102d8424:	ebffffd0 	bl	102d836c <writedata>
	writedata(0x00);
102d8428:	e3a00000 	mov	r0, #0
102d842c:	ebffffce 	bl	102d836c <writedata>
	writedata(x1+0);   // XEND
102d8430:	e1a00006 	mov	r0, r6
102d8434:	ebffffcc 	bl	102d836c <writedata>

	writecommand(ST7735_RASET);  // row addr set
102d8438:	e3a0002b 	mov	r0, #43	; 0x2b
102d843c:	ebffffb9 	bl	102d8328 <writecommand>
	writedata(0x00);
102d8440:	e3a00000 	mov	r0, #0
102d8444:	ebffffc8 	bl	102d836c <writedata>
	writedata(y0+0);    // YSTART
102d8448:	e1a00005 	mov	r0, r5
102d844c:	ebffffc6 	bl	102d836c <writedata>
	writedata(0x00);
102d8450:	e3a00000 	mov	r0, #0
102d8454:	ebffffc4 	bl	102d836c <writedata>
	writedata(y1+0);    // YEND
102d8458:	e1a00007 	mov	r0, r7
102d845c:	ebffffc2 	bl	102d836c <writedata>

	writecommand(ST7735_RAMWR);  // write to RAM
102d8460:	e3a0002c 	mov	r0, #44	; 0x2c
}
102d8464:	e8bd40f8 	pop	{r3, r4, r5, r6, r7, lr}
	writedata(0x00);
	writedata(y0+0);    // YSTART
	writedata(0x00);
	writedata(y1+0);    // YEND

	writecommand(ST7735_RAMWR);  // write to RAM
102d8468:	eaffffae 	b	102d8328 <writecommand>

102d846c <ST7735_pushColor>:
{
	// LCD_RS = 1;
	// LCD_CS = 0;
	// write_spi_byte(color >> 8);
	// write_spi_byte(color);
	writedata_16bit(color);
102d846c:	eaffffcf 	b	102d83b0 <writedata_16bit>

102d8470 <ST7735_drawPixel>:
	// LCD_CS = 1;
}

void ST7735_drawPixel(unsigned char x, unsigned char y, unsigned int color)
{
102d8470:	e92d4010 	push	{r4, lr}
	setAddrWindow(x, y, x, y);
102d8474:	e1a03001 	mov	r3, r1
	writedata_16bit(color);
	// LCD_CS = 1;
}

void ST7735_drawPixel(unsigned char x, unsigned char y, unsigned int color)
{
102d8478:	e1a04002 	mov	r4, r2
	setAddrWindow(x, y, x, y);
102d847c:	e1a02000 	mov	r2, r0
102d8480:	ebffffdd 	bl	102d83fc <setAddrWindow>
	// LCD_RS = 1;
	// LCD_CS = 0;

	// write_spi_byte(color >> 8);
	// write_spi_byte(color);
	writedata_16bit(color);
102d8484:	e1a00004 	mov	r0, r4

	// LCD_CS = 1;
}
102d8488:	e8bd4010 	pop	{r4, lr}
	// LCD_RS = 1;
	// LCD_CS = 0;

	// write_spi_byte(color >> 8);
	// write_spi_byte(color);
	writedata_16bit(color);
102d848c:	eaffffc7 	b	102d83b0 <writedata_16bit>

102d8490 <ST7735_initR>:

	// LCD_CS = 1;
}
 */
void ST7735_initR(void)
{
102d8490:	e92d4038 	push	{r3, r4, r5, lr}
102d8494:	e59f4304 	ldr	r4, [pc, #772]	; 102d87a0 <ST7735_initR+0x310>
102d8498:	e59f5304 	ldr	r5, [pc, #772]	; 102d87a4 <ST7735_initR+0x314>
	delay_us(500);

	LCD_CS = 0;
	 */
	for(i=0;i<200000;i++)
		Ql_GPIO_SetLevel(PINNAME_RTS, PINLEVEL_LOW); // reset line set to 0
102d849c:	e3a00005 	mov	r0, #5
102d84a0:	e3a01000 	mov	r1, #0
102d84a4:	e12fff35 	blx	r5
	LCD_RESET = 1;
	delay_us(500);

	LCD_CS = 0;
	 */
	for(i=0;i<200000;i++)
102d84a8:	e2544001 	subs	r4, r4, #1
102d84ac:	1afffffa 	bne	102d849c <ST7735_initR+0xc>
102d84b0:	e59f42e8 	ldr	r4, [pc, #744]	; 102d87a0 <ST7735_initR+0x310>
		Ql_GPIO_SetLevel(PINNAME_RTS, PINLEVEL_LOW); // reset line set to 0

	for(i=0;i<200000;i++)
		Ql_GPIO_SetLevel(PINNAME_RTS, PINLEVEL_HIGH); // reset line set to 1
102d84b4:	e3a00005 	mov	r0, #5
102d84b8:	e3a01001 	mov	r1, #1
102d84bc:	e12fff35 	blx	r5
	LCD_CS = 0;
	 */
	for(i=0;i<200000;i++)
		Ql_GPIO_SetLevel(PINNAME_RTS, PINLEVEL_LOW); // reset line set to 0

	for(i=0;i<200000;i++)
102d84c0:	e2544001 	subs	r4, r4, #1
102d84c4:	1afffffa 	bne	102d84b4 <ST7735_initR+0x24>
		Ql_GPIO_SetLevel(PINNAME_RTS, PINLEVEL_HIGH); // reset line set to 1

	writecommand(ST7735_SWRESET); // software reset
102d84c8:	e3a00001 	mov	r0, #1
102d84cc:	ebffff95 	bl	102d8328 <writecommand>
	// delay_us(150);
	writecommand(ST7735_SLPOUT);  // out of sleep mode
102d84d0:	e3a00011 	mov	r0, #17
102d84d4:	ebffff93 	bl	102d8328 <writecommand>
	// delay_us(500);

	writecommand(ST7735_COLMOD);  // set color mode
102d84d8:	e3a0003a 	mov	r0, #58	; 0x3a
102d84dc:	ebffff91 	bl	102d8328 <writecommand>
	writedata(0x05);        // 16-bit color
102d84e0:	e3a00005 	mov	r0, #5
102d84e4:	ebffffa0 	bl	102d836c <writedata>
	// delay_us(10);

	writecommand(ST7735_FRMCTR1);  // frame rate control - normal mode
102d84e8:	e3a000b1 	mov	r0, #177	; 0xb1
102d84ec:	ebffff8d 	bl	102d8328 <writecommand>
	writedata(0x01);  // frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D)
102d84f0:	e3a00001 	mov	r0, #1
102d84f4:	ebffff9c 	bl	102d836c <writedata>
	writedata(0x2C);
102d84f8:	e3a0002c 	mov	r0, #44	; 0x2c
102d84fc:	ebffff9a 	bl	102d836c <writedata>
	writedata(0x2D);
102d8500:	e3a0002d 	mov	r0, #45	; 0x2d
102d8504:	ebffff98 	bl	102d836c <writedata>

	writecommand(ST7735_FRMCTR2);  // frame rate control - idle mode
102d8508:	e3a000b2 	mov	r0, #178	; 0xb2
102d850c:	ebffff85 	bl	102d8328 <writecommand>
	writedata(0x01);  // frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D)
102d8510:	e3a00001 	mov	r0, #1
102d8514:	ebffff94 	bl	102d836c <writedata>
	writedata(0x2C);
102d8518:	e3a0002c 	mov	r0, #44	; 0x2c
102d851c:	ebffff92 	bl	102d836c <writedata>
	writedata(0x2D);
102d8520:	e3a0002d 	mov	r0, #45	; 0x2d
102d8524:	ebffff90 	bl	102d836c <writedata>

	writecommand(ST7735_FRMCTR3);  // frame rate control - partial mode
102d8528:	e3a000b3 	mov	r0, #179	; 0xb3
102d852c:	ebffff7d 	bl	102d8328 <writecommand>
	writedata(0x01); // dot inversion mode
102d8530:	e3a00001 	mov	r0, #1
102d8534:	ebffff8c 	bl	102d836c <writedata>
	writedata(0x2C);
102d8538:	e3a0002c 	mov	r0, #44	; 0x2c
102d853c:	ebffff8a 	bl	102d836c <writedata>
	writedata(0x2D);
102d8540:	e3a0002d 	mov	r0, #45	; 0x2d
102d8544:	ebffff88 	bl	102d836c <writedata>
	writedata(0x01); // line inversion mode
102d8548:	e3a00001 	mov	r0, #1
102d854c:	ebffff86 	bl	102d836c <writedata>
	writedata(0x2C);
102d8550:	e3a0002c 	mov	r0, #44	; 0x2c
102d8554:	ebffff84 	bl	102d836c <writedata>
	writedata(0x2D);
102d8558:	e3a0002d 	mov	r0, #45	; 0x2d
102d855c:	ebffff82 	bl	102d836c <writedata>

	writecommand(ST7735_INVCTR);  // display inversion control
102d8560:	e3a000b4 	mov	r0, #180	; 0xb4
102d8564:	ebffff6f 	bl	102d8328 <writecommand>
	writedata(0x07);  // no inversion
102d8568:	e3a00007 	mov	r0, #7
102d856c:	ebffff7e 	bl	102d836c <writedata>

	writecommand(ST7735_PWCTR1);  // power control
102d8570:	e3a000c0 	mov	r0, #192	; 0xc0
102d8574:	ebffff6b 	bl	102d8328 <writecommand>
	writedata(0xA2);
102d8578:	e3a000a2 	mov	r0, #162	; 0xa2
102d857c:	ebffff7a 	bl	102d836c <writedata>
	writedata(0x02);      // -4.6V
102d8580:	e3a00002 	mov	r0, #2
102d8584:	ebffff78 	bl	102d836c <writedata>
	writedata(0x84);      // AUTO mode
102d8588:	e3a00084 	mov	r0, #132	; 0x84
102d858c:	ebffff76 	bl	102d836c <writedata>

	writecommand(ST7735_PWCTR2);  // power control
102d8590:	e3a000c1 	mov	r0, #193	; 0xc1
102d8594:	ebffff63 	bl	102d8328 <writecommand>
	writedata(0xC5);      // VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD
102d8598:	e3a000c5 	mov	r0, #197	; 0xc5
102d859c:	ebffff72 	bl	102d836c <writedata>

	writecommand(ST7735_PWCTR3);  // power control
102d85a0:	e3a000c2 	mov	r0, #194	; 0xc2
102d85a4:	ebffff5f 	bl	102d8328 <writecommand>
	writedata(0x0A);      // Opamp current small
102d85a8:	e3a0000a 	mov	r0, #10
102d85ac:	ebffff6e 	bl	102d836c <writedata>
	writedata(0x00);      // Boost frequency
102d85b0:	e1a00004 	mov	r0, r4
102d85b4:	ebffff6c 	bl	102d836c <writedata>

	writecommand(ST7735_PWCTR4);  // power control
102d85b8:	e3a000c3 	mov	r0, #195	; 0xc3
102d85bc:	ebffff59 	bl	102d8328 <writecommand>
	writedata(0x8A);      // BCLK/2, Opamp current small & Medium low
102d85c0:	e3a0008a 	mov	r0, #138	; 0x8a
102d85c4:	ebffff68 	bl	102d836c <writedata>
	writedata(0x2A);
102d85c8:	e3a0002a 	mov	r0, #42	; 0x2a
102d85cc:	ebffff66 	bl	102d836c <writedata>

	writecommand(ST7735_PWCTR5);  // power control
102d85d0:	e3a000c4 	mov	r0, #196	; 0xc4
102d85d4:	ebffff53 	bl	102d8328 <writecommand>
	writedata(0x8A);
102d85d8:	e3a0008a 	mov	r0, #138	; 0x8a
102d85dc:	ebffff62 	bl	102d836c <writedata>
	writedata(0xEE);
102d85e0:	e3a000ee 	mov	r0, #238	; 0xee
102d85e4:	ebffff60 	bl	102d836c <writedata>

	writecommand(ST7735_VMCTR1);  // power control
102d85e8:	e3a000c5 	mov	r0, #197	; 0xc5
102d85ec:	ebffff4d 	bl	102d8328 <writecommand>
	writedata(0x0E);
102d85f0:	e3a0000e 	mov	r0, #14
102d85f4:	ebffff5c 	bl	102d836c <writedata>

	writecommand(ST7735_INVON);    // invert display
102d85f8:	e3a00021 	mov	r0, #33	; 0x21
102d85fc:	ebffff49 	bl	102d8328 <writecommand>


	writecommand(ST7735_MADCTL);  // memory access control (directions)
102d8600:	e3a00036 	mov	r0, #54	; 0x36
102d8604:	ebffff47 	bl	102d8328 <writecommand>

	// R and B byte are swapped
	// madctl = 0xC8;

	// normal R G B order
	madctl = 0xC0;
102d8608:	e59f3198 	ldr	r3, [pc, #408]	; 102d87a8 <ST7735_initR+0x318>
102d860c:	e3e0203f 	mvn	r2, #63	; 0x3f
	writedata(madctl);  // row address/col address, bottom to top refresh
102d8610:	e3a000c0 	mov	r0, #192	; 0xc0

	// R and B byte are swapped
	// madctl = 0xC8;

	// normal R G B order
	madctl = 0xC0;
102d8614:	e5c32000 	strb	r2, [r3]
	writedata(madctl);  // row address/col address, bottom to top refresh
102d8618:	ebffff53 	bl	102d836c <writedata>

	writecommand(ST7735_COLMOD);  // set color mode
102d861c:	e3a0003a 	mov	r0, #58	; 0x3a
102d8620:	ebffff40 	bl	102d8328 <writecommand>
	writedata(0x05);        // 16-bit color
102d8624:	e3a00005 	mov	r0, #5
102d8628:	ebffff4f 	bl	102d836c <writedata>

	writecommand(ST7735_CASET);  // column addr set
102d862c:	e3a0002a 	mov	r0, #42	; 0x2a
102d8630:	ebffff3c 	bl	102d8328 <writecommand>
	writedata(0x00);
102d8634:	e1a00004 	mov	r0, r4
102d8638:	ebffff4b 	bl	102d836c <writedata>
	writedata(0x00);   // XSTART = 0
102d863c:	e1a00004 	mov	r0, r4
102d8640:	ebffff49 	bl	102d836c <writedata>
	writedata(0x00);
102d8644:	e1a00004 	mov	r0, r4
102d8648:	ebffff47 	bl	102d836c <writedata>
	writedata(0x7F);   // XEND = 127
102d864c:	e3a0007f 	mov	r0, #127	; 0x7f
102d8650:	ebffff45 	bl	102d836c <writedata>

	writecommand(ST7735_RASET);  // row addr set
102d8654:	e3a0002b 	mov	r0, #43	; 0x2b
102d8658:	ebffff32 	bl	102d8328 <writecommand>
	writedata(0x00);
102d865c:	e1a00004 	mov	r0, r4
102d8660:	ebffff41 	bl	102d836c <writedata>
	writedata(0x00);    // XSTART = 0
102d8664:	e1a00004 	mov	r0, r4
102d8668:	ebffff3f 	bl	102d836c <writedata>
	writedata(0x00);
102d866c:	e1a00004 	mov	r0, r4
102d8670:	ebffff3d 	bl	102d836c <writedata>
	writedata(0x9F);    // XEND = 159
102d8674:	e3a0009f 	mov	r0, #159	; 0x9f
102d8678:	ebffff3b 	bl	102d836c <writedata>

	writecommand(ST7735_GMCTRP1);
102d867c:	e3a000e0 	mov	r0, #224	; 0xe0
102d8680:	ebffff28 	bl	102d8328 <writecommand>
	writedata(0x0f);
102d8684:	e3a0000f 	mov	r0, #15
102d8688:	ebffff37 	bl	102d836c <writedata>
	writedata(0x1a);
102d868c:	e3a0001a 	mov	r0, #26
102d8690:	ebffff35 	bl	102d836c <writedata>
	writedata(0x0f);
102d8694:	e3a0000f 	mov	r0, #15
102d8698:	ebffff33 	bl	102d836c <writedata>
	writedata(0x18);
102d869c:	e3a00018 	mov	r0, #24
102d86a0:	ebffff31 	bl	102d836c <writedata>
	writedata(0x2f);
102d86a4:	e3a0002f 	mov	r0, #47	; 0x2f
102d86a8:	ebffff2f 	bl	102d836c <writedata>
	writedata(0x28);
102d86ac:	e3a00028 	mov	r0, #40	; 0x28
102d86b0:	ebffff2d 	bl	102d836c <writedata>
	writedata(0x20);
102d86b4:	e3a00020 	mov	r0, #32
102d86b8:	ebffff2b 	bl	102d836c <writedata>
	writedata(0x22);
102d86bc:	e3a00022 	mov	r0, #34	; 0x22
102d86c0:	ebffff29 	bl	102d836c <writedata>
	writedata(0x1f);
102d86c4:	e3a0001f 	mov	r0, #31
102d86c8:	ebffff27 	bl	102d836c <writedata>
	writedata(0x1b);
102d86cc:	e3a0001b 	mov	r0, #27
102d86d0:	ebffff25 	bl	102d836c <writedata>
	writedata(0x23);
102d86d4:	e3a00023 	mov	r0, #35	; 0x23
102d86d8:	ebffff23 	bl	102d836c <writedata>
	writedata(0x37);
102d86dc:	e3a00037 	mov	r0, #55	; 0x37
102d86e0:	ebffff21 	bl	102d836c <writedata>
	writedata(0x00);
102d86e4:	e1a00004 	mov	r0, r4
102d86e8:	ebffff1f 	bl	102d836c <writedata>
	writedata(0x07);
102d86ec:	e3a00007 	mov	r0, #7
102d86f0:	ebffff1d 	bl	102d836c <writedata>
	writedata(0x02);
102d86f4:	e3a00002 	mov	r0, #2
102d86f8:	ebffff1b 	bl	102d836c <writedata>
	writedata(0x10);
102d86fc:	e3a00010 	mov	r0, #16
102d8700:	ebffff19 	bl	102d836c <writedata>
	writecommand(ST7735_GMCTRN1);
102d8704:	e3a000e1 	mov	r0, #225	; 0xe1
102d8708:	ebffff06 	bl	102d8328 <writecommand>
	writedata(0x0f);
102d870c:	e3a0000f 	mov	r0, #15
102d8710:	ebffff15 	bl	102d836c <writedata>
	writedata(0x1b);
102d8714:	e3a0001b 	mov	r0, #27
102d8718:	ebffff13 	bl	102d836c <writedata>
	writedata(0x0f);
102d871c:	e3a0000f 	mov	r0, #15
102d8720:	ebffff11 	bl	102d836c <writedata>
	writedata(0x17);
102d8724:	e3a00017 	mov	r0, #23
102d8728:	ebffff0f 	bl	102d836c <writedata>
	writedata(0x33);
102d872c:	e3a00033 	mov	r0, #51	; 0x33
102d8730:	ebffff0d 	bl	102d836c <writedata>
	writedata(0x2c);
102d8734:	e3a0002c 	mov	r0, #44	; 0x2c
102d8738:	ebffff0b 	bl	102d836c <writedata>
	writedata(0x29);
102d873c:	e3a00029 	mov	r0, #41	; 0x29
102d8740:	ebffff09 	bl	102d836c <writedata>
	writedata(0x2e);
102d8744:	e3a0002e 	mov	r0, #46	; 0x2e
102d8748:	ebffff07 	bl	102d836c <writedata>
	writedata(0x30);
102d874c:	e3a00030 	mov	r0, #48	; 0x30
102d8750:	ebffff05 	bl	102d836c <writedata>
	writedata(0x30);
102d8754:	e3a00030 	mov	r0, #48	; 0x30
102d8758:	ebffff03 	bl	102d836c <writedata>
	writedata(0x39);
102d875c:	e3a00039 	mov	r0, #57	; 0x39
102d8760:	ebffff01 	bl	102d836c <writedata>
	writedata(0x3f);
102d8764:	e3a0003f 	mov	r0, #63	; 0x3f
102d8768:	ebfffeff 	bl	102d836c <writedata>
	writedata(0x00);
102d876c:	e1a00004 	mov	r0, r4
102d8770:	ebfffefd 	bl	102d836c <writedata>
	writedata(0x07);
102d8774:	e3a00007 	mov	r0, #7
102d8778:	ebfffefb 	bl	102d836c <writedata>
	writedata(0x03);
102d877c:	e3a00003 	mov	r0, #3
102d8780:	ebfffef9 	bl	102d836c <writedata>
	writedata(0x10);
102d8784:	e3a00010 	mov	r0, #16
102d8788:	ebfffef7 	bl	102d836c <writedata>

	writecommand(ST7735_DISPON);
102d878c:	e3a00029 	mov	r0, #41	; 0x29
102d8790:	ebfffee4 	bl	102d8328 <writecommand>
	// delay_us(100);

	writecommand(ST7735_NORON);  // normal display on
102d8794:	e3a00013 	mov	r0, #19
	// delay_us(10);

	// LCD_CS = 1;

}
102d8798:	e8bd4038 	pop	{r3, r4, r5, lr}
	writedata(0x10);

	writecommand(ST7735_DISPON);
	// delay_us(100);

	writecommand(ST7735_NORON);  // normal display on
102d879c:	eafffee1 	b	102d8328 <writecommand>
102d87a0:	00030d40 	.word	0x00030d40
102d87a4:	102e47d8 	.word	0x102e47d8
102d87a8:	f03de530 	.word	0xf03de530

102d87ac <Font_BigFont>:
		}
	}
}
// more ready made font are available on http://www.rinkydinkelectronics.com/r_fonts.php this link
// Function for to print "BALANCE" on center of the display
void Font_BigFont(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d87ac:	e59fc10c 	ldr	ip, [pc, #268]	; 102d88c0 <Font_BigFont+0x114>
{
102d87b0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
		}
	}
}
// more ready made font are available on http://www.rinkydinkelectronics.com/r_fonts.php this link
// Function for to print "BALANCE" on center of the display
void Font_BigFont(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d87b4:	e24cce3e 	sub	ip, ip, #992	; 0x3e0
{
102d87b8:	e24dd04c 	sub	sp, sp, #76	; 0x4c
		}
	}
}
// more ready made font are available on http://www.rinkydinkelectronics.com/r_fonts.php this link
// Function for to print "BALANCE" on center of the display
void Font_BigFont(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d87bc:	e24cc001 	sub	ip, ip, #1
102d87c0:	e20110ff 	and	r1, r1, #255	; 0xff
{
102d87c4:	e1a07003 	mov	r7, r3
102d87c8:	e20060ff 	and	r6, r0, #255	; 0xff

	unsigned char qm;
	long int ulOffset;
	char  ywbuf[50],temp[2];

	for(i = 0; i<strlen((char*)c);i++)
102d87cc:	e3a0a000 	mov	sl, #0
		}
	}
}
// more ready made font are available on http://www.rinkydinkelectronics.com/r_fonts.php this link
// Function for to print "BALANCE" on center of the display
void Font_BigFont(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d87d0:	e28d8034 	add	r8, sp, #52	; 0x34
						}
					}
					else //print first 8 bit data of 16 bit data
					{
						k=x % 8;
						if(ywbuf[z]&(0x80 >> k)) // print ywbuf[z] first 8 bit data
102d87d4:	e3a0b080 	mov	fp, #128	; 0x80
		}
	}
}
// more ready made font are available on http://www.rinkydinkelectronics.com/r_fonts.php this link
// Function for to print "BALANCE" on center of the display
void Font_BigFont(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d87d8:	e98d1004 	stmib	sp, {r2, ip}
102d87dc:	e58d100c 	str	r1, [sp, #12]

	unsigned char qm;
	long int ulOffset;
	char  ywbuf[50],temp[2];

	for(i = 0; i<strlen((char*)c);i++)
102d87e0:	e59d0004 	ldr	r0, [sp, #4]
102d87e4:	e59f10d8 	ldr	r1, [pc, #216]	; 102d88c4 <Font_BigFont+0x118>
102d87e8:	e12fff31 	blx	r1
102d87ec:	e15a0000 	cmp	sl, r0
102d87f0:	2a000030 	bcs	102d88b8 <Font_BigFont+0x10c>
	{
		int z = 0;
		if(((unsigned char)(*(c+i))) >= 161)
102d87f4:	e59dc004 	ldr	ip, [sp, #4]
102d87f8:	e7dc300a 	ldrb	r3, [ip, sl]
102d87fc:	e35300a0 	cmp	r3, #160	; 0xa0
102d8800:	8a00002c 	bhi	102d88b8 <Font_BigFont+0x10c>
			return;
		}
		else
		{
			qm = *(c+i);
			ulOffset = (long int)(qm) * 32;  // calculate pointer to print character (32 bit raw data is available in single character)
102d8804:	e1a00283 	lsl	r0, r3, #5
		}
	}
}
// more ready made font are available on http://www.rinkydinkelectronics.com/r_fonts.php this link
// Function for to print "BALANCE" on center of the display
void Font_BigFont(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d8808:	e2403b01 	sub	r3, r0, #1024	; 0x400
102d880c:	e59f10ac 	ldr	r1, [pc, #172]	; 102d88c0 <Font_BigFont+0x114>
102d8810:	e59dc008 	ldr	ip, [sp, #8]
102d8814:	e2433001 	sub	r3, r3, #1
102d8818:	e0813003 	add	r3, r1, r3
102d881c:	e28d2013 	add	r2, sp, #19
102d8820:	e080000c 	add	r0, r0, ip
		{
			qm = *(c+i);
			ulOffset = (long int)(qm) * 32;  // calculate pointer to print character (32 bit raw data is available in single character)
			for (j = 0; j < 32; j ++)
			{
				ywbuf[j]=BigFont[(ulOffset-1024)+j]; // copy  character into ywbuf[j] buffer memory (1024 = 32(character per line) *32(difference between 'A' and 'a')
102d8824:	e5f31001 	ldrb	r1, [r3, #1]!
102d8828:	e5e21001 	strb	r1, [r2, #1]!
		}
		else
		{
			qm = *(c+i);
			ulOffset = (long int)(qm) * 32;  // calculate pointer to print character (32 bit raw data is available in single character)
			for (j = 0; j < 32; j ++)
102d882c:	e1530000 	cmp	r3, r0
102d8830:	1afffffb 	bne	102d8824 <Font_BigFont+0x78>
102d8834:	e59d400c 	ldr	r4, [sp, #12]
102d8838:	e28d9014 	add	r9, sp, #20
	}
}
// more ready made font are available on http://www.rinkydinkelectronics.com/r_fonts.php this link
// Function for to print "BALANCE" on center of the display
void Font_BigFont(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
{
102d883c:	e3a05000 	mov	r5, #0
102d8840:	ea000005 	b	102d885c <Font_BigFont+0xb0>
				{

					if(x > 7) //print next 8 bit data of 16 bit data
					{
						k=x % 8;
						if(ywbuf[z+1]&(0x80 >> k)) // print ywbuf[z+1] next 8 bit data
102d8844:	e5d92001 	ldrb	r2, [r9, #1]
102d8848:	e012235b 	ands	r2, r2, fp, asr r3
102d884c:	1a000008 	bne	102d8874 <Font_BigFont+0xc8>
			{
				ywbuf[j]=BigFont[(ulOffset-1024)+j]; // copy  character into ywbuf[j] buffer memory (1024 = 32(character per line) *32(difference between 'A' and 'a')
			}
			for(y = 0;y < 16; y++) //16 is vertical line
			{
				for(x=0;x<16;x++) // 16 is horizontal line
102d8850:	e2855001 	add	r5, r5, #1
102d8854:	e3550010 	cmp	r5, #16
102d8858:	0a00000d 	beq	102d8894 <Font_BigFont+0xe8>
				{

					if(x > 7) //print next 8 bit data of 16 bit data
102d885c:	e3550007 	cmp	r5, #7
					{
						k=x % 8;
102d8860:	e2053007 	and	r3, r5, #7
			for(y = 0;y < 16; y++) //16 is vertical line
			{
				for(x=0;x<16;x++) // 16 is horizontal line
				{

					if(x > 7) //print next 8 bit data of 16 bit data
102d8864:	cafffff6 	bgt	102d8844 <Font_BigFont+0x98>
						}
					}
					else //print first 8 bit data of 16 bit data
					{
						k=x % 8;
						if(ywbuf[z]&(0x80 >> k)) // print ywbuf[z] first 8 bit data
102d8868:	e5d93000 	ldrb	r3, [r9]
102d886c:	e013355b 	ands	r3, r3, fp, asr r5
102d8870:	0afffff6 	beq	102d8850 <Font_BigFont+0xa4>
						{
							xx=x0+x+i*16;
							//Output_Pixel(xx,y+y0);
							ST7735_drawPixel(xx, y+y0, color);
102d8874:	e0860005 	add	r0, r6, r5
102d8878:	e20000ff 	and	r0, r0, #255	; 0xff
102d887c:	e1a01004 	mov	r1, r4
102d8880:	e1a02007 	mov	r2, r7
			{
				ywbuf[j]=BigFont[(ulOffset-1024)+j]; // copy  character into ywbuf[j] buffer memory (1024 = 32(character per line) *32(difference between 'A' and 'a')
			}
			for(y = 0;y < 16; y++) //16 is vertical line
			{
				for(x=0;x<16;x++) // 16 is horizontal line
102d8884:	e2855001 	add	r5, r5, #1
						k=x % 8;
						if(ywbuf[z]&(0x80 >> k)) // print ywbuf[z] first 8 bit data
						{
							xx=x0+x+i*16;
							//Output_Pixel(xx,y+y0);
							ST7735_drawPixel(xx, y+y0, color);
102d8888:	ebfffef8 	bl	102d8470 <ST7735_drawPixel>
			{
				ywbuf[j]=BigFont[(ulOffset-1024)+j]; // copy  character into ywbuf[j] buffer memory (1024 = 32(character per line) *32(difference between 'A' and 'a')
			}
			for(y = 0;y < 16; y++) //16 is vertical line
			{
				for(x=0;x<16;x++) // 16 is horizontal line
102d888c:	e3550010 	cmp	r5, #16
102d8890:	1afffff1 	bne	102d885c <Font_BigFont+0xb0>
102d8894:	e2899002 	add	r9, r9, #2
102d8898:	e2844001 	add	r4, r4, #1
			ulOffset = (long int)(qm) * 32;  // calculate pointer to print character (32 bit raw data is available in single character)
			for (j = 0; j < 32; j ++)
			{
				ywbuf[j]=BigFont[(ulOffset-1024)+j]; // copy  character into ywbuf[j] buffer memory (1024 = 32(character per line) *32(difference between 'A' and 'a')
			}
			for(y = 0;y < 16; y++) //16 is vertical line
102d889c:	e1590008 	cmp	r9, r8
102d88a0:	e20440ff 	and	r4, r4, #255	; 0xff
102d88a4:	1affffe4 	bne	102d883c <Font_BigFont+0x90>
102d88a8:	e2866010 	add	r6, r6, #16

	unsigned char qm;
	long int ulOffset;
	char  ywbuf[50],temp[2];

	for(i = 0; i<strlen((char*)c);i++)
102d88ac:	e28aa001 	add	sl, sl, #1
102d88b0:	e20660ff 	and	r6, r6, #255	; 0xff
102d88b4:	eaffffc9 	b	102d87e0 <Font_BigFont+0x34>
				}
				z=z+2; // increment of ywbuf[] buffer memory  by 2 every time because of 16 bit data
			}
		}
	}
}
102d88b8:	e28dd04c 	add	sp, sp, #76	; 0x4c
102d88bc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
102d88c0:	f03d20c8 	.word	0xf03d20c8
102d88c4:	102dff65 	.word	0x102dff65

102d88c8 <Font_Grotesk16x32>:

// Function for to print "999.9 L" water balance on center of the display
void Font_Grotesk16x32(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
{
102d88c8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102d88cc:	e20110ff 	and	r1, r1, #255	; 0xff
102d88d0:	e24dd07c 	sub	sp, sp, #124	; 0x7c
102d88d4:	e58d100c 	str	r1, [sp, #12]
		}
	}
}

// Function for to print "999.9 L" water balance on center of the display
void Font_Grotesk16x32(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d88d8:	e59f1110 	ldr	r1, [pc, #272]	; 102d89f0 <Font_Grotesk16x32+0x128>
{
102d88dc:	e58d2004 	str	r2, [sp, #4]
		}
	}
}

// Function for to print "999.9 L" water balance on center of the display
void Font_Grotesk16x32(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d88e0:	e2411d1f 	sub	r1, r1, #1984	; 0x7c0
102d88e4:	e58d1008 	str	r1, [sp, #8]
102d88e8:	e59d100c 	ldr	r1, [sp, #12]
102d88ec:	e59d2008 	ldr	r2, [sp, #8]
102d88f0:	e2818020 	add	r8, r1, #32
102d88f4:	e2422001 	sub	r2, r2, #1
{
102d88f8:	e1a07003 	mov	r7, r3
102d88fc:	e20060ff 	and	r6, r0, #255	; 0xff

	unsigned char qm;
	long int ulOffset;
	char  ywbuf[100],temp[2];

	for(i = 0; i<strlen((char*)c);i++)
102d8900:	e3a0a000 	mov	sl, #0
		}
	}
}

// Function for to print "999.9 L" water balance on center of the display
void Font_Grotesk16x32(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d8904:	e20880ff 	and	r8, r8, #255	; 0xff
102d8908:	e58d2008 	str	r2, [sp, #8]

	unsigned char qm;
	long int ulOffset;
	char  ywbuf[100],temp[2];

	for(i = 0; i<strlen((char*)c);i++)
102d890c:	e59d0004 	ldr	r0, [sp, #4]
102d8910:	e59f20dc 	ldr	r2, [pc, #220]	; 102d89f4 <Font_Grotesk16x32+0x12c>
102d8914:	e12fff32 	blx	r2
102d8918:	e15a0000 	cmp	sl, r0
102d891c:	2a000031 	bcs	102d89e8 <Font_Grotesk16x32+0x120>
	{
		int z = 0;
		if(((unsigned char)(*(c+i))) >= 161)
102d8920:	e59d1004 	ldr	r1, [sp, #4]
102d8924:	e7d1300a 	ldrb	r3, [r1, sl]
102d8928:	e35300a0 	cmp	r3, #160	; 0xa0
102d892c:	8a00002d 	bhi	102d89e8 <Font_Grotesk16x32+0x120>
			return;
		}
		else
		{
			qm = *(c+i);
			ulOffset = (long int)(qm) * 64;// calculate pointer to print character (64 bit raw data is available in single character)
102d8930:	e1a00303 	lsl	r0, r3, #6
		}
	}
}

// Function for to print "999.9 L" water balance on center of the display
void Font_Grotesk16x32(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
102d8934:	e2403b02 	sub	r3, r0, #2048	; 0x800
102d8938:	e59f20b0 	ldr	r2, [pc, #176]	; 102d89f0 <Font_Grotesk16x32+0x128>
102d893c:	e59d1008 	ldr	r1, [sp, #8]
102d8940:	e2433001 	sub	r3, r3, #1
102d8944:	e0823003 	add	r3, r2, r3
102d8948:	e0800001 	add	r0, r0, r1
102d894c:	e28d2013 	add	r2, sp, #19
		{
			qm = *(c+i);
			ulOffset = (long int)(qm) * 64;// calculate pointer to print character (64 bit raw data is available in single character)
			for (j = 0; j < 64; j ++)
			{
				ywbuf[j]=Grotesk16x32[(ulOffset-2048)+j];// copy  character into ywbuf[j] buffer memory (2048 = 64(character per line) *32(difference between 'A' and 'a')
102d8950:	e5f31001 	ldrb	r1, [r3, #1]!
102d8954:	e5e21001 	strb	r1, [r2, #1]!
		}
		else
		{
			qm = *(c+i);
			ulOffset = (long int)(qm) * 64;// calculate pointer to print character (64 bit raw data is available in single character)
			for (j = 0; j < 64; j ++)
102d8958:	e1530000 	cmp	r3, r0
102d895c:	1afffffb 	bne	102d8950 <Font_Grotesk16x32+0x88>
102d8960:	e59d500c 	ldr	r5, [sp, #12]
102d8964:	e28db014 	add	fp, sp, #20
						}
					}
					else  //print first 8 bit dta of 16 bit data
					{
						k=x % 8;
						if(ywbuf[z]&(0x80 >> k)) // print ywbuf[z] first 8 bit data
102d8968:	e3a09080 	mov	r9, #128	; 0x80
	}
}

// Function for to print "999.9 L" water balance on center of the display
void Font_Grotesk16x32(unsigned int x0, unsigned int y0, unsigned char *c, unsigned int color)
{
102d896c:	e3a04000 	mov	r4, #0
102d8970:	ea000005 	b	102d898c <Font_Grotesk16x32+0xc4>
				{

					if(x > 7)  //print next 8 bit data of 16 bit data
					{
						k=x % 8;
						if(ywbuf[z+1]&(0x80 >> k))  // print ywbuf[z+1] next 8 bit data
102d8974:	e5db2001 	ldrb	r2, [fp, #1]
102d8978:	e0122359 	ands	r2, r2, r9, asr r3
102d897c:	1a000008 	bne	102d89a4 <Font_Grotesk16x32+0xdc>
			{
				ywbuf[j]=Grotesk16x32[(ulOffset-2048)+j];// copy  character into ywbuf[j] buffer memory (2048 = 64(character per line) *32(difference between 'A' and 'a')
			}
			for(y = 0;y < 32; y++) // 32 is vertical line
			{
				for(x=0;x<16;x++)  // 16 is horizontal line
102d8980:	e2844001 	add	r4, r4, #1
102d8984:	e3540010 	cmp	r4, #16
102d8988:	0a00000d 	beq	102d89c4 <Font_Grotesk16x32+0xfc>
				{

					if(x > 7)  //print next 8 bit data of 16 bit data
102d898c:	e3540007 	cmp	r4, #7
					{
						k=x % 8;
102d8990:	e2043007 	and	r3, r4, #7
			for(y = 0;y < 32; y++) // 32 is vertical line
			{
				for(x=0;x<16;x++)  // 16 is horizontal line
				{

					if(x > 7)  //print next 8 bit data of 16 bit data
102d8994:	cafffff6 	bgt	102d8974 <Font_Grotesk16x32+0xac>
						}
					}
					else  //print first 8 bit dta of 16 bit data
					{
						k=x % 8;
						if(ywbuf[z]&(0x80 >> k)) // print ywbuf[z] first 8 bit data
102d8998:	e5db3000 	ldrb	r3, [fp]
102d899c:	e0133459 	ands	r3, r3, r9, asr r4
102d89a0:	0afffff6 	beq	102d8980 <Font_Grotesk16x32+0xb8>
						{
							xx=x0+x+i*16;
							//Output_Pixel(xx,y+y0);
							ST7735_drawPixel(xx, y+y0, color);
102d89a4:	e0860004 	add	r0, r6, r4
102d89a8:	e20000ff 	and	r0, r0, #255	; 0xff
102d89ac:	e1a01005 	mov	r1, r5
102d89b0:	e1a02007 	mov	r2, r7
			{
				ywbuf[j]=Grotesk16x32[(ulOffset-2048)+j];// copy  character into ywbuf[j] buffer memory (2048 = 64(character per line) *32(difference between 'A' and 'a')
			}
			for(y = 0;y < 32; y++) // 32 is vertical line
			{
				for(x=0;x<16;x++)  // 16 is horizontal line
102d89b4:	e2844001 	add	r4, r4, #1
						k=x % 8;
						if(ywbuf[z]&(0x80 >> k)) // print ywbuf[z] first 8 bit data
						{
							xx=x0+x+i*16;
							//Output_Pixel(xx,y+y0);
							ST7735_drawPixel(xx, y+y0, color);
102d89b8:	ebfffeac 	bl	102d8470 <ST7735_drawPixel>
			{
				ywbuf[j]=Grotesk16x32[(ulOffset-2048)+j];// copy  character into ywbuf[j] buffer memory (2048 = 64(character per line) *32(difference between 'A' and 'a')
			}
			for(y = 0;y < 32; y++) // 32 is vertical line
			{
				for(x=0;x<16;x++)  // 16 is horizontal line
102d89bc:	e3540010 	cmp	r4, #16
102d89c0:	1afffff1 	bne	102d898c <Font_Grotesk16x32+0xc4>
102d89c4:	e2855001 	add	r5, r5, #1
102d89c8:	e20550ff 	and	r5, r5, #255	; 0xff
			ulOffset = (long int)(qm) * 64;// calculate pointer to print character (64 bit raw data is available in single character)
			for (j = 0; j < 64; j ++)
			{
				ywbuf[j]=Grotesk16x32[(ulOffset-2048)+j];// copy  character into ywbuf[j] buffer memory (2048 = 64(character per line) *32(difference between 'A' and 'a')
			}
			for(y = 0;y < 32; y++) // 32 is vertical line
102d89cc:	e1550008 	cmp	r5, r8
102d89d0:	e28bb002 	add	fp, fp, #2
102d89d4:	1affffe4 	bne	102d896c <Font_Grotesk16x32+0xa4>
102d89d8:	e2866010 	add	r6, r6, #16

	unsigned char qm;
	long int ulOffset;
	char  ywbuf[100],temp[2];

	for(i = 0; i<strlen((char*)c);i++)
102d89dc:	e28aa001 	add	sl, sl, #1
102d89e0:	e20660ff 	and	r6, r6, #255	; 0xff
102d89e4:	eaffffc8 	b	102d890c <Font_Grotesk16x32+0x44>
				}
				z=z+2; // increment of ywbuf[] buffer memory  by 2 every time beciuse of 16 bit data
			}
		}
	}
}
102d89e8:	e28dd07c 	add	sp, sp, #124	; 0x7c
102d89ec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
102d89f0:	f03d2ca8 	.word	0xf03d2ca8
102d89f4:	102dff65 	.word	0x102dff65

102d89f8 <ST7735_drawString_for_BALANCE_align_Center>:
	}
}


void ST7735_drawString_for_BALANCE_align_Center(unsigned char y, char *c, unsigned int color)
{
102d89f8:	e92d4070 	push	{r4, r5, r6, lr}
102d89fc:	e1a05000 	mov	r5, r0
102d8a00:	e1a04001 	mov	r4, r1
	unsigned char string_length;
	unsigned char x;
	unsigned char pixel_strength;
	string_length = strlen(c); // number of letters in the string
102d8a04:	e1a00001 	mov	r0, r1
102d8a08:	e59f1044 	ldr	r1, [pc, #68]	; 102d8a54 <ST7735_drawString_for_BALANCE_align_Center+0x5c>
	}
}


void ST7735_drawString_for_BALANCE_align_Center(unsigned char y, char *c, unsigned int color)
{
102d8a0c:	e1a06002 	mov	r6, r2
	unsigned char string_length;
	unsigned char x;
	unsigned char pixel_strength;
	string_length = strlen(c); // number of letters in the string
102d8a10:	e12fff31 	blx	r1

	pixel_strength = (string_length * 16)+ ((string_length -1) ); // number of pixel in width direction of the string

	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;
	if(y == 25)
102d8a14:	e3550019 	cmp	r5, #25
	{
		Font_BigFont(x, y, c, color); // Function for to print "BALANCE" on center of the display
102d8a18:	e1a01005 	mov	r1, r5
102d8a1c:	e1a02004 	mov	r2, r4
102d8a20:	e1a03006 	mov	r3, r6
	unsigned char string_length;
	unsigned char x;
	unsigned char pixel_strength;
	string_length = strlen(c); // number of letters in the string

	pixel_strength = (string_length * 16)+ ((string_length -1) ); // number of pixel in width direction of the string
102d8a24:	e0800200 	add	r0, r0, r0, lsl #4
102d8a28:	e240c001 	sub	ip, r0, #1

	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;
102d8a2c:	e20cc0ff 	and	ip, ip, #255	; 0xff
102d8a30:	e26cc0a0 	rsb	ip, ip, #160	; 0xa0
102d8a34:	e08ccfac 	add	ip, ip, ip, lsr #31
102d8a38:	e1a0c0cc 	asr	ip, ip, #1
	if(y == 25)
	{
		Font_BigFont(x, y, c, color); // Function for to print "BALANCE" on center of the display
102d8a3c:	e20c00ff 	and	r0, ip, #255	; 0xff

	pixel_strength = (string_length * 16)+ ((string_length -1) ); // number of pixel in width direction of the string

	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;
	if(y == 25)
102d8a40:	0a000001 	beq	102d8a4c <ST7735_drawString_for_BALANCE_align_Center+0x54>
	}
	else
	{
		Font_Grotesk16x32(x, y, c, color); // Function for to print "999.9 L" water balance on center of the display
	}
}
102d8a44:	e8bd4070 	pop	{r4, r5, r6, lr}
	{
		Font_BigFont(x, y, c, color); // Function for to print "BALANCE" on center of the display
	}
	else
	{
		Font_Grotesk16x32(x, y, c, color); // Function for to print "999.9 L" water balance on center of the display
102d8a48:	eaffff9e 	b	102d88c8 <Font_Grotesk16x32>
	}
}
102d8a4c:	e8bd4070 	pop	{r4, r5, r6, lr}

	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;
	if(y == 25)
	{
		Font_BigFont(x, y, c, color); // Function for to print "BALANCE" on center of the display
102d8a50:	eaffff55 	b	102d87ac <Font_BigFont>
102d8a54:	102dff65 	.word	0x102dff65

102d8a58 <ST7735_drawCircleHelper>:
	}
}


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
{
102d8a58:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
102d8a5c:	e3520000 	cmp	r2, #0
	}
}


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
{
102d8a60:	e24dd01c 	sub	sp, sp, #28
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
102d8a64:	e0629f82 	rsb	r9, r2, r2, lsl #31
	}
}


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
{
102d8a68:	e1a07000 	mov	r7, r0
102d8a6c:	e1a08001 	mov	r8, r1
102d8a70:	e59da040 	ldr	sl, [sp, #64]	; 0x40
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
102d8a74:	e2625001 	rsb	r5, r2, #1
102d8a78:	e1a09089 	lsl	r9, r9, #1
	while (x<y)
102d8a7c:	da000067 	ble	102d8c20 <ST7735_drawCircleHelper+0x1c8>
102d8a80:	e2031008 	and	r1, r3, #8
102d8a84:	e203b002 	and	fp, r3, #2
102d8a88:	e58d1010 	str	r1, [sp, #16]
102d8a8c:	e2031001 	and	r1, r3, #1
102d8a90:	e2033004 	and	r3, r3, #4
102d8a94:	e58d100c 	str	r1, [sp, #12]
102d8a98:	e58d3014 	str	r3, [sp, #20]
102d8a9c:	e1a06002 	mov	r6, r2


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
102d8aa0:	e3a04000 	mov	r4, #0
102d8aa4:	ea000009 	b	102d8ad0 <ST7735_drawCircleHelper+0x78>
		if (cornername & 0x4)
		{
			ST7735_drawPixel(x0 + x, y0 + y, color);
			ST7735_drawPixel(x0 + y, y0 + x, color);
		}
		if (cornername & 0x2)
102d8aa8:	e35b0000 	cmp	fp, #0
102d8aac:	1a000023 	bne	102d8b40 <ST7735_drawCircleHelper+0xe8>
		{
			ST7735_drawPixel(x0 + x, y0 - y, color);
			ST7735_drawPixel(x0 + y, y0 - x, color);
		}
		if (cornername & 0x8)
102d8ab0:	e59d3010 	ldr	r3, [sp, #16]
102d8ab4:	e3530000 	cmp	r3, #0
102d8ab8:	1a000033 	bne	102d8b8c <ST7735_drawCircleHelper+0x134>
		{
			ST7735_drawPixel(x0 - y, y0 + x, color);
			ST7735_drawPixel(x0 - x, y0 + y, color);
		}
		if (cornername & 0x1)
102d8abc:	e59d300c 	ldr	r3, [sp, #12]
102d8ac0:	e3530000 	cmp	r3, #0
102d8ac4:	1a000043 	bne	102d8bd8 <ST7735_drawCircleHelper+0x180>

void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
102d8ac8:	e1560004 	cmp	r6, r4
102d8acc:	da000053 	ble	102d8c20 <ST7735_drawCircleHelper+0x1c8>
	{
		if (f >= 0)
102d8ad0:	e3550000 	cmp	r5, #0
		{
			y--;
			ddF_y += 2;
102d8ad4:	a2899002 	addge	r9, r9, #2
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;
		if (cornername & 0x4)
102d8ad8:	e59d3014 	ldr	r3, [sp, #20]
	{
		if (f >= 0)
		{
			y--;
			ddF_y += 2;
			f += ddF_y;
102d8adc:	a0855009 	addge	r5, r5, r9
		}
		x++;
102d8ae0:	e2844001 	add	r4, r4, #1
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
	{
		if (f >= 0)
		{
			y--;
102d8ae4:	a2466001 	subge	r6, r6, #1
		}
	}
}


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
102d8ae8:	e0855084 	add	r5, r5, r4, lsl #1
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;
		if (cornername & 0x4)
102d8aec:	e3530000 	cmp	r3, #0
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;
102d8af0:	e2855001 	add	r5, r5, #1
		if (cornername & 0x4)
102d8af4:	0affffeb 	beq	102d8aa8 <ST7735_drawCircleHelper+0x50>
		}
	}
}


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
102d8af8:	e20430ff 	and	r3, r4, #255	; 0xff
		x++;
		ddF_x += 2;
		f += ddF_x;
		if (cornername & 0x4)
		{
			ST7735_drawPixel(x0 + x, y0 + y, color);
102d8afc:	e206c0ff 	and	ip, r6, #255	; 0xff
102d8b00:	e0830007 	add	r0, r3, r7
102d8b04:	e08c1008 	add	r1, ip, r8
102d8b08:	e20000ff 	and	r0, r0, #255	; 0xff
102d8b0c:	e20110ff 	and	r1, r1, #255	; 0xff
102d8b10:	e1a0200a 	mov	r2, sl
102d8b14:	e98d1008 	stmib	sp, {r3, ip}
102d8b18:	ebfffe54 	bl	102d8470 <ST7735_drawPixel>
			ST7735_drawPixel(x0 + y, y0 + x, color);
102d8b1c:	e99d1008 	ldmib	sp, {r3, ip}
102d8b20:	e08c0007 	add	r0, ip, r7
102d8b24:	e0831008 	add	r1, r3, r8
102d8b28:	e20000ff 	and	r0, r0, #255	; 0xff
102d8b2c:	e20110ff 	and	r1, r1, #255	; 0xff
102d8b30:	e1a0200a 	mov	r2, sl
102d8b34:	ebfffe4d 	bl	102d8470 <ST7735_drawPixel>
		}
		if (cornername & 0x2)
102d8b38:	e35b0000 	cmp	fp, #0
102d8b3c:	0affffdb 	beq	102d8ab0 <ST7735_drawCircleHelper+0x58>
		}
	}
}


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
102d8b40:	e20430ff 	and	r3, r4, #255	; 0xff
			ST7735_drawPixel(x0 + x, y0 + y, color);
			ST7735_drawPixel(x0 + y, y0 + x, color);
		}
		if (cornername & 0x2)
		{
			ST7735_drawPixel(x0 + x, y0 - y, color);
102d8b44:	e206c0ff 	and	ip, r6, #255	; 0xff
102d8b48:	e0830007 	add	r0, r3, r7
102d8b4c:	e06c1008 	rsb	r1, ip, r8
102d8b50:	e20000ff 	and	r0, r0, #255	; 0xff
102d8b54:	e20110ff 	and	r1, r1, #255	; 0xff
102d8b58:	e1a0200a 	mov	r2, sl
102d8b5c:	e98d1008 	stmib	sp, {r3, ip}
102d8b60:	ebfffe42 	bl	102d8470 <ST7735_drawPixel>
			ST7735_drawPixel(x0 + y, y0 - x, color);
102d8b64:	e99d1008 	ldmib	sp, {r3, ip}
102d8b68:	e0631008 	rsb	r1, r3, r8
102d8b6c:	e08c0007 	add	r0, ip, r7
102d8b70:	e20000ff 	and	r0, r0, #255	; 0xff
102d8b74:	e20110ff 	and	r1, r1, #255	; 0xff
102d8b78:	e1a0200a 	mov	r2, sl
102d8b7c:	ebfffe3b 	bl	102d8470 <ST7735_drawPixel>
		}
		if (cornername & 0x8)
102d8b80:	e59d3010 	ldr	r3, [sp, #16]
102d8b84:	e3530000 	cmp	r3, #0
102d8b88:	0affffcb 	beq	102d8abc <ST7735_drawCircleHelper+0x64>
		{
			ST7735_drawPixel(x0 - y, y0 + x, color);
102d8b8c:	e20630ff 	and	r3, r6, #255	; 0xff
		}
	}
}


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
102d8b90:	e204c0ff 	and	ip, r4, #255	; 0xff
			ST7735_drawPixel(x0 + x, y0 - y, color);
			ST7735_drawPixel(x0 + y, y0 - x, color);
		}
		if (cornername & 0x8)
		{
			ST7735_drawPixel(x0 - y, y0 + x, color);
102d8b94:	e0630007 	rsb	r0, r3, r7
102d8b98:	e08c1008 	add	r1, ip, r8
102d8b9c:	e20000ff 	and	r0, r0, #255	; 0xff
102d8ba0:	e20110ff 	and	r1, r1, #255	; 0xff
102d8ba4:	e1a0200a 	mov	r2, sl
102d8ba8:	e98d1008 	stmib	sp, {r3, ip}
102d8bac:	ebfffe2f 	bl	102d8470 <ST7735_drawPixel>
			ST7735_drawPixel(x0 - x, y0 + y, color);
102d8bb0:	e99d1008 	ldmib	sp, {r3, ip}
102d8bb4:	e0831008 	add	r1, r3, r8
102d8bb8:	e06c0007 	rsb	r0, ip, r7
102d8bbc:	e20000ff 	and	r0, r0, #255	; 0xff
102d8bc0:	e20110ff 	and	r1, r1, #255	; 0xff
102d8bc4:	e1a0200a 	mov	r2, sl
102d8bc8:	ebfffe28 	bl	102d8470 <ST7735_drawPixel>
		}
		if (cornername & 0x1)
102d8bcc:	e59d300c 	ldr	r3, [sp, #12]
102d8bd0:	e3530000 	cmp	r3, #0
102d8bd4:	0affffbb 	beq	102d8ac8 <ST7735_drawCircleHelper+0x70>
		{
			ST7735_drawPixel(x0 - y, y0 - x, color);
102d8bd8:	e20630ff 	and	r3, r6, #255	; 0xff
		}
	}
}


void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
102d8bdc:	e204c0ff 	and	ip, r4, #255	; 0xff
			ST7735_drawPixel(x0 - y, y0 + x, color);
			ST7735_drawPixel(x0 - x, y0 + y, color);
		}
		if (cornername & 0x1)
		{
			ST7735_drawPixel(x0 - y, y0 - x, color);
102d8be0:	e0630007 	rsb	r0, r3, r7
102d8be4:	e06c1008 	rsb	r1, ip, r8
102d8be8:	e20000ff 	and	r0, r0, #255	; 0xff
102d8bec:	e20110ff 	and	r1, r1, #255	; 0xff
102d8bf0:	e1a0200a 	mov	r2, sl
102d8bf4:	e98d1008 	stmib	sp, {r3, ip}
102d8bf8:	ebfffe1c 	bl	102d8470 <ST7735_drawPixel>
			ST7735_drawPixel(x0 - x, y0 - y, color);
102d8bfc:	e99d1008 	ldmib	sp, {r3, ip}
102d8c00:	e06c0007 	rsb	r0, ip, r7
102d8c04:	e0631008 	rsb	r1, r3, r8
102d8c08:	e20000ff 	and	r0, r0, #255	; 0xff
102d8c0c:	e20110ff 	and	r1, r1, #255	; 0xff
102d8c10:	e1a0200a 	mov	r2, sl
102d8c14:	ebfffe15 	bl	102d8470 <ST7735_drawPixel>

void ST7735_drawCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
102d8c18:	e1560004 	cmp	r6, r4
102d8c1c:	caffffab 	bgt	102d8ad0 <ST7735_drawCircleHelper+0x78>
		{
			ST7735_drawPixel(x0 - y, y0 - x, color);
			ST7735_drawPixel(x0 - x, y0 - y, color);
		}
	}
}
102d8c20:	e28dd01c 	add	sp, sp, #28
102d8c24:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

102d8c28 <ST7735_drawCircle>:
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8c28:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102d8c2c:	e24dd014 	sub	sp, sp, #20
	int f = 1 - r;
102d8c30:	e58d2008 	str	r2, [sp, #8]
	int ddF_x = 1;
	int ddF_y = -2 * r;
102d8c34:	e59dc008 	ldr	ip, [sp, #8]
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8c38:	e1a0a001 	mov	sl, r1
102d8c3c:	e1a04003 	mov	r4, r3
	int ddF_x = 1;
	int ddF_y = -2 * r;
	int x = 0;
	int y = r;

	ST7735_drawPixel(x0, y0+r, color);
102d8c40:	e0821001 	add	r1, r2, r1
102d8c44:	e1a02003 	mov	r2, r3

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
	int f = 1 - r;
	int ddF_x = 1;
	int ddF_y = -2 * r;
102d8c48:	e06c3f8c 	rsb	r3, ip, ip, lsl #31
102d8c4c:	e1a03083 	lsl	r3, r3, #1
	int x = 0;
	int y = r;

	ST7735_drawPixel(x0, y0+r, color);
102d8c50:	e20110ff 	and	r1, r1, #255	; 0xff
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8c54:	e1a09000 	mov	r9, r0
	int f = 1 - r;
	int ddF_x = 1;
	int ddF_y = -2 * r;
102d8c58:	e58d300c 	str	r3, [sp, #12]
	int x = 0;
	int y = r;

	ST7735_drawPixel(x0, y0+r, color);
102d8c5c:	ebfffe03 	bl	102d8470 <ST7735_drawPixel>
	ST7735_drawPixel(x0, y0-r, color);
102d8c60:	e59dc008 	ldr	ip, [sp, #8]
102d8c64:	e1a00009 	mov	r0, r9
102d8c68:	e06c100a 	rsb	r1, ip, sl
102d8c6c:	e20110ff 	and	r1, r1, #255	; 0xff
102d8c70:	e1a02004 	mov	r2, r4
102d8c74:	ebfffdfd 	bl	102d8470 <ST7735_drawPixel>
	ST7735_drawPixel(x0+r, y0, color);
102d8c78:	e59dc008 	ldr	ip, [sp, #8]
102d8c7c:	e1a0100a 	mov	r1, sl
102d8c80:	e08c0009 	add	r0, ip, r9
102d8c84:	e20000ff 	and	r0, r0, #255	; 0xff
102d8c88:	e1a02004 	mov	r2, r4
102d8c8c:	ebfffdf7 	bl	102d8470 <ST7735_drawPixel>
	ST7735_drawPixel(x0-r, y0, color);
102d8c90:	e59dc008 	ldr	ip, [sp, #8]
102d8c94:	e1a0100a 	mov	r1, sl
102d8c98:	e06c0009 	rsb	r0, ip, r9
102d8c9c:	e20000ff 	and	r0, r0, #255	; 0xff
102d8ca0:	e1a02004 	mov	r2, r4
102d8ca4:	ebfffdf1 	bl	102d8470 <ST7735_drawPixel>

	while (x<y)
102d8ca8:	e59dc008 	ldr	ip, [sp, #8]
102d8cac:	e35c0000 	cmp	ip, #0
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
	int f = 1 - r;
102d8cb0:	e26c8001 	rsb	r8, ip, #1
	ST7735_drawPixel(x0, y0+r, color);
	ST7735_drawPixel(x0, y0-r, color);
	ST7735_drawPixel(x0+r, y0, color);
	ST7735_drawPixel(x0-r, y0, color);

	while (x<y)
102d8cb4:	0a000048 	beq	102d8ddc <ST7735_drawCircle+0x1b4>
102d8cb8:	e3a05000 	mov	r5, #0
		{
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
102d8cbc:	e2855001 	add	r5, r5, #1
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8cc0:	e20560ff 	and	r6, r5, #255	; 0xff
102d8cc4:	e089c006 	add	ip, r9, r6
102d8cc8:	e20cc0ff 	and	ip, ip, #255	; 0xff
	ST7735_drawPixel(x0+r, y0, color);
	ST7735_drawPixel(x0-r, y0, color);

	while (x<y)
	{
		if (f >= 0)
102d8ccc:	e3580000 	cmp	r8, #0
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		ST7735_drawPixel(x0 + x, y0 + y, color);
102d8cd0:	e1a0000c 	mov	r0, ip
102d8cd4:	e1a02004 	mov	r2, r4
	ST7735_drawPixel(x0+r, y0, color);
	ST7735_drawPixel(x0-r, y0, color);

	while (x<y)
	{
		if (f >= 0)
102d8cd8:	ba000006 	blt	102d8cf8 <ST7735_drawCircle+0xd0>
		{
			y--;
			ddF_y += 2;
102d8cdc:	e59d300c 	ldr	r3, [sp, #12]

	while (x<y)
	{
		if (f >= 0)
		{
			y--;
102d8ce0:	e59de008 	ldr	lr, [sp, #8]
			ddF_y += 2;
102d8ce4:	e2833002 	add	r3, r3, #2

	while (x<y)
	{
		if (f >= 0)
		{
			y--;
102d8ce8:	e24ee001 	sub	lr, lr, #1
			ddF_y += 2;
			f += ddF_y;
102d8cec:	e0888003 	add	r8, r8, r3
	while (x<y)
	{
		if (f >= 0)
		{
			y--;
			ddF_y += 2;
102d8cf0:	e58d300c 	str	r3, [sp, #12]

	while (x<y)
	{
		if (f >= 0)
		{
			y--;
102d8cf4:	e58de008 	str	lr, [sp, #8]
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		ST7735_drawPixel(x0 + x, y0 + y, color);
102d8cf8:	e59d3008 	ldr	r3, [sp, #8]
102d8cfc:	e58dc004 	str	ip, [sp, #4]
102d8d00:	e20370ff 	and	r7, r3, #255	; 0xff
102d8d04:	e087b00a 	add	fp, r7, sl
102d8d08:	e20bb0ff 	and	fp, fp, #255	; 0xff
102d8d0c:	e1a0100b 	mov	r1, fp
102d8d10:	ebfffdd6 	bl	102d8470 <ST7735_drawPixel>
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8d14:	e0663009 	rsb	r3, r6, r9
102d8d18:	e20330ff 	and	r3, r3, #255	; 0xff
		x++;
		ddF_x += 2;
		f += ddF_x;

		ST7735_drawPixel(x0 + x, y0 + y, color);
		ST7735_drawPixel(x0 - x, y0 + y, color);
102d8d1c:	e1a00003 	mov	r0, r3
102d8d20:	e1a0100b 	mov	r1, fp
102d8d24:	e1a02004 	mov	r2, r4
102d8d28:	e58d3000 	str	r3, [sp]
		ST7735_drawPixel(x0 + x, y0 - y, color);
102d8d2c:	e067b00a 	rsb	fp, r7, sl
		x++;
		ddF_x += 2;
		f += ddF_x;

		ST7735_drawPixel(x0 + x, y0 + y, color);
		ST7735_drawPixel(x0 - x, y0 + y, color);
102d8d30:	ebfffdce 	bl	102d8470 <ST7735_drawPixel>
		ST7735_drawPixel(x0 + x, y0 - y, color);
102d8d34:	e59dc004 	ldr	ip, [sp, #4]
102d8d38:	e20bb0ff 	and	fp, fp, #255	; 0xff
102d8d3c:	e1a0000c 	mov	r0, ip
102d8d40:	e1a0100b 	mov	r1, fp
102d8d44:	e1a02004 	mov	r2, r4
102d8d48:	ebfffdc8 	bl	102d8470 <ST7735_drawPixel>
		ST7735_drawPixel(x0 - x, y0 - y, color);
102d8d4c:	e59d3000 	ldr	r3, [sp]
102d8d50:	e1a0100b 	mov	r1, fp
102d8d54:	e1a00003 	mov	r0, r3
102d8d58:	e1a02004 	mov	r2, r4
102d8d5c:	ebfffdc3 	bl	102d8470 <ST7735_drawPixel>

		ST7735_drawPixel(x0 + y, y0 + x, color);
102d8d60:	e087b009 	add	fp, r7, r9
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8d64:	e08a3006 	add	r3, sl, r6
102d8d68:	e20330ff 	and	r3, r3, #255	; 0xff
		ST7735_drawPixel(x0 + x, y0 + y, color);
		ST7735_drawPixel(x0 - x, y0 + y, color);
		ST7735_drawPixel(x0 + x, y0 - y, color);
		ST7735_drawPixel(x0 - x, y0 - y, color);

		ST7735_drawPixel(x0 + y, y0 + x, color);
102d8d6c:	e20bb0ff 	and	fp, fp, #255	; 0xff
102d8d70:	e1a01003 	mov	r1, r3
102d8d74:	e1a0000b 	mov	r0, fp
102d8d78:	e1a02004 	mov	r2, r4
102d8d7c:	e58d3000 	str	r3, [sp]
		ST7735_drawPixel(x0 - y, y0 + x, color);
102d8d80:	e0677009 	rsb	r7, r7, r9
		ST7735_drawPixel(x0 + x, y0 + y, color);
		ST7735_drawPixel(x0 - x, y0 + y, color);
		ST7735_drawPixel(x0 + x, y0 - y, color);
		ST7735_drawPixel(x0 - x, y0 - y, color);

		ST7735_drawPixel(x0 + y, y0 + x, color);
102d8d84:	ebfffdb9 	bl	102d8470 <ST7735_drawPixel>
		ST7735_drawPixel(x0 - y, y0 + x, color);
102d8d88:	e59d3000 	ldr	r3, [sp]
102d8d8c:	e20770ff 	and	r7, r7, #255	; 0xff
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8d90:	e066600a 	rsb	r6, r6, sl
		ST7735_drawPixel(x0 - x, y0 + y, color);
		ST7735_drawPixel(x0 + x, y0 - y, color);
		ST7735_drawPixel(x0 - x, y0 - y, color);

		ST7735_drawPixel(x0 + y, y0 + x, color);
		ST7735_drawPixel(x0 - y, y0 + x, color);
102d8d94:	e1a01003 	mov	r1, r3
102d8d98:	e1a00007 	mov	r0, r7
102d8d9c:	e1a02004 	mov	r2, r4
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8da0:	e20660ff 	and	r6, r6, #255	; 0xff
		ST7735_drawPixel(x0 - x, y0 + y, color);
		ST7735_drawPixel(x0 + x, y0 - y, color);
		ST7735_drawPixel(x0 - x, y0 - y, color);

		ST7735_drawPixel(x0 + y, y0 + x, color);
		ST7735_drawPixel(x0 - y, y0 + x, color);
102d8da4:	ebfffdb1 	bl	102d8470 <ST7735_drawPixel>
		ST7735_drawPixel(x0 + y, y0 - x, color);
102d8da8:	e1a0000b 	mov	r0, fp
102d8dac:	e1a01006 	mov	r1, r6
102d8db0:	e1a02004 	mov	r2, r4
102d8db4:	ebfffdad 	bl	102d8470 <ST7735_drawPixel>
		ST7735_drawPixel(x0 - y, y0 - x, color);
102d8db8:	e1a00007 	mov	r0, r7
102d8dbc:	e1a01006 	mov	r1, r6
102d8dc0:	e1a02004 	mov	r2, r4
102d8dc4:	ebfffda9 	bl	102d8470 <ST7735_drawPixel>
	ST7735_drawPixel(x0, y0+r, color);
	ST7735_drawPixel(x0, y0-r, color);
	ST7735_drawPixel(x0+r, y0, color);
	ST7735_drawPixel(x0-r, y0, color);

	while (x<y)
102d8dc8:	e59dc008 	ldr	ip, [sp, #8]
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}

// draw a circle outline
void ST7735_drawCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d8dcc:	e0888085 	add	r8, r8, r5, lsl #1
	ST7735_drawPixel(x0, y0+r, color);
	ST7735_drawPixel(x0, y0-r, color);
	ST7735_drawPixel(x0+r, y0, color);
	ST7735_drawPixel(x0-r, y0, color);

	while (x<y)
102d8dd0:	e15c0005 	cmp	ip, r5
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;
102d8dd4:	e2888001 	add	r8, r8, #1
	ST7735_drawPixel(x0, y0+r, color);
	ST7735_drawPixel(x0, y0-r, color);
	ST7735_drawPixel(x0+r, y0, color);
	ST7735_drawPixel(x0-r, y0, color);

	while (x<y)
102d8dd8:	caffffb7 	bgt	102d8cbc <ST7735_drawCircle+0x94>
		ST7735_drawPixel(x0 - y, y0 + x, color);
		ST7735_drawPixel(x0 + y, y0 - x, color);
		ST7735_drawPixel(x0 - y, y0 - x, color);

	}
}
102d8ddc:	e28dd014 	add	sp, sp, #20
102d8de0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

102d8de4 <ST7735_getRotation>:

unsigned char ST7735_getRotation()
{
	return madctl;
102d8de4:	e59f3004 	ldr	r3, [pc, #4]	; 102d8df0 <ST7735_getRotation+0xc>
}
102d8de8:	e5d30000 	ldrb	r0, [r3]
102d8dec:	e12fff1e 	bx	lr
102d8df0:	f03de530 	.word	0xf03de530

102d8df4 <ST7735_setRotation>:

void ST7735_setRotation(unsigned char m)
{
102d8df4:	e92d4010 	push	{r4, lr}
	madctl = m;
102d8df8:	e59f4014 	ldr	r4, [pc, #20]	; 102d8e14 <ST7735_setRotation+0x20>
102d8dfc:	e5c40000 	strb	r0, [r4]
	writecommand(ST7735_MADCTL);  // memory access control (directions)
102d8e00:	e3a00036 	mov	r0, #54	; 0x36
102d8e04:	ebfffd47 	bl	102d8328 <writecommand>
	writedata(madctl);  // row address/col address, bottom to top refresh
102d8e08:	e5d40000 	ldrb	r0, [r4]
}
102d8e0c:	e8bd4010 	pop	{r4, lr}

void ST7735_setRotation(unsigned char m)
{
	madctl = m;
	writecommand(ST7735_MADCTL);  // memory access control (directions)
	writedata(madctl);  // row address/col address, bottom to top refresh
102d8e10:	eafffd55 	b	102d836c <writedata>
102d8e14:	f03de530 	.word	0xf03de530

102d8e18 <ST7735_fillScreen>:

	// LCD_CS = 1;
}

void ST7735_fillScreen(unsigned int color)
{
102d8e18:	e92d4070 	push	{r4, r5, r6, lr}
102d8e1c:	e1a05000 	mov	r5, r0
	unsigned char x;
	unsigned char y;

	ST7735_setRotation(0xC0); // Start point Right - top
102d8e20:	e3a000c0 	mov	r0, #192	; 0xc0
102d8e24:	ebfffff2 	bl	102d8df4 <ST7735_setRotation>

	setAddrWindow(0, 0, SCREEN_WIDTH-1, SCREEN_HEIGHT-1);
102d8e28:	e3a00000 	mov	r0, #0
102d8e2c:	e1a01000 	mov	r1, r0
102d8e30:	e3a0207f 	mov	r2, #127	; 0x7f
102d8e34:	e3a0309f 	mov	r3, #159	; 0x9f
102d8e38:	ebfffd6f 	bl	102d83fc <setAddrWindow>
102d8e3c:	e3a06080 	mov	r6, #128	; 0x80

	// LCD_CS = 1;
}

void ST7735_fillScreen(unsigned int color)
{
102d8e40:	e3a040a0 	mov	r4, #160	; 0xa0

	for (x=0; x < SCREEN_WIDTH; x++)
	{
		for (y=0; y < SCREEN_HEIGHT; y++)
		{
			writedata_16bit(color);
102d8e44:	e1a00005 	mov	r0, r5
102d8e48:	ebfffd58 	bl	102d83b0 <writedata_16bit>
102d8e4c:	e2443001 	sub	r3, r4, #1

	// setup for data

	for (x=0; x < SCREEN_WIDTH; x++)
	{
		for (y=0; y < SCREEN_HEIGHT; y++)
102d8e50:	e21340ff 	ands	r4, r3, #255	; 0xff
102d8e54:	1afffffa 	bne	102d8e44 <ST7735_fillScreen+0x2c>

	setAddrWindow(0, 0, SCREEN_WIDTH-1, SCREEN_HEIGHT-1);

	// setup for data

	for (x=0; x < SCREEN_WIDTH; x++)
102d8e58:	e2566001 	subs	r6, r6, #1
102d8e5c:	1afffff7 	bne	102d8e40 <ST7735_fillScreen+0x28>
102d8e60:	e8bd8070 	pop	{r4, r5, r6, pc}

102d8e64 <ST7735_fillRect>:
	ST7735_drawVerticalLine(x, y, h, color);
	ST7735_drawVerticalLine(x+w-1, y, h, color);
}

void ST7735_fillRect(unsigned char x, unsigned char y, unsigned char w, unsigned char h,unsigned int color)
{
102d8e64:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102d8e68:	e1a08002 	mov	r8, r2
102d8e6c:	e1a05003 	mov	r5, r3
	// smarter version

	setAddrWindow(x, y, x+w-1, y+h-1);
102d8e70:	e2402001 	sub	r2, r0, #1
102d8e74:	e2413001 	sub	r3, r1, #1
102d8e78:	e0882002 	add	r2, r8, r2
102d8e7c:	e0853003 	add	r3, r5, r3
102d8e80:	e20220ff 	and	r2, r2, #255	; 0xff
102d8e84:	e20330ff 	and	r3, r3, #255	; 0xff
	ST7735_drawVerticalLine(x, y, h, color);
	ST7735_drawVerticalLine(x+w-1, y, h, color);
}

void ST7735_fillRect(unsigned char x, unsigned char y, unsigned char w, unsigned char h,unsigned int color)
{
102d8e88:	e59d6018 	ldr	r6, [sp, #24]
	// smarter version

	setAddrWindow(x, y, x+w-1, y+h-1);
102d8e8c:	ebfffd5a 	bl	102d83fc <setAddrWindow>

	// setup for data
	// LCD_RS = 1;
	// LCD_CS = 0;

	for (x=0; x < w; x++)
102d8e90:	e3580000 	cmp	r8, #0
102d8e94:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
102d8e98:	e3a07000 	mov	r7, #0
	{
		for (y=0; y < h; y++)
102d8e9c:	e3550000 	cmp	r5, #0
102d8ea0:	0a000006 	beq	102d8ec0 <ST7735_fillRect+0x5c>
102d8ea4:	e3a04000 	mov	r4, #0
102d8ea8:	e2844001 	add	r4, r4, #1
		{
			// write_spi_byte(colorB);
			// write_spi_byte(color);
			// writedata(colorB);
			writedata_16bit(color);
102d8eac:	e1a00006 	mov	r0, r6
	// LCD_RS = 1;
	// LCD_CS = 0;

	for (x=0; x < w; x++)
	{
		for (y=0; y < h; y++)
102d8eb0:	e20440ff 	and	r4, r4, #255	; 0xff
		{
			// write_spi_byte(colorB);
			// write_spi_byte(color);
			// writedata(colorB);
			writedata_16bit(color);
102d8eb4:	ebfffd3d 	bl	102d83b0 <writedata_16bit>
	// LCD_RS = 1;
	// LCD_CS = 0;

	for (x=0; x < w; x++)
	{
		for (y=0; y < h; y++)
102d8eb8:	e1540005 	cmp	r4, r5
102d8ebc:	1afffff9 	bne	102d8ea8 <ST7735_fillRect+0x44>

	// setup for data
	// LCD_RS = 1;
	// LCD_CS = 0;

	for (x=0; x < w; x++)
102d8ec0:	e2877001 	add	r7, r7, #1
102d8ec4:	e20770ff 	and	r7, r7, #255	; 0xff
102d8ec8:	e1570008 	cmp	r7, r8
102d8ecc:	1afffff2 	bne	102d8e9c <ST7735_fillRect+0x38>
102d8ed0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

102d8ed4 <ST7735_drawChar>:
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
{
102d8ed4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
102d8ed8:	e3520051 	cmp	r2, #81	; 0x51
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
{
102d8edc:	e24dd024 	sub	sp, sp, #36	; 0x24
102d8ee0:	e58d2010 	str	r2, [sp, #16]
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
102d8ee4:	859d2010 	ldrhi	r2, [sp, #16]
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
{
102d8ee8:	e1a0a003 	mov	sl, r3
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
102d8eec:	92423020 	subls	r3, r2, #32
102d8ef0:	82423052 	subhi	r3, r2, #82	; 0x52
			x = 0;
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
102d8ef4:	e59f20dc 	ldr	r2, [pc, #220]	; 102d8fd8 <ST7735_drawChar+0x104>
{
102d8ef8:	e58d0014 	str	r0, [sp, #20]
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
102d8efc:	e20330ff 	and	r3, r3, #255	; 0xff
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];
102d8f00:	e0833103 	add	r3, r3, r3, lsl #2
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
{
102d8f04:	e58d100c 	str	r1, [sp, #12]
102d8f08:	e5dd6048 	ldrb	r6, [sp, #72]	; 0x48
			x = 0;
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
102d8f0c:	e24210fc 	sub	r1, r2, #252	; 0xfc
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];
102d8f10:	e59d7014 	ldr	r7, [sp, #20]
			x = 0;
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
102d8f14:	e0822003 	add	r2, r2, r3
102d8f18:	e0811003 	add	r1, r1, r3
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];
102d8f1c:	e3a08000 	mov	r8, #0
			x = 0;
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
102d8f20:	e58d2018 	str	r2, [sp, #24]
102d8f24:	e58d101c 	str	r1, [sp, #28]
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];
102d8f28:	e59d3010 	ldr	r3, [sp, #16]
102d8f2c:	e3530051 	cmp	r3, #81	; 0x51
102d8f30:	8a000025 	bhi	102d8fcc <ST7735_drawChar+0xf8>
102d8f34:	e59d201c 	ldr	r2, [sp, #28]
102d8f38:	e7d25008 	ldrb	r5, [r2, r8]
			x = 0;
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
102d8f3c:	e59d3014 	ldr	r3, [sp, #20]
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];
102d8f40:	e59d900c 	ldr	r9, [sp, #12]
			x = 0;
		}
	}
}

void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
102d8f44:	e083b008 	add	fp, r3, r8
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];
102d8f48:	e3a04000 	mov	r4, #0
		for (j = 0; j<8; j++)
		{
			if (line & 0x1)
			{
				if (size == 1) // default size
					ST7735_drawPixel(x+i, y+j, color);
102d8f4c:	e20bb0ff 	and	fp, fp, #255	; 0xff
102d8f50:	ea000007 	b	102d8f74 <ST7735_drawChar+0xa0>
				else   // big size
					ST7735_fillRect(x+i*size, y+j*size, size, size, color);
102d8f54:	e58da000 	str	sl, [sp]
102d8f58:	ebffffc1 	bl	102d8e64 <ST7735_fillRect>
102d8f5c:	e2844001 	add	r4, r4, #1
102d8f60:	e0899006 	add	r9, r9, r6
	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];

		for (j = 0; j<8; j++)
102d8f64:	e3540008 	cmp	r4, #8
				if (size == 1) // default size
					ST7735_drawPixel(x+i, y+j, color);
				else   // big size
					ST7735_fillRect(x+i*size, y+j*size, size, size, color);
			}
			line >>= 1;
102d8f68:	e1a050a5 	lsr	r5, r5, #1
102d8f6c:	e20990ff 	and	r9, r9, #255	; 0xff
	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];

		for (j = 0; j<8; j++)
102d8f70:	0a00000e 	beq	102d8fb0 <ST7735_drawChar+0xdc>
		{
			if (line & 0x1)
102d8f74:	e3150001 	tst	r5, #1
102d8f78:	0afffff7 	beq	102d8f5c <ST7735_drawChar+0x88>
			{
				if (size == 1) // default size
102d8f7c:	e3560001 	cmp	r6, #1
					ST7735_drawPixel(x+i, y+j, color);
				else   // big size
					ST7735_fillRect(x+i*size, y+j*size, size, size, color);
102d8f80:	e1a01009 	mov	r1, r9
102d8f84:	e1a00007 	mov	r0, r7
102d8f88:	e1a02006 	mov	r2, r6
102d8f8c:	e1a03006 	mov	r3, r6

		for (j = 0; j<8; j++)
		{
			if (line & 0x1)
			{
				if (size == 1) // default size
102d8f90:	1affffef 	bne	102d8f54 <ST7735_drawChar+0x80>
					ST7735_drawPixel(x+i, y+j, color);
102d8f94:	e59d300c 	ldr	r3, [sp, #12]
102d8f98:	e1a0000b 	mov	r0, fp
102d8f9c:	e0831004 	add	r1, r3, r4
102d8fa0:	e20110ff 	and	r1, r1, #255	; 0xff
102d8fa4:	e1a0200a 	mov	r2, sl
102d8fa8:	ebfffd30 	bl	102d8470 <ST7735_drawPixel>
102d8fac:	eaffffea 	b	102d8f5c <ST7735_drawChar+0x88>
102d8fb0:	e2888001 	add	r8, r8, #1
102d8fb4:	e0877006 	add	r7, r7, r6
void ST7735_drawChar(unsigned char x, unsigned char y, char c, unsigned int color, unsigned char size)
{
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
102d8fb8:	e3580005 	cmp	r8, #5
102d8fbc:	e20770ff 	and	r7, r7, #255	; 0xff
102d8fc0:	1affffd8 	bne	102d8f28 <ST7735_drawChar+0x54>
					ST7735_fillRect(x+i*size, y+j*size, size, size, color);
			}
			line >>= 1;
		}
	}
}
102d8fc4:	e28dd024 	add	sp, sp, #36	; 0x24
102d8fc8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	unsigned char i, j;

	unsigned char letter = c < 0x52 ? c - 0x20 : c - 0x52;
	for (i =0; i<5; i++ )
	{
		unsigned char line = c < 0x52 ? Alpha1[letter*5+i] : Alpha2[letter*5+i];
102d8fcc:	e59d2018 	ldr	r2, [sp, #24]
102d8fd0:	e7d25008 	ldrb	r5, [r2, r8]
102d8fd4:	eaffffd8 	b	102d8f3c <ST7735_drawChar+0x68>
102d8fd8:	102e72dc 	.word	0x102e72dc

102d8fdc <ST7735_drawString>:
}



void ST7735_drawString(unsigned char x, unsigned char y, char *c, unsigned int color, unsigned char size)
{
102d8fdc:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
102d8fe0:	e24dd00c 	sub	sp, sp, #12
102d8fe4:	e5dd7028 	ldrb	r7, [sp, #40]	; 0x28
102d8fe8:	e1a04000 	mov	r4, r0
	while (c[0] != 0)
	{
		ST7735_drawChar(x, y, c[0], color, size);
		x += size*6;
102d8fec:	e087a087 	add	sl, r7, r7, lsl #1
102d8ff0:	e1a0a08a 	lsl	sl, sl, #1
}



void ST7735_drawString(unsigned char x, unsigned char y, char *c, unsigned int color, unsigned char size)
{
102d8ff4:	e1a05001 	mov	r5, r1
102d8ff8:	e1a08003 	mov	r8, r3
	while (c[0] != 0)
	{
		ST7735_drawChar(x, y, c[0], color, size);
		x += size*6;
102d8ffc:	e20aa0ff 	and	sl, sl, #255	; 0xff
	}
}



void ST7735_drawString(unsigned char x, unsigned char y, char *c, unsigned int color, unsigned char size)
102d9000:	e2426001 	sub	r6, r2, #1
{
	while (c[0] != 0)
102d9004:	ea000007 	b	102d9028 <ST7735_drawString+0x4c>
	{
		ST7735_drawChar(x, y, c[0], color, size);
		x += size*6;
102d9008:	e084400a 	add	r4, r4, sl
102d900c:	e20440ff 	and	r4, r4, #255	; 0xff

void ST7735_drawString(unsigned char x, unsigned char y, char *c, unsigned int color, unsigned char size)
{
	while (c[0] != 0)
	{
		ST7735_drawChar(x, y, c[0], color, size);
102d9010:	e58d7000 	str	r7, [sp]
102d9014:	ebffffae 	bl	102d8ed4 <ST7735_drawChar>
		x += size*6;
		c++;
		// if (x + 5 >= SCREEN_WIDTH) //Text display is aligned to shorter side of the screen
		if (x + 5 >= SCREEN_HEIGHT) // Text display is aligned to longer side of the screen
102d9018:	e354009a 	cmp	r4, #154	; 0x9a
		{
			y += 10;
102d901c:	e285300a 	add	r3, r5, #10
102d9020:	c20350ff 	andgt	r5, r3, #255	; 0xff
			x = 0;
102d9024:	c3a04000 	movgt	r4, #0



void ST7735_drawString(unsigned char x, unsigned char y, char *c, unsigned int color, unsigned char size)
{
	while (c[0] != 0)
102d9028:	e5f6c001 	ldrb	ip, [r6, #1]!
	{
		ST7735_drawChar(x, y, c[0], color, size);
102d902c:	e1a00004 	mov	r0, r4



void ST7735_drawString(unsigned char x, unsigned char y, char *c, unsigned int color, unsigned char size)
{
	while (c[0] != 0)
102d9030:	e25c2000 	subs	r2, ip, #0
	{
		ST7735_drawChar(x, y, c[0], color, size);
102d9034:	e1a01005 	mov	r1, r5
102d9038:	e1a03008 	mov	r3, r8



void ST7735_drawString(unsigned char x, unsigned char y, char *c, unsigned int color, unsigned char size)
{
	while (c[0] != 0)
102d903c:	1afffff1 	bne	102d9008 <ST7735_drawString+0x2c>
		{
			y += 10;
			x = 0;
		}
	}
}
102d9040:	e28dd00c 	add	sp, sp, #12
102d9044:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}

102d9048 <ST7735_drawString_align_Center>:
	// LCD_CS = 1;

}

void ST7735_drawString_align_Center(unsigned char y, char *c, unsigned int color, unsigned char size)
{
102d9048:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
102d904c:	e1a07003 	mov	r7, r3
102d9050:	e24dd00c 	sub	sp, sp, #12
102d9054:	e1a05000 	mov	r5, r0
	unsigned char string_length;
	unsigned char x;
	unsigned char pixel_strength;
	string_length = strlen(c); // number of letters in the string
102d9058:	e59f3088 	ldr	r3, [pc, #136]	; 102d90e8 <ST7735_drawString_align_Center+0xa0>
102d905c:	e1a00001 	mov	r0, r1
	// LCD_CS = 1;

}

void ST7735_drawString_align_Center(unsigned char y, char *c, unsigned int color, unsigned char size)
{
102d9060:	e1a06001 	mov	r6, r1
102d9064:	e1a08002 	mov	r8, r2
	unsigned char string_length;
	unsigned char x;
	unsigned char pixel_strength;
	string_length = strlen(c); // number of letters in the string
102d9068:	e12fff33 	blx	r3
	x = (160 - pixel_strength)/2;

	while (c[0] != 0)
	{
		ST7735_drawChar(x, y, c[0], color, size);
		x += size*6;
102d906c:	e087a087 	add	sl, r7, r7, lsl #1
102d9070:	e1a0a08a 	lsl	sl, sl, #1
102d9074:	e20aa0ff 	and	sl, sl, #255	; 0xff

	// LCD_CS = 1;

}

void ST7735_drawString_align_Center(unsigned char y, char *c, unsigned int color, unsigned char size)
102d9078:	e2466001 	sub	r6, r6, #1
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102d907c:	e20040ff 	and	r4, r0, #255	; 0xff
	unsigned char string_length;
	unsigned char x;
	unsigned char pixel_strength;
	string_length = strlen(c); // number of letters in the string

	pixel_strength = (string_length * (size * 5))+ ((string_length -1) * size); // number of pixel in width direction of the string
102d9080:	e2444001 	sub	r4, r4, #1
102d9084:	e0800100 	add	r0, r0, r0, lsl #2
102d9088:	e0844000 	add	r4, r4, r0

	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;
102d908c:	e0040497 	mul	r4, r7, r4
102d9090:	e20440ff 	and	r4, r4, #255	; 0xff
102d9094:	e26440a0 	rsb	r4, r4, #160	; 0xa0
102d9098:	e0844fa4 	add	r4, r4, r4, lsr #31
102d909c:	e1a040c4 	asr	r4, r4, #1
102d90a0:	e20440ff 	and	r4, r4, #255	; 0xff

	while (c[0] != 0)
102d90a4:	ea000007 	b	102d90c8 <ST7735_drawString_align_Center+0x80>
	{
		ST7735_drawChar(x, y, c[0], color, size);
		x += size*6;
102d90a8:	e084400a 	add	r4, r4, sl
102d90ac:	e20440ff 	and	r4, r4, #255	; 0xff
	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;

	while (c[0] != 0)
	{
		ST7735_drawChar(x, y, c[0], color, size);
102d90b0:	e58d7000 	str	r7, [sp]
102d90b4:	ebffff86 	bl	102d8ed4 <ST7735_drawChar>
		x += size*6;
		c++;
		// if (x + 5 >= SCREEN_WIDTH) //Text display is aligned to shorter side of the screen
		if (x + 5 >= SCREEN_HEIGHT) // Text display is aligned to longer side of the screen
102d90b8:	e354009a 	cmp	r4, #154	; 0x9a
		{
			y += 10;
102d90bc:	e285300a 	add	r3, r5, #10
102d90c0:	c20350ff 	andgt	r5, r3, #255	; 0xff
			x = 0;
102d90c4:	c3a04000 	movgt	r4, #0
	pixel_strength = (string_length * (size * 5))+ ((string_length -1) * size); // number of pixel in width direction of the string

	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;

	while (c[0] != 0)
102d90c8:	e5f6c001 	ldrb	ip, [r6, #1]!
	{
		ST7735_drawChar(x, y, c[0], color, size);
102d90cc:	e1a00004 	mov	r0, r4
	pixel_strength = (string_length * (size * 5))+ ((string_length -1) * size); // number of pixel in width direction of the string

	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;

	while (c[0] != 0)
102d90d0:	e25c2000 	subs	r2, ip, #0
	{
		ST7735_drawChar(x, y, c[0], color, size);
102d90d4:	e1a01005 	mov	r1, r5
102d90d8:	e1a03008 	mov	r3, r8
	pixel_strength = (string_length * (size * 5))+ ((string_length -1) * size); // number of pixel in width direction of the string

	// Find out the start position of string in x direction to align the string in Center
	x = (160 - pixel_strength)/2;

	while (c[0] != 0)
102d90dc:	1afffff1 	bne	102d90a8 <ST7735_drawString_align_Center+0x60>
		{
			y += 10;
			x = 0;
		}
	}
}
102d90e0:	e28dd00c 	add	sp, sp, #12
102d90e4:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
102d90e8:	102dff65 	.word	0x102dff65

102d90ec <ST7735_drawFastLine>:
	}
	// LCD_CS = 1;
}

void ST7735_drawFastLine(unsigned char x, unsigned char y, unsigned char length,unsigned int color, unsigned char rotflag)
{
102d90ec:	e92d4038 	push	{r3, r4, r5, lr}
	if (rotflag)
102d90f0:	e5ddc010 	ldrb	ip, [sp, #16]
	}
	// LCD_CS = 1;
}

void ST7735_drawFastLine(unsigned char x, unsigned char y, unsigned char length,unsigned int color, unsigned char rotflag)
{
102d90f4:	e1a04002 	mov	r4, r2
	if (rotflag)
102d90f8:	e35c0000 	cmp	ip, #0
	}
	// LCD_CS = 1;
}

void ST7735_drawFastLine(unsigned char x, unsigned char y, unsigned char length,unsigned int color, unsigned char rotflag)
{
102d90fc:	e1a05003 	mov	r5, r3
	if (rotflag)
	{
		setAddrWindow(x, y, x, y+length-1);
102d9100:	12413001 	subne	r3, r1, #1
102d9104:	10823003 	addne	r3, r2, r3
	}
	else
	{
		setAddrWindow(x, y, x+length, y-1);
102d9108:	00842000 	addeq	r2, r4, r0
102d910c:	02413001 	subeq	r3, r1, #1

void ST7735_drawFastLine(unsigned char x, unsigned char y, unsigned char length,unsigned int color, unsigned char rotflag)
{
	if (rotflag)
	{
		setAddrWindow(x, y, x, y+length-1);
102d9110:	11a02000 	movne	r2, r0
	}
	else
	{
		setAddrWindow(x, y, x+length, y-1);
102d9114:	020220ff 	andeq	r2, r2, #255	; 0xff
102d9118:	e20330ff 	and	r3, r3, #255	; 0xff
102d911c:	ebfffcb6 	bl	102d83fc <setAddrWindow>
	}
	// setup for data
	// LCD_RS = 1;
	// LCD_CS = 0;

	while (length--)
102d9120:	e3540000 	cmp	r4, #0
102d9124:	08bd8038 	popeq	{r3, r4, r5, pc}
	{
		// write_spi_byte(colorB);
		// write_spi_byte(color);
		// writedata(colorB);
		writedata_16bit(color);
102d9128:	e1a00005 	mov	r0, r5
102d912c:	ebfffc9f 	bl	102d83b0 <writedata_16bit>
102d9130:	e2442001 	sub	r2, r4, #1
	}
	// setup for data
	// LCD_RS = 1;
	// LCD_CS = 0;

	while (length--)
102d9134:	e21240ff 	ands	r4, r2, #255	; 0xff
102d9138:	1afffffa 	bne	102d9128 <ST7735_drawFastLine+0x3c>
102d913c:	e8bd8038 	pop	{r3, r4, r5, pc}

102d9140 <ST7735_drawVerticalLine>:
	// LCD_CS = 1;
}

void ST7735_drawVerticalLine(unsigned char x, unsigned char y, unsigned char length, unsigned int color)
{
	if (x >= SCREEN_WIDTH)
102d9140:	e3100080 	tst	r0, #128	; 0x80
	}
	// LCD_CS = 1;
}

void ST7735_drawVerticalLine(unsigned char x, unsigned char y, unsigned char length, unsigned int color)
{
102d9144:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102d9148:	e24dd00c 	sub	sp, sp, #12
	if (x >= SCREEN_WIDTH)
102d914c:	1a000007 	bne	102d9170 <ST7735_drawVerticalLine+0x30>
		return;
	if (y+length >= SCREEN_HEIGHT)
102d9150:	e081c002 	add	ip, r1, r2
102d9154:	e35c009f 	cmp	ip, #159	; 0x9f
		length = SCREEN_HEIGHT-y-1;
102d9158:	c3e02060 	mvngt	r2, #96	; 0x60
102d915c:	c0612002 	rsbgt	r2, r1, r2

	ST7735_drawFastLine(x,y,length,color,1);
102d9160:	e3a0c001 	mov	ip, #1
void ST7735_drawVerticalLine(unsigned char x, unsigned char y, unsigned char length, unsigned int color)
{
	if (x >= SCREEN_WIDTH)
		return;
	if (y+length >= SCREEN_HEIGHT)
		length = SCREEN_HEIGHT-y-1;
102d9164:	c20220ff 	andgt	r2, r2, #255	; 0xff

	ST7735_drawFastLine(x,y,length,color,1);
102d9168:	e58dc000 	str	ip, [sp]
102d916c:	ebffffde 	bl	102d90ec <ST7735_drawFastLine>
}
102d9170:	e28dd00c 	add	sp, sp, #12
102d9174:	e8bd8000 	ldmfd	sp!, {pc}

102d9178 <ST7735_fillCircle>:
	ST7735_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
	ST7735_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d9178:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int f = 1 - r;
102d917c:	e1a04002 	mov	r4, r2
	ST7735_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
	ST7735_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d9180:	e24dd014 	sub	sp, sp, #20
	int ddF_x = 1;
	int ddF_y = -2 * r;
	int x = 0;
	int y = r;

	ST7735_drawVerticalLine(x0, y0-r, 2*r+1, color);
102d9184:	e1a02082 	lsl	r2, r2, #1
	ST7735_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
	ST7735_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d9188:	e58d100c 	str	r1, [sp, #12]
	int ddF_x = 1;
	int ddF_y = -2 * r;
	int x = 0;
	int y = r;

	ST7735_drawVerticalLine(x0, y0-r, 2*r+1, color);
102d918c:	e2822001 	add	r2, r2, #1
102d9190:	e0641001 	rsb	r1, r4, r1
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
	int f = 1 - r;
	int ddF_x = 1;
	int ddF_y = -2 * r;
102d9194:	e064cf84 	rsb	ip, r4, r4, lsl #31
102d9198:	e1a0c08c 	lsl	ip, ip, #1
	int x = 0;
	int y = r;

	ST7735_drawVerticalLine(x0, y0-r, 2*r+1, color);
102d919c:	e20110ff 	and	r1, r1, #255	; 0xff
102d91a0:	e20220ff 	and	r2, r2, #255	; 0xff
	ST7735_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
	ST7735_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d91a4:	e1a08000 	mov	r8, r0
102d91a8:	e1a0a003 	mov	sl, r3
	int f = 1 - r;
	int ddF_x = 1;
	int ddF_y = -2 * r;
102d91ac:	e58dc008 	str	ip, [sp, #8]
	int x = 0;
	int y = r;

	ST7735_drawVerticalLine(x0, y0-r, 2*r+1, color);
102d91b0:	ebffffe2 	bl	102d9140 <ST7735_drawVerticalLine>

	while (x<y)
102d91b4:	e3540000 	cmp	r4, #0
	ST7735_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
	int f = 1 - r;
102d91b8:	e2647001 	rsb	r7, r4, #1
	int x = 0;
	int y = r;

	ST7735_drawVerticalLine(x0, y0-r, 2*r+1, color);

	while (x<y)
102d91bc:	0a000033 	beq	102d9290 <ST7735_fillCircle+0x118>
102d91c0:	e3a05000 	mov	r5, #0
	{
		if (f >= 0)
102d91c4:	e3570000 	cmp	r7, #0
		{
			y--;
			ddF_y += 2;
102d91c8:	a59dc008 	ldrge	ip, [sp, #8]

	while (x<y)
	{
		if (f >= 0)
		{
			y--;
102d91cc:	a2444001 	subge	r4, r4, #1
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1, color);
102d91d0:	e59d200c 	ldr	r2, [sp, #12]
	while (x<y)
	{
		if (f >= 0)
		{
			y--;
			ddF_y += 2;
102d91d4:	a28cc002 	addge	ip, ip, #2
			f += ddF_y;
		}
		x++;
102d91d8:	e2855001 	add	r5, r5, #1
		ddF_x += 2;
		f += ddF_x;

		ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1, color);
102d91dc:	e20490ff 	and	r9, r4, #255	; 0xff
102d91e0:	e1a0b084 	lsl	fp, r4, #1
	{
		if (f >= 0)
		{
			y--;
			ddF_y += 2;
			f += ddF_y;
102d91e4:	a087700c 	addge	r7, r7, ip
	while (x<y)
	{
		if (f >= 0)
		{
			y--;
			ddF_y += 2;
102d91e8:	a58dc008 	strge	ip, [sp, #8]
	ST7735_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
	ST7735_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d91ec:	e20560ff 	and	r6, r5, #255	; 0xff
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1, color);
102d91f0:	e069c002 	rsb	ip, r9, r2
102d91f4:	e28bb001 	add	fp, fp, #1
102d91f8:	e20cc0ff 	and	ip, ip, #255	; 0xff
102d91fc:	e20bb0ff 	and	fp, fp, #255	; 0xff
102d9200:	e0880006 	add	r0, r8, r6
102d9204:	e1a0100c 	mov	r1, ip
102d9208:	e1a0200b 	mov	r2, fp
102d920c:	e20000ff 	and	r0, r0, #255	; 0xff
102d9210:	e1a0300a 	mov	r3, sl
102d9214:	e58dc004 	str	ip, [sp, #4]
102d9218:	ebffffc8 	bl	102d9140 <ST7735_drawVerticalLine>
		ST7735_drawVerticalLine(x0-x, y0-y, 2*y+1, color);
102d921c:	e59dc004 	ldr	ip, [sp, #4]
102d9220:	e0660008 	rsb	r0, r6, r8
102d9224:	e1a0100c 	mov	r1, ip
102d9228:	e1a0200b 	mov	r2, fp
102d922c:	e20000ff 	and	r0, r0, #255	; 0xff
102d9230:	e1a0300a 	mov	r3, sl
102d9234:	ebffffc1 	bl	102d9140 <ST7735_drawVerticalLine>
	ST7735_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
	ST7735_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d9238:	e59dc00c 	ldr	ip, [sp, #12]
102d923c:	e1a0b086 	lsl	fp, r6, #1
102d9240:	e28bb001 	add	fp, fp, #1
102d9244:	e066600c 	rsb	r6, r6, ip
102d9248:	e20660ff 	and	r6, r6, #255	; 0xff
102d924c:	e20bb0ff 	and	fp, fp, #255	; 0xff
		ddF_x += 2;
		f += ddF_x;

		ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1, color);
		ST7735_drawVerticalLine(x0-x, y0-y, 2*y+1, color);
		ST7735_drawVerticalLine(x0+y, y0-x, 2*x+1, color);
102d9250:	e0890008 	add	r0, r9, r8
102d9254:	e20000ff 	and	r0, r0, #255	; 0xff
102d9258:	e1a01006 	mov	r1, r6
102d925c:	e1a0200b 	mov	r2, fp
102d9260:	e1a0300a 	mov	r3, sl
102d9264:	ebffffb5 	bl	102d9140 <ST7735_drawVerticalLine>
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
102d9268:	e0690008 	rsb	r0, r9, r8
102d926c:	e20000ff 	and	r0, r0, #255	; 0xff
102d9270:	e1a01006 	mov	r1, r6
102d9274:	e1a0200b 	mov	r2, fp
102d9278:	e1a0300a 	mov	r3, sl
	ST7735_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
	ST7735_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}
 */
// fill a circle
void ST7735_fillCircle(unsigned char x0, unsigned char y0, unsigned char r, unsigned int color) {
102d927c:	e0877085 	add	r7, r7, r5, lsl #1
		f += ddF_x;

		ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1, color);
		ST7735_drawVerticalLine(x0-x, y0-y, 2*y+1, color);
		ST7735_drawVerticalLine(x0+y, y0-x, 2*x+1, color);
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
102d9280:	ebffffae 	bl	102d9140 <ST7735_drawVerticalLine>
	int x = 0;
	int y = r;

	ST7735_drawVerticalLine(x0, y0-r, 2*r+1, color);

	while (x<y)
102d9284:	e1540005 	cmp	r4, r5
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;
102d9288:	e2877001 	add	r7, r7, #1
	int x = 0;
	int y = r;

	ST7735_drawVerticalLine(x0, y0-r, 2*r+1, color);

	while (x<y)
102d928c:	caffffcc 	bgt	102d91c4 <ST7735_fillCircle+0x4c>
		ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1, color);
		ST7735_drawVerticalLine(x0-x, y0-y, 2*y+1, color);
		ST7735_drawVerticalLine(x0+y, y0-x, 2*x+1, color);
		ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1, color);
	}
}
102d9290:	e28dd014 	add	sp, sp, #20
102d9294:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

102d9298 <ST7735_fillCircleHelper>:
			ST7735_drawPixel(x0 - x, y0 - y, color);
		}
	}
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
{
102d9298:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
102d929c:	e3520000 	cmp	r2, #0
	}
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
102d92a0:	e0628f82 	rsb	r8, r2, r2, lsl #31
			ST7735_drawPixel(x0 - x, y0 - y, color);
		}
	}
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
{
102d92a4:	e24dd014 	sub	sp, sp, #20
102d92a8:	e1a0a000 	mov	sl, r0
102d92ac:	e1a09001 	mov	r9, r1
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
102d92b0:	e2624001 	rsb	r4, r2, #1
102d92b4:	e1a08088 	lsl	r8, r8, #1
	while (x<y)
102d92b8:	da00004a 	ble	102d93e8 <ST7735_fillCircleHelper+0x150>
102d92bc:	e2031002 	and	r1, r3, #2
102d92c0:	e2033001 	and	r3, r3, #1
102d92c4:	e58d3008 	str	r3, [sp, #8]
		ddF_x += 2;
		f += ddF_x;

		if (cornername & 0x1)
		{
			ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1+delta, color);
102d92c8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
	}
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
102d92cc:	e3a06001 	mov	r6, #1
		ddF_x += 2;
		f += ddF_x;

		if (cornername & 0x1)
		{
			ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1+delta, color);
102d92d0:	e0833006 	add	r3, r3, r6
102d92d4:	e58d1004 	str	r1, [sp, #4]
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
102d92d8:	e1a05002 	mov	r5, r2
	}
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
102d92dc:	e3a07000 	mov	r7, #0
		ddF_x += 2;
		f += ddF_x;

		if (cornername & 0x1)
		{
			ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1+delta, color);
102d92e0:	e58d300c 	str	r3, [sp, #12]
102d92e4:	ea000004 	b	102d92fc <ST7735_fillCircleHelper+0x64>
			ST7735_drawVerticalLine(x0+y, y0-x, 2*x+1+delta, color);
		}
		if (cornername & 0x2)
102d92e8:	e59d1004 	ldr	r1, [sp, #4]
102d92ec:	e3510000 	cmp	r1, #0
102d92f0:	1a000024 	bne	102d9388 <ST7735_fillCircleHelper+0xf0>
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
102d92f4:	e1550007 	cmp	r5, r7
102d92f8:	da00003a 	ble	102d93e8 <ST7735_fillCircleHelper+0x150>
	{
		if (f >= 0)
102d92fc:	e3540000 	cmp	r4, #0
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		if (cornername & 0x1)
102d9300:	e59d1008 	ldr	r1, [sp, #8]
	while (x<y)
	{
		if (f >= 0)
		{
			y--;
			ddF_y += 2;
102d9304:	a2888002 	addge	r8, r8, #2
			f += ddF_y;
102d9308:	a0844008 	addge	r4, r4, r8
		}
		x++;
		ddF_x += 2;
102d930c:	e2866002 	add	r6, r6, #2
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
	{
		if (f >= 0)
		{
			y--;
102d9310:	a2455001 	subge	r5, r5, #1
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		if (cornername & 0x1)
102d9314:	e3510000 	cmp	r1, #0
		{
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
102d9318:	e2877001 	add	r7, r7, #1
		ddF_x += 2;
		f += ddF_x;
102d931c:	e0844006 	add	r4, r4, r6

		if (cornername & 0x1)
102d9320:	0afffff0 	beq	102d92e8 <ST7735_fillCircleHelper+0x50>
		{
			ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1+delta, color);
102d9324:	e59d300c 	ldr	r3, [sp, #12]
102d9328:	e205c0ff 	and	ip, r5, #255	; 0xff
			ST7735_drawPixel(x0 - y, y0 - x, color);
			ST7735_drawPixel(x0 - x, y0 - y, color);
		}
	}
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
102d932c:	e207b0ff 	and	fp, r7, #255	; 0xff
		ddF_x += 2;
		f += ddF_x;

		if (cornername & 0x1)
		{
			ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1+delta, color);
102d9330:	e06c1009 	rsb	r1, ip, r9
102d9334:	e0832085 	add	r2, r3, r5, lsl #1
102d9338:	e08b000a 	add	r0, fp, sl
102d933c:	e20000ff 	and	r0, r0, #255	; 0xff
102d9340:	e20110ff 	and	r1, r1, #255	; 0xff
102d9344:	e20220ff 	and	r2, r2, #255	; 0xff
102d9348:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
102d934c:	e58dc000 	str	ip, [sp]
102d9350:	ebffff7a 	bl	102d9140 <ST7735_drawVerticalLine>
			ST7735_drawVerticalLine(x0+y, y0-x, 2*x+1+delta, color);
102d9354:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
102d9358:	e59dc000 	ldr	ip, [sp]
102d935c:	e0832006 	add	r2, r3, r6
102d9360:	e08c000a 	add	r0, ip, sl
102d9364:	e06b1009 	rsb	r1, fp, r9
102d9368:	e20110ff 	and	r1, r1, #255	; 0xff
102d936c:	e20000ff 	and	r0, r0, #255	; 0xff
102d9370:	e20220ff 	and	r2, r2, #255	; 0xff
102d9374:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
102d9378:	ebffff70 	bl	102d9140 <ST7735_drawVerticalLine>
		}
		if (cornername & 0x2)
102d937c:	e59d1004 	ldr	r1, [sp, #4]
102d9380:	e3510000 	cmp	r1, #0
102d9384:	0affffda 	beq	102d92f4 <ST7735_fillCircleHelper+0x5c>
		{
			ST7735_drawVerticalLine(x0-x, y0-y, 2*y+1+delta, color);
102d9388:	e59d300c 	ldr	r3, [sp, #12]
102d938c:	e205c0ff 	and	ip, r5, #255	; 0xff
			ST7735_drawPixel(x0 - y, y0 - x, color);
			ST7735_drawPixel(x0 - x, y0 - y, color);
		}
	}
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
102d9390:	e207b0ff 	and	fp, r7, #255	; 0xff
			ST7735_drawVerticalLine(x0+x, y0-y, 2*y+1+delta, color);
			ST7735_drawVerticalLine(x0+y, y0-x, 2*x+1+delta, color);
		}
		if (cornername & 0x2)
		{
			ST7735_drawVerticalLine(x0-x, y0-y, 2*y+1+delta, color);
102d9394:	e06c1009 	rsb	r1, ip, r9
102d9398:	e0832085 	add	r2, r3, r5, lsl #1
102d939c:	e06b000a 	rsb	r0, fp, sl
102d93a0:	e20000ff 	and	r0, r0, #255	; 0xff
102d93a4:	e20110ff 	and	r1, r1, #255	; 0xff
102d93a8:	e20220ff 	and	r2, r2, #255	; 0xff
102d93ac:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
102d93b0:	e58dc000 	str	ip, [sp]
102d93b4:	ebffff61 	bl	102d9140 <ST7735_drawVerticalLine>
			ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1+delta, color);
102d93b8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
102d93bc:	e59dc000 	ldr	ip, [sp]
102d93c0:	e0832006 	add	r2, r3, r6
102d93c4:	e06c000a 	rsb	r0, ip, sl
102d93c8:	e06b1009 	rsb	r1, fp, r9
102d93cc:	e20000ff 	and	r0, r0, #255	; 0xff
102d93d0:	e20110ff 	and	r1, r1, #255	; 0xff
102d93d4:	e20220ff 	and	r2, r2, #255	; 0xff
102d93d8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
102d93dc:	ebffff57 	bl	102d9140 <ST7735_drawVerticalLine>
}
void ST7735_fillCircleHelper(signed int x0, signed int y0, signed int r, unsigned char cornername, signed int delta, unsigned int color)
{
	signed int f, ddF_x, ddF_y, x, y;
	f = 1 - r, ddF_x = 1, ddF_y = -2 * r, x = 0, y = r;
	while (x<y)
102d93e0:	e1550007 	cmp	r5, r7
102d93e4:	caffffc4 	bgt	102d92fc <ST7735_fillCircleHelper+0x64>
		{
			ST7735_drawVerticalLine(x0-x, y0-y, 2*y+1+delta, color);
			ST7735_drawVerticalLine(x0-y, y0-x, 2*x+1+delta, color);
		}
	}
}
102d93e8:	e28dd014 	add	sp, sp, #20
102d93ec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

102d93f0 <ST7735_drawHorizontalLine>:
	ST7735_drawFastLine(x,y,length,color,1);
}

void ST7735_drawHorizontalLine(unsigned char x, unsigned char y, unsigned char length, unsigned int color)
{
	if (y >= SCREEN_HEIGHT)
102d93f0:	e351009f 	cmp	r1, #159	; 0x9f

	ST7735_drawFastLine(x,y,length,color,1);
}

void ST7735_drawHorizontalLine(unsigned char x, unsigned char y, unsigned char length, unsigned int color)
{
102d93f4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102d93f8:	e24dd00c 	sub	sp, sp, #12
	if (y >= SCREEN_HEIGHT)
102d93fc:	8a000006 	bhi	102d941c <ST7735_drawHorizontalLine+0x2c>
		return;
	if (x+length >= SCREEN_WIDTH)
102d9400:	e080c002 	add	ip, r0, r2
102d9404:	e35c007f 	cmp	ip, #127	; 0x7f
		length = SCREEN_WIDTH-x-1;
102d9408:	c260207f 	rsbgt	r2, r0, #127	; 0x7f

	ST7735_drawFastLine(x,y,length,color,0);
102d940c:	e3a0c000 	mov	ip, #0
void ST7735_drawHorizontalLine(unsigned char x, unsigned char y, unsigned char length, unsigned int color)
{
	if (y >= SCREEN_HEIGHT)
		return;
	if (x+length >= SCREEN_WIDTH)
		length = SCREEN_WIDTH-x-1;
102d9410:	c20220ff 	andgt	r2, r2, #255	; 0xff

	ST7735_drawFastLine(x,y,length,color,0);
102d9414:	e58dc000 	str	ip, [sp]
102d9418:	ebffff33 	bl	102d90ec <ST7735_drawFastLine>
}
102d941c:	e28dd00c 	add	sp, sp, #12
102d9420:	e8bd8000 	ldmfd	sp!, {pc}

102d9424 <ST7735_drawRect>:
	writedata(madctl);  // row address/col address, bottom to top refresh
}

// draw a rectangle
void ST7735_drawRect(unsigned char x, unsigned char y, unsigned char w, unsigned char h,unsigned int color)
{
102d9424:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102d9428:	e59d4018 	ldr	r4, [sp, #24]
102d942c:	e1a06001 	mov	r6, r1
102d9430:	e1a05003 	mov	r5, r3
	// smarter version
	ST7735_drawHorizontalLine(x, y, w, color);
102d9434:	e1a03004 	mov	r3, r4
	writedata(madctl);  // row address/col address, bottom to top refresh
}

// draw a rectangle
void ST7735_drawRect(unsigned char x, unsigned char y, unsigned char w, unsigned char h,unsigned int color)
{
102d9438:	e1a07000 	mov	r7, r0
102d943c:	e1a08002 	mov	r8, r2
	// smarter version
	ST7735_drawHorizontalLine(x, y, w, color);
102d9440:	ebffffea 	bl	102d93f0 <ST7735_drawHorizontalLine>
	ST7735_drawHorizontalLine(x, y+h-1, w, color);
102d9444:	e2461001 	sub	r1, r6, #1
102d9448:	e0851001 	add	r1, r5, r1
102d944c:	e1a00007 	mov	r0, r7
102d9450:	e1a02008 	mov	r2, r8
102d9454:	e1a03004 	mov	r3, r4
102d9458:	e20110ff 	and	r1, r1, #255	; 0xff
102d945c:	ebffffe3 	bl	102d93f0 <ST7735_drawHorizontalLine>
	ST7735_drawVerticalLine(x, y, h, color);
102d9460:	e1a00007 	mov	r0, r7
102d9464:	e1a01006 	mov	r1, r6
102d9468:	e1a02005 	mov	r2, r5
102d946c:	e1a03004 	mov	r3, r4
102d9470:	ebffff32 	bl	102d9140 <ST7735_drawVerticalLine>
	ST7735_drawVerticalLine(x+w-1, y, h, color);
102d9474:	e2477001 	sub	r7, r7, #1
102d9478:	e0880007 	add	r0, r8, r7
102d947c:	e20000ff 	and	r0, r0, #255	; 0xff
102d9480:	e1a01006 	mov	r1, r6
102d9484:	e1a02005 	mov	r2, r5
102d9488:	e1a03004 	mov	r3, r4
}
102d948c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
{
	// smarter version
	ST7735_drawHorizontalLine(x, y, w, color);
	ST7735_drawHorizontalLine(x, y+h-1, w, color);
	ST7735_drawVerticalLine(x, y, h, color);
	ST7735_drawVerticalLine(x+w-1, y, h, color);
102d9490:	eaffff2a 	b	102d9140 <ST7735_drawVerticalLine>

102d9494 <abs>:


int abs(int val)
{
	return (val > 0) ? val : -val;
}
102d9494:	e3500000 	cmp	r0, #0
102d9498:	b2600000 	rsblt	r0, r0, #0
102d949c:	e12fff1e 	bx	lr

102d94a0 <ST7735_drawLine>:

// bresenham's algorithm - thx wikpedia
void ST7735_drawLine(int x0, int y0, int x1, int y1,unsigned int color)
{
102d94a0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102d94a4:	e1a07002 	mov	r7, r2
	unsigned int steep = abs(y1 - y0) > abs(x1 - x0);
102d94a8:	e061a003 	rsb	sl, r1, r3
102d94ac:	e0602002 	rsb	r2, r0, r2
102d94b0:	e35a0000 	cmp	sl, #0
102d94b4:	b26aa000 	rsblt	sl, sl, #0
102d94b8:	e3520000 	cmp	r2, #0
102d94bc:	b2622000 	rsblt	r2, r2, #0
102d94c0:	e15a0002 	cmp	sl, r2
102d94c4:	d3a0a000 	movle	sl, #0
102d94c8:	c3a0a001 	movgt	sl, #1
	return (val > 0) ? val : -val;
}

// bresenham's algorithm - thx wikpedia
void ST7735_drawLine(int x0, int y0, int x1, int y1,unsigned int color)
{
102d94cc:	e24dd00c 	sub	sp, sp, #12
	unsigned int steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep)
102d94d0:	e35a0000 	cmp	sl, #0
	return (val > 0) ? val : -val;
}

// bresenham's algorithm - thx wikpedia
void ST7735_drawLine(int x0, int y0, int x1, int y1,unsigned int color)
{
102d94d4:	e1a04000 	mov	r4, r0
102d94d8:	e1a0b001 	mov	fp, r1
102d94dc:	e59d8030 	ldr	r8, [sp, #48]	; 0x30
	unsigned int steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep)
102d94e0:	0a000004 	beq	102d94f8 <ST7735_drawLine+0x58>
102d94e4:	e1a01007 	mov	r1, r7
	{
		swap(x0, y0);
102d94e8:	e1a0400b 	mov	r4, fp
		swap(x1, y1);
102d94ec:	e1a07003 	mov	r7, r3
void ST7735_drawLine(int x0, int y0, int x1, int y1,unsigned int color)
{
	unsigned int steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep)
	{
		swap(x0, y0);
102d94f0:	e1a0b000 	mov	fp, r0
		swap(x1, y1);
102d94f4:	e1a03001 	mov	r3, r1
	}

	if (x0 > x1)
102d94f8:	e1540007 	cmp	r4, r7
102d94fc:	da000005 	ble	102d9518 <ST7735_drawLine+0x78>
102d9500:	e1a0100b 	mov	r1, fp
102d9504:	e1a02004 	mov	r2, r4
	{
		swap(x0, x1);
		swap(y0, y1);
102d9508:	e1a0b003 	mov	fp, r3
	{
		swap(x0, y0);
		swap(x1, y1);
	}

	if (x0 > x1)
102d950c:	e1a04007 	mov	r4, r7
	{
		swap(x0, x1);
		swap(y0, y1);
102d9510:	e1a03001 	mov	r3, r1
	{
		swap(x0, y0);
		swap(x1, y1);
	}

	if (x0 > x1)
102d9514:	e1a07002 	mov	r7, r2
		swap(y0, y1);
	}

	unsigned int dx, dy;
	dx = x1 - x0;
	dy = abs(y1 - y0);
102d9518:	e06b6003 	rsb	r6, fp, r3
102d951c:	e3560000 	cmp	r6, #0
102d9520:	b2666000 	rsblt	r6, r6, #0
	int err = dx / 2;
	int ystep;

	if (y0 < y1)
	{
		ystep = 1;
102d9524:	e15b0003 	cmp	fp, r3
102d9528:	a3e03000 	mvnge	r3, #0
102d952c:	b3a03001 	movlt	r3, #1
		swap(x0, x1);
		swap(y0, y1);
	}

	unsigned int dx, dy;
	dx = x1 - x0;
102d9530:	e0649007 	rsb	r9, r4, r7
	else
	{
		ystep = -1;
	}

	for (; x0<=x1; x0++)
102d9534:	e1540007 	cmp	r4, r7
	int err = dx / 2;
	int ystep;

	if (y0 < y1)
	{
		ystep = 1;
102d9538:	e58d3004 	str	r3, [sp, #4]

	unsigned int dx, dy;
	dx = x1 - x0;
	dy = abs(y1 - y0);

	int err = dx / 2;
102d953c:	e1a050a9 	lsr	r5, r9, #1
	else
	{
		ystep = -1;
	}

	for (; x0<=x1; x0++)
102d9540:	ca00000e 	bgt	102d9580 <ST7735_drawLine+0xe0>
		{
			ST7735_drawPixel(y0, x0, color);
		}
		else
		{
			ST7735_drawPixel(x0, y0, color);
102d9544:	e20400ff 	and	r0, r4, #255	; 0xff

	for (; x0<=x1; x0++)
	{
		if (steep)
		{
			ST7735_drawPixel(y0, x0, color);
102d9548:	e1a03000 	mov	r3, r0
		}
		else
		{
			ST7735_drawPixel(x0, y0, color);
102d954c:	e20b10ff 	and	r1, fp, #255	; 0xff
		ystep = -1;
	}

	for (; x0<=x1; x0++)
	{
		if (steep)
102d9550:	e35a0000 	cmp	sl, #0
		{
			ST7735_drawPixel(y0, x0, color);
102d9554:	11a00001 	movne	r0, r1
		}
		else
		{
			ST7735_drawPixel(x0, y0, color);
102d9558:	e1a02008 	mov	r2, r8

	for (; x0<=x1; x0++)
	{
		if (steep)
		{
			ST7735_drawPixel(y0, x0, color);
102d955c:	11a01003 	movne	r1, r3
		}
		else
		{
			ST7735_drawPixel(x0, y0, color);
102d9560:	ebfffbc2 	bl	102d8470 <ST7735_drawPixel>
		}
		err -= dy;
		if (err < 0)
102d9564:	e0555006 	subs	r5, r5, r6
		{
			y0 += ystep;
102d9568:	459d3004 	ldrmi	r3, [sp, #4]
	else
	{
		ystep = -1;
	}

	for (; x0<=x1; x0++)
102d956c:	e2844001 	add	r4, r4, #1
		}
		err -= dy;
		if (err < 0)
		{
			y0 += ystep;
			err += dx;
102d9570:	40855009 	addmi	r5, r5, r9
			ST7735_drawPixel(x0, y0, color);
		}
		err -= dy;
		if (err < 0)
		{
			y0 += ystep;
102d9574:	408bb003 	addmi	fp, fp, r3
	else
	{
		ystep = -1;
	}

	for (; x0<=x1; x0++)
102d9578:	e1570004 	cmp	r7, r4
102d957c:	aafffff0 	bge	102d9544 <ST7735_drawLine+0xa4>
		{
			y0 += ystep;
			err += dx;
		}
	}
}
102d9580:	e28dd00c 	add	sp, sp, #12
102d9584:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

102d9588 <loadBitmapToLCD>:
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
{
102d9588:	e3500001 	cmp	r0, #1
102d958c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102d9590:	e24dd03c 	sub	sp, sp, #60	; 0x3c
102d9594:	0a000028 	beq	102d963c <loadBitmapToLCD+0xb4>
102d9598:	e3a03000 	mov	r3, #0
102d959c:	e58d3000 	str	r3, [sp]
102d95a0:	e3a030a0 	mov	r3, #160	; 0xa0
102d95a4:	e58d301c 	str	r3, [sp, #28]

		image_data = (int *)Welcome_Logo_Image_data;
		break;
	}

	switch(style)
102d95a8:	e3510001 	cmp	r1, #1
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
{
102d95ac:	e3a03000 	mov	r3, #0
102d95b0:	e3a0b080 	mov	fp, #128	; 0x80
102d95b4:	e58d3018 	str	r3, [sp, #24]

		image_data = (int *)Welcome_Logo_Image_data;
		break;
	}

	switch(style)
102d95b8:	0a000028 	beq	102d9660 <loadBitmapToLCD+0xd8>
102d95bc:	2a00001a 	bcs	102d962c <loadBitmapToLCD+0xa4>
102d95c0:	e59d101c 	ldr	r1, [sp, #28]
102d95c4:	e59d3000 	ldr	r3, [sp]
	{
	case 0:
		// Plane Horizontal swipe in one directions to fill the image on screen
		for (Pixel_Data_Read = 0; Pixel_Data_Read<(bitmapWidth * bitmapHeight);Pixel_Data_Read++)
102d95c8:	e3a07000 	mov	r7, #0
102d95cc:	e0838001 	add	r8, r3, r1
102d95d0:	e2488001 	sub	r8, r8, #1
102d95d4:	e16a018b 	smulbb	sl, fp, r1
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d95d8:	e59f631c 	ldr	r6, [pc, #796]	; 102d98fc <loadBitmapToLCD+0x374>

	switch(style)
	{
	case 0:
		// Plane Horizontal swipe in one directions to fill the image on screen
		for (Pixel_Data_Read = 0; Pixel_Data_Read<(bitmapWidth * bitmapHeight);Pixel_Data_Read++)
102d95dc:	e59d9018 	ldr	r9, [sp, #24]
102d95e0:	e20880ff 	and	r8, r8, #255	; 0xff
102d95e4:	e1a04007 	mov	r4, r7
102d95e8:	e1a05007 	mov	r5, r7
		{
			ST7735_drawPixel(curX+start_X, (bitmapHeight-curY+start_Y-1), (image_data[Pixel_Data_Read]));
102d95ec:	e0671008 	rsb	r1, r7, r8
102d95f0:	e0840009 	add	r0, r4, r9
			curX++;
102d95f4:	e2844001 	add	r4, r4, #1
102d95f8:	e20440ff 	and	r4, r4, #255	; 0xff
	{
	case 0:
		// Plane Horizontal swipe in one directions to fill the image on screen
		for (Pixel_Data_Read = 0; Pixel_Data_Read<(bitmapWidth * bitmapHeight);Pixel_Data_Read++)
		{
			ST7735_drawPixel(curX+start_X, (bitmapHeight-curY+start_Y-1), (image_data[Pixel_Data_Read]));
102d95fc:	e20000ff 	and	r0, r0, #255	; 0xff
102d9600:	e20110ff 	and	r1, r1, #255	; 0xff
102d9604:	e5b62004 	ldr	r2, [r6, #4]!
102d9608:	ebfffb98 	bl	102d8470 <ST7735_drawPixel>
			curX++;

			if (curX == bitmapWidth)
102d960c:	e154000b 	cmp	r4, fp
			{
				curY++;
102d9610:	02877001 	addeq	r7, r7, #1

	switch(style)
	{
	case 0:
		// Plane Horizontal swipe in one directions to fill the image on screen
		for (Pixel_Data_Read = 0; Pixel_Data_Read<(bitmapWidth * bitmapHeight);Pixel_Data_Read++)
102d9614:	e2855001 	add	r5, r5, #1
			ST7735_drawPixel(curX+start_X, (bitmapHeight-curY+start_Y-1), (image_data[Pixel_Data_Read]));
			curX++;

			if (curX == bitmapWidth)
			{
				curY++;
102d9618:	020770ff 	andeq	r7, r7, #255	; 0xff
				curX = 0;
102d961c:	03a04000 	moveq	r4, #0

	switch(style)
	{
	case 0:
		// Plane Horizontal swipe in one directions to fill the image on screen
		for (Pixel_Data_Read = 0; Pixel_Data_Read<(bitmapWidth * bitmapHeight);Pixel_Data_Read++)
102d9620:	e155000a 	cmp	r5, sl
102d9624:	1afffff0 	bne	102d95ec <loadBitmapToLCD+0x64>
102d9628:	ea000001 	b	102d9634 <loadBitmapToLCD+0xac>

		image_data = (int *)Welcome_Logo_Image_data;
		break;
	}

	switch(style)
102d962c:	e3510002 	cmp	r1, #2
102d9630:	0a000034 	beq	102d9708 <loadBitmapToLCD+0x180>
			coloumn = curY;
		}
		break;
	}

}
102d9634:	e28dd03c 	add	sp, sp, #60	; 0x3c
102d9638:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
{
102d963c:	e3a03049 	mov	r3, #73	; 0x49
102d9640:	e58d301c 	str	r3, [sp, #28]
102d9644:	e3a0302a 	mov	r3, #42	; 0x2a
102d9648:	e58d3000 	str	r3, [sp]

		image_data = (int *)Welcome_Logo_Image_data;
		break;
	}

	switch(style)
102d964c:	e3510001 	cmp	r1, #1
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
{
102d9650:	e3a03028 	mov	r3, #40	; 0x28
102d9654:	e3a0b035 	mov	fp, #53	; 0x35
102d9658:	e58d3018 	str	r3, [sp, #24]

		image_data = (int *)Welcome_Logo_Image_data;
		break;
	}

	switch(style)
102d965c:	1affffd6 	bne	102d95bc <loadBitmapToLCD+0x34>
			}
		}
		break;
	case 1:
		// Plane two Horizontal swipes in opposite directions to fill the image
		for (Pixel_Data_Read = 0; Pixel_Data_Read<((bitmapWidth * bitmapHeight)/2);Pixel_Data_Read++)
102d9660:	e59d301c 	ldr	r3, [sp, #28]
102d9664:	e59d1000 	ldr	r1, [sp]
102d9668:	e16a038b 	smulbb	sl, fp, r3
102d966c:	e0818003 	add	r8, r1, r3
102d9670:	e2488001 	sub	r8, r8, #1
102d9674:	e3a05000 	mov	r5, #0
102d9678:	e20880ff 	and	r8, r8, #255	; 0xff
102d967c:	e59f627c 	ldr	r6, [pc, #636]	; 102d9900 <loadBitmapToLCD+0x378>
102d9680:	e1a0a0ca 	asr	sl, sl, #1
102d9684:	e1a04005 	mov	r4, r5
102d9688:	e1a07005 	mov	r7, r5
102d968c:	e1a09008 	mov	r9, r8
		{
			ST7735_drawPixel(curX+start_X, curY+start_Y, image_data[Pixel_Data_Read]);
102d9690:	e59d3018 	ldr	r3, [sp, #24]
102d9694:	e084c003 	add	ip, r4, r3
102d9698:	e59d3000 	ldr	r3, [sp]
102d969c:	e20c80ff 	and	r8, ip, #255	; 0xff
102d96a0:	e0851003 	add	r1, r5, r3
102d96a4:	e59f3258 	ldr	r3, [pc, #600]	; 102d9904 <loadBitmapToLCD+0x37c>
102d96a8:	e1a00008 	mov	r0, r8
102d96ac:	e7932107 	ldr	r2, [r3, r7, lsl #2]
102d96b0:	e20110ff 	and	r1, r1, #255	; 0xff
102d96b4:	ebfffb6d 	bl	102d8470 <ST7735_drawPixel>
			ST7735_drawPixel(curX+start_X, bitmapHeight-curY+start_Y-1, image_data[((bitmapHeight-curY-1) * bitmapWidth)+ curX]);
102d96b8:	e59d301c 	ldr	r3, [sp, #28]
102d96bc:	e0651009 	rsb	r1, r5, r9
102d96c0:	e0652003 	rsb	r2, r5, r3
102d96c4:	e2422001 	sub	r2, r2, #1
102d96c8:	e022429b 	mla	r2, fp, r2, r4
			curX++;
102d96cc:	e2844001 	add	r4, r4, #1
	case 1:
		// Plane two Horizontal swipes in opposite directions to fill the image
		for (Pixel_Data_Read = 0; Pixel_Data_Read<((bitmapWidth * bitmapHeight)/2);Pixel_Data_Read++)
		{
			ST7735_drawPixel(curX+start_X, curY+start_Y, image_data[Pixel_Data_Read]);
			ST7735_drawPixel(curX+start_X, bitmapHeight-curY+start_Y-1, image_data[((bitmapHeight-curY-1) * bitmapWidth)+ curX]);
102d96d0:	e0862102 	add	r2, r6, r2, lsl #2
			curX++;
102d96d4:	e20440ff 	and	r4, r4, #255	; 0xff
	case 1:
		// Plane two Horizontal swipes in opposite directions to fill the image
		for (Pixel_Data_Read = 0; Pixel_Data_Read<((bitmapWidth * bitmapHeight)/2);Pixel_Data_Read++)
		{
			ST7735_drawPixel(curX+start_X, curY+start_Y, image_data[Pixel_Data_Read]);
			ST7735_drawPixel(curX+start_X, bitmapHeight-curY+start_Y-1, image_data[((bitmapHeight-curY-1) * bitmapWidth)+ curX]);
102d96d8:	e1a00008 	mov	r0, r8
102d96dc:	e20110ff 	and	r1, r1, #255	; 0xff
102d96e0:	e59221e4 	ldr	r2, [r2, #484]	; 0x1e4
102d96e4:	ebfffb61 	bl	102d8470 <ST7735_drawPixel>
			curX++;

			if (curX == bitmapWidth)
102d96e8:	e154000b 	cmp	r4, fp
			{
				curY++;
102d96ec:	02855001 	addeq	r5, r5, #1
			}
		}
		break;
	case 1:
		// Plane two Horizontal swipes in opposite directions to fill the image
		for (Pixel_Data_Read = 0; Pixel_Data_Read<((bitmapWidth * bitmapHeight)/2);Pixel_Data_Read++)
102d96f0:	e2877001 	add	r7, r7, #1
			ST7735_drawPixel(curX+start_X, bitmapHeight-curY+start_Y-1, image_data[((bitmapHeight-curY-1) * bitmapWidth)+ curX]);
			curX++;

			if (curX == bitmapWidth)
			{
				curY++;
102d96f4:	020550ff 	andeq	r5, r5, #255	; 0xff
				curX = 0;
102d96f8:	03a04000 	moveq	r4, #0
			}
		}
		break;
	case 1:
		// Plane two Horizontal swipes in opposite directions to fill the image
		for (Pixel_Data_Read = 0; Pixel_Data_Read<((bitmapWidth * bitmapHeight)/2);Pixel_Data_Read++)
102d96fc:	e157000a 	cmp	r7, sl
102d9700:	1affffe2 	bne	102d9690 <loadBitmapToLCD+0x108>
102d9704:	eaffffca 	b	102d9634 <loadBitmapToLCD+0xac>
102d9708:	e59d1018 	ldr	r1, [sp, #24]
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d970c:	e3a02000 	mov	r2, #0
102d9710:	e08b3001 	add	r3, fp, r1
102d9714:	e59d101c 	ldr	r1, [sp, #28]
102d9718:	e58d2004 	str	r2, [sp, #4]
102d971c:	e2412001 	sub	r2, r1, #1
			}
		}
		break;
	case 2:

		for (coloumn = 0; coloumn<bitmapHeight/2;)
102d9720:	e1a010a1 	lsr	r1, r1, #1
102d9724:	e58d102c 	str	r1, [sp, #44]	; 0x2c
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d9728:	e26b1000 	rsb	r1, fp, #0
102d972c:	e58d1028 	str	r1, [sp, #40]	; 0x28
102d9730:	e0010b92 	mul	r1, r2, fp
102d9734:	e2433001 	sub	r3, r3, #1
102d9738:	e3a09000 	mov	r9, #0
102d973c:	e20330ff 	and	r3, r3, #255	; 0xff
102d9740:	e58d1008 	str	r1, [sp, #8]
102d9744:	e59d201c 	ldr	r2, [sp, #28]
102d9748:	e59d1000 	ldr	r1, [sp]
102d974c:	e58d3034 	str	r3, [sp, #52]	; 0x34
102d9750:	e069300b 	rsb	r3, r9, fp
102d9754:	e0822001 	add	r2, r2, r1
		break;
	case 2:

		for (coloumn = 0; coloumn<bitmapHeight/2;)
		{
			for(row = curX; row<(bitmapWidth-curX); row++)
102d9758:	e1530009 	cmp	r3, r9
102d975c:	e58d9014 	str	r9, [sp, #20]
102d9760:	e58d2030 	str	r2, [sp, #48]	; 0x30
102d9764:	e59f5194 	ldr	r5, [pc, #404]	; 102d9900 <loadBitmapToLCD+0x378>
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d9768:	e58d300c 	str	r3, [sp, #12]
		break;
	case 2:

		for (coloumn = 0; coloumn<bitmapHeight/2;)
		{
			for(row = curX; row<(bitmapWidth-curX); row++)
102d976c:	da00005e 	ble	102d98ec <loadBitmapToLCD+0x364>
102d9770:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d9774:	e59d2014 	ldr	r2, [sp, #20]
102d9778:	e203a0ff 	and	sl, r3, #255	; 0xff
102d977c:	e59d1000 	ldr	r1, [sp]
102d9780:	e24aa001 	sub	sl, sl, #1
102d9784:	e0813002 	add	r3, r1, r2
102d9788:	e062a00a 	rsb	sl, r2, sl
102d978c:	e59d1018 	ldr	r1, [sp, #24]
102d9790:	e203c0ff 	and	ip, r3, #255	; 0xff
102d9794:	e20a30ff 	and	r3, sl, #255	; 0xff
			for(row = curX; row<(bitmapWidth-curX); row++)
			{
				// if(image_data[(coloumn * bitmapWidth) + row] !=BACKGROUND_COLOUR)// skip those pixels with background colour to speed up the entire image paint
				ST7735_drawPixel(row+start_X, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + row]);
				// if(image_data[((bitmapHeight-coloumn-1) * bitmapWidth)+ row] !=BACKGROUND_COLOUR)
				ST7735_drawPixel(row+start_X, bitmapHeight-coloumn+start_Y-1, image_data[((bitmapHeight-coloumn-1) * bitmapWidth)+ row]);
102d9798:	e1a04009 	mov	r4, r9
102d979c:	e0817002 	add	r7, r1, r2
102d97a0:	e58d9024 	str	r9, [sp, #36]	; 0x24
102d97a4:	e2822001 	add	r2, r2, #1
102d97a8:	e3a06000 	mov	r6, #0
102d97ac:	e1a0a00c 	mov	sl, ip
102d97b0:	e1a09003 	mov	r9, r3
102d97b4:	e58d2010 	str	r2, [sp, #16]
102d97b8:	e58db020 	str	fp, [sp, #32]
		for (coloumn = 0; coloumn<bitmapHeight/2;)
		{
			for(row = curX; row<(bitmapWidth-curX); row++)
			{
				// if(image_data[(coloumn * bitmapWidth) + row] !=BACKGROUND_COLOUR)// skip those pixels with background colour to speed up the entire image paint
				ST7735_drawPixel(row+start_X, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + row]);
102d97bc:	e59d3004 	ldr	r3, [sp, #4]
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d97c0:	e206b0ff 	and	fp, r6, #255	; 0xff
		for (coloumn = 0; coloumn<bitmapHeight/2;)
		{
			for(row = curX; row<(bitmapWidth-curX); row++)
			{
				// if(image_data[(coloumn * bitmapWidth) + row] !=BACKGROUND_COLOUR)// skip those pixels with background colour to speed up the entire image paint
				ST7735_drawPixel(row+start_X, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + row]);
102d97c4:	e0842003 	add	r2, r4, r3
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d97c8:	e08bc007 	add	ip, fp, r7
102d97cc:	e20c80ff 	and	r8, ip, #255	; 0xff
		for (coloumn = 0; coloumn<bitmapHeight/2;)
		{
			for(row = curX; row<(bitmapWidth-curX); row++)
			{
				// if(image_data[(coloumn * bitmapWidth) + row] !=BACKGROUND_COLOUR)// skip those pixels with background colour to speed up the entire image paint
				ST7735_drawPixel(row+start_X, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + row]);
102d97d0:	e0852102 	add	r2, r5, r2, lsl #2
102d97d4:	e1a00008 	mov	r0, r8
102d97d8:	e1a0100a 	mov	r1, sl
102d97dc:	e59221e4 	ldr	r2, [r2, #484]	; 0x1e4
102d97e0:	ebfffb22 	bl	102d8470 <ST7735_drawPixel>
				// if(image_data[((bitmapHeight-coloumn-1) * bitmapWidth)+ row] !=BACKGROUND_COLOUR)
				ST7735_drawPixel(row+start_X, bitmapHeight-coloumn+start_Y-1, image_data[((bitmapHeight-coloumn-1) * bitmapWidth)+ row]);
102d97e4:	e59d3008 	ldr	r3, [sp, #8]
102d97e8:	e1a00008 	mov	r0, r8
102d97ec:	e0844003 	add	r4, r4, r3
102d97f0:	e0854104 	add	r4, r5, r4, lsl #2
102d97f4:	e59421e4 	ldr	r2, [r4, #484]	; 0x1e4
102d97f8:	e1a01009 	mov	r1, r9
102d97fc:	ebfffb1b 	bl	102d8470 <ST7735_drawPixel>
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d9800:	e59d3010 	ldr	r3, [sp, #16]
102d9804:	e2866001 	add	r6, r6, #1
102d9808:	e08b4003 	add	r4, fp, r3
		break;
	case 2:

		for (coloumn = 0; coloumn<bitmapHeight/2;)
		{
			for(row = curX; row<(bitmapWidth-curX); row++)
102d980c:	e59d300c 	ldr	r3, [sp, #12]
102d9810:	e20440ff 	and	r4, r4, #255	; 0xff
102d9814:	e1530004 	cmp	r3, r4
102d9818:	caffffe7 	bgt	102d97bc <loadBitmapToLCD+0x234>
102d981c:	e59db020 	ldr	fp, [sp, #32]
102d9820:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d9824:	e59d3010 	ldr	r3, [sp, #16]
102d9828:	e20380ff 	and	r8, r3, #255	; 0xff
				ST7735_drawPixel(row+start_X, bitmapHeight-coloumn+start_Y-1, image_data[((bitmapHeight-coloumn-1) * bitmapWidth)+ row]);
			}
			curY++;
			row = curX;

			for(coloumn = curY; coloumn<(bitmapHeight-curY); coloumn++)
102d982c:	e59d301c 	ldr	r3, [sp, #28]
102d9830:	e0684003 	rsb	r4, r8, r3
102d9834:	e1580004 	cmp	r8, r4
102d9838:	aa00001a 	bge	102d98a8 <loadBitmapToLCD+0x320>
102d983c:	e59d3018 	ldr	r3, [sp, #24]
102d9840:	e59d1014 	ldr	r1, [sp, #20]
102d9844:	e0837001 	add	r7, r3, r1
102d9848:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
			{
				// if(image_data[(coloumn * bitmapWidth) + row] !=BACKGROUND_COLOUR)
				ST7735_drawPixel(row+start_X, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + row]);
102d984c:	e20770ff 	and	r7, r7, #255	; 0xff
102d9850:	e0616003 	rsb	r6, r1, r3
				// if(image_data[(coloumn * bitmapWidth) + bitmapWidth-row-1] !=BACKGROUND_COLOUR)// skip those pixels with background colour to speed up the entire image paint
				ST7735_drawPixel(bitmapWidth-row+start_X-1, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + bitmapWidth-row-1]);
102d9854:	e20660ff 	and	r6, r6, #255	; 0xff
			row = curX;

			for(coloumn = curY; coloumn<(bitmapHeight-curY); coloumn++)
			{
				// if(image_data[(coloumn * bitmapWidth) + row] !=BACKGROUND_COLOUR)
				ST7735_drawPixel(row+start_X, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + row]);
102d9858:	e59d1000 	ldr	r1, [sp]
102d985c:	e0229b98 	mla	r2, r8, fp, r9
102d9860:	e0883001 	add	r3, r8, r1
102d9864:	e203a0ff 	and	sl, r3, #255	; 0xff
102d9868:	e0852102 	add	r2, r5, r2, lsl #2
102d986c:	e1a00007 	mov	r0, r7
102d9870:	e1a0100a 	mov	r1, sl
102d9874:	e59221e4 	ldr	r2, [r2, #484]	; 0x1e4
102d9878:	ebfffafc 	bl	102d8470 <ST7735_drawPixel>
				// if(image_data[(coloumn * bitmapWidth) + bitmapWidth-row-1] !=BACKGROUND_COLOUR)// skip those pixels with background colour to speed up the entire image paint
				ST7735_drawPixel(bitmapWidth-row+start_X-1, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + bitmapWidth-row-1]);
102d987c:	e2888001 	add	r8, r8, #1
102d9880:	e1e02009 	mvn	r2, r9
102d9884:	e022289b 	mla	r2, fp, r8, r2
102d9888:	e1a00006 	mov	r0, r6
102d988c:	e0852102 	add	r2, r5, r2, lsl #2
102d9890:	e1a0100a 	mov	r1, sl
102d9894:	e59221e4 	ldr	r2, [r2, #484]	; 0x1e4
				ST7735_drawPixel(row+start_X, bitmapHeight-coloumn+start_Y-1, image_data[((bitmapHeight-coloumn-1) * bitmapWidth)+ row]);
			}
			curY++;
			row = curX;

			for(coloumn = curY; coloumn<(bitmapHeight-curY); coloumn++)
102d9898:	e20880ff 	and	r8, r8, #255	; 0xff
			{
				// if(image_data[(coloumn * bitmapWidth) + row] !=BACKGROUND_COLOUR)
				ST7735_drawPixel(row+start_X, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + row]);
				// if(image_data[(coloumn * bitmapWidth) + bitmapWidth-row-1] !=BACKGROUND_COLOUR)// skip those pixels with background colour to speed up the entire image paint
				ST7735_drawPixel(bitmapWidth-row+start_X-1, coloumn+start_Y, image_data[(coloumn * bitmapWidth) + bitmapWidth-row-1]);
102d989c:	ebfffaf3 	bl	102d8470 <ST7735_drawPixel>
				ST7735_drawPixel(row+start_X, bitmapHeight-coloumn+start_Y-1, image_data[((bitmapHeight-coloumn-1) * bitmapWidth)+ row]);
			}
			curY++;
			row = curX;

			for(coloumn = curY; coloumn<(bitmapHeight-curY); coloumn++)
102d98a0:	e1580004 	cmp	r8, r4
102d98a4:	baffffeb 	blt	102d9858 <loadBitmapToLCD+0x2d0>
			}
		}
		break;
	case 2:

		for (coloumn = 0; coloumn<bitmapHeight/2;)
102d98a8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
102d98ac:	e2899001 	add	r9, r9, #1
102d98b0:	e20930ff 	and	r3, r9, #255	; 0xff
102d98b4:	e1510003 	cmp	r1, r3
102d98b8:	e58d3014 	str	r3, [sp, #20]
102d98bc:	e59d3004 	ldr	r3, [sp, #4]
102d98c0:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
102d98c4:	e083300b 	add	r3, r3, fp
102d98c8:	e58d3004 	str	r3, [sp, #4]
102d98cc:	e59d3008 	ldr	r3, [sp, #8]
102d98d0:	e0833001 	add	r3, r3, r1
102d98d4:	e58d3008 	str	r3, [sp, #8]
102d98d8:	9affff55 	bls	102d9634 <loadBitmapToLCD+0xac>
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d98dc:	e069300b 	rsb	r3, r9, fp
		break;
	case 2:

		for (coloumn = 0; coloumn<bitmapHeight/2;)
		{
			for(row = curX; row<(bitmapWidth-curX); row++)
102d98e0:	e1530009 	cmp	r3, r9
	}
}
// Load an image on the LCD screen.
//The images can appear on screen in three styles
// 0 -> converge to center of image. 1 -> Horizontal swipe, 1 -> 2 horizontal swipes in opposite direction
void loadBitmapToLCD(char image_number, char style)
102d98e4:	e58d300c 	str	r3, [sp, #12]
		break;
	case 2:

		for (coloumn = 0; coloumn<bitmapHeight/2;)
		{
			for(row = curX; row<(bitmapWidth-curX); row++)
102d98e8:	caffffa0 	bgt	102d9770 <loadBitmapToLCD+0x1e8>
102d98ec:	e59d3014 	ldr	r3, [sp, #20]
102d98f0:	e2833001 	add	r3, r3, #1
102d98f4:	e58d3010 	str	r3, [sp, #16]
102d98f8:	eaffffc9 	b	102d9824 <loadBitmapToLCD+0x29c>
102d98fc:	102e73c0 	.word	0x102e73c0
102d9900:	102e71e0 	.word	0x102e71e0
102d9904:	102e73c4 	.word	0x102e73c4

102d9908 <Refresh_Antenna_Symbol>:
	}

}

void Refresh_Antenna_Symbol(void)
{
102d9908:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	if(FLAG.SIMCARD_REGISTERED)//Draw antenna signal strength only if SIM Card is Present and detected
102d990c:	e59f4214 	ldr	r4, [pc, #532]	; 102d9b28 <Refresh_Antenna_Symbol+0x220>
	}

}

void Refresh_Antenna_Symbol(void)
{
102d9910:	e24dd00c 	sub	sp, sp, #12
	if(FLAG.SIMCARD_REGISTERED)//Draw antenna signal strength only if SIM Card is Present and detected
102d9914:	e5d43002 	ldrb	r3, [r4, #2]
102d9918:	e3530000 	cmp	r3, #0
102d991c:	1a000001 	bne	102d9928 <Refresh_Antenna_Symbol+0x20>
			ST7735_drawString(145, 20, (char *)buffer, colWhite, 1);  //Service provider name details
		}
		//assign present value to prev variable
		previous_rssival = RssiLevel;
	}
}
102d9920:	e28dd00c 	add	sp, sp, #12
102d9924:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
{
	if(FLAG.SIMCARD_REGISTERED)//Draw antenna signal strength only if SIM Card is Present and detected
	{
		ST7735_setRotation(0x0); // Start point Left - top

		if(RssiLevel >=21 && RssiLevel <=31)
102d9928:	e59f51fc 	ldr	r5, [pc, #508]	; 102d9b2c <Refresh_Antenna_Symbol+0x224>

void Refresh_Antenna_Symbol(void)
{
	if(FLAG.SIMCARD_REGISTERED)//Draw antenna signal strength only if SIM Card is Present and detected
	{
		ST7735_setRotation(0x0); // Start point Left - top
102d992c:	e3a00000 	mov	r0, #0
102d9930:	ebfffd2f 	bl	102d8df4 <ST7735_setRotation>

		if(RssiLevel >=21 && RssiLevel <=31)
102d9934:	e5d53000 	ldrb	r3, [r5]
102d9938:	e2432015 	sub	r2, r3, #21
102d993c:	e352000a 	cmp	r2, #10
		{
			ST7735_fillRect(111, 156, 15, 2, colWhite);
102d9940:	959f61e8 	ldrls	r6, [pc, #488]	; 102d9b30 <Refresh_Antenna_Symbol+0x228>
102d9944:	958d6000 	strls	r6, [sp]
{
	if(FLAG.SIMCARD_REGISTERED)//Draw antenna signal strength only if SIM Card is Present and detected
	{
		ST7735_setRotation(0x0); // Start point Left - top

		if(RssiLevel >=21 && RssiLevel <=31)
102d9948:	9a00002c 	bls	102d9a00 <Refresh_Antenna_Symbol+0xf8>
			ST7735_fillRect(111, 156, 15, 2, colWhite);
			ST7735_fillRect(111, 152, 12, 2, colWhite);
			ST7735_fillRect(111, 148,  9, 2, colWhite);
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=16 && RssiLevel <=20)
102d994c:	e2432010 	sub	r2, r3, #16
102d9950:	e3520004 	cmp	r2, #4
102d9954:	9a000026 	bls	102d99f4 <Refresh_Antenna_Symbol+0xec>
			ST7735_fillRect(111, 156, 15, 2, colGray);
			ST7735_fillRect(111, 152, 12, 2, colWhite);
			ST7735_fillRect(111, 148,  9, 2, colWhite);
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=11 && RssiLevel <=15)
102d9958:	e243200b 	sub	r2, r3, #11
102d995c:	e3520004 	cmp	r2, #4
102d9960:	9a00004b 	bls	102d9a94 <Refresh_Antenna_Symbol+0x18c>
			ST7735_fillRect(111, 156, 15, 2, colGray);
			ST7735_fillRect(111, 152, 12, 2, colGray);
			ST7735_fillRect(111, 148,  9, 2, colWhite);
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=6 && RssiLevel <=10)
102d9964:	e2433006 	sub	r3, r3, #6
102d9968:	e3530004 	cmp	r3, #4
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
102d996c:	e59f61c0 	ldr	r6, [pc, #448]	; 102d9b34 <Refresh_Antenna_Symbol+0x22c>
			ST7735_fillRect(111, 156, 15, 2, colGray);
			ST7735_fillRect(111, 152, 12, 2, colGray);
			ST7735_fillRect(111, 148,  9, 2, colWhite);
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=6 && RssiLevel <=10)
102d9970:	8a000035 	bhi	102d9a4c <Refresh_Antenna_Symbol+0x144>
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
102d9974:	e3a0006f 	mov	r0, #111	; 0x6f
102d9978:	e3a0109c 	mov	r1, #156	; 0x9c
102d997c:	e3a0200f 	mov	r2, #15
102d9980:	e3a03002 	mov	r3, #2
102d9984:	e58d6000 	str	r6, [sp]
102d9988:	ebfffd35 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 152, 12, 2, colGray);
102d998c:	e3a0006f 	mov	r0, #111	; 0x6f
102d9990:	e3a01098 	mov	r1, #152	; 0x98
102d9994:	e3a0200c 	mov	r2, #12
102d9998:	e3a03002 	mov	r3, #2
102d999c:	e58d6000 	str	r6, [sp]
102d99a0:	ebfffd2f 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 148,  9, 2, colGray);
102d99a4:	e3a03002 	mov	r3, #2
102d99a8:	e58d6000 	str	r6, [sp]
102d99ac:	e3a0006f 	mov	r0, #111	; 0x6f
102d99b0:	e3a01094 	mov	r1, #148	; 0x94
102d99b4:	e3a02009 	mov	r2, #9
102d99b8:	ebfffd29 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 144,  6, 2, colWhite);
102d99bc:	e59f316c 	ldr	r3, [pc, #364]	; 102d9b30 <Refresh_Antenna_Symbol+0x228>
102d99c0:	e58d3000 	str	r3, [sp]
		else
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
			ST7735_fillRect(111, 152, 12, 2, colGray);
			ST7735_fillRect(111, 148,  9, 2, colGray);
			ST7735_fillRect(111, 144,  6, 2, colGray);
102d99c4:	e3a0006f 	mov	r0, #111	; 0x6f
102d99c8:	e3a01090 	mov	r1, #144	; 0x90
102d99cc:	e3a02006 	mov	r2, #6
102d99d0:	e3a03002 	mov	r3, #2
102d99d4:	ebfffd22 	bl	102d8e64 <ST7735_fillRect>
		}

		//If in Diagnostic print RSSI value just below the antenna symbol
		if(FLAG.DIGNOSTIC_MODE == TRUE)
102d99d8:	e5d4400a 	ldrb	r4, [r4, #10]
102d99dc:	e3540001 	cmp	r4, #1
102d99e0:	0a000035 	beq	102d9abc <Refresh_Antenna_Symbol+0x1b4>
102d99e4:	e59f614c 	ldr	r6, [pc, #332]	; 102d9b38 <Refresh_Antenna_Symbol+0x230>
			ST7735_drawString(145, 20, (char *)buffer, colBlack, 1);  //Service provider name details
			Ql_sprintf((char *)buffer,"%d",RssiLevel);
			ST7735_drawString(145, 20, (char *)buffer, colWhite, 1);  //Service provider name details
		}
		//assign present value to prev variable
		previous_rssival = RssiLevel;
102d99e8:	e5d53000 	ldrb	r3, [r5]
102d99ec:	e5c63000 	strb	r3, [r6]
102d99f0:	eaffffca 	b	102d9920 <Refresh_Antenna_Symbol+0x18>
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=16 && RssiLevel <=20)
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
			ST7735_fillRect(111, 152, 12, 2, colWhite);
102d99f4:	e59f6134 	ldr	r6, [pc, #308]	; 102d9b30 <Refresh_Antenna_Symbol+0x228>
			ST7735_fillRect(111, 148,  9, 2, colWhite);
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=16 && RssiLevel <=20)
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
102d99f8:	e59f3134 	ldr	r3, [pc, #308]	; 102d9b34 <Refresh_Antenna_Symbol+0x22c>
102d99fc:	e58d3000 	str	r3, [sp]
102d9a00:	e3a0006f 	mov	r0, #111	; 0x6f
102d9a04:	e3a0109c 	mov	r1, #156	; 0x9c
102d9a08:	e3a0200f 	mov	r2, #15
102d9a0c:	e3a03002 	mov	r3, #2
102d9a10:	ebfffd13 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 152, 12, 2, colWhite);
102d9a14:	e58d6000 	str	r6, [sp]
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=11 && RssiLevel <=15)
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
			ST7735_fillRect(111, 152, 12, 2, colGray);
102d9a18:	e3a0006f 	mov	r0, #111	; 0x6f
102d9a1c:	e3a01098 	mov	r1, #152	; 0x98
102d9a20:	e3a0200c 	mov	r2, #12
102d9a24:	e3a03002 	mov	r3, #2
102d9a28:	ebfffd0d 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 148,  9, 2, colWhite);
102d9a2c:	e3a0006f 	mov	r0, #111	; 0x6f
102d9a30:	e3a01094 	mov	r1, #148	; 0x94
102d9a34:	e3a02009 	mov	r2, #9
102d9a38:	e3a03002 	mov	r3, #2
102d9a3c:	e58d6000 	str	r6, [sp]
		}
		else
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
			ST7735_fillRect(111, 152, 12, 2, colGray);
			ST7735_fillRect(111, 148,  9, 2, colGray);
102d9a40:	ebfffd07 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 144,  6, 2, colGray);
102d9a44:	e58d6000 	str	r6, [sp]
102d9a48:	eaffffdd 	b	102d99c4 <Refresh_Antenna_Symbol+0xbc>
			ST7735_fillRect(111, 148,  9, 2, colGray);
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
102d9a4c:	e3a0006f 	mov	r0, #111	; 0x6f
102d9a50:	e3a0109c 	mov	r1, #156	; 0x9c
102d9a54:	e3a0200f 	mov	r2, #15
102d9a58:	e3a03002 	mov	r3, #2
102d9a5c:	e58d6000 	str	r6, [sp]
102d9a60:	ebfffcff 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 152, 12, 2, colGray);
102d9a64:	e3a0006f 	mov	r0, #111	; 0x6f
102d9a68:	e3a01098 	mov	r1, #152	; 0x98
102d9a6c:	e3a0200c 	mov	r2, #12
102d9a70:	e3a03002 	mov	r3, #2
102d9a74:	e58d6000 	str	r6, [sp]
102d9a78:	ebfffcf9 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 148,  9, 2, colGray);
102d9a7c:	e3a0006f 	mov	r0, #111	; 0x6f
102d9a80:	e3a01094 	mov	r1, #148	; 0x94
102d9a84:	e3a02009 	mov	r2, #9
102d9a88:	e3a03002 	mov	r3, #2
102d9a8c:	e58d6000 	str	r6, [sp]
102d9a90:	eaffffea 	b	102d9a40 <Refresh_Antenna_Symbol+0x138>
			ST7735_fillRect(111, 148,  9, 2, colWhite);
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=11 && RssiLevel <=15)
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
102d9a94:	e59f7098 	ldr	r7, [pc, #152]	; 102d9b34 <Refresh_Antenna_Symbol+0x22c>
102d9a98:	e58d7000 	str	r7, [sp]
102d9a9c:	e3a0006f 	mov	r0, #111	; 0x6f
102d9aa0:	e3a0109c 	mov	r1, #156	; 0x9c
102d9aa4:	e3a0200f 	mov	r2, #15
102d9aa8:	e3a03002 	mov	r3, #2
102d9aac:	ebfffcec 	bl	102d8e64 <ST7735_fillRect>
			ST7735_fillRect(111, 152, 12, 2, colGray);
			ST7735_fillRect(111, 148,  9, 2, colWhite);
102d9ab0:	e59f6078 	ldr	r6, [pc, #120]	; 102d9b30 <Refresh_Antenna_Symbol+0x228>
			ST7735_fillRect(111, 144,  6, 2, colWhite);
		}
		else if(RssiLevel >=11 && RssiLevel <=15)
		{
			ST7735_fillRect(111, 156, 15, 2, colGray);
			ST7735_fillRect(111, 152, 12, 2, colGray);
102d9ab4:	e58d7000 	str	r7, [sp]
102d9ab8:	eaffffd6 	b	102d9a18 <Refresh_Antenna_Symbol+0x110>

		//If in Diagnostic print RSSI value just below the antenna symbol
		if(FLAG.DIGNOSTIC_MODE == TRUE)
		{
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_rssival);
102d9abc:	e59f7078 	ldr	r7, [pc, #120]	; 102d9b3c <Refresh_Antenna_Symbol+0x234>
102d9ac0:	e59f6070 	ldr	r6, [pc, #112]	; 102d9b38 <Refresh_Antenna_Symbol+0x230>
		}

		//If in Diagnostic print RSSI value just below the antenna symbol
		if(FLAG.DIGNOSTIC_MODE == TRUE)
		{
			ST7735_setRotation(0x60);
102d9ac4:	e3a00060 	mov	r0, #96	; 0x60
102d9ac8:	ebfffcc9 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"%d",previous_rssival);
102d9acc:	e1d620d0 	ldrsb	r2, [r6]
102d9ad0:	e5973000 	ldr	r3, [r7]
102d9ad4:	e59f1064 	ldr	r1, [pc, #100]	; 102d9b40 <Refresh_Antenna_Symbol+0x238>
102d9ad8:	e59f0064 	ldr	r0, [pc, #100]	; 102d9b44 <Refresh_Antenna_Symbol+0x23c>
102d9adc:	e12fff33 	blx	r3
			ST7735_drawString(145, 20, (char *)buffer, colBlack, 1);  //Service provider name details
102d9ae0:	e3a03000 	mov	r3, #0
102d9ae4:	e3a00091 	mov	r0, #145	; 0x91
102d9ae8:	e3a01014 	mov	r1, #20
102d9aec:	e59f2050 	ldr	r2, [pc, #80]	; 102d9b44 <Refresh_Antenna_Symbol+0x23c>
102d9af0:	e58d4000 	str	r4, [sp]
102d9af4:	ebfffd38 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"%d",RssiLevel);
102d9af8:	e1d520d0 	ldrsb	r2, [r5]
102d9afc:	e5973000 	ldr	r3, [r7]
102d9b00:	e59f1038 	ldr	r1, [pc, #56]	; 102d9b40 <Refresh_Antenna_Symbol+0x238>
102d9b04:	e59f0038 	ldr	r0, [pc, #56]	; 102d9b44 <Refresh_Antenna_Symbol+0x23c>
102d9b08:	e12fff33 	blx	r3
			ST7735_drawString(145, 20, (char *)buffer, colWhite, 1);  //Service provider name details
102d9b0c:	e58d4000 	str	r4, [sp]
102d9b10:	e3a00091 	mov	r0, #145	; 0x91
102d9b14:	e3a01014 	mov	r1, #20
102d9b18:	e59f2024 	ldr	r2, [pc, #36]	; 102d9b44 <Refresh_Antenna_Symbol+0x23c>
102d9b1c:	e59f300c 	ldr	r3, [pc, #12]	; 102d9b30 <Refresh_Antenna_Symbol+0x228>
102d9b20:	ebfffd2d 	bl	102d8fdc <ST7735_drawString>
102d9b24:	eaffffaf 	b	102d99e8 <Refresh_Antenna_Symbol+0xe0>
102d9b28:	f03da5f0 	.word	0xf03da5f0
102d9b2c:	f03da820 	.word	0xf03da820
102d9b30:	0000ffff 	.word	0x0000ffff
102d9b34:	00007bef 	.word	0x00007bef
102d9b38:	f03da821 	.word	0xf03da821
102d9b3c:	f03de540 	.word	0xf03de540
102d9b40:	102edef4 	.word	0x102edef4
102d9b44:	f03d64c4 	.word	0xf03d64c4

102d9b48 <Refresh_Cloud_Connectivity_Symbol>:
		previous_rssival = RssiLevel;
	}
}

void Refresh_Cloud_Connectivity_Symbol(char cloud_connetcivity_status)
{
102d9b48:	e92d4010 	push	{r4, lr}
102d9b4c:	e1a04000 	mov	r4, r0
	ST7735_setRotation(0x0); // Start point Left - top
102d9b50:	e3a00000 	mov	r0, #0
102d9b54:	ebfffca6 	bl	102d8df4 <ST7735_setRotation>
	if(cloud_connetcivity_status == 2)
102d9b58:	e3540002 	cmp	r4, #2
102d9b5c:	0a000010 	beq	102d9ba4 <Refresh_Cloud_Connectivity_Symbol+0x5c>
		{
			RssiLevel = 6;// Show at least one active bar when connection is success with rssi value lower than 6
			Refresh_Antenna_Symbol();
		}
	}
	else if(cloud_connetcivity_status == 1) // DOT will become RED when DPS session is complete but IoT Hub session is not success
102d9b60:	e3540001 	cmp	r4, #1
102d9b64:	0a000018 	beq	102d9bcc <Refresh_Cloud_Connectivity_Symbol+0x84>
	{
		ST7735_fillCircle(116, 125, 5, colOrangeRed);
	}
	else if(cloud_connetcivity_status == 0) // The DOT will remain in GRAY colour till DPS session is complete
102d9b68:	e3540000 	cmp	r4, #0
102d9b6c:	18bd8010 	popne	{r4, pc}
	{
		ST7735_fillCircle(116, 125, 5, colGray);
102d9b70:	e3a02005 	mov	r2, #5
102d9b74:	e59f3068 	ldr	r3, [pc, #104]	; 102d9be4 <Refresh_Cloud_Connectivity_Symbol+0x9c>
102d9b78:	e3a00074 	mov	r0, #116	; 0x74
102d9b7c:	e3a0107d 	mov	r1, #125	; 0x7d
102d9b80:	ebfffd7c 	bl	102d9178 <ST7735_fillCircle>
		if(RssiLevel < 6)
102d9b84:	e59f305c 	ldr	r3, [pc, #92]	; 102d9be8 <Refresh_Cloud_Connectivity_Symbol+0xa0>
102d9b88:	e1d320d0 	ldrsb	r2, [r3]
102d9b8c:	e3520005 	cmp	r2, #5
102d9b90:	c8bd8010 	popgt	{r4, pc}
		{
			RssiLevel = 6;// Show at least one active bar when connection is success with rssi value lower than 6
102d9b94:	e3a02006 	mov	r2, #6
102d9b98:	e5c32000 	strb	r2, [r3]
			Refresh_Antenna_Symbol();
		}
	}

}
102d9b9c:	e8bd4010 	pop	{r4, lr}
	{
		ST7735_fillCircle(116, 125, 5, colGray);
		if(RssiLevel < 6)
		{
			RssiLevel = 6;// Show at least one active bar when connection is success with rssi value lower than 6
			Refresh_Antenna_Symbol();
102d9ba0:	eaffff58 	b	102d9908 <Refresh_Antenna_Symbol>
void Refresh_Cloud_Connectivity_Symbol(char cloud_connetcivity_status)
{
	ST7735_setRotation(0x0); // Start point Left - top
	if(cloud_connetcivity_status == 2)
	{
		ST7735_fillCircle(116, 125, 5, colLawngreen);
102d9ba4:	e3a02005 	mov	r2, #5
102d9ba8:	e59f303c 	ldr	r3, [pc, #60]	; 102d9bec <Refresh_Cloud_Connectivity_Symbol+0xa4>
102d9bac:	e3a00074 	mov	r0, #116	; 0x74
102d9bb0:	e3a0107d 	mov	r1, #125	; 0x7d
102d9bb4:	ebfffd6f 	bl	102d9178 <ST7735_fillCircle>
		if(RssiLevel < 6)
102d9bb8:	e59f3028 	ldr	r3, [pc, #40]	; 102d9be8 <Refresh_Cloud_Connectivity_Symbol+0xa0>
102d9bbc:	e1d320d0 	ldrsb	r2, [r3]
102d9bc0:	e3520005 	cmp	r2, #5
102d9bc4:	c8bd8010 	popgt	{r4, pc}
102d9bc8:	eafffff1 	b	102d9b94 <Refresh_Cloud_Connectivity_Symbol+0x4c>
			Refresh_Antenna_Symbol();
		}
	}
	else if(cloud_connetcivity_status == 1) // DOT will become RED when DPS session is complete but IoT Hub session is not success
	{
		ST7735_fillCircle(116, 125, 5, colOrangeRed);
102d9bcc:	e3a00074 	mov	r0, #116	; 0x74
102d9bd0:	e3a0107d 	mov	r1, #125	; 0x7d
102d9bd4:	e3a02005 	mov	r2, #5
102d9bd8:	e59f3010 	ldr	r3, [pc, #16]	; 102d9bf0 <Refresh_Cloud_Connectivity_Symbol+0xa8>
			RssiLevel = 6;// Show at least one active bar when connection is success with rssi value lower than 6
			Refresh_Antenna_Symbol();
		}
	}

}
102d9bdc:	e8bd4010 	pop	{r4, lr}
			Refresh_Antenna_Symbol();
		}
	}
	else if(cloud_connetcivity_status == 1) // DOT will become RED when DPS session is complete but IoT Hub session is not success
	{
		ST7735_fillCircle(116, 125, 5, colOrangeRed);
102d9be0:	eafffd64 	b	102d9178 <ST7735_fillCircle>
102d9be4:	00007bef 	.word	0x00007bef
102d9be8:	f03da820 	.word	0xf03da820
102d9bec:	00007fe0 	.word	0x00007fe0
102d9bf0:	0000fa20 	.word	0x0000fa20

102d9bf4 <Refresh_Communication_inprogress_Symbol>:
	}

}

void Refresh_Communication_inprogress_Symbol(unsigned int colour)
{
102d9bf4:	e92d4070 	push	{r4, r5, r6, lr}
	if(FLAG.WATER_SCREEN_INITIALIZED == TRUE) // Only if water balance screen is initialized
102d9bf8:	e59f4030 	ldr	r4, [pc, #48]	; 102d9c30 <Refresh_Communication_inprogress_Symbol+0x3c>
	}

}

void Refresh_Communication_inprogress_Symbol(unsigned int colour)
{
102d9bfc:	e1a06000 	mov	r6, r0
	if(FLAG.WATER_SCREEN_INITIALIZED == TRUE) // Only if water balance screen is initialized
102d9c00:	e5d45012 	ldrb	r5, [r4, #18]
102d9c04:	e3550001 	cmp	r5, #1
102d9c08:	18bd8070 	popne	{r4, r5, r6, pc}
	{
		ST7735_setRotation(0x0); // Start point Left - top
102d9c0c:	e3a00000 	mov	r0, #0
102d9c10:	ebfffc77 	bl	102d8df4 <ST7735_setRotation>
		ST7735_drawCircle(116, 125, 7, colour);
102d9c14:	e3a00074 	mov	r0, #116	; 0x74
102d9c18:	e3a0107d 	mov	r1, #125	; 0x7d
102d9c1c:	e3a02007 	mov	r2, #7
102d9c20:	e1a03006 	mov	r3, r6
102d9c24:	ebfffbff 	bl	102d8c28 <ST7735_drawCircle>
		FLAG.CLOUD_COMMUNICATION_IN_PROGRESS = TRUE;//This will clean up the symbol / indication after 1 second.
102d9c28:	e5c4500b 	strb	r5, [r4, #11]
102d9c2c:	e8bd8070 	pop	{r4, r5, r6, pc}
102d9c30:	f03da5f0 	.word	0xf03da5f0

102d9c34 <Init_display>:
	}
}


void Init_display(void)
{
102d9c34:	e92d4008 	push	{r3, lr}
	ST7735_initR();
102d9c38:	ebfffa14 	bl	102d8490 <ST7735_initR>
	ST7735_fillScreen(colBlack);
102d9c3c:	e3a00000 	mov	r0, #0
102d9c40:	ebfffc74 	bl	102d8e18 <ST7735_fillScreen>
	loadBitmapToLCD(WELCOME_LOGO,2);
102d9c44:	e3a00001 	mov	r0, #1
102d9c48:	e3a01002 	mov	r1, #2
}
102d9c4c:	e8bd4008 	pop	{r3, lr}

void Init_display(void)
{
	ST7735_initR();
	ST7735_fillScreen(colBlack);
	loadBitmapToLCD(WELCOME_LOGO,2);
102d9c50:	eafffe4c 	b	102d9588 <loadBitmapToLCD>

102d9c54 <Fill_Screen_Color>:
}


void Fill_Screen_Color(u32 color)
{
	ST7735_fillScreen(color);
102d9c54:	eafffc6f 	b	102d8e18 <ST7735_fillScreen>

102d9c58 <Display_Water_Balance_on_LCD>:
}

void Display_Water_Balance_on_LCD(bool Schedule_Data_Publish)
{
102d9c58:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102d9c5c:	e1a06000 	mov	r6, r0
	ST7735_setRotation(0x60);
	ST7735_drawString_for_BALANCE_align_Center(45, water_balance_buffer_last, colBlack);  // Start point Right - top // Erase last message string
	if(water_balance<20)
102d9c60:	e59f5318 	ldr	r5, [pc, #792]	; 102d9f80 <Display_Water_Balance_on_LCD+0x328>
	ST7735_fillScreen(color);
}

void Display_Water_Balance_on_LCD(bool Schedule_Data_Publish)
{
	ST7735_setRotation(0x60);
102d9c64:	e3a00060 	mov	r0, #96	; 0x60
102d9c68:	ebfffc61 	bl	102d8df4 <ST7735_setRotation>
	ST7735_drawString_for_BALANCE_align_Center(45, water_balance_buffer_last, colBlack);  // Start point Right - top // Erase last message string
102d9c6c:	e3a0002d 	mov	r0, #45	; 0x2d
102d9c70:	e59f130c 	ldr	r1, [pc, #780]	; 102d9f84 <Display_Water_Balance_on_LCD+0x32c>
102d9c74:	e3a02000 	mov	r2, #0
102d9c78:	ebfffb5e 	bl	102d89f8 <ST7735_drawString_for_BALANCE_align_Center>
	if(water_balance<20)
102d9c7c:	e5953000 	ldr	r3, [r5]
102d9c80:	e3530013 	cmp	r3, #19
102d9c84:	9a000019 	bls	102d9cf0 <Display_Water_Balance_on_LCD+0x98>
		}
		Balance_in_green =0;
	}
	else
	{
		if(FLAG.TANK_STATUS_IS_FULL)
102d9c88:	e59f32f8 	ldr	r3, [pc, #760]	; 102d9f88 <Display_Water_Balance_on_LCD+0x330>
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colLawngreen, 1);  //Erase Tank Full message
102d9c8c:	e59f42f8 	ldr	r4, [pc, #760]	; 102d9f8c <Display_Water_Balance_on_LCD+0x334>
		}
		Balance_in_green =0;
	}
	else
	{
		if(FLAG.TANK_STATUS_IS_FULL)
102d9c90:	e5d33007 	ldrb	r3, [r3, #7]
102d9c94:	e3530000 	cmp	r3, #0
102d9c98:	1a000056 	bne	102d9df8 <Display_Water_Balance_on_LCD+0x1a0>
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colLawngreen, 1);  //Erase Tank Full message
		ST7735_drawString_for_BALANCE_align_Center(45, water_balance_buffer, colLawngreen);  // Start point Right - top
102d9c9c:	e3a0002d 	mov	r0, #45	; 0x2d
102d9ca0:	e59f12e8 	ldr	r1, [pc, #744]	; 102d9f90 <Display_Water_Balance_on_LCD+0x338>
102d9ca4:	e59f22e8 	ldr	r2, [pc, #744]	; 102d9f94 <Display_Water_Balance_on_LCD+0x33c>
102d9ca8:	ebfffb52 	bl	102d89f8 <ST7735_drawString_for_BALANCE_align_Center>
		if(!Balance_in_green)
102d9cac:	e5d4503a 	ldrb	r5, [r4, #58]	; 0x3a
102d9cb0:	e59f72d4 	ldr	r7, [pc, #724]	; 102d9f8c <Display_Water_Balance_on_LCD+0x334>
102d9cb4:	e3550000 	cmp	r5, #0
102d9cb8:	0a00002a 	beq	102d9d68 <Display_Water_Balance_on_LCD+0x110>
			ST7735_drawString_align_Center(90, LCD_Dislpay_Message[MESSAGE_LOW_BALANCE], colBlack, 1);  // Start point Right - top
			ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_RECHARGE], colBlack, 1);  // Start point Right - top

			Balance_in_green =1;
		}
		if(Schedule_Data_Publish)
102d9cbc:	e3560000 	cmp	r6, #0
		{
			// Send message to cloud ..
			PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_WATER_BALANCE;
102d9cc0:	159f32d0 	ldrne	r3, [pc, #720]	; 102d9f98 <Display_Water_Balance_on_LCD+0x340>
102d9cc4:	15932000 	ldrne	r2, [r3]
102d9cc8:	13822008 	orrne	r2, r2, #8
102d9ccc:	15832000 	strne	r2, [r3]
		}
		sendonetimelowbal = 0;
102d9cd0:	e3a03000 	mov	r3, #0
102d9cd4:	e5c43038 	strb	r3, [r4, #56]	; 0x38
		sendonetimezerobal = 0;
102d9cd8:	e5c43039 	strb	r3, [r4, #57]	; 0x39
	}
	strcpy(water_balance_buffer_last,water_balance_buffer);
102d9cdc:	e59f12ac 	ldr	r1, [pc, #684]	; 102d9f90 <Display_Water_Balance_on_LCD+0x338>
102d9ce0:	e59f32b4 	ldr	r3, [pc, #692]	; 102d9f9c <Display_Water_Balance_on_LCD+0x344>
102d9ce4:	e59f0298 	ldr	r0, [pc, #664]	; 102d9f84 <Display_Water_Balance_on_LCD+0x32c>
102d9ce8:	e12fff33 	blx	r3
102d9cec:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
{
	ST7735_setRotation(0x60);
	ST7735_drawString_for_BALANCE_align_Center(45, water_balance_buffer_last, colBlack);  // Start point Right - top // Erase last message string
	if(water_balance<20)
	{
		ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colBlack, 1);  // Start point Right - top
102d9cf0:	e59f4294 	ldr	r4, [pc, #660]	; 102d9f8c <Display_Water_Balance_on_LCD+0x334>
102d9cf4:	e59f72a4 	ldr	r7, [pc, #676]	; 102d9fa0 <Display_Water_Balance_on_LCD+0x348>
102d9cf8:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102d9cfc:	e3a00050 	mov	r0, #80	; 0x50
102d9d00:	e1a03183 	lsl	r3, r3, #3
102d9d04:	e2833001 	add	r3, r3, #1
102d9d08:	e0833103 	add	r3, r3, r3, lsl #2
102d9d0c:	e0831103 	add	r1, r3, r3, lsl #2
102d9d10:	e0871001 	add	r1, r7, r1
102d9d14:	e3a03001 	mov	r3, #1
102d9d18:	e3a02000 	mov	r2, #0
102d9d1c:	ebfffcc9 	bl	102d9048 <ST7735_drawString_align_Center>
		ST7735_drawString_for_BALANCE_align_Center(45, water_balance_buffer, colOrangeRed);  // Start point Right - top
102d9d20:	e59f227c 	ldr	r2, [pc, #636]	; 102d9fa4 <Display_Water_Balance_on_LCD+0x34c>
102d9d24:	e3a0002d 	mov	r0, #45	; 0x2d
102d9d28:	e59f1260 	ldr	r1, [pc, #608]	; 102d9f90 <Display_Water_Balance_on_LCD+0x338>
102d9d2c:	ebfffb31 	bl	102d89f8 <ST7735_drawString_for_BALANCE_align_Center>
		if(water_balance > 0 && water_balance < 20)
102d9d30:	e5953000 	ldr	r3, [r5]
102d9d34:	e2432001 	sub	r2, r3, #1
102d9d38:	e3520012 	cmp	r2, #18
102d9d3c:	9a000039 	bls	102d9e28 <Display_Water_Balance_on_LCD+0x1d0>
				}
				sendonetimelowbal = 1;
			}
			sendonetimezerobal = 0;
		}
		else if(0 == water_balance )
102d9d40:	e3530000 	cmp	r3, #0
102d9d44:	1a000004 	bne	102d9d5c <Display_Water_Balance_on_LCD+0x104>
		{
			if(!sendonetimezerobal)
102d9d48:	e5d45039 	ldrb	r5, [r4, #57]	; 0x39
102d9d4c:	e3550000 	cmp	r5, #0
102d9d50:	0a000062 	beq	102d9ee0 <Display_Water_Balance_on_LCD+0x288>
					// Send message to cloud
					PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_BAL_ZERO;
				}
				sendonetimezerobal = 1;
			}
			sendonetimelowbal = 0;
102d9d54:	e3a03000 	mov	r3, #0
102d9d58:	e5c43038 	strb	r3, [r4, #56]	; 0x38
		}
		Balance_in_green =0;
102d9d5c:	e3a03000 	mov	r3, #0
102d9d60:	e5c4303a 	strb	r3, [r4, #58]	; 0x3a
102d9d64:	eaffffdc 	b	102d9cdc <Display_Water_Balance_on_LCD+0x84>
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colLawngreen, 1);  //Erase Tank Full message
		ST7735_drawString_for_BALANCE_align_Center(45, water_balance_buffer, colLawngreen);  // Start point Right - top
		if(!Balance_in_green)
		{
			// clear water balance alarm messages
			ST7735_setRotation(0x60);
102d9d68:	e3a00060 	mov	r0, #96	; 0x60
102d9d6c:	ebfffc20 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString_align_Center(90, LCD_Dislpay_Message[MESSAGE_NO_BALANCE], colBlack, 1);  // Start point Right - top
102d9d70:	e5971034 	ldr	r1, [r7, #52]	; 0x34
102d9d74:	e59f8224 	ldr	r8, [pc, #548]	; 102d9fa0 <Display_Water_Balance_on_LCD+0x348>
102d9d78:	e1a01181 	lsl	r1, r1, #3
102d9d7c:	e2811002 	add	r1, r1, #2
102d9d80:	e0811101 	add	r1, r1, r1, lsl #2
102d9d84:	e0811101 	add	r1, r1, r1, lsl #2
102d9d88:	e3a0005a 	mov	r0, #90	; 0x5a
102d9d8c:	e0881001 	add	r1, r8, r1
102d9d90:	e1a02005 	mov	r2, r5
102d9d94:	e3a03001 	mov	r3, #1
102d9d98:	ebfffcaa 	bl	102d9048 <ST7735_drawString_align_Center>
			ST7735_drawString_align_Center(90, LCD_Dislpay_Message[MESSAGE_LOW_BALANCE], colBlack, 1);  // Start point Right - top
102d9d9c:	e5971034 	ldr	r1, [r7, #52]	; 0x34
102d9da0:	e3a0005a 	mov	r0, #90	; 0x5a
102d9da4:	e1a01181 	lsl	r1, r1, #3
102d9da8:	e2811003 	add	r1, r1, #3
102d9dac:	e0811101 	add	r1, r1, r1, lsl #2
102d9db0:	e0811101 	add	r1, r1, r1, lsl #2
102d9db4:	e0881001 	add	r1, r8, r1
102d9db8:	e1a02005 	mov	r2, r5
102d9dbc:	e3a03001 	mov	r3, #1
102d9dc0:	ebfffca0 	bl	102d9048 <ST7735_drawString_align_Center>
			ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_RECHARGE], colBlack, 1);  // Start point Right - top
102d9dc4:	e5971034 	ldr	r1, [r7, #52]	; 0x34
102d9dc8:	e3a03001 	mov	r3, #1
102d9dcc:	e1a01181 	lsl	r1, r1, #3
102d9dd0:	e2811004 	add	r1, r1, #4
102d9dd4:	e0811101 	add	r1, r1, r1, lsl #2
102d9dd8:	e0811101 	add	r1, r1, r1, lsl #2
102d9ddc:	e3a00069 	mov	r0, #105	; 0x69
102d9de0:	e0881001 	add	r1, r8, r1
102d9de4:	e1a02005 	mov	r2, r5
102d9de8:	ebfffc96 	bl	102d9048 <ST7735_drawString_align_Center>

			Balance_in_green =1;
102d9dec:	e3a03001 	mov	r3, #1
102d9df0:	e5c7303a 	strb	r3, [r7, #58]	; 0x3a
102d9df4:	eaffffb0 	b	102d9cbc <Display_Water_Balance_on_LCD+0x64>
		Balance_in_green =0;
	}
	else
	{
		if(FLAG.TANK_STATUS_IS_FULL)
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colLawngreen, 1);  //Erase Tank Full message
102d9df8:	e5941034 	ldr	r1, [r4, #52]	; 0x34
102d9dfc:	e59f319c 	ldr	r3, [pc, #412]	; 102d9fa0 <Display_Water_Balance_on_LCD+0x348>
102d9e00:	e1a01181 	lsl	r1, r1, #3
102d9e04:	e2811001 	add	r1, r1, #1
102d9e08:	e0811101 	add	r1, r1, r1, lsl #2
102d9e0c:	e0811101 	add	r1, r1, r1, lsl #2
102d9e10:	e0831001 	add	r1, r3, r1
102d9e14:	e3a00050 	mov	r0, #80	; 0x50
102d9e18:	e59f2174 	ldr	r2, [pc, #372]	; 102d9f94 <Display_Water_Balance_on_LCD+0x33c>
102d9e1c:	e3a03001 	mov	r3, #1
102d9e20:	ebfffc88 	bl	102d9048 <ST7735_drawString_align_Center>
102d9e24:	eaffff9c 	b	102d9c9c <Display_Water_Balance_on_LCD+0x44>
	{
		ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colBlack, 1);  // Start point Right - top
		ST7735_drawString_for_BALANCE_align_Center(45, water_balance_buffer, colOrangeRed);  // Start point Right - top
		if(water_balance > 0 && water_balance < 20)
		{
			if(!sendonetimelowbal)
102d9e28:	e5d45038 	ldrb	r5, [r4, #56]	; 0x38
102d9e2c:	e3550000 	cmp	r5, #0
102d9e30:	0a000002 	beq	102d9e40 <Display_Water_Balance_on_LCD+0x1e8>
					// Send message to cloud
					PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_BAL_LOW;
				}
				sendonetimelowbal = 1;
			}
			sendonetimezerobal = 0;
102d9e34:	e3a03000 	mov	r3, #0
102d9e38:	e5c43039 	strb	r3, [r4, #57]	; 0x39
102d9e3c:	eaffffc6 	b	102d9d5c <Display_Water_Balance_on_LCD+0x104>
		if(water_balance > 0 && water_balance < 20)
		{
			if(!sendonetimelowbal)
			{
				// Display Low Balance message
				ST7735_setRotation(0x60);
102d9e40:	e3a00060 	mov	r0, #96	; 0x60
102d9e44:	ebfffbea 	bl	102d8df4 <ST7735_setRotation>
				ST7735_drawString_align_Center(90, LCD_Dislpay_Message[MESSAGE_NO_BALANCE], colBlack, 1);  // Start point Right - top
102d9e48:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102d9e4c:	e3a0005a 	mov	r0, #90	; 0x5a
102d9e50:	e1a03183 	lsl	r3, r3, #3
102d9e54:	e2833002 	add	r3, r3, #2
102d9e58:	e0833103 	add	r3, r3, r3, lsl #2
102d9e5c:	e0831103 	add	r1, r3, r3, lsl #2
102d9e60:	e0871001 	add	r1, r7, r1
102d9e64:	e1a02005 	mov	r2, r5
102d9e68:	e3a03001 	mov	r3, #1
102d9e6c:	ebfffc75 	bl	102d9048 <ST7735_drawString_align_Center>
				ST7735_drawString_align_Center(90, LCD_Dislpay_Message[MESSAGE_LOW_BALANCE], colOrangeRed, 1);  // Start point Right - top
102d9e70:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102d9e74:	e3a0005a 	mov	r0, #90	; 0x5a
102d9e78:	e1a03183 	lsl	r3, r3, #3
102d9e7c:	e2833003 	add	r3, r3, #3
102d9e80:	e0833103 	add	r3, r3, r3, lsl #2
102d9e84:	e0831103 	add	r1, r3, r3, lsl #2
102d9e88:	e0871001 	add	r1, r7, r1
102d9e8c:	e59f2110 	ldr	r2, [pc, #272]	; 102d9fa4 <Display_Water_Balance_on_LCD+0x34c>
102d9e90:	e3a03001 	mov	r3, #1
102d9e94:	ebfffc6b 	bl	102d9048 <ST7735_drawString_align_Center>
				ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_RECHARGE], colOrangeRed, 1);  // Start point Right - top
102d9e98:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102d9e9c:	e59f2100 	ldr	r2, [pc, #256]	; 102d9fa4 <Display_Water_Balance_on_LCD+0x34c>
102d9ea0:	e1a03183 	lsl	r3, r3, #3
102d9ea4:	e2833004 	add	r3, r3, #4
102d9ea8:	e0833103 	add	r3, r3, r3, lsl #2
102d9eac:	e0831103 	add	r1, r3, r3, lsl #2
102d9eb0:	e3a00069 	mov	r0, #105	; 0x69
102d9eb4:	e3a03001 	mov	r3, #1
102d9eb8:	e0871001 	add	r1, r7, r1
102d9ebc:	ebfffc61 	bl	102d9048 <ST7735_drawString_align_Center>

				if(Schedule_Data_Publish)
102d9ec0:	e3560000 	cmp	r6, #0
				{
					// Send message to cloud
					PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_BAL_LOW;
102d9ec4:	159f30cc 	ldrne	r3, [pc, #204]	; 102d9f98 <Display_Water_Balance_on_LCD+0x340>
102d9ec8:	15932000 	ldrne	r2, [r3]
102d9ecc:	13822080 	orrne	r2, r2, #128	; 0x80
102d9ed0:	15832000 	strne	r2, [r3]
				}
				sendonetimelowbal = 1;
102d9ed4:	e3a03001 	mov	r3, #1
102d9ed8:	e5c43038 	strb	r3, [r4, #56]	; 0x38
102d9edc:	eaffffd4 	b	102d9e34 <Display_Water_Balance_on_LCD+0x1dc>
		else if(0 == water_balance )
		{
			if(!sendonetimezerobal)
			{
				// Display No Balance message
				ST7735_setRotation(0x60);
102d9ee0:	e3a00060 	mov	r0, #96	; 0x60
102d9ee4:	ebfffbc2 	bl	102d8df4 <ST7735_setRotation>
				ST7735_drawString_align_Center(90, LCD_Dislpay_Message[MESSAGE_LOW_BALANCE], colBlack, 1);  // Start point Right - top
102d9ee8:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102d9eec:	e3a0005a 	mov	r0, #90	; 0x5a
102d9ef0:	e1a03183 	lsl	r3, r3, #3
102d9ef4:	e2833003 	add	r3, r3, #3
102d9ef8:	e0833103 	add	r3, r3, r3, lsl #2
102d9efc:	e0831103 	add	r1, r3, r3, lsl #2
102d9f00:	e0871001 	add	r1, r7, r1
102d9f04:	e1a02005 	mov	r2, r5
102d9f08:	e3a03001 	mov	r3, #1
102d9f0c:	ebfffc4d 	bl	102d9048 <ST7735_drawString_align_Center>
				ST7735_drawString_align_Center(90, LCD_Dislpay_Message[MESSAGE_NO_BALANCE], colOrangeRed, 1);  // Start point Right - top
102d9f10:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102d9f14:	e3a0005a 	mov	r0, #90	; 0x5a
102d9f18:	e1a03183 	lsl	r3, r3, #3
102d9f1c:	e2833002 	add	r3, r3, #2
102d9f20:	e0833103 	add	r3, r3, r3, lsl #2
102d9f24:	e0831103 	add	r1, r3, r3, lsl #2
102d9f28:	e0871001 	add	r1, r7, r1
102d9f2c:	e59f2070 	ldr	r2, [pc, #112]	; 102d9fa4 <Display_Water_Balance_on_LCD+0x34c>
102d9f30:	e3a03001 	mov	r3, #1
102d9f34:	ebfffc43 	bl	102d9048 <ST7735_drawString_align_Center>
				ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_RECHARGE], colOrangeRed, 1);  // Start point Right - top
102d9f38:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102d9f3c:	e59f2060 	ldr	r2, [pc, #96]	; 102d9fa4 <Display_Water_Balance_on_LCD+0x34c>
102d9f40:	e1a03183 	lsl	r3, r3, #3
102d9f44:	e2833004 	add	r3, r3, #4
102d9f48:	e0833103 	add	r3, r3, r3, lsl #2
102d9f4c:	e0831103 	add	r1, r3, r3, lsl #2
102d9f50:	e3a00069 	mov	r0, #105	; 0x69
102d9f54:	e3a03001 	mov	r3, #1
102d9f58:	e0871001 	add	r1, r7, r1
102d9f5c:	ebfffc39 	bl	102d9048 <ST7735_drawString_align_Center>

				if(Schedule_Data_Publish)
102d9f60:	e3560000 	cmp	r6, #0
				{
					// Send message to cloud
					PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_BAL_ZERO;
102d9f64:	159f302c 	ldrne	r3, [pc, #44]	; 102d9f98 <Display_Water_Balance_on_LCD+0x340>
102d9f68:	15932000 	ldrne	r2, [r3]
102d9f6c:	13822c01 	orrne	r2, r2, #256	; 0x100
102d9f70:	15832000 	strne	r2, [r3]
				}
				sendonetimezerobal = 1;
102d9f74:	e3a03001 	mov	r3, #1
102d9f78:	e5c43039 	strb	r3, [r4, #57]	; 0x39
102d9f7c:	eaffff74 	b	102d9d54 <Display_Water_Balance_on_LCD+0xfc>
102d9f80:	f03d5bf4 	.word	0xf03d5bf4
102d9f84:	f03da588 	.word	0xf03da588
102d9f88:	f03da5f0 	.word	0xf03da5f0
102d9f8c:	f03d64c4 	.word	0xf03d64c4
102d9f90:	f03da518 	.word	0xf03da518
102d9f94:	00007fe0 	.word	0x00007fe0
102d9f98:	f03da598 	.word	0xf03da598
102d9f9c:	102dff55 	.word	0x102dff55
102d9fa0:	f03d4468 	.word	0xf03d4468
102d9fa4:	0000fa20 	.word	0x0000fa20

102d9fa8 <Init_Water_Balance_Screen>:
	}
	strcpy(water_balance_buffer_last,water_balance_buffer);
}

void Init_Water_Balance_Screen()
{
102d9fa8:	e92d4008 	push	{r3, lr}
}


void Fill_Screen_Color(u32 color)
{
	ST7735_fillScreen(color);
102d9fac:	e3a00000 	mov	r0, #0
102d9fb0:	ebfffb98 	bl	102d8e18 <ST7735_fillScreen>
}

void Init_Water_Balance_Screen()
{
	Fill_Screen_Color(colBlack);
	FLAG.WATER_SCREEN_INITIALIZED = TRUE;//Set flag to avoid unwanted message to appear on Unilever logo
102d9fb4:	e59f3050 	ldr	r3, [pc, #80]	; 102da00c <Init_Water_Balance_Screen+0x64>
102d9fb8:	e3a02001 	mov	r2, #1
	// Display "BALANCE" as a word
	ST7735_setRotation(0x60);
102d9fbc:	e3a00060 	mov	r0, #96	; 0x60
}

void Init_Water_Balance_Screen()
{
	Fill_Screen_Color(colBlack);
	FLAG.WATER_SCREEN_INITIALIZED = TRUE;//Set flag to avoid unwanted message to appear on Unilever logo
102d9fc0:	e5c32012 	strb	r2, [r3, #18]
	// Display "BALANCE" as a word
	ST7735_setRotation(0x60);
102d9fc4:	ebfffb8a 	bl	102d8df4 <ST7735_setRotation>
	//ST7735_drawLine(0 , 20, 160, 20,colDarkSlateGray);
	ST7735_drawString_for_BALANCE_align_Center(25, LCD_Dislpay_Message[MESSAGE_BALANCE], colWhite);  // Start point Right - top
102d9fc8:	e59f3040 	ldr	r3, [pc, #64]	; 102da010 <Init_Water_Balance_Screen+0x68>
102d9fcc:	e3a00019 	mov	r0, #25
102d9fd0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
102d9fd4:	e59f2038 	ldr	r2, [pc, #56]	; 102da014 <Init_Water_Balance_Screen+0x6c>
102d9fd8:	e1a01283 	lsl	r1, r3, #5
102d9fdc:	e0811183 	add	r1, r1, r3, lsl #3
102d9fe0:	e59f3030 	ldr	r3, [pc, #48]	; 102da018 <Init_Water_Balance_Screen+0x70>
102d9fe4:	e0811101 	add	r1, r1, r1, lsl #2
102d9fe8:	e0831001 	add	r1, r3, r1
102d9fec:	ebfffa81 	bl	102d89f8 <ST7735_drawString_for_BALANCE_align_Center>
	//ST7735_setRotation(0x0); // Start point Left - top
	//ST7735_fillRoundRect(60, 125, 25, 16, 3, colAqua);
	//ST7735_fillRect(85, 130, 6, 6, colAqua);

	//Finally show water balance string
	Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_STRING_VALUE);
102d9ff0:	e59f1024 	ldr	r1, [pc, #36]	; 102da01c <Init_Water_Balance_Screen+0x74>
102d9ff4:	e3a02002 	mov	r2, #2
102d9ff8:	e3a03016 	mov	r3, #22
102d9ffc:	e59fc01c 	ldr	ip, [pc, #28]	; 102da020 <Init_Water_Balance_Screen+0x78>
102da000:	e3a00003 	mov	r0, #3
102da004:	e12fff3c 	blx	ip
102da008:	e8bd8008 	pop	{r3, pc}
102da00c:	f03da5f0 	.word	0xf03da5f0
102da010:	f03d64c4 	.word	0xf03d64c4
102da014:	0000ffff 	.word	0x0000ffff
102da018:	f03d4468 	.word	0xf03d4468
102da01c:	000010c8 	.word	0x000010c8
102da020:	102e5cb4 	.word	0x102e5cb4

102da024 <display_please_wait>:
}

void display_please_wait(void)
{
102da024:	e92d4010 	push	{r4, lr}
	ST7735_setRotation(0x60);
102da028:	e3a00060 	mov	r0, #96	; 0x60
102da02c:	ebfffb70 	bl	102d8df4 <ST7735_setRotation>
	ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_WAIT], colWhite, 1);  // Start point Right - top
102da030:	e59f302c 	ldr	r3, [pc, #44]	; 102da064 <display_please_wait+0x40>
102da034:	e3a00069 	mov	r0, #105	; 0x69
102da038:	e5931034 	ldr	r1, [r3, #52]	; 0x34
102da03c:	e59f3024 	ldr	r3, [pc, #36]	; 102da068 <display_please_wait+0x44>
102da040:	e1a01181 	lsl	r1, r1, #3
102da044:	e2811005 	add	r1, r1, #5
102da048:	e0811101 	add	r1, r1, r1, lsl #2
102da04c:	e0811101 	add	r1, r1, r1, lsl #2
102da050:	e0831001 	add	r1, r3, r1
102da054:	e3a03001 	mov	r3, #1
102da058:	e59f200c 	ldr	r2, [pc, #12]	; 102da06c <display_please_wait+0x48>
}
102da05c:	e8bd4010 	pop	{r4, lr}
}

void display_please_wait(void)
{
	ST7735_setRotation(0x60);
	ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_WAIT], colWhite, 1);  // Start point Right - top
102da060:	eafffbf8 	b	102d9048 <ST7735_drawString_align_Center>
102da064:	f03d64c4 	.word	0xf03d64c4
102da068:	f03d4468 	.word	0xf03d4468
102da06c:	0000ffff 	.word	0x0000ffff

102da070 <display_FW_Version_Info>:
}
void display_FW_Version_Info()
{
102da070:	e92d4010 	push	{r4, lr}
	Ql_sprintf((char *)buffer,"PUREIT VERSION %d.%d",FW_Version_Major_COMM,FW_Version_Minor_COMM);//Display version information
102da074:	e59f0064 	ldr	r0, [pc, #100]	; 102da0e0 <display_FW_Version_Info+0x70>
102da078:	e59f4064 	ldr	r4, [pc, #100]	; 102da0e4 <display_FW_Version_Info+0x74>
102da07c:	e590c000 	ldr	ip, [r0]
102da080:	e59f1060 	ldr	r1, [pc, #96]	; 102da0e8 <display_FW_Version_Info+0x78>
102da084:	e3a02000 	mov	r2, #0
102da088:	e3a03004 	mov	r3, #4
102da08c:	e1a00004 	mov	r0, r4
102da090:	e12fff3c 	blx	ip
	ST7735_setRotation(0x60);
102da094:	e3a00060 	mov	r0, #96	; 0x60
102da098:	ebfffb55 	bl	102d8df4 <ST7735_setRotation>
	ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_WAIT], colBlack, 1);  // Start point Right - top
102da09c:	e5941034 	ldr	r1, [r4, #52]	; 0x34
102da0a0:	e59f3044 	ldr	r3, [pc, #68]	; 102da0ec <display_FW_Version_Info+0x7c>
102da0a4:	e1a01181 	lsl	r1, r1, #3
102da0a8:	e2811005 	add	r1, r1, #5
102da0ac:	e0811101 	add	r1, r1, r1, lsl #2
102da0b0:	e0811101 	add	r1, r1, r1, lsl #2
102da0b4:	e0831001 	add	r1, r3, r1
102da0b8:	e3a00069 	mov	r0, #105	; 0x69
102da0bc:	e3a02000 	mov	r2, #0
102da0c0:	e3a03001 	mov	r3, #1
102da0c4:	ebfffbdf 	bl	102d9048 <ST7735_drawString_align_Center>
	ST7735_drawString_align_Center(105, (char *)buffer, colWhite, 1);  // Start point Right - top
102da0c8:	e3a00069 	mov	r0, #105	; 0x69
102da0cc:	e1a01004 	mov	r1, r4
102da0d0:	e3a03001 	mov	r3, #1
102da0d4:	e59f2014 	ldr	r2, [pc, #20]	; 102da0f0 <display_FW_Version_Info+0x80>
}
102da0d8:	e8bd4010 	pop	{r4, lr}
void display_FW_Version_Info()
{
	Ql_sprintf((char *)buffer,"PUREIT VERSION %d.%d",FW_Version_Major_COMM,FW_Version_Minor_COMM);//Display version information
	ST7735_setRotation(0x60);
	ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_WAIT], colBlack, 1);  // Start point Right - top
	ST7735_drawString_align_Center(105, (char *)buffer, colWhite, 1);  // Start point Right - top
102da0dc:	eafffbd9 	b	102d9048 <ST7735_drawString_align_Center>
102da0e0:	f03de540 	.word	0xf03de540
102da0e4:	f03d64c4 	.word	0xf03d64c4
102da0e8:	102ef940 	.word	0x102ef940
102da0ec:	f03d4468 	.word	0xf03d4468
102da0f0:	0000ffff 	.word	0x0000ffff

102da0f4 <repaint_water_balance_screen>:
}
void repaint_water_balance_screen(void)
{
	if(FLAG.DIGNOSTIC_MODE == FALSE)
102da0f4:	e59f3190 	ldr	r3, [pc, #400]	; 102da28c <repaint_water_balance_screen+0x198>
	ST7735_setRotation(0x60);
	ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_WAIT], colBlack, 1);  // Start point Right - top
	ST7735_drawString_align_Center(105, (char *)buffer, colWhite, 1);  // Start point Right - top
}
void repaint_water_balance_screen(void)
{
102da0f8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	if(FLAG.DIGNOSTIC_MODE == FALSE)
102da0fc:	e5d3400a 	ldrb	r4, [r3, #10]
	ST7735_setRotation(0x60);
	ST7735_drawString_align_Center(105, LCD_Dislpay_Message[MESSAGE_PLEASE_WAIT], colBlack, 1);  // Start point Right - top
	ST7735_drawString_align_Center(105, (char *)buffer, colWhite, 1);  // Start point Right - top
}
void repaint_water_balance_screen(void)
{
102da100:	e24dd00c 	sub	sp, sp, #12
	if(FLAG.DIGNOSTIC_MODE == FALSE)
102da104:	e3540000 	cmp	r4, #0
102da108:	1a00005d 	bne	102da284 <repaint_water_balance_screen+0x190>
	{
		// Display "BALANCE" as a word
		ST7735_setRotation(0x60);
		ST7735_drawString_for_BALANCE_align_Center(25, LCD_Dislpay_Message[LAST_MESSAGE_BALANCE], colBlack);  //Erase last message
102da10c:	e59f517c 	ldr	r5, [pc, #380]	; 102da290 <repaint_water_balance_screen+0x19c>
void repaint_water_balance_screen(void)
{
	if(FLAG.DIGNOSTIC_MODE == FALSE)
	{
		// Display "BALANCE" as a word
		ST7735_setRotation(0x60);
102da110:	e3a00060 	mov	r0, #96	; 0x60
102da114:	ebfffb36 	bl	102d8df4 <ST7735_setRotation>
		ST7735_drawString_for_BALANCE_align_Center(25, LCD_Dislpay_Message[LAST_MESSAGE_BALANCE], colBlack);  //Erase last message
102da118:	e595303c 	ldr	r3, [r5, #60]	; 0x3c
102da11c:	e59f6170 	ldr	r6, [pc, #368]	; 102da294 <repaint_water_balance_screen+0x1a0>
102da120:	e1a01283 	lsl	r1, r3, #5
102da124:	e0811183 	add	r1, r1, r3, lsl #3
102da128:	e0811101 	add	r1, r1, r1, lsl #2
102da12c:	e3a00019 	mov	r0, #25
102da130:	e0861001 	add	r1, r6, r1
102da134:	e1a02004 	mov	r2, r4
102da138:	ebfffa2e 	bl	102d89f8 <ST7735_drawString_for_BALANCE_align_Center>
		ST7735_drawString_for_BALANCE_align_Center(25, LCD_Dislpay_Message[MESSAGE_BALANCE], colWhite);  // repaint in new language
102da13c:	e5953034 	ldr	r3, [r5, #52]	; 0x34
102da140:	e59f2150 	ldr	r2, [pc, #336]	; 102da298 <repaint_water_balance_screen+0x1a4>
102da144:	e1a01283 	lsl	r1, r3, #5
102da148:	e0811183 	add	r1, r1, r3, lsl #3
102da14c:	e0811101 	add	r1, r1, r1, lsl #2
102da150:	e0861001 	add	r1, r6, r1
102da154:	e3a00019 	mov	r0, #25
102da158:	ebfffa26 	bl	102d89f8 <ST7735_drawString_for_BALANCE_align_Center>
		sendonetimelowbal = 0;
		sendonetimezerobal = 0;
		Balance_in_green = 0;

		//Erase last water balance related warnings
		ST7735_setRotation(0x60);
102da15c:	e3a00060 	mov	r0, #96	; 0x60
		ST7735_setRotation(0x60);
		ST7735_drawString_for_BALANCE_align_Center(25, LCD_Dislpay_Message[LAST_MESSAGE_BALANCE], colBlack);  //Erase last message
		ST7735_drawString_for_BALANCE_align_Center(25, LCD_Dislpay_Message[MESSAGE_BALANCE], colWhite);  // repaint in new language

		//Now update the water balance and associated messages.
		sendonetimelowbal = 0;
102da160:	e5c54038 	strb	r4, [r5, #56]	; 0x38
		sendonetimezerobal = 0;
102da164:	e5c54039 	strb	r4, [r5, #57]	; 0x39
		Balance_in_green = 0;
102da168:	e5c5403a 	strb	r4, [r5, #58]	; 0x3a

		//Erase last water balance related warnings
		ST7735_setRotation(0x60);
102da16c:	ebfffb20 	bl	102d8df4 <ST7735_setRotation>
		ST7735_drawString_align_Center(90, LCD_Dislpay_Message[LAST_MESSAGE_NO_BALANCE], colBlack, 1);
102da170:	e595103c 	ldr	r1, [r5, #60]	; 0x3c
102da174:	e3a0005a 	mov	r0, #90	; 0x5a
102da178:	e1a01181 	lsl	r1, r1, #3
102da17c:	e2811002 	add	r1, r1, #2
102da180:	e0811101 	add	r1, r1, r1, lsl #2
102da184:	e0811101 	add	r1, r1, r1, lsl #2
102da188:	e0861001 	add	r1, r6, r1
102da18c:	e1a02004 	mov	r2, r4
102da190:	e3a03001 	mov	r3, #1
102da194:	ebfffbab 	bl	102d9048 <ST7735_drawString_align_Center>
		ST7735_drawString_align_Center(90, LCD_Dislpay_Message[LAST_MESSAGE_LOW_BALANCE], colBlack, 1);
102da198:	e595103c 	ldr	r1, [r5, #60]	; 0x3c
102da19c:	e3a0005a 	mov	r0, #90	; 0x5a
102da1a0:	e1a01181 	lsl	r1, r1, #3
102da1a4:	e2811003 	add	r1, r1, #3
102da1a8:	e0811101 	add	r1, r1, r1, lsl #2
102da1ac:	e0811101 	add	r1, r1, r1, lsl #2
102da1b0:	e0861001 	add	r1, r6, r1
102da1b4:	e1a02004 	mov	r2, r4
102da1b8:	e3a03001 	mov	r3, #1
102da1bc:	ebfffba1 	bl	102d9048 <ST7735_drawString_align_Center>
		ST7735_drawString_align_Center(105, LCD_Dislpay_Message[LAST_MESSAGE_PLEASE_RECHARGE], colBlack, 1);
102da1c0:	e595103c 	ldr	r1, [r5, #60]	; 0x3c
102da1c4:	e3a00069 	mov	r0, #105	; 0x69
102da1c8:	e1a01181 	lsl	r1, r1, #3
102da1cc:	e2811004 	add	r1, r1, #4
102da1d0:	e0811101 	add	r1, r1, r1, lsl #2
102da1d4:	e0811101 	add	r1, r1, r1, lsl #2
102da1d8:	e0861001 	add	r1, r6, r1
102da1dc:	e1a02004 	mov	r2, r4
102da1e0:	e3a03001 	mov	r3, #1
102da1e4:	ebfffb97 	bl	102d9048 <ST7735_drawString_align_Center>
		ST7735_drawString_align_Center(80, LCD_Dislpay_Message[LAST_MESSAGE_TANK_FULL], colBlack, 1);  //Erase Tank Full message
102da1e8:	e595103c 	ldr	r1, [r5, #60]	; 0x3c
102da1ec:	e1a02004 	mov	r2, r4
102da1f0:	e1a01181 	lsl	r1, r1, #3
102da1f4:	e2811001 	add	r1, r1, #1
102da1f8:	e0811101 	add	r1, r1, r1, lsl #2
102da1fc:	e0811101 	add	r1, r1, r1, lsl #2
102da200:	e0861001 	add	r1, r6, r1
102da204:	e3a03001 	mov	r3, #1
102da208:	e3a00050 	mov	r0, #80	; 0x50
102da20c:	ebfffb8d 	bl	102d9048 <ST7735_drawString_align_Center>
		Display_Water_Balance_on_LCD(0); // Just to repaint water balance related warings if any without publish to cloud
102da210:	e1a00004 	mov	r0, r4
102da214:	ebfffe8f 	bl	102d9c58 <Display_Water_Balance_on_LCD>

		//Erase last Heater related messages
		ST7735_drawString(5, 120, LCD_Dislpay_Message[LAST_MESSAGE_HOT_WATER_READY], colBlack, 1);
102da218:	e595203c 	ldr	r2, [r5, #60]	; 0x3c
102da21c:	e3a07001 	mov	r7, #1
102da220:	e1a02182 	lsl	r2, r2, #3
102da224:	e2822007 	add	r2, r2, #7
102da228:	e0822102 	add	r2, r2, r2, lsl #2
102da22c:	e0822102 	add	r2, r2, r2, lsl #2
102da230:	e3a00005 	mov	r0, #5
102da234:	e3a01078 	mov	r1, #120	; 0x78
102da238:	e0862002 	add	r2, r6, r2
102da23c:	e1a03004 	mov	r3, r4
102da240:	e58d7000 	str	r7, [sp]
102da244:	ebfffb64 	bl	102d8fdc <ST7735_drawString>
		ST7735_drawString(5, 120, LCD_Dislpay_Message[LAST_MESSAGE_HEATING_ON], colBlack, 1); //Erase last Tank Full message// Start point Right - top
102da248:	e595203c 	ldr	r2, [r5, #60]	; 0x3c
102da24c:	e1a03004 	mov	r3, r4
102da250:	e1a02182 	lsl	r2, r2, #3
102da254:	e2822006 	add	r2, r2, #6
102da258:	e0822102 	add	r2, r2, r2, lsl #2
102da25c:	e0822102 	add	r2, r2, r2, lsl #2
102da260:	e0862002 	add	r2, r6, r2
102da264:	e58d7000 	str	r7, [sp]
102da268:	e3a00005 	mov	r0, #5
102da26c:	e3a01078 	mov	r1, #120	; 0x78
102da270:	ebfffb59 	bl	102d8fdc <ST7735_drawString>

		IPC_CMD_REQ_source |= SCHEDULE_IPC_GET_HEATER_STATUS_DATA_CMD; // Just to refresh the hear status
102da274:	e59f3020 	ldr	r3, [pc, #32]	; 102da29c <repaint_water_balance_screen+0x1a8>
102da278:	e5932000 	ldr	r2, [r3]
102da27c:	e3822080 	orr	r2, r2, #128	; 0x80
102da280:	e5832000 	str	r2, [r3]
	}
}
102da284:	e28dd00c 	add	sp, sp, #12
102da288:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
102da28c:	f03da5f0 	.word	0xf03da5f0
102da290:	f03d64c4 	.word	0xf03d64c4
102da294:	f03d4468 	.word	0xf03d4468
102da298:	0000ffff 	.word	0x0000ffff
102da29c:	f03da514 	.word	0xf03da514

102da2a0 <display_on_tftlcd>:
void display_on_tftlcd(u32 dparam)
{
102da2a0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	u8 i =0;

	if(FLAG.DIGNOSTIC_MODE == TRUE) // Belwo are the messages grouped together for diagnostic screen)
102da2a4:	e59f4de4 	ldr	r4, [pc, #3556]	; 102db090 <display_on_tftlcd+0xdf0>

		IPC_CMD_REQ_source |= SCHEDULE_IPC_GET_HEATER_STATUS_DATA_CMD; // Just to refresh the hear status
	}
}
void display_on_tftlcd(u32 dparam)
{
102da2a8:	e24dd00c 	sub	sp, sp, #12
	u8 i =0;

	if(FLAG.DIGNOSTIC_MODE == TRUE) // Belwo are the messages grouped together for diagnostic screen)
102da2ac:	e5d4300a 	ldrb	r3, [r4, #10]
102da2b0:	e3530001 	cmp	r3, #1
102da2b4:	0a000012 	beq	102da304 <display_on_tftlcd+0x64>
			break;
		}
	}
	else //Messages on Main water balance screen
	{
		switch (dparam)
102da2b8:	e2403016 	sub	r3, r0, #22
102da2bc:	e353000e 	cmp	r3, #14
102da2c0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
102da2c4:	ea00003c 	b	102da3bc <display_on_tftlcd+0x11c>
102da2c8:	102da474 	.word	0x102da474
102da2cc:	102da484 	.word	0x102da484
102da2d0:	102da4c4 	.word	0x102da4c4
102da2d4:	102da3bc 	.word	0x102da3bc
102da2d8:	102da3bc 	.word	0x102da3bc
102da2dc:	102da3bc 	.word	0x102da3bc
102da2e0:	102da3bc 	.word	0x102da3bc
102da2e4:	102da3bc 	.word	0x102da3bc
102da2e8:	102da3bc 	.word	0x102da3bc
102da2ec:	102da3bc 	.word	0x102da3bc
102da2f0:	102da3bc 	.word	0x102da3bc
102da2f4:	102da3bc 	.word	0x102da3bc
102da2f8:	102da504 	.word	0x102da504
102da2fc:	102da578 	.word	0x102da578
102da300:	102da5e8 	.word	0x102da5e8
{
	u8 i =0;

	if(FLAG.DIGNOSTIC_MODE == TRUE) // Belwo are the messages grouped together for diagnostic screen)
	{
		switch(dparam)
102da304:	e2403007 	sub	r3, r0, #7
102da308:	e3530029 	cmp	r3, #41	; 0x29
102da30c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
102da310:	ea000029 	b	102da3bc <display_on_tftlcd+0x11c>
102da314:	102db234 	.word	0x102db234
102da318:	102db25c 	.word	0x102db25c
102da31c:	102db324 	.word	0x102db324
102da320:	102db34c 	.word	0x102db34c
102da324:	102db284 	.word	0x102db284
102da328:	102db2ac 	.word	0x102db2ac
102da32c:	102db2d4 	.word	0x102db2d4
102da330:	102db2fc 	.word	0x102db2fc
102da334:	102daf14 	.word	0x102daf14
102da338:	102daf3c 	.word	0x102daf3c
102da33c:	102da93c 	.word	0x102da93c
102da340:	102da964 	.word	0x102da964
102da344:	102da98c 	.word	0x102da98c
102da348:	102da9b4 	.word	0x102da9b4
102da34c:	102da3bc 	.word	0x102da3bc
102da350:	102da3bc 	.word	0x102da3bc
102da354:	102da3bc 	.word	0x102da3bc
102da358:	102da3bc 	.word	0x102da3bc
102da35c:	102da9dc 	.word	0x102da9dc
102da360:	102daa2c 	.word	0x102daa2c
102da364:	102daa7c 	.word	0x102daa7c
102da368:	102dab70 	.word	0x102dab70
102da36c:	102dabe8 	.word	0x102dabe8
102da370:	102dac64 	.word	0x102dac64
102da374:	102dad20 	.word	0x102dad20
102da378:	102da3bc 	.word	0x102da3bc
102da37c:	102da3bc 	.word	0x102da3bc
102da380:	102dad9c 	.word	0x102dad9c
102da384:	102dadc4 	.word	0x102dadc4
102da388:	102dadec 	.word	0x102dadec
102da38c:	102da3bc 	.word	0x102da3bc
102da390:	102da3bc 	.word	0x102da3bc
102da394:	102da3bc 	.word	0x102da3bc
102da398:	102da3bc 	.word	0x102da3bc
102da39c:	102dae14 	.word	0x102dae14
102da3a0:	102da3bc 	.word	0x102da3bc
102da3a4:	102daeac 	.word	0x102daeac
102da3a8:	102daf64 	.word	0x102daf64
102da3ac:	102dafc8 	.word	0x102dafc8
102da3b0:	102db02c 	.word	0x102db02c
102da3b4:	102db1d0 	.word	0x102db1d0
102da3b8:	102db374 	.word	0x102db374
			break;
		}
	}

	//Common Messages on Main water balance screen and Diagnostic screen
	switch (dparam)
102da3bc:	e350002a 	cmp	r0, #42	; 0x2a
102da3c0:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
102da3c4:	ea000069 	b	102da570 <display_on_tftlcd+0x2d0>
102da3c8:	102da658 	.word	0x102da658
102da3cc:	102da67c 	.word	0x102da67c
102da3d0:	102da664 	.word	0x102da664
102da3d4:	102da750 	.word	0x102da750
102da3d8:	102da73c 	.word	0x102da73c
102da3dc:	102da730 	.word	0x102da730
102da3e0:	102da68c 	.word	0x102da68c
102da3e4:	102da570 	.word	0x102da570
102da3e8:	102da570 	.word	0x102da570
102da3ec:	102da570 	.word	0x102da570
102da3f0:	102da570 	.word	0x102da570
102da3f4:	102da570 	.word	0x102da570
102da3f8:	102da570 	.word	0x102da570
102da3fc:	102da570 	.word	0x102da570
102da400:	102da570 	.word	0x102da570
102da404:	102da570 	.word	0x102da570
102da408:	102da570 	.word	0x102da570
102da40c:	102da570 	.word	0x102da570
102da410:	102da570 	.word	0x102da570
102da414:	102da570 	.word	0x102da570
102da418:	102da570 	.word	0x102da570
102da41c:	102da900 	.word	0x102da900
102da420:	102da570 	.word	0x102da570
102da424:	102da570 	.word	0x102da570
102da428:	102da570 	.word	0x102da570
102da42c:	102da570 	.word	0x102da570
102da430:	102da570 	.word	0x102da570
102da434:	102da570 	.word	0x102da570
102da438:	102da570 	.word	0x102da570
102da43c:	102da570 	.word	0x102da570
102da440:	102da570 	.word	0x102da570
102da444:	102da570 	.word	0x102da570
102da448:	102da8d8 	.word	0x102da8d8
102da44c:	102da8b0 	.word	0x102da8b0
102da450:	102da570 	.word	0x102da570
102da454:	102da570 	.word	0x102da570
102da458:	102da570 	.word	0x102da570
102da45c:	102da888 	.word	0x102da888
102da460:	102da844 	.word	0x102da844
102da464:	102da810 	.word	0x102da810
102da468:	102da780 	.word	0x102da780
102da46c:	102da570 	.word	0x102da570
102da470:	102da768 	.word	0x102da768
	else //Messages on Main water balance screen
	{
		switch (dparam)
		{
		case TFT_STATE_DRAW_STRING_VALUE:
			Display_Water_Balance_on_LCD(1); //Just to repaint water balance and related warings if any with publish to cloud
102da474:	e3a00001 	mov	r0, #1
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da478:	e28dd00c 	add	sp, sp, #12
102da47c:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
	else //Messages on Main water balance screen
	{
		switch (dparam)
		{
		case TFT_STATE_DRAW_STRING_VALUE:
			Display_Water_Balance_on_LCD(1); //Just to repaint water balance and related warings if any with publish to cloud
102da480:	eafffdf4 	b	102d9c58 <Display_Water_Balance_on_LCD>
			break;
		case TFT_STATE_DRAW_STRING_TANK_FULL:
			ST7735_setRotation(0x60);
102da484:	e3a00060 	mov	r0, #96	; 0x60
102da488:	ebfffa59 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colLawngreen, 1);  // Start point Right - top
102da48c:	e59f3d34 	ldr	r3, [pc, #3380]	; 102db1c8 <display_on_tftlcd+0xf28>
102da490:	e59f1bfc 	ldr	r1, [pc, #3068]	; 102db094 <display_on_tftlcd+0xdf4>
102da494:	e5933034 	ldr	r3, [r3, #52]	; 0x34
102da498:	e3a00050 	mov	r0, #80	; 0x50
102da49c:	e1a03183 	lsl	r3, r3, #3
102da4a0:	e2833001 	add	r3, r3, #1
102da4a4:	e0833103 	add	r3, r3, r3, lsl #2
102da4a8:	e0833103 	add	r3, r3, r3, lsl #2
102da4ac:	e0811003 	add	r1, r1, r3
102da4b0:	e3a03001 	mov	r3, #1
102da4b4:	e59f2bdc 	ldr	r2, [pc, #3036]	; 102db098 <display_on_tftlcd+0xdf8>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da4b8:	e28dd00c 	add	sp, sp, #12
102da4bc:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
		case TFT_STATE_DRAW_STRING_VALUE:
			Display_Water_Balance_on_LCD(1); //Just to repaint water balance and related warings if any with publish to cloud
			break;
		case TFT_STATE_DRAW_STRING_TANK_FULL:
			ST7735_setRotation(0x60);
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colLawngreen, 1);  // Start point Right - top
102da4c0:	eafffae0 	b	102d9048 <ST7735_drawString_align_Center>
			break;
		case TFT_STATE_CLEAR_STRING_TANK_FULL:
			ST7735_setRotation(0x60);
102da4c4:	e3a00060 	mov	r0, #96	; 0x60
102da4c8:	ebfffa49 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colBlack, 1);  // Start point Right - top
102da4cc:	e59f3cf4 	ldr	r3, [pc, #3316]	; 102db1c8 <display_on_tftlcd+0xf28>
102da4d0:	e59f1bbc 	ldr	r1, [pc, #3004]	; 102db094 <display_on_tftlcd+0xdf4>
102da4d4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
102da4d8:	e3a00050 	mov	r0, #80	; 0x50
102da4dc:	e1a03183 	lsl	r3, r3, #3
102da4e0:	e2833001 	add	r3, r3, #1
102da4e4:	e0833103 	add	r3, r3, r3, lsl #2
102da4e8:	e0833103 	add	r3, r3, r3, lsl #2
102da4ec:	e0811003 	add	r1, r1, r3
102da4f0:	e3a02000 	mov	r2, #0
102da4f4:	e3a03001 	mov	r3, #1
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da4f8:	e28dd00c 	add	sp, sp, #12
102da4fc:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
			ST7735_setRotation(0x60);
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colLawngreen, 1);  // Start point Right - top
			break;
		case TFT_STATE_CLEAR_STRING_TANK_FULL:
			ST7735_setRotation(0x60);
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colBlack, 1);  // Start point Right - top
102da500:	eafffad0 	b	102d9048 <ST7735_drawString_align_Center>
			break;
		case TFT_STATE_DRAW_STRING_HOTG:
			ST7735_setRotation(0x60);
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HEATING_ON], colBlack, 1);  // Start point Right - top
102da504:	e59f6cbc 	ldr	r6, [pc, #3260]	; 102db1c8 <display_on_tftlcd+0xf28>
		case TFT_STATE_CLEAR_STRING_TANK_FULL:
			ST7735_setRotation(0x60);
			ST7735_drawString_align_Center(80, LCD_Dislpay_Message[MESSAGE_TANK_FULL], colBlack, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_HOTG:
			ST7735_setRotation(0x60);
102da508:	e3a00060 	mov	r0, #96	; 0x60
102da50c:	ebfffa38 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HEATING_ON], colBlack, 1);  // Start point Right - top
102da510:	e5963034 	ldr	r3, [r6, #52]	; 0x34
102da514:	e59f4b78 	ldr	r4, [pc, #2936]	; 102db094 <display_on_tftlcd+0xdf4>
102da518:	e1a03183 	lsl	r3, r3, #3
102da51c:	e2833006 	add	r3, r3, #6
102da520:	e0833103 	add	r3, r3, r3, lsl #2
102da524:	e0832103 	add	r2, r3, r3, lsl #2
102da528:	e3a05001 	mov	r5, #1
102da52c:	e0842002 	add	r2, r4, r2
102da530:	e3a00005 	mov	r0, #5
102da534:	e3a01078 	mov	r1, #120	; 0x78
102da538:	e3a03000 	mov	r3, #0
102da53c:	e58d5000 	str	r5, [sp]
102da540:	ebfffaa5 	bl	102d8fdc <ST7735_drawString>
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HOT_WATER_READY], colLawngreen, 1);  // Start point Right - top
102da544:	e5963034 	ldr	r3, [r6, #52]	; 0x34
102da548:	e3a00005 	mov	r0, #5
102da54c:	e1a03183 	lsl	r3, r3, #3
102da550:	e2833007 	add	r3, r3, #7
102da554:	e0833103 	add	r3, r3, r3, lsl #2
102da558:	e0832103 	add	r2, r3, r3, lsl #2
102da55c:	e58d5000 	str	r5, [sp]
102da560:	e3a01078 	mov	r1, #120	; 0x78
102da564:	e0842002 	add	r2, r4, r2
102da568:	e59f3b28 	ldr	r3, [pc, #2856]	; 102db098 <display_on_tftlcd+0xdf8>
102da56c:	ebfffa9a 	bl	102d8fdc <ST7735_drawString>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da570:	e28dd00c 	add	sp, sp, #12
102da574:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HEATING_ON], colBlack, 1);  // Start point Right - top
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HOT_WATER_READY], colLawngreen, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_HOTR:
			ST7735_setRotation(0x60);
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HOT_WATER_READY], colBlack, 1);  // Start point Right - top
102da578:	e59f6c48 	ldr	r6, [pc, #3144]	; 102db1c8 <display_on_tftlcd+0xf28>
			ST7735_setRotation(0x60);
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HEATING_ON], colBlack, 1);  // Start point Right - top
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HOT_WATER_READY], colLawngreen, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_HOTR:
			ST7735_setRotation(0x60);
102da57c:	e3a00060 	mov	r0, #96	; 0x60
102da580:	ebfffa1b 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HOT_WATER_READY], colBlack, 1);  // Start point Right - top
102da584:	e5963034 	ldr	r3, [r6, #52]	; 0x34
102da588:	e59f4b04 	ldr	r4, [pc, #2820]	; 102db094 <display_on_tftlcd+0xdf4>
102da58c:	e1a03183 	lsl	r3, r3, #3
102da590:	e2833007 	add	r3, r3, #7
102da594:	e0833103 	add	r3, r3, r3, lsl #2
102da598:	e3a05001 	mov	r5, #1
102da59c:	e0832103 	add	r2, r3, r3, lsl #2
102da5a0:	e0842002 	add	r2, r4, r2
102da5a4:	e58d5000 	str	r5, [sp]
102da5a8:	e3a00005 	mov	r0, #5
102da5ac:	e3a01078 	mov	r1, #120	; 0x78
102da5b0:	e3a03000 	mov	r3, #0
102da5b4:	ebfffa88 	bl	102d8fdc <ST7735_drawString>
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HEATING_ON], colOrangeRed, 1);  // Start point Right - top
102da5b8:	e5963034 	ldr	r3, [r6, #52]	; 0x34
102da5bc:	e3a00005 	mov	r0, #5
102da5c0:	e1a03183 	lsl	r3, r3, #3
102da5c4:	e2833006 	add	r3, r3, #6
102da5c8:	e0833103 	add	r3, r3, r3, lsl #2
102da5cc:	e0832103 	add	r2, r3, r3, lsl #2
102da5d0:	e58d5000 	str	r5, [sp]
102da5d4:	e3a01078 	mov	r1, #120	; 0x78
102da5d8:	e0842002 	add	r2, r4, r2
102da5dc:	e59f3be8 	ldr	r3, [pc, #3048]	; 102db1cc <display_on_tftlcd+0xf2c>
102da5e0:	ebfffa7d 	bl	102d8fdc <ST7735_drawString>
			break;
102da5e4:	eaffffe1 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_CLEAR_STRING_HOT:
			ST7735_setRotation(0x60);
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HOT_WATER_READY], colBlack, 1);  // Start point Right - top
102da5e8:	e59f6bd8 	ldr	r6, [pc, #3032]	; 102db1c8 <display_on_tftlcd+0xf28>
			ST7735_setRotation(0x60);
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HOT_WATER_READY], colBlack, 1);  // Start point Right - top
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HEATING_ON], colOrangeRed, 1);  // Start point Right - top
			break;
		case TFT_STATE_CLEAR_STRING_HOT:
			ST7735_setRotation(0x60);
102da5ec:	e3a00060 	mov	r0, #96	; 0x60
102da5f0:	ebfff9ff 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HOT_WATER_READY], colBlack, 1);  // Start point Right - top
102da5f4:	e5963034 	ldr	r3, [r6, #52]	; 0x34
102da5f8:	e59f4a94 	ldr	r4, [pc, #2708]	; 102db094 <display_on_tftlcd+0xdf4>
102da5fc:	e1a03183 	lsl	r3, r3, #3
102da600:	e2833007 	add	r3, r3, #7
102da604:	e0833103 	add	r3, r3, r3, lsl #2
102da608:	e3a05001 	mov	r5, #1
102da60c:	e0832103 	add	r2, r3, r3, lsl #2
102da610:	e0842002 	add	r2, r4, r2
102da614:	e58d5000 	str	r5, [sp]
102da618:	e3a00005 	mov	r0, #5
102da61c:	e3a01078 	mov	r1, #120	; 0x78
102da620:	e3a03000 	mov	r3, #0
102da624:	ebfffa6c 	bl	102d8fdc <ST7735_drawString>
			ST7735_drawString(5, 120, LCD_Dislpay_Message[MESSAGE_HEATING_ON], colBlack, 1);  // Start point Right - top
102da628:	e5963034 	ldr	r3, [r6, #52]	; 0x34
102da62c:	e3a00005 	mov	r0, #5
102da630:	e1a03183 	lsl	r3, r3, #3
102da634:	e2833006 	add	r3, r3, #6
102da638:	e0833103 	add	r3, r3, r3, lsl #2
102da63c:	e0832103 	add	r2, r3, r3, lsl #2
102da640:	e58d5000 	str	r5, [sp]
102da644:	e3a01078 	mov	r1, #120	; 0x78
102da648:	e0842002 	add	r2, r4, r2
102da64c:	e3a03000 	mov	r3, #0
102da650:	ebfffa61 	bl	102d8fdc <ST7735_drawString>
			break;
102da654:	eaffffc5 	b	102da570 <display_on_tftlcd+0x2d0>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da658:	e28dd00c 	add	sp, sp, #12
102da65c:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
	{
	case TFT_STATE_DRAW_INIT_SCREEN:
		Init_Water_Balance_Screen();
		break;
	case TFT_STATE_DRAW_ANTENNA_SYMBOL:
		Refresh_Antenna_Symbol();
102da660:	eafffca8 	b	102d9908 <Refresh_Antenna_Symbol>
		break;
	case TFT_STATE_DRAW_CLOUD_CON_ON_SYMBOL:
		Refresh_Cloud_Connectivity_Symbol(2);
		break;
	case TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL:
		if(FLAG.AUTOPROVISIONING_COMPLETE == TRUE) // Only if Azure DPS is complete.
102da664:	e5d40017 	ldrb	r0, [r4, #23]
102da668:	e3500001 	cmp	r0, #1
102da66c:	1affffbf 	bne	102da570 <display_on_tftlcd+0x2d0>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da670:	e28dd00c 	add	sp, sp, #12
102da674:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
	case TFT_STATE_DRAW_CLOUD_CON_ON_SYMBOL:
		Refresh_Cloud_Connectivity_Symbol(2);
		break;
	case TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL:
		if(FLAG.AUTOPROVISIONING_COMPLETE == TRUE) // Only if Azure DPS is complete.
			Refresh_Cloud_Connectivity_Symbol(1);
102da678:	eafffd32 	b	102d9b48 <Refresh_Cloud_Connectivity_Symbol>
		break;
	case TFT_STATE_DRAW_ANTENNA_SYMBOL:
		Refresh_Antenna_Symbol();
		break;
	case TFT_STATE_DRAW_CLOUD_CON_ON_SYMBOL:
		Refresh_Cloud_Connectivity_Symbol(2);
102da67c:	e3a00002 	mov	r0, #2
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da680:	e28dd00c 	add	sp, sp, #12
102da684:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
		break;
	case TFT_STATE_DRAW_ANTENNA_SYMBOL:
		Refresh_Antenna_Symbol();
		break;
	case TFT_STATE_DRAW_CLOUD_CON_ON_SYMBOL:
		Refresh_Cloud_Connectivity_Symbol(2);
102da688:	eafffd2e 	b	102d9b48 <Refresh_Cloud_Connectivity_Symbol>
		ST7735_setRotation(0x0);
		ST7735_fillScreen(colBlack);
		break;
	case TFT_STATE_DRAW_SIM_NOT_PRESENT:
		ST7735_setRotation(0x0);
		ST7735_fillRect(110, 145, 15, 6, colWhiteSmoke);
102da68c:	e59f4a08 	ldr	r4, [pc, #2568]	; 102db09c <display_on_tftlcd+0xdfc>
	case TFT_STATE_CLEAR_SCREEN:
		ST7735_setRotation(0x0);
		ST7735_fillScreen(colBlack);
		break;
	case TFT_STATE_DRAW_SIM_NOT_PRESENT:
		ST7735_setRotation(0x0);
102da690:	e3a00000 	mov	r0, #0
102da694:	ebfff9d6 	bl	102d8df4 <ST7735_setRotation>
		ST7735_fillRect(110, 145, 15, 6, colWhiteSmoke);
102da698:	e58d4000 	str	r4, [sp]
102da69c:	e3a0006e 	mov	r0, #110	; 0x6e
102da6a0:	e3a01091 	mov	r1, #145	; 0x91
102da6a4:	e3a0200f 	mov	r2, #15
102da6a8:	e3a03006 	mov	r3, #6
102da6ac:	ebfff9ec 	bl	102d8e64 <ST7735_fillRect>
		ST7735_fillRect(110, 151, 14, 1, colWhiteSmoke);
102da6b0:	e58d4000 	str	r4, [sp]
102da6b4:	e3a0006e 	mov	r0, #110	; 0x6e
102da6b8:	e3a01097 	mov	r1, #151	; 0x97
102da6bc:	e3a0200e 	mov	r2, #14
102da6c0:	e3a03001 	mov	r3, #1
102da6c4:	ebfff9e6 	bl	102d8e64 <ST7735_fillRect>
		ST7735_fillRect(110, 152, 13, 1, colWhiteSmoke);
102da6c8:	e58d4000 	str	r4, [sp]
102da6cc:	e3a0006e 	mov	r0, #110	; 0x6e
102da6d0:	e3a01098 	mov	r1, #152	; 0x98
102da6d4:	e3a0200d 	mov	r2, #13
102da6d8:	e3a03001 	mov	r3, #1
102da6dc:	ebfff9e0 	bl	102d8e64 <ST7735_fillRect>
		ST7735_fillRect(110, 153, 12, 1, colWhiteSmoke);
102da6e0:	e58d4000 	str	r4, [sp]
102da6e4:	e3a0006e 	mov	r0, #110	; 0x6e
102da6e8:	e3a01099 	mov	r1, #153	; 0x99
102da6ec:	e3a0200c 	mov	r2, #12
102da6f0:	e3a03001 	mov	r3, #1
102da6f4:	ebfff9da 	bl	102d8e64 <ST7735_fillRect>
		ST7735_fillRect(110, 154, 11, 1, colWhiteSmoke);
102da6f8:	e58d4000 	str	r4, [sp]
102da6fc:	e3a0006e 	mov	r0, #110	; 0x6e
102da700:	e3a0109a 	mov	r1, #154	; 0x9a
102da704:	e3a0200b 	mov	r2, #11
102da708:	e3a03001 	mov	r3, #1
102da70c:	ebfff9d4 	bl	102d8e64 <ST7735_fillRect>
		ST7735_drawString(  115, 146, "X", colOrangeRed, 1);  //set x to indicate sim not present
102da710:	e3a03001 	mov	r3, #1
102da714:	e58d3000 	str	r3, [sp]
102da718:	e3a00073 	mov	r0, #115	; 0x73
102da71c:	e3a01092 	mov	r1, #146	; 0x92
102da720:	e59f2978 	ldr	r2, [pc, #2424]	; 102db0a0 <display_on_tftlcd+0xe00>
102da724:	e59f3aa0 	ldr	r3, [pc, #2720]	; 102db1cc <display_on_tftlcd+0xf2c>
102da728:	ebfffa2b 	bl	102d8fdc <ST7735_drawString>
		break;
102da72c:	eaffff8f 	b	102da570 <display_on_tftlcd+0x2d0>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da730:	e28dd00c 	add	sp, sp, #12
102da734:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}

	//Common Messages on Main water balance screen and Diagnostic screen
	switch (dparam)
	{
	case TFT_STATE_DRAW_INIT_SCREEN:
		Init_Water_Balance_Screen();
102da738:	eafffe1a 	b	102d9fa8 <Init_Water_Balance_Screen>
	case TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL:
		Refresh_Cloud_Connectivity_Symbol(2); //Just to make sure there is no conectivity activity displayed with conectivity symbol as inactive
		Refresh_Communication_inprogress_Symbol(colLawngreen);
		break;
	case TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_OFF_SYMBOL:
		Refresh_Communication_inprogress_Symbol(colBlack);
102da73c:	e3a00000 	mov	r0, #0
102da740:	ebfffd2b 	bl	102d9bf4 <Refresh_Communication_inprogress_Symbol>
		FLAG.CLOUD_COMMUNICATION_IN_PROGRESS = FALSE;
102da744:	e3a03000 	mov	r3, #0
102da748:	e5c4300b 	strb	r3, [r4, #11]
		break;
102da74c:	eaffff87 	b	102da570 <display_on_tftlcd+0x2d0>
	case TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL:
		if(FLAG.AUTOPROVISIONING_COMPLETE == TRUE) // Only if Azure DPS is complete.
			Refresh_Cloud_Connectivity_Symbol(1);
		break;
	case TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL:
		Refresh_Cloud_Connectivity_Symbol(2); //Just to make sure there is no conectivity activity displayed with conectivity symbol as inactive
102da750:	e3a00002 	mov	r0, #2
102da754:	ebfffcfb 	bl	102d9b48 <Refresh_Cloud_Connectivity_Symbol>
		Refresh_Communication_inprogress_Symbol(colLawngreen);
102da758:	e59f0938 	ldr	r0, [pc, #2360]	; 102db098 <display_on_tftlcd+0xdf8>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da75c:	e28dd00c 	add	sp, sp, #12
102da760:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
		if(FLAG.AUTOPROVISIONING_COMPLETE == TRUE) // Only if Azure DPS is complete.
			Refresh_Cloud_Connectivity_Symbol(1);
		break;
	case TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_ON_SYMBOL:
		Refresh_Cloud_Connectivity_Symbol(2); //Just to make sure there is no conectivity activity displayed with conectivity symbol as inactive
		Refresh_Communication_inprogress_Symbol(colLawngreen);
102da764:	eafffd22 	b	102d9bf4 <Refresh_Communication_inprogress_Symbol>
			ST7735_drawString(135, 120, Internal_error_code, colOrangeRed, 1);  // Start point Right - top
			FLAG.INTERNAL_ERROR_SET = TRUE;
		}
		break;
	case TFT_STATE_CLEAR_SCREEN:
		ST7735_setRotation(0x0);
102da768:	e3a00000 	mov	r0, #0
102da76c:	ebfff9a0 	bl	102d8df4 <ST7735_setRotation>
		ST7735_fillScreen(colBlack);
102da770:	e3a00000 	mov	r0, #0
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da774:	e28dd00c 	add	sp, sp, #12
102da778:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
			FLAG.INTERNAL_ERROR_SET = TRUE;
		}
		break;
	case TFT_STATE_CLEAR_SCREEN:
		ST7735_setRotation(0x0);
		ST7735_fillScreen(colBlack);
102da77c:	eafff9a5 	b	102d8e18 <ST7735_fillScreen>
		Ql_sprintf((char *)buffer,"SUCCESS");
		ST7735_drawString_for_BALANCE_align_Center(40, (char *)buffer, colLawngreen);  // Start point Right - top
		break;
	case TFT_FOTA_FILE_DOWNLOAD_SIZE:
		ST7735_setRotation(0x60);
		ST7735_drawString(10,90, "FILE SIZE", colWhite, 1);
102da780:	e3a04001 	mov	r4, #1
		ST7735_setRotation(0x60);
		Ql_sprintf((char *)buffer,"SUCCESS");
		ST7735_drawString_for_BALANCE_align_Center(40, (char *)buffer, colLawngreen);  // Start point Right - top
		break;
	case TFT_FOTA_FILE_DOWNLOAD_SIZE:
		ST7735_setRotation(0x60);
102da784:	e3a00060 	mov	r0, #96	; 0x60
102da788:	ebfff999 	bl	102d8df4 <ST7735_setRotation>
		ST7735_drawString(10,90, "FILE SIZE", colWhite, 1);
102da78c:	e3a0000a 	mov	r0, #10
102da790:	e3a0105a 	mov	r1, #90	; 0x5a
102da794:	e59f2908 	ldr	r2, [pc, #2312]	; 102db0a4 <display_on_tftlcd+0xe04>
102da798:	e59f3908 	ldr	r3, [pc, #2312]	; 102db0a8 <display_on_tftlcd+0xe08>
102da79c:	e58d4000 	str	r4, [sp]
102da7a0:	ebfffa0d 	bl	102d8fdc <ST7735_drawString>
		ST7735_drawString(80, 90,(char *)LAST_FOTA_FILE_SIZE, colBlack, 1);  // Start point Right - top // Erase last message string
102da7a4:	e3a03000 	mov	r3, #0
102da7a8:	e3a00050 	mov	r0, #80	; 0x50
102da7ac:	e3a0105a 	mov	r1, #90	; 0x5a
102da7b0:	e59f28f4 	ldr	r2, [pc, #2292]	; 102db0ac <display_on_tftlcd+0xe0c>
102da7b4:	e58d4000 	str	r4, [sp]
102da7b8:	ebfffa07 	bl	102d8fdc <ST7735_drawString>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
102da7bc:	e59f38ec 	ldr	r3, [pc, #2284]	; 102db0b0 <display_on_tftlcd+0xe10>
102da7c0:	e59f18ec 	ldr	r1, [pc, #2284]	; 102db0b4 <display_on_tftlcd+0xe14>
102da7c4:	e5932000 	ldr	r2, [r3]
102da7c8:	e59f38e8 	ldr	r3, [pc, #2280]	; 102db0b8 <display_on_tftlcd+0xe18>
102da7cc:	e59f08e8 	ldr	r0, [pc, #2280]	; 102db0bc <display_on_tftlcd+0xe1c>
102da7d0:	e5933000 	ldr	r3, [r3]
102da7d4:	e0822003 	add	r2, r2, r3
102da7d8:	e59f39c4 	ldr	r3, [pc, #2500]	; 102db1a4 <display_on_tftlcd+0xf04>
102da7dc:	e5933000 	ldr	r3, [r3]
102da7e0:	e12fff33 	blx	r3
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
102da7e4:	e3a00050 	mov	r0, #80	; 0x50
102da7e8:	e3a0105a 	mov	r1, #90	; 0x5a
102da7ec:	e58d4000 	str	r4, [sp]
102da7f0:	e59f28c4 	ldr	r2, [pc, #2244]	; 102db0bc <display_on_tftlcd+0xe1c>
102da7f4:	e59f38ac 	ldr	r3, [pc, #2220]	; 102db0a8 <display_on_tftlcd+0xe08>
102da7f8:	ebfff9f7 	bl	102d8fdc <ST7735_drawString>
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
102da7fc:	e59f08a8 	ldr	r0, [pc, #2216]	; 102db0ac <display_on_tftlcd+0xe0c>
102da800:	e59f38b8 	ldr	r3, [pc, #2232]	; 102db0c0 <display_on_tftlcd+0xe20>
102da804:	e280101c 	add	r1, r0, #28
102da808:	e12fff33 	blx	r3
		break;
102da80c:	eaffff57 	b	102da570 <display_on_tftlcd+0x2d0>
		ST7735_setRotation(0x60);
		Ql_sprintf((char *)buffer,"FAIL %d",Fota_Fail_Reason_Code);
		ST7735_drawString(40,65, (char *)buffer, colOrangeRed, 2);  // Start point Right - top
		break;
	case TFT_STATE_FOTA_SUCCESS:
		ST7735_setRotation(0x60);
102da810:	e3a00060 	mov	r0, #96	; 0x60
102da814:	ebfff976 	bl	102d8df4 <ST7735_setRotation>
		Ql_sprintf((char *)buffer,"SUCCESS");
102da818:	e59f3984 	ldr	r3, [pc, #2436]	; 102db1a4 <display_on_tftlcd+0xf04>
102da81c:	e59f18a0 	ldr	r1, [pc, #2208]	; 102db0c4 <display_on_tftlcd+0xe24>
102da820:	e5933000 	ldr	r3, [r3]
102da824:	e59f099c 	ldr	r0, [pc, #2460]	; 102db1c8 <display_on_tftlcd+0xf28>
102da828:	e12fff33 	blx	r3
		ST7735_drawString_for_BALANCE_align_Center(40, (char *)buffer, colLawngreen);  // Start point Right - top
102da82c:	e3a00028 	mov	r0, #40	; 0x28
102da830:	e59f1990 	ldr	r1, [pc, #2448]	; 102db1c8 <display_on_tftlcd+0xf28>
102da834:	e59f285c 	ldr	r2, [pc, #2140]	; 102db098 <display_on_tftlcd+0xdf8>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da838:	e28dd00c 	add	sp, sp, #12
102da83c:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
		ST7735_drawString(40,65, (char *)buffer, colOrangeRed, 2);  // Start point Right - top
		break;
	case TFT_STATE_FOTA_SUCCESS:
		ST7735_setRotation(0x60);
		Ql_sprintf((char *)buffer,"SUCCESS");
		ST7735_drawString_for_BALANCE_align_Center(40, (char *)buffer, colLawngreen);  // Start point Right - top
102da840:	eafff86c 	b	102d89f8 <ST7735_drawString_for_BALANCE_align_Center>
		ST7735_fillScreen(colBlack);
		ST7735_setRotation(0x60);
		ST7735_drawString_for_BALANCE_align_Center(25, "UPDATING...", colWhite);  // Start point Right - top
		break;
	case TFT_STATE_FOTA_FAIL:
		ST7735_setRotation(0x60);
102da844:	e3a00060 	mov	r0, #96	; 0x60
102da848:	ebfff969 	bl	102d8df4 <ST7735_setRotation>
		Ql_sprintf((char *)buffer,"FAIL %d",Fota_Fail_Reason_Code);
102da84c:	e59f3950 	ldr	r3, [pc, #2384]	; 102db1a4 <display_on_tftlcd+0xf04>
102da850:	e59f2870 	ldr	r2, [pc, #2160]	; 102db0c8 <display_on_tftlcd+0xe28>
102da854:	e5933000 	ldr	r3, [r3]
102da858:	e5d22000 	ldrb	r2, [r2]
102da85c:	e59f1868 	ldr	r1, [pc, #2152]	; 102db0cc <display_on_tftlcd+0xe2c>
102da860:	e59f0960 	ldr	r0, [pc, #2400]	; 102db1c8 <display_on_tftlcd+0xf28>
102da864:	e12fff33 	blx	r3
		ST7735_drawString(40,65, (char *)buffer, colOrangeRed, 2);  // Start point Right - top
102da868:	e3a03002 	mov	r3, #2
102da86c:	e58d3000 	str	r3, [sp]
102da870:	e3a00028 	mov	r0, #40	; 0x28
102da874:	e3a01041 	mov	r1, #65	; 0x41
102da878:	e59f2948 	ldr	r2, [pc, #2376]	; 102db1c8 <display_on_tftlcd+0xf28>
102da87c:	e59f3948 	ldr	r3, [pc, #2376]	; 102db1cc <display_on_tftlcd+0xf2c>
102da880:	ebfff9d5 	bl	102d8fdc <ST7735_drawString>
		break;
102da884:	eaffff39 	b	102da570 <display_on_tftlcd+0x2d0>
	case TFT_STATE_CLEAR_STRING_LOCKED:
		ST7735_setRotation(0x60);
		ST7735_drawString(0, 0, "LOCKED", colBlack, 1);  // Start point Right - top
		break;
	case TFT_STATE_FOTA_UPDATE:
		ST7735_fillScreen(colBlack);
102da888:	e3a00000 	mov	r0, #0
102da88c:	ebfff961 	bl	102d8e18 <ST7735_fillScreen>
		ST7735_setRotation(0x60);
102da890:	e3a00060 	mov	r0, #96	; 0x60
102da894:	ebfff956 	bl	102d8df4 <ST7735_setRotation>
		ST7735_drawString_for_BALANCE_align_Center(25, "UPDATING...", colWhite);  // Start point Right - top
102da898:	e3a00019 	mov	r0, #25
102da89c:	e59f182c 	ldr	r1, [pc, #2092]	; 102db0d0 <display_on_tftlcd+0xe30>
102da8a0:	e59f2800 	ldr	r2, [pc, #2048]	; 102db0a8 <display_on_tftlcd+0xe08>
		Ql_sprintf((char *)&FOTA_FILE_SIZE," %d",g_rcvdDataLen + dataLen_here);
		ST7735_drawString(80, 90,(char *)FOTA_FILE_SIZE, colWhite, 1);  // Start point Right - top
		strcpy((char *)LAST_FOTA_FILE_SIZE,(char *)FOTA_FILE_SIZE);
		break;
	}
}
102da8a4:	e28dd00c 	add	sp, sp, #12
102da8a8:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
		ST7735_drawString(0, 0, "LOCKED", colBlack, 1);  // Start point Right - top
		break;
	case TFT_STATE_FOTA_UPDATE:
		ST7735_fillScreen(colBlack);
		ST7735_setRotation(0x60);
		ST7735_drawString_for_BALANCE_align_Center(25, "UPDATING...", colWhite);  // Start point Right - top
102da8ac:	eafff851 	b	102d89f8 <ST7735_drawString_for_BALANCE_align_Center>
	case TFT_STATE_DRAW_STRING_LOCKED:
		ST7735_setRotation(0x60);
		ST7735_drawString(0, 0, "LOCKED", colOrangeRed, 1);  // Start point Right - top
		break;
	case TFT_STATE_CLEAR_STRING_LOCKED:
		ST7735_setRotation(0x60);
102da8b0:	e3a00060 	mov	r0, #96	; 0x60
102da8b4:	ebfff94e 	bl	102d8df4 <ST7735_setRotation>
		ST7735_drawString(0, 0, "LOCKED", colBlack, 1);  // Start point Right - top
102da8b8:	e3a00000 	mov	r0, #0
102da8bc:	e3a03001 	mov	r3, #1
102da8c0:	e58d3000 	str	r3, [sp]
102da8c4:	e1a01000 	mov	r1, r0
102da8c8:	e59f2804 	ldr	r2, [pc, #2052]	; 102db0d4 <display_on_tftlcd+0xe34>
102da8cc:	e1a03000 	mov	r3, r0
102da8d0:	ebfff9c1 	bl	102d8fdc <ST7735_drawString>
		break;
102da8d4:	eaffff25 	b	102da570 <display_on_tftlcd+0x2d0>
		ST7735_fillRect(110, 153, 12, 1, colWhiteSmoke);
		ST7735_fillRect(110, 154, 11, 1, colWhiteSmoke);
		ST7735_drawString(  115, 146, "X", colOrangeRed, 1);  //set x to indicate sim not present
		break;
	case TFT_STATE_DRAW_STRING_LOCKED:
		ST7735_setRotation(0x60);
102da8d8:	e3a00060 	mov	r0, #96	; 0x60
102da8dc:	ebfff944 	bl	102d8df4 <ST7735_setRotation>
		ST7735_drawString(0, 0, "LOCKED", colOrangeRed, 1);  // Start point Right - top
102da8e0:	e3a00000 	mov	r0, #0
102da8e4:	e3a03001 	mov	r3, #1
102da8e8:	e58d3000 	str	r3, [sp]
102da8ec:	e1a01000 	mov	r1, r0
102da8f0:	e59f27dc 	ldr	r2, [pc, #2012]	; 102db0d4 <display_on_tftlcd+0xe34>
102da8f4:	e59f38d0 	ldr	r3, [pc, #2256]	; 102db1cc <display_on_tftlcd+0xf2c>
102da8f8:	ebfff9b7 	bl	102d8fdc <ST7735_drawString>
		break;
102da8fc:	eaffff1b 	b	102da570 <display_on_tftlcd+0x2d0>
	case TFT_STATE_DRAW_CLOUD_COM_INPROGRESS_OFF_SYMBOL:
		Refresh_Communication_inprogress_Symbol(colBlack);
		FLAG.CLOUD_COMMUNICATION_IN_PROGRESS = FALSE;
		break;
	case TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE:
		if(FLAG.INTERNAL_ERROR_SET == FALSE) // Do not overwrite internal faults..
102da900:	e5d4301c 	ldrb	r3, [r4, #28]
102da904:	e3530000 	cmp	r3, #0
102da908:	1affff18 	bne	102da570 <display_on_tftlcd+0x2d0>
		{
			ST7735_setRotation(0x60);
102da90c:	e3a00060 	mov	r0, #96	; 0x60
			ST7735_drawString(135, 120, Internal_error_code, colOrangeRed, 1);  // Start point Right - top
102da910:	e3a04001 	mov	r4, #1
		FLAG.CLOUD_COMMUNICATION_IN_PROGRESS = FALSE;
		break;
	case TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE:
		if(FLAG.INTERNAL_ERROR_SET == FALSE) // Do not overwrite internal faults..
		{
			ST7735_setRotation(0x60);
102da914:	ebfff936 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(135, 120, Internal_error_code, colOrangeRed, 1);  // Start point Right - top
102da918:	e59f38ac 	ldr	r3, [pc, #2220]	; 102db1cc <display_on_tftlcd+0xf2c>
102da91c:	e58d4000 	str	r4, [sp]
102da920:	e3a00087 	mov	r0, #135	; 0x87
102da924:	e3a01078 	mov	r1, #120	; 0x78
102da928:	e59f27a8 	ldr	r2, [pc, #1960]	; 102db0d8 <display_on_tftlcd+0xe38>
102da92c:	ebfff9aa 	bl	102d8fdc <ST7735_drawString>
			FLAG.INTERNAL_ERROR_SET = TRUE;
102da930:	e59f3758 	ldr	r3, [pc, #1880]	; 102db090 <display_on_tftlcd+0xdf0>
102da934:	e5c3401c 	strb	r4, [r3, #28]
102da938:	eaffff0c 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_STRING_E9:
			ST7735_setRotation(0x60);
			ST7735_drawString(105, 120, "E9", colOrangeRed, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_E10:
			ST7735_setRotation(0x60);
102da93c:	e3a00060 	mov	r0, #96	; 0x60
102da940:	ebfff92b 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(105, 120, "E10", colOrangeRed, 1);  // Start point Right - top
102da944:	e3a03001 	mov	r3, #1
102da948:	e58d3000 	str	r3, [sp]
102da94c:	e3a00069 	mov	r0, #105	; 0x69
102da950:	e3a01078 	mov	r1, #120	; 0x78
102da954:	e59f2780 	ldr	r2, [pc, #1920]	; 102db0dc <display_on_tftlcd+0xe3c>
102da958:	e59f386c 	ldr	r3, [pc, #2156]	; 102db1cc <display_on_tftlcd+0xf2c>
102da95c:	ebfff99e 	bl	102d8fdc <ST7735_drawString>
			break;
102da960:	eaffff02 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_STRING_E11:
			ST7735_setRotation(0x60);
			ST7735_drawString(105, 120, "E11", colOrangeRed, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_E12:
			ST7735_setRotation(0x60);
102da964:	e3a00060 	mov	r0, #96	; 0x60
102da968:	ebfff921 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(105, 120, "E12", colOrangeRed, 1);  // Start point Right - top
102da96c:	e3a03001 	mov	r3, #1
102da970:	e58d3000 	str	r3, [sp]
102da974:	e3a00069 	mov	r0, #105	; 0x69
102da978:	e3a01078 	mov	r1, #120	; 0x78
102da97c:	e59f275c 	ldr	r2, [pc, #1884]	; 102db0e0 <display_on_tftlcd+0xe40>
102da980:	e59f3844 	ldr	r3, [pc, #2116]	; 102db1cc <display_on_tftlcd+0xf2c>
102da984:	ebfff994 	bl	102d8fdc <ST7735_drawString>
			break;
102da988:	eafffef8 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_CLEAR_STRING_E5:
			ST7735_setRotation(0x60);
			ST7735_drawString(25, 120, "E5", colBlack, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_E15:
			ST7735_setRotation(0x60);
102da98c:	e3a00060 	mov	r0, #96	; 0x60
102da990:	ebfff917 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(45, 120, "E15", colOrangeRed, 1);  // Start point Right - top
102da994:	e3a03001 	mov	r3, #1
102da998:	e58d3000 	str	r3, [sp]
102da99c:	e3a0002d 	mov	r0, #45	; 0x2d
102da9a0:	e3a01078 	mov	r1, #120	; 0x78
102da9a4:	e59f2738 	ldr	r2, [pc, #1848]	; 102db0e4 <display_on_tftlcd+0xe44>
102da9a8:	e59f381c 	ldr	r3, [pc, #2076]	; 102db1cc <display_on_tftlcd+0xf2c>
102da9ac:	ebfff98a 	bl	102d8fdc <ST7735_drawString>
			break;
102da9b0:	eafffeee 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_CLEAR_STRING_E15:
			ST7735_setRotation(0x60);
102da9b4:	e3a00060 	mov	r0, #96	; 0x60
102da9b8:	ebfff90d 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(45, 120, "E15", colBlack, 1);  // Start point Right - top
102da9bc:	e3a03001 	mov	r3, #1
102da9c0:	e58d3000 	str	r3, [sp]
102da9c4:	e3a0002d 	mov	r0, #45	; 0x2d
102da9c8:	e3a01078 	mov	r1, #120	; 0x78
102da9cc:	e59f2710 	ldr	r2, [pc, #1808]	; 102db0e4 <display_on_tftlcd+0xe44>
102da9d0:	e3a03000 	mov	r3, #0
102da9d4:	ebfff980 	bl	102d8fdc <ST7735_drawString>
			break;
102da9d8:	eafffee4 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_STRING_E12:
			ST7735_setRotation(0x60);
			ST7735_drawString(105, 120, "E12", colOrangeRed, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_IMEI:
			ST7735_setRotation(0x60);
102da9dc:	e3a00060 	mov	r0, #96	; 0x60
102da9e0:	ebfff903 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(  0, 35, Last_CCIDNumber, colBlack, 1);  //Erase earlier message.. mostly it is "Unknown"
102da9e4:	e3a04001 	mov	r4, #1
102da9e8:	e3a00000 	mov	r0, #0
102da9ec:	e1a03000 	mov	r3, r0
102da9f0:	e58d4000 	str	r4, [sp]
102da9f4:	e3a01023 	mov	r1, #35	; 0x23
102da9f8:	e59f26e8 	ldr	r2, [pc, #1768]	; 102db0e8 <display_on_tftlcd+0xe48>
102da9fc:	ebfff976 	bl	102d8fdc <ST7735_drawString>
			ST7735_drawString(  0, 35, IMEINumber, colWhite, 1);  //SIM details
102daa00:	e58d4000 	str	r4, [sp]
102daa04:	e3a00000 	mov	r0, #0
102daa08:	e3a01023 	mov	r1, #35	; 0x23
102daa0c:	e59f26d8 	ldr	r2, [pc, #1752]	; 102db0ec <display_on_tftlcd+0xe4c>
102daa10:	e59f3690 	ldr	r3, [pc, #1680]	; 102db0a8 <display_on_tftlcd+0xe08>
102daa14:	ebfff970 	bl	102d8fdc <ST7735_drawString>
			strcpy(Last_IMEINumber,IMEINumber);
102daa18:	e59f16cc 	ldr	r1, [pc, #1740]	; 102db0ec <display_on_tftlcd+0xe4c>
102daa1c:	e59f369c 	ldr	r3, [pc, #1692]	; 102db0c0 <display_on_tftlcd+0xe20>
102daa20:	e59f06c8 	ldr	r0, [pc, #1736]	; 102db0f0 <display_on_tftlcd+0xe50>
102daa24:	e12fff33 	blx	r3
			break;
102daa28:	eafffed0 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_CCID:
			ST7735_setRotation(0x60);
102daa2c:	e3a00060 	mov	r0, #96	; 0x60
102daa30:	ebfff8ef 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(  0, 35, Last_IMEINumber, colBlack, 1);  //Erase earlier message.. mostly it is "Unknown"
102daa34:	e3a04001 	mov	r4, #1
102daa38:	e3a00000 	mov	r0, #0
102daa3c:	e1a03000 	mov	r3, r0
102daa40:	e58d4000 	str	r4, [sp]
102daa44:	e3a01023 	mov	r1, #35	; 0x23
102daa48:	e59f26a0 	ldr	r2, [pc, #1696]	; 102db0f0 <display_on_tftlcd+0xe50>
102daa4c:	ebfff962 	bl	102d8fdc <ST7735_drawString>
			ST7735_drawString(  0, 35, CCIDNumber, colWhite, 1);  //SIM details
102daa50:	e58d4000 	str	r4, [sp]
102daa54:	e3a00000 	mov	r0, #0
102daa58:	e3a01023 	mov	r1, #35	; 0x23
102daa5c:	e59f2690 	ldr	r2, [pc, #1680]	; 102db0f4 <display_on_tftlcd+0xe54>
102daa60:	e59f3640 	ldr	r3, [pc, #1600]	; 102db0a8 <display_on_tftlcd+0xe08>
102daa64:	ebfff95c 	bl	102d8fdc <ST7735_drawString>
			strcpy(Last_CCIDNumber,CCIDNumber);
102daa68:	e59f1684 	ldr	r1, [pc, #1668]	; 102db0f4 <display_on_tftlcd+0xe54>
102daa6c:	e59f364c 	ldr	r3, [pc, #1612]	; 102db0c0 <display_on_tftlcd+0xe20>
102daa70:	e59f0670 	ldr	r0, [pc, #1648]	; 102db0e8 <display_on_tftlcd+0xe48>
102daa74:	e12fff33 	blx	r3
			break;
102daa78:	eafffebc 	b	102da570 <display_on_tftlcd+0x2d0>
	{
		switch(dparam)
		{
		case TFT_STATE_DRAW_DIAG_INIT:
			ST7735_setRotation(0x60);
			ST7735_drawString(  0, 25, (char *)deviceidentitydata, colWhite, 1);  // Control Module Identity String
102daa7c:	e3a04001 	mov	r4, #1
	if(FLAG.DIGNOSTIC_MODE == TRUE) // Belwo are the messages grouped together for diagnostic screen)
	{
		switch(dparam)
		{
		case TFT_STATE_DRAW_DIAG_INIT:
			ST7735_setRotation(0x60);
102daa80:	e3a00060 	mov	r0, #96	; 0x60
102daa84:	ebfff8da 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(  0, 25, (char *)deviceidentitydata, colWhite, 1);  // Control Module Identity String
102daa88:	e58d4000 	str	r4, [sp]
102daa8c:	e3a00000 	mov	r0, #0
102daa90:	e3a01019 	mov	r1, #25
102daa94:	e59f265c 	ldr	r2, [pc, #1628]	; 102db0f8 <display_on_tftlcd+0xe58>
102daa98:	e59f3608 	ldr	r3, [pc, #1544]	; 102db0a8 <display_on_tftlcd+0xe08>
102daa9c:	ebfff94e 	bl	102d8fdc <ST7735_drawString>
			ST7735_drawString(  0, 45, control_module_identity_number, colWhite, 1);  //Communication Module identity string
102daaa0:	e58d4000 	str	r4, [sp]
102daaa4:	e3a00000 	mov	r0, #0
102daaa8:	e3a0102d 	mov	r1, #45	; 0x2d
102daaac:	e59f2648 	ldr	r2, [pc, #1608]	; 102db0fc <display_on_tftlcd+0xe5c>
102daab0:	e59f35f0 	ldr	r3, [pc, #1520]	; 102db0a8 <display_on_tftlcd+0xe08>
102daab4:	ebfff948 	bl	102d8fdc <ST7735_drawString>
			ST7735_drawString(  0, 55, Last_service_provider_name, colBlack, 1);  //Erase earlier message.. mostly it is "Unknown"
102daab8:	e3a00000 	mov	r0, #0
102daabc:	e1a03000 	mov	r3, r0
102daac0:	e58d4000 	str	r4, [sp]
102daac4:	e3a01037 	mov	r1, #55	; 0x37
102daac8:	e59f2630 	ldr	r2, [pc, #1584]	; 102db100 <display_on_tftlcd+0xe60>
102daacc:	ebfff942 	bl	102d8fdc <ST7735_drawString>
			ST7735_drawString(  0, 55, service_provider_name, colWhite, 1);  //Service provider name details
102daad0:	e59f262c 	ldr	r2, [pc, #1580]	; 102db104 <display_on_tftlcd+0xe64>
102daad4:	e59f35cc 	ldr	r3, [pc, #1484]	; 102db0a8 <display_on_tftlcd+0xe08>
102daad8:	e58d4000 	str	r4, [sp]
102daadc:	e3a00000 	mov	r0, #0
102daae0:	e3a01037 	mov	r1, #55	; 0x37
102daae4:	ebfff93c 	bl	102d8fdc <ST7735_drawString>
			strcpy(Last_service_provider_name,service_provider_name);
102daae8:	e59f55d0 	ldr	r5, [pc, #1488]	; 102db0c0 <display_on_tftlcd+0xe20>
102daaec:	e59f1610 	ldr	r1, [pc, #1552]	; 102db104 <display_on_tftlcd+0xe64>
102daaf0:	e59f0608 	ldr	r0, [pc, #1544]	; 102db100 <display_on_tftlcd+0xe60>
102daaf4:	e12fff35 	blx	r5
			ST7735_drawString(  0, 65, last_latlong, colBlack, 1);  //Last gps information clear
102daaf8:	e3a00000 	mov	r0, #0
102daafc:	e1a03000 	mov	r3, r0
102dab00:	e58d4000 	str	r4, [sp]
102dab04:	e3a01041 	mov	r1, #65	; 0x41
102dab08:	e59f25f8 	ldr	r2, [pc, #1528]	; 102db108 <display_on_tftlcd+0xe68>
102dab0c:	ebfff932 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char*)buffer,"5. %s %s",latitude_[0]=='\0'? "Unknown" : latitude_,longitude_[0]=='\0'? "Unknown" : longitude_);
102dab10:	e59f25f4 	ldr	r2, [pc, #1524]	; 102db10c <display_on_tftlcd+0xe6c>
102dab14:	e59f35f4 	ldr	r3, [pc, #1524]	; 102db110 <display_on_tftlcd+0xe70>
102dab18:	e5d2c000 	ldrb	ip, [r2]
102dab1c:	e5d30000 	ldrb	r0, [r3]
102dab20:	e59f15ec 	ldr	r1, [pc, #1516]	; 102db114 <display_on_tftlcd+0xe74>
102dab24:	e35c0000 	cmp	ip, #0
102dab28:	01a02001 	moveq	r2, r1
102dab2c:	e3500000 	cmp	r0, #0
102dab30:	01a03001 	moveq	r3, r1
102dab34:	e59f1668 	ldr	r1, [pc, #1640]	; 102db1a4 <display_on_tftlcd+0xf04>
102dab38:	e59f0688 	ldr	r0, [pc, #1672]	; 102db1c8 <display_on_tftlcd+0xf28>
102dab3c:	e591c000 	ldr	ip, [r1]
102dab40:	e59f15d0 	ldr	r1, [pc, #1488]	; 102db118 <display_on_tftlcd+0xe78>
102dab44:	e12fff3c 	blx	ip
			ST7735_drawString(  0, 65, (char *)buffer, colWhite, 1);  //GPS information
102dab48:	e58d4000 	str	r4, [sp]
102dab4c:	e3a00000 	mov	r0, #0
102dab50:	e3a01041 	mov	r1, #65	; 0x41
102dab54:	e59f266c 	ldr	r2, [pc, #1644]	; 102db1c8 <display_on_tftlcd+0xf28>
102dab58:	e59f3548 	ldr	r3, [pc, #1352]	; 102db0a8 <display_on_tftlcd+0xe08>
102dab5c:	ebfff91e 	bl	102d8fdc <ST7735_drawString>
			strcpy(last_latlong,(char *)buffer);
102dab60:	e59f1660 	ldr	r1, [pc, #1632]	; 102db1c8 <display_on_tftlcd+0xf28>
102dab64:	e59f059c 	ldr	r0, [pc, #1436]	; 102db108 <display_on_tftlcd+0xe68>
102dab68:	e12fff35 	blx	r5
			break;
102dab6c:	eafffe7f 	b	102da570 <display_on_tftlcd+0x2d0>
			ST7735_drawString(  0, 35, Last_IMEINumber, colBlack, 1);  //Erase earlier message.. mostly it is "Unknown"
			ST7735_drawString(  0, 35, CCIDNumber, colWhite, 1);  //SIM details
			strcpy(Last_CCIDNumber,CCIDNumber);
			break;
		case TFT_STATE_DRAW_DIAG_LAST_CONNECT_TIME:
			ST7735_setRotation(0x60);
102dab70:	e3a00060 	mov	r0, #96	; 0x60
102dab74:	ebfff89e 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(  0, 75, (char *)last_lastconnectedtime, colBlack, 1);  // Start point Right - top // Erase last message string
102dab78:	e3a04001 	mov	r4, #1
102dab7c:	e3a00000 	mov	r0, #0
102dab80:	e1a03000 	mov	r3, r0
102dab84:	e58d4000 	str	r4, [sp]
102dab88:	e3a0104b 	mov	r1, #75	; 0x4b
102dab8c:	e59f2588 	ldr	r2, [pc, #1416]	; 102db11c <display_on_tftlcd+0xe7c>
102dab90:	ebfff911 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"6. %s",last_connectedtime[0] == '\0'? "Unknown" : last_connectedtime);  //for diagnostic
102dab94:	e59f3584 	ldr	r3, [pc, #1412]	; 102db120 <display_on_tftlcd+0xe80>
102dab98:	e59f2604 	ldr	r2, [pc, #1540]	; 102db1a4 <display_on_tftlcd+0xf04>
102dab9c:	e5d31000 	ldrb	r1, [r3]
102daba0:	e592c000 	ldr	ip, [r2]
102daba4:	e3510000 	cmp	r1, #0
102daba8:	e59f2564 	ldr	r2, [pc, #1380]	; 102db114 <display_on_tftlcd+0xe74>
102dabac:	e59f1570 	ldr	r1, [pc, #1392]	; 102db124 <display_on_tftlcd+0xe84>
102dabb0:	11a02003 	movne	r2, r3
102dabb4:	e59f060c 	ldr	r0, [pc, #1548]	; 102db1c8 <display_on_tftlcd+0xf28>
102dabb8:	e12fff3c 	blx	ip
			ST7735_drawString(  0, 75, (char *)buffer, colWhite, 1);
102dabbc:	e58d4000 	str	r4, [sp]
102dabc0:	e3a00000 	mov	r0, #0
102dabc4:	e3a0104b 	mov	r1, #75	; 0x4b
102dabc8:	e59f25f8 	ldr	r2, [pc, #1528]	; 102db1c8 <display_on_tftlcd+0xf28>
102dabcc:	e59f34d4 	ldr	r3, [pc, #1236]	; 102db0a8 <display_on_tftlcd+0xe08>
102dabd0:	ebfff901 	bl	102d8fdc <ST7735_drawString>
			strcpy((char *)last_lastconnectedtime,(char *)buffer);
102dabd4:	e59f15ec 	ldr	r1, [pc, #1516]	; 102db1c8 <display_on_tftlcd+0xf28>
102dabd8:	e59f34e0 	ldr	r3, [pc, #1248]	; 102db0c0 <display_on_tftlcd+0xe20>
102dabdc:	e59f0538 	ldr	r0, [pc, #1336]	; 102db11c <display_on_tftlcd+0xe7c>
102dabe0:	e12fff33 	blx	r3
			break;
102dabe4:	eafffe61 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_DIAG_RECHARGE_INFO:
			ST7735_setRotation(0x60);
102dabe8:	e3a00060 	mov	r0, #96	; 0x60
102dabec:	ebfff880 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(0, 85, (char *)last_water_balance_info_buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102dabf0:	e3a04001 	mov	r4, #1
102dabf4:	e3a00000 	mov	r0, #0
102dabf8:	e1a03000 	mov	r3, r0
102dabfc:	e58d4000 	str	r4, [sp]
102dac00:	e3a01055 	mov	r1, #85	; 0x55
102dac04:	e59f251c 	ldr	r2, [pc, #1308]	; 102db128 <display_on_tftlcd+0xe88>
102dac08:	ebfff8f3 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"7. %s  %s",(char)cmdrcbal[0] == '\0'? "Unknown" : cmdrcbal,water_balance_buffer);
102dac0c:	e59f3518 	ldr	r3, [pc, #1304]	; 102db12c <display_on_tftlcd+0xe8c>
102dac10:	e59f258c 	ldr	r2, [pc, #1420]	; 102db1a4 <display_on_tftlcd+0xf04>
102dac14:	e5d31000 	ldrb	r1, [r3]
102dac18:	e592c000 	ldr	ip, [r2]
102dac1c:	e3510000 	cmp	r1, #0
102dac20:	e59f24ec 	ldr	r2, [pc, #1260]	; 102db114 <display_on_tftlcd+0xe74>
102dac24:	e59f1504 	ldr	r1, [pc, #1284]	; 102db130 <display_on_tftlcd+0xe90>
102dac28:	11a02003 	movne	r2, r3
102dac2c:	e59f0594 	ldr	r0, [pc, #1428]	; 102db1c8 <display_on_tftlcd+0xf28>
102dac30:	e59f34fc 	ldr	r3, [pc, #1276]	; 102db134 <display_on_tftlcd+0xe94>
102dac34:	e12fff3c 	blx	ip
			ST7735_drawString(  0, 85, (char *)buffer, colWhite, 1);  //Display recharge and current balance
102dac38:	e58d4000 	str	r4, [sp]
102dac3c:	e3a00000 	mov	r0, #0
102dac40:	e3a01055 	mov	r1, #85	; 0x55
102dac44:	e59f257c 	ldr	r2, [pc, #1404]	; 102db1c8 <display_on_tftlcd+0xf28>
102dac48:	e59f3458 	ldr	r3, [pc, #1112]	; 102db0a8 <display_on_tftlcd+0xe08>
102dac4c:	ebfff8e2 	bl	102d8fdc <ST7735_drawString>
			strcpy((char *)last_water_balance_info_buffer,(char *)buffer);
102dac50:	e59f04d0 	ldr	r0, [pc, #1232]	; 102db128 <display_on_tftlcd+0xe88>
102dac54:	e59f3464 	ldr	r3, [pc, #1124]	; 102db0c0 <display_on_tftlcd+0xe20>
102dac58:	e2401040 	sub	r1, r0, #64	; 0x40
102dac5c:	e12fff33 	blx	r3
			break;
102dac60:	eafffe42 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_SENSOR_INPUT:
			ST7735_setRotation(0x60);
102dac64:	e3a00060 	mov	r0, #96	; 0x60
102dac68:	ebfff861 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"8. %s",Last_Sensor_Input_String);
102dac6c:	e59f5530 	ldr	r5, [pc, #1328]	; 102db1a4 <display_on_tftlcd+0xf04>
102dac70:	e59f0550 	ldr	r0, [pc, #1360]	; 102db1c8 <display_on_tftlcd+0xf28>
102dac74:	e59f14bc 	ldr	r1, [pc, #1212]	; 102db138 <display_on_tftlcd+0xe98>
102dac78:	e2802060 	add	r2, r0, #96	; 0x60
102dac7c:	e5953000 	ldr	r3, [r5]
102dac80:	e12fff33 	blx	r3
			ST7735_drawString(0, 95,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102dac84:	e3a00000 	mov	r0, #0
102dac88:	e3a03001 	mov	r3, #1
102dac8c:	e58d3000 	str	r3, [sp]
102dac90:	e3a0105f 	mov	r1, #95	; 0x5f
102dac94:	e1a03000 	mov	r3, r0
102dac98:	e59f2528 	ldr	r2, [pc, #1320]	; 102db1c8 <display_on_tftlcd+0xf28>
102dac9c:	ebfff8ce 	bl	102d8fdc <ST7735_drawString>
102daca0:	e59f3494 	ldr	r3, [pc, #1172]	; 102db13c <display_on_tftlcd+0xe9c>
102daca4:	e59f0494 	ldr	r0, [pc, #1172]	; 102db140 <display_on_tftlcd+0xea0>
102daca8:	e1d310b0 	ldrh	r1, [r3]
102dacac:	e3a03000 	mov	r3, #0
			for(i=0; i <16 ; i++)
			{
				Sensor_Input_String[i] = (((Sensor_Status_Byte >> i) & 0x1 ) ? 'X' : '-');
102dacb0:	e1a02351 	asr	r2, r1, r3
102dacb4:	e3120001 	tst	r2, #1
102dacb8:	03a0202d 	moveq	r2, #45	; 0x2d
102dacbc:	13a02058 	movne	r2, #88	; 0x58
102dacc0:	e7c02003 	strb	r2, [r0, r3]
102dacc4:	e2833001 	add	r3, r3, #1
			break;
		case TFT_STATE_DRAW_SENSOR_INPUT:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"8. %s",Last_Sensor_Input_String);
			ST7735_drawString(0, 95,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			for(i=0; i <16 ; i++)
102dacc8:	e3530010 	cmp	r3, #16
			{
				Sensor_Input_String[i] = (((Sensor_Status_Byte >> i) & 0x1 ) ? 'X' : '-');
102daccc:	e59f44f4 	ldr	r4, [pc, #1268]	; 102db1c8 <display_on_tftlcd+0xf28>
			break;
		case TFT_STATE_DRAW_SENSOR_INPUT:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"8. %s",Last_Sensor_Input_String);
			ST7735_drawString(0, 95,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			for(i=0; i <16 ; i++)
102dacd0:	1afffff6 	bne	102dacb0 <display_on_tftlcd+0xa10>
			{
				Sensor_Input_String[i] = (((Sensor_Status_Byte >> i) & 0x1 ) ? 'X' : '-');
			}
			Sensor_Input_String[16] = '\0';
102dacd4:	e3a06000 	mov	r6, #0
			Ql_sprintf((char *)buffer,"8. %s",Sensor_Input_String);
102dacd8:	e2842074 	add	r2, r4, #116	; 0x74
102dacdc:	e5953000 	ldr	r3, [r5]
			ST7735_drawString(0, 95,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			for(i=0; i <16 ; i++)
			{
				Sensor_Input_String[i] = (((Sensor_Status_Byte >> i) & 0x1 ) ? 'X' : '-');
			}
			Sensor_Input_String[16] = '\0';
102dace0:	e5c46084 	strb	r6, [r4, #132]	; 0x84
			Ql_sprintf((char *)buffer,"8. %s",Sensor_Input_String);
102dace4:	e1a00004 	mov	r0, r4
102dace8:	e59f1448 	ldr	r1, [pc, #1096]	; 102db138 <display_on_tftlcd+0xe98>
102dacec:	e12fff33 	blx	r3
			ST7735_drawString(0, 95,(char *)buffer, colWhite, 1);  // Start point Right - top
102dacf0:	e3a03001 	mov	r3, #1
102dacf4:	e1a00006 	mov	r0, r6
102dacf8:	e58d3000 	str	r3, [sp]
102dacfc:	e3a0105f 	mov	r1, #95	; 0x5f
102dad00:	e1a02004 	mov	r2, r4
102dad04:	e59f339c 	ldr	r3, [pc, #924]	; 102db0a8 <display_on_tftlcd+0xe08>
102dad08:	ebfff8b3 	bl	102d8fdc <ST7735_drawString>
			strcpy(Last_Sensor_Input_String,Sensor_Input_String);
102dad0c:	e2840060 	add	r0, r4, #96	; 0x60
102dad10:	e2841074 	add	r1, r4, #116	; 0x74
102dad14:	e59f33a4 	ldr	r3, [pc, #932]	; 102db0c0 <display_on_tftlcd+0xe20>
102dad18:	e12fff33 	blx	r3
			break;
102dad1c:	eafffe13 	b	102da570 <display_on_tftlcd+0x2d0>
			ST7735_drawString(96, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_OUT_value = TDS_Sensor_OUT_value;
			break;
		case TFT_STATE_DRAW_TOTAL_ON_TIME:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",Previous_Purification_ON_Counter);
102dad20:	e59f747c 	ldr	r7, [pc, #1148]	; 102db1a4 <display_on_tftlcd+0xf04>
102dad24:	e59f4418 	ldr	r4, [pc, #1048]	; 102db144 <display_on_tftlcd+0xea4>
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_OUT_value);
			ST7735_drawString(96, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_OUT_value = TDS_Sensor_OUT_value;
			break;
		case TFT_STATE_DRAW_TOTAL_ON_TIME:
			ST7735_setRotation(0x60);
102dad28:	e3a00060 	mov	r0, #96	; 0x60
102dad2c:	ebfff830 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"%d",Previous_Purification_ON_Counter);
			ST7735_drawString(126, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102dad30:	e3a06001 	mov	r6, #1
			ST7735_drawString(96, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_OUT_value = TDS_Sensor_OUT_value;
			break;
		case TFT_STATE_DRAW_TOTAL_ON_TIME:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",Previous_Purification_ON_Counter);
102dad34:	e59f1474 	ldr	r1, [pc, #1140]	; 102db1b0 <display_on_tftlcd+0xf10>
102dad38:	e1d420b0 	ldrh	r2, [r4]
102dad3c:	e5973000 	ldr	r3, [r7]
			ST7735_drawString(126, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			Ql_sprintf((char *)buffer,"%d",Purification_ON_Counter);
102dad40:	e59f5400 	ldr	r5, [pc, #1024]	; 102db148 <display_on_tftlcd+0xea8>
			ST7735_drawString(96, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_OUT_value = TDS_Sensor_OUT_value;
			break;
		case TFT_STATE_DRAW_TOTAL_ON_TIME:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",Previous_Purification_ON_Counter);
102dad44:	e59f047c 	ldr	r0, [pc, #1148]	; 102db1c8 <display_on_tftlcd+0xf28>
102dad48:	e12fff33 	blx	r3
			ST7735_drawString(126, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102dad4c:	e3a03000 	mov	r3, #0
102dad50:	e3a0007e 	mov	r0, #126	; 0x7e
102dad54:	e3a01069 	mov	r1, #105	; 0x69
102dad58:	e59f2468 	ldr	r2, [pc, #1128]	; 102db1c8 <display_on_tftlcd+0xf28>
102dad5c:	e58d6000 	str	r6, [sp]
102dad60:	ebfff89d 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"%d",Purification_ON_Counter);
102dad64:	e59f1444 	ldr	r1, [pc, #1092]	; 102db1b0 <display_on_tftlcd+0xf10>
102dad68:	e1d520b0 	ldrh	r2, [r5]
102dad6c:	e5973000 	ldr	r3, [r7]
102dad70:	e59f0450 	ldr	r0, [pc, #1104]	; 102db1c8 <display_on_tftlcd+0xf28>
102dad74:	e12fff33 	blx	r3
			ST7735_drawString(126, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
102dad78:	e3a0007e 	mov	r0, #126	; 0x7e
102dad7c:	e58d6000 	str	r6, [sp]
		case TFT_STATE_DRAW_TDS_SENSOR_IN_TEMPRATURE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"9. %d",previous_TDS_Sensor_In_Temp_value);
			ST7735_drawString(0, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			Ql_sprintf((char *)buffer,"9. %d",TDS_Sensor_In_Temp_value);
			ST7735_drawString(0, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
102dad80:	e3a01069 	mov	r1, #105	; 0x69
				else if(AMC_Status_Byte & AMC_PROCESS_BUILDING_PRESSURE)
					ST7735_drawString(138, 75,(char *)buffer, colOrangeRed, 1);  // Start point Right - top
				else if(AMC_Status_Byte & AMC_MEMBRANE_CLEANING)
					ST7735_drawString(138, 75,(char *)buffer, colLightGreen, 1);  // Start point Right - top
				else
					ST7735_drawString(138, 75,(char *)buffer, colWhite, 1);  // Start point Right - top
102dad84:	e59f243c 	ldr	r2, [pc, #1084]	; 102db1c8 <display_on_tftlcd+0xf28>
102dad88:	e59f3318 	ldr	r3, [pc, #792]	; 102db0a8 <display_on_tftlcd+0xe08>
102dad8c:	ebfff892 	bl	102d8fdc <ST7735_drawString>
			}
			else // normal purification mode is ON
				ST7735_drawString(138, 75,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_amc_timer = amc_timer;
102dad90:	e1d530b0 	ldrh	r3, [r5]
102dad94:	e1c430b0 	strh	r3, [r4]
			break;
102dad98:	eafffdf4 	b	102da570 <display_on_tftlcd+0x2d0>
				ST7735_drawString(132, 95, (char *)buffer, colOrangeRed, 1);  //Flow rate in mL per minute
			}
			previous_flowrate = water_flow_rate_ml_minute;
			break;
		case TFT_STATE_DRAW_STRING_HOTG:
			ST7735_setRotation(0x60);
102dad9c:	e3a00060 	mov	r0, #96	; 0x60
102dada0:	ebfff813 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(70, 0, "HOT", colLawngreen, 1);  // Start point Right - top
102dada4:	e3a03001 	mov	r3, #1
102dada8:	e58d3000 	str	r3, [sp]
102dadac:	e3a00046 	mov	r0, #70	; 0x46
102dadb0:	e3a01000 	mov	r1, #0
102dadb4:	e59f2390 	ldr	r2, [pc, #912]	; 102db14c <display_on_tftlcd+0xeac>
102dadb8:	e59f32d8 	ldr	r3, [pc, #728]	; 102db098 <display_on_tftlcd+0xdf8>
102dadbc:	ebfff886 	bl	102d8fdc <ST7735_drawString>
			break;
102dadc0:	eafffdea 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_STRING_HOTR:
			ST7735_setRotation(0x60);
102dadc4:	e3a00060 	mov	r0, #96	; 0x60
102dadc8:	ebfff809 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(70, 0, "HOT", colOrangeRed, 1);  // Start point Right - top
102dadcc:	e3a03001 	mov	r3, #1
102dadd0:	e58d3000 	str	r3, [sp]
102dadd4:	e3a00046 	mov	r0, #70	; 0x46
102dadd8:	e3a01000 	mov	r1, #0
102daddc:	e59f2368 	ldr	r2, [pc, #872]	; 102db14c <display_on_tftlcd+0xeac>
102dade0:	e59f33e4 	ldr	r3, [pc, #996]	; 102db1cc <display_on_tftlcd+0xf2c>
102dade4:	ebfff87c 	bl	102d8fdc <ST7735_drawString>
			break;
102dade8:	eafffde0 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_CLEAR_STRING_HOT:
			ST7735_setRotation(0x60);
102dadec:	e3a00060 	mov	r0, #96	; 0x60
102dadf0:	ebfff7ff 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(70, 0, "HOT", colBlack, 1);  // Start point Right - top
102dadf4:	e3a01000 	mov	r1, #0
102dadf8:	e3a03001 	mov	r3, #1
102dadfc:	e58d3000 	str	r3, [sp]
102dae00:	e3a00046 	mov	r0, #70	; 0x46
102dae04:	e59f2340 	ldr	r2, [pc, #832]	; 102db14c <display_on_tftlcd+0xeac>
102dae08:	e1a03001 	mov	r3, r1
102dae0c:	ebfff872 	bl	102d8fdc <ST7735_drawString>
			break;
102dae10:	eafffdd6 	b	102da570 <display_on_tftlcd+0x2d0>
				ST7735_drawString(138, 75,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_amc_timer = amc_timer;
			break;
		case TFT_STATE_DRAW_FLOW_RATE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_flowrate);
102dae14:	e59f6388 	ldr	r6, [pc, #904]	; 102db1a4 <display_on_tftlcd+0xf04>
102dae18:	e59f5330 	ldr	r5, [pc, #816]	; 102db150 <display_on_tftlcd+0xeb0>
			else // normal purification mode is ON
				ST7735_drawString(138, 75,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_amc_timer = amc_timer;
			break;
		case TFT_STATE_DRAW_FLOW_RATE:
			ST7735_setRotation(0x60);
102dae1c:	e3a00060 	mov	r0, #96	; 0x60
102dae20:	ebfff7f3 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"%d",previous_flowrate);
			ST7735_drawString(132, 95, (char *)buffer, colBlack, 1);
			Ql_sprintf((char *)buffer,"%d",water_flow_rate_ml_minute);
102dae24:	e59f4328 	ldr	r4, [pc, #808]	; 102db154 <display_on_tftlcd+0xeb4>
				ST7735_drawString(138, 75,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_amc_timer = amc_timer;
			break;
		case TFT_STATE_DRAW_FLOW_RATE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_flowrate);
102dae28:	e59f1380 	ldr	r1, [pc, #896]	; 102db1b0 <display_on_tftlcd+0xf10>
102dae2c:	e1d520b0 	ldrh	r2, [r5]
102dae30:	e5963000 	ldr	r3, [r6]
102dae34:	e59f038c 	ldr	r0, [pc, #908]	; 102db1c8 <display_on_tftlcd+0xf28>
			ST7735_drawString(132, 95, (char *)buffer, colBlack, 1);
102dae38:	e3a07001 	mov	r7, #1
				ST7735_drawString(138, 75,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_amc_timer = amc_timer;
			break;
		case TFT_STATE_DRAW_FLOW_RATE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_flowrate);
102dae3c:	e12fff33 	blx	r3
			ST7735_drawString(132, 95, (char *)buffer, colBlack, 1);
102dae40:	e3a00084 	mov	r0, #132	; 0x84
102dae44:	e3a0105f 	mov	r1, #95	; 0x5f
102dae48:	e59f2378 	ldr	r2, [pc, #888]	; 102db1c8 <display_on_tftlcd+0xf28>
102dae4c:	e3a03000 	mov	r3, #0
102dae50:	e58d7000 	str	r7, [sp]
102dae54:	ebfff860 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"%d",water_flow_rate_ml_minute);
102dae58:	e5963000 	ldr	r3, [r6]
102dae5c:	e59f0364 	ldr	r0, [pc, #868]	; 102db1c8 <display_on_tftlcd+0xf28>
102dae60:	e59f1348 	ldr	r1, [pc, #840]	; 102db1b0 <display_on_tftlcd+0xf10>
102dae64:	e1d420b0 	ldrh	r2, [r4]
102dae68:	e12fff33 	blx	r3
			if( water_flow_rate_ml_minute >= 80)
102dae6c:	e1d430b0 	ldrh	r3, [r4]
102dae70:	e353004f 	cmp	r3, #79	; 0x4f
102dae74:	8a00016c 	bhi	102db42c <display_on_tftlcd+0x118c>
			{
				ST7735_drawString(132, 95, (char *)buffer, colAqua, 1);  //Flow rate in mL per minute
			}
			else if( water_flow_rate_ml_minute >=50  && water_flow_rate_ml_minute < 80)
102dae78:	e2433032 	sub	r3, r3, #50	; 0x32
102dae7c:	e1a03803 	lsl	r3, r3, #16
102dae80:	e353081d 	cmp	r3, #1900544	; 0x1d0000
			{
				ST7735_drawString(132, 95, (char *)buffer, colLawngreen, 1);  //Flow rate in mL per minute
102dae84:	e58d7000 	str	r7, [sp]
102dae88:	e3a00084 	mov	r0, #132	; 0x84
102dae8c:	e3a0105f 	mov	r1, #95	; 0x5f
102dae90:	e59f2330 	ldr	r2, [pc, #816]	; 102db1c8 <display_on_tftlcd+0xf28>
102dae94:	959f31fc 	ldrls	r3, [pc, #508]	; 102db098 <display_on_tftlcd+0xdf8>
			}
			else if( water_flow_rate_ml_minute < 50)
			{
				ST7735_drawString(132, 95, (char *)buffer, colOrangeRed, 1);  //Flow rate in mL per minute
102dae98:	859f332c 	ldrhi	r3, [pc, #812]	; 102db1cc <display_on_tftlcd+0xf2c>
102dae9c:	ebfff84e 	bl	102d8fdc <ST7735_drawString>
			}
			previous_flowrate = water_flow_rate_ml_minute;
102daea0:	e1d430b0 	ldrh	r3, [r4]
102daea4:	e1c530b0 	strh	r3, [r5]
			break;
102daea8:	eafffdb0 	b	102da570 <display_on_tftlcd+0x2d0>
			ST7735_drawString(0, 95,(char *)buffer, colWhite, 1);  // Start point Right - top
			strcpy(Last_Sensor_Input_String,Sensor_Input_String);
			break;
		case TFT_STATE_DRAW_RO_PUMP_CURRENT:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_ro_pump_current);
102daeac:	e59f72f0 	ldr	r7, [pc, #752]	; 102db1a4 <display_on_tftlcd+0xf04>
102daeb0:	e59f42a0 	ldr	r4, [pc, #672]	; 102db158 <display_on_tftlcd+0xeb8>
			Ql_sprintf((char *)buffer,"8. %s",Sensor_Input_String);
			ST7735_drawString(0, 95,(char *)buffer, colWhite, 1);  // Start point Right - top
			strcpy(Last_Sensor_Input_String,Sensor_Input_String);
			break;
		case TFT_STATE_DRAW_RO_PUMP_CURRENT:
			ST7735_setRotation(0x60);
102daeb4:	e3a00060 	mov	r0, #96	; 0x60
102daeb8:	ebfff7cd 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"%d",previous_ro_pump_current);
			ST7735_drawString(132, 85,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102daebc:	e3a06001 	mov	r6, #1
			ST7735_drawString(0, 95,(char *)buffer, colWhite, 1);  // Start point Right - top
			strcpy(Last_Sensor_Input_String,Sensor_Input_String);
			break;
		case TFT_STATE_DRAW_RO_PUMP_CURRENT:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_ro_pump_current);
102daec0:	e59f12e8 	ldr	r1, [pc, #744]	; 102db1b0 <display_on_tftlcd+0xf10>
102daec4:	e1d420b0 	ldrh	r2, [r4]
102daec8:	e5973000 	ldr	r3, [r7]
			ST7735_drawString(132, 85,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			Ql_sprintf((char *)buffer,"%d",ro_pump_current_in_mA);
102daecc:	e59f5288 	ldr	r5, [pc, #648]	; 102db15c <display_on_tftlcd+0xebc>
			ST7735_drawString(0, 95,(char *)buffer, colWhite, 1);  // Start point Right - top
			strcpy(Last_Sensor_Input_String,Sensor_Input_String);
			break;
		case TFT_STATE_DRAW_RO_PUMP_CURRENT:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_ro_pump_current);
102daed0:	e59f02f0 	ldr	r0, [pc, #752]	; 102db1c8 <display_on_tftlcd+0xf28>
102daed4:	e12fff33 	blx	r3
			ST7735_drawString(132, 85,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102daed8:	e3a03000 	mov	r3, #0
102daedc:	e3a00084 	mov	r0, #132	; 0x84
102daee0:	e3a01055 	mov	r1, #85	; 0x55
102daee4:	e59f22dc 	ldr	r2, [pc, #732]	; 102db1c8 <display_on_tftlcd+0xf28>
102daee8:	e58d6000 	str	r6, [sp]
102daeec:	ebfff83a 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"%d",ro_pump_current_in_mA);
102daef0:	e59f12b8 	ldr	r1, [pc, #696]	; 102db1b0 <display_on_tftlcd+0xf10>
102daef4:	e1d520b0 	ldrh	r2, [r5]
102daef8:	e5973000 	ldr	r3, [r7]
102daefc:	e59f02c4 	ldr	r0, [pc, #708]	; 102db1c8 <display_on_tftlcd+0xf28>
102daf00:	e12fff33 	blx	r3
			ST7735_drawString(132, 85,(char *)buffer, colWhite, 1);  // Start point Right - top
102daf04:	e58d6000 	str	r6, [sp]
102daf08:	e3a00084 	mov	r0, #132	; 0x84
102daf0c:	e3a01055 	mov	r1, #85	; 0x55
102daf10:	eaffff9b 	b	102dad84 <display_on_tftlcd+0xae4>
		case TFT_STATE_DRAW_STRING_E10:
			ST7735_setRotation(0x60);
			ST7735_drawString(105, 120, "E10", colOrangeRed, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_E11:
			ST7735_setRotation(0x60);
102daf14:	e3a00060 	mov	r0, #96	; 0x60
102daf18:	ebfff7b5 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(105, 120, "E11", colOrangeRed, 1);  // Start point Right - top
102daf1c:	e3a03001 	mov	r3, #1
102daf20:	e58d3000 	str	r3, [sp]
102daf24:	e3a00069 	mov	r0, #105	; 0x69
102daf28:	e3a01078 	mov	r1, #120	; 0x78
102daf2c:	e59f222c 	ldr	r2, [pc, #556]	; 102db160 <display_on_tftlcd+0xec0>
102daf30:	e59f3294 	ldr	r3, [pc, #660]	; 102db1cc <display_on_tftlcd+0xf2c>
102daf34:	ebfff828 	bl	102d8fdc <ST7735_drawString>
			break;
102daf38:	eafffd8c 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_STRING_E6:
			ST7735_setRotation(0x60);
			ST7735_drawString(105, 120, "E6", colOrangeRed, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_E9:
			ST7735_setRotation(0x60);
102daf3c:	e3a00060 	mov	r0, #96	; 0x60
102daf40:	ebfff7ab 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(105, 120, "E9", colOrangeRed, 1);  // Start point Right - top
102daf44:	e3a03001 	mov	r3, #1
102daf48:	e58d3000 	str	r3, [sp]
102daf4c:	e3a00069 	mov	r0, #105	; 0x69
102daf50:	e3a01078 	mov	r1, #120	; 0x78
102daf54:	e59f2208 	ldr	r2, [pc, #520]	; 102db164 <display_on_tftlcd+0xec4>
102daf58:	e59f326c 	ldr	r3, [pc, #620]	; 102db1cc <display_on_tftlcd+0xf2c>
102daf5c:	ebfff81e 	bl	102d8fdc <ST7735_drawString>
			break;
102daf60:	eafffd82 	b	102da570 <display_on_tftlcd+0x2d0>
			ST7735_drawString(132, 85,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_ro_pump_current = ro_pump_current_in_mA;
			break;
		case TFT_STATE_DRAW_TDS_SENSOR_IN_TEMPRATURE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"9. %d",previous_TDS_Sensor_In_Temp_value);
102daf64:	e59f7238 	ldr	r7, [pc, #568]	; 102db1a4 <display_on_tftlcd+0xf04>
102daf68:	e59f41f8 	ldr	r4, [pc, #504]	; 102db168 <display_on_tftlcd+0xec8>
			Ql_sprintf((char *)buffer,"%d",ro_pump_current_in_mA);
			ST7735_drawString(132, 85,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_ro_pump_current = ro_pump_current_in_mA;
			break;
		case TFT_STATE_DRAW_TDS_SENSOR_IN_TEMPRATURE:
			ST7735_setRotation(0x60);
102daf6c:	e3a00060 	mov	r0, #96	; 0x60
102daf70:	ebfff79f 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"9. %d",previous_TDS_Sensor_In_Temp_value);
102daf74:	e59f11f0 	ldr	r1, [pc, #496]	; 102db16c <display_on_tftlcd+0xecc>
102daf78:	e1d420b0 	ldrh	r2, [r4]
102daf7c:	e5973000 	ldr	r3, [r7]
102daf80:	e59f0240 	ldr	r0, [pc, #576]	; 102db1c8 <display_on_tftlcd+0xf28>
102daf84:	e12fff33 	blx	r3
			ST7735_drawString(0, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102daf88:	e3a06001 	mov	r6, #1
102daf8c:	e3a00000 	mov	r0, #0
			Ql_sprintf((char *)buffer,"9. %d",TDS_Sensor_In_Temp_value);
102daf90:	e59f51d8 	ldr	r5, [pc, #472]	; 102db170 <display_on_tftlcd+0xed0>
			previous_ro_pump_current = ro_pump_current_in_mA;
			break;
		case TFT_STATE_DRAW_TDS_SENSOR_IN_TEMPRATURE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"9. %d",previous_TDS_Sensor_In_Temp_value);
			ST7735_drawString(0, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102daf94:	e1a03000 	mov	r3, r0
102daf98:	e3a01069 	mov	r1, #105	; 0x69
102daf9c:	e59f2224 	ldr	r2, [pc, #548]	; 102db1c8 <display_on_tftlcd+0xf28>
102dafa0:	e58d6000 	str	r6, [sp]
102dafa4:	ebfff80c 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"9. %d",TDS_Sensor_In_Temp_value);
102dafa8:	e59f11bc 	ldr	r1, [pc, #444]	; 102db16c <display_on_tftlcd+0xecc>
102dafac:	e1d520b0 	ldrh	r2, [r5]
102dafb0:	e5973000 	ldr	r3, [r7]
102dafb4:	e59f020c 	ldr	r0, [pc, #524]	; 102db1c8 <display_on_tftlcd+0xf28>
102dafb8:	e12fff33 	blx	r3
			ST7735_drawString(0, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
102dafbc:	e58d6000 	str	r6, [sp]
102dafc0:	e3a00000 	mov	r0, #0
102dafc4:	eaffff6d 	b	102dad80 <display_on_tftlcd+0xae0>
			ST7735_drawString(42, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_In_value = TDS_Sensor_In_value;
			break;
		case TFT_STATE_DRAW_TDS_SENSOR_OUT_TEMPRATURE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_Out_Temp_value);
102dafc8:	e59f71d4 	ldr	r7, [pc, #468]	; 102db1a4 <display_on_tftlcd+0xf04>
102dafcc:	e59f41a0 	ldr	r4, [pc, #416]	; 102db174 <display_on_tftlcd+0xed4>
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_In_value);
			ST7735_drawString(42, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_In_value = TDS_Sensor_In_value;
			break;
		case TFT_STATE_DRAW_TDS_SENSOR_OUT_TEMPRATURE:
			ST7735_setRotation(0x60);
102dafd0:	e3a00060 	mov	r0, #96	; 0x60
102dafd4:	ebfff786 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_Out_Temp_value);
			ST7735_drawString(72, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102dafd8:	e3a06001 	mov	r6, #1
			ST7735_drawString(42, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_In_value = TDS_Sensor_In_value;
			break;
		case TFT_STATE_DRAW_TDS_SENSOR_OUT_TEMPRATURE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_Out_Temp_value);
102dafdc:	e59f11cc 	ldr	r1, [pc, #460]	; 102db1b0 <display_on_tftlcd+0xf10>
102dafe0:	e1d420b0 	ldrh	r2, [r4]
102dafe4:	e5973000 	ldr	r3, [r7]
			ST7735_drawString(72, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_Out_Temp_value);
102dafe8:	e59f5188 	ldr	r5, [pc, #392]	; 102db178 <display_on_tftlcd+0xed8>
			ST7735_drawString(42, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_In_value = TDS_Sensor_In_value;
			break;
		case TFT_STATE_DRAW_TDS_SENSOR_OUT_TEMPRATURE:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_Out_Temp_value);
102dafec:	e59f01d4 	ldr	r0, [pc, #468]	; 102db1c8 <display_on_tftlcd+0xf28>
102daff0:	e12fff33 	blx	r3
			ST7735_drawString(72, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102daff4:	e3a03000 	mov	r3, #0
102daff8:	e3a00048 	mov	r0, #72	; 0x48
102daffc:	e3a01069 	mov	r1, #105	; 0x69
102db000:	e59f21c0 	ldr	r2, [pc, #448]	; 102db1c8 <display_on_tftlcd+0xf28>
102db004:	e58d6000 	str	r6, [sp]
102db008:	ebfff7f3 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_Out_Temp_value);
102db00c:	e59f119c 	ldr	r1, [pc, #412]	; 102db1b0 <display_on_tftlcd+0xf10>
102db010:	e1d520b0 	ldrh	r2, [r5]
102db014:	e5973000 	ldr	r3, [r7]
102db018:	e59f01a8 	ldr	r0, [pc, #424]	; 102db1c8 <display_on_tftlcd+0xf28>
102db01c:	e12fff33 	blx	r3
			ST7735_drawString(72, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
102db020:	e58d6000 	str	r6, [sp]
102db024:	e3a00048 	mov	r0, #72	; 0x48
102db028:	eaffff54 	b	102dad80 <display_on_tftlcd+0xae0>
			ST7735_drawString(0, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_In_Temp_value = TDS_Sensor_In_Temp_value;
			break;
		case TFT_STATE_DRAW_TDS_IN_SENSOR_VALUE_IN_PPM:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_In_value);
102db02c:	e59f7170 	ldr	r7, [pc, #368]	; 102db1a4 <display_on_tftlcd+0xf04>
102db030:	e59f4144 	ldr	r4, [pc, #324]	; 102db17c <display_on_tftlcd+0xedc>
			Ql_sprintf((char *)buffer,"9. %d",TDS_Sensor_In_Temp_value);
			ST7735_drawString(0, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_In_Temp_value = TDS_Sensor_In_Temp_value;
			break;
		case TFT_STATE_DRAW_TDS_IN_SENSOR_VALUE_IN_PPM:
			ST7735_setRotation(0x60);
102db034:	e3a00060 	mov	r0, #96	; 0x60
102db038:	ebfff76d 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_In_value);
			ST7735_drawString(42, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102db03c:	e3a06001 	mov	r6, #1
			ST7735_drawString(0, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_In_Temp_value = TDS_Sensor_In_Temp_value;
			break;
		case TFT_STATE_DRAW_TDS_IN_SENSOR_VALUE_IN_PPM:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_In_value);
102db040:	e59f1168 	ldr	r1, [pc, #360]	; 102db1b0 <display_on_tftlcd+0xf10>
102db044:	e1d420b0 	ldrh	r2, [r4]
102db048:	e5973000 	ldr	r3, [r7]
			ST7735_drawString(42, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_In_value);
102db04c:	e59f512c 	ldr	r5, [pc, #300]	; 102db180 <display_on_tftlcd+0xee0>
			ST7735_drawString(0, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_In_Temp_value = TDS_Sensor_In_Temp_value;
			break;
		case TFT_STATE_DRAW_TDS_IN_SENSOR_VALUE_IN_PPM:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_In_value);
102db050:	e59f0170 	ldr	r0, [pc, #368]	; 102db1c8 <display_on_tftlcd+0xf28>
102db054:	e12fff33 	blx	r3
			ST7735_drawString(42, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102db058:	e3a03000 	mov	r3, #0
102db05c:	e3a0002a 	mov	r0, #42	; 0x2a
102db060:	e3a01069 	mov	r1, #105	; 0x69
102db064:	e59f215c 	ldr	r2, [pc, #348]	; 102db1c8 <display_on_tftlcd+0xf28>
102db068:	e58d6000 	str	r6, [sp]
102db06c:	ebfff7da 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_In_value);
102db070:	e59f1138 	ldr	r1, [pc, #312]	; 102db1b0 <display_on_tftlcd+0xf10>
102db074:	e1d520b0 	ldrh	r2, [r5]
102db078:	e5973000 	ldr	r3, [r7]
102db07c:	e59f0144 	ldr	r0, [pc, #324]	; 102db1c8 <display_on_tftlcd+0xf28>
102db080:	e12fff33 	blx	r3
			ST7735_drawString(42, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
102db084:	e58d6000 	str	r6, [sp]
102db088:	e3a0002a 	mov	r0, #42	; 0x2a
102db08c:	eaffff3b 	b	102dad80 <display_on_tftlcd+0xae0>
102db090:	f03da5f0 	.word	0xf03da5f0
102db094:	f03d4468 	.word	0xf03d4468
102db098:	00007fe0 	.word	0x00007fe0
102db09c:	0000f7be 	.word	0x0000f7be
102db0a0:	102f0370 	.word	0x102f0370
102db0a4:	102ef9e4 	.word	0x102ef9e4
102db0a8:	0000ffff 	.word	0x0000ffff
102db0ac:	f03d654c 	.word	0xf03d654c
102db0b0:	f03de524 	.word	0xf03de524
102db0b4:	102ef9d8 	.word	0x102ef9d8
102db0b8:	f03d6068 	.word	0xf03d6068
102db0bc:	f03d6568 	.word	0xf03d6568
102db0c0:	102dff55 	.word	0x102dff55
102db0c4:	102ef9dc 	.word	0x102ef9dc
102db0c8:	f03de528 	.word	0xf03de528
102db0cc:	102ef9d4 	.word	0x102ef9d4
102db0d0:	102ef9c8 	.word	0x102ef9c8
102db0d4:	102ef9c0 	.word	0x102ef9c0
102db0d8:	f03d4684 	.word	0xf03d4684
102db0dc:	102ef98c 	.word	0x102ef98c
102db0e0:	102ef994 	.word	0x102ef994
102db0e4:	102ef974 	.word	0x102ef974
102db0e8:	f03d4638 	.word	0xf03d4638
102db0ec:	f03d46a8 	.word	0xf03d46a8
102db0f0:	f03d464c 	.word	0xf03d464c
102db0f4:	f03d468c 	.word	0xf03d468c
102db0f8:	f03da5cc 	.word	0xf03da5cc
102db0fc:	f03da5b8 	.word	0xf03da5b8
102db100:	f03d45f8 	.word	0xf03d45f8
102db104:	f03d46d0 	.word	0xf03d46d0
102db108:	f03d4618 	.word	0xf03d4618
102db10c:	f03da824 	.word	0xf03da824
102db110:	f03da830 	.word	0xf03da830
102db114:	102ef958 	.word	0x102ef958
102db118:	102ef960 	.word	0x102ef960
102db11c:	f03d4660 	.word	0xf03d4660
102db120:	f03d5bac 	.word	0xf03d5bac
102db124:	102ef998 	.word	0x102ef998
102db128:	f03d6504 	.word	0xf03d6504
102db12c:	f03d5be8 	.word	0xf03d5be8
102db130:	102ef9a0 	.word	0x102ef9a0
102db134:	f03da518 	.word	0xf03da518
102db138:	102ef9ac 	.word	0x102ef9ac
102db13c:	f03da5a0 	.word	0xf03da5a0
102db140:	f03d6538 	.word	0xf03d6538
102db144:	f03da5a8 	.word	0xf03da5a8
102db148:	f03da510 	.word	0xf03da510
102db14c:	102ef9bc 	.word	0x102ef9bc
102db150:	f03da520 	.word	0xf03da520
102db154:	f03da522 	.word	0xf03da522
102db158:	f03da538 	.word	0xf03da538
102db15c:	f03da53a 	.word	0xf03da53a
102db160:	102ef990 	.word	0x102ef990
102db164:	102ef988 	.word	0x102ef988
102db168:	f03da536 	.word	0xf03da536
102db16c:	102ef9b4 	.word	0x102ef9b4
102db170:	f03da534 	.word	0xf03da534
102db174:	f03da532 	.word	0xf03da532
102db178:	f03da530 	.word	0xf03da530
102db17c:	f03da52e 	.word	0xf03da52e
102db180:	f03da52c 	.word	0xf03da52c
102db184:	f03da52a 	.word	0xf03da52a
102db188:	f03da528 	.word	0xf03da528
102db18c:	102ef96c 	.word	0x102ef96c
102db190:	102ef980 	.word	0x102ef980
102db194:	102ef970 	.word	0x102ef970
102db198:	102ef984 	.word	0x102ef984
102db19c:	102ef978 	.word	0x102ef978
102db1a0:	102ef97c 	.word	0x102ef97c
102db1a4:	f03de540 	.word	0xf03de540
102db1a8:	f03da524 	.word	0xf03da524
102db1ac:	f03da526 	.word	0xf03da526
102db1b0:	102edef4 	.word	0x102edef4
102db1b4:	f03da53d 	.word	0xf03da53d
102db1b8:	f03da59d 	.word	0xf03da59d
102db1bc:	00009772 	.word	0x00009772
102db1c0:	000007ff 	.word	0x000007ff
102db1c4:	0000ffe0 	.word	0x0000ffe0
102db1c8:	f03d64c4 	.word	0xf03d64c4
102db1cc:	0000fa20 	.word	0x0000fa20
			ST7735_drawString(72, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_Out_Temp_value = TDS_Sensor_Out_Temp_value;
			break;
		case TFT_STATE_DRAW_TDS_OUT_SENSOR_VALUE_IN_PPM:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_OUT_value);
102db1d0:	e51f7034 	ldr	r7, [pc, #-52]	; 102db1a4 <display_on_tftlcd+0xf04>
102db1d4:	e51f4058 	ldr	r4, [pc, #-88]	; 102db184 <display_on_tftlcd+0xee4>
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_Out_Temp_value);
			ST7735_drawString(72, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_Out_Temp_value = TDS_Sensor_Out_Temp_value;
			break;
		case TFT_STATE_DRAW_TDS_OUT_SENSOR_VALUE_IN_PPM:
			ST7735_setRotation(0x60);
102db1d8:	e3a00060 	mov	r0, #96	; 0x60
102db1dc:	ebfff704 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_OUT_value);
			ST7735_drawString(96, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102db1e0:	e3a06001 	mov	r6, #1
			ST7735_drawString(72, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_Out_Temp_value = TDS_Sensor_Out_Temp_value;
			break;
		case TFT_STATE_DRAW_TDS_OUT_SENSOR_VALUE_IN_PPM:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_OUT_value);
102db1e4:	e51f103c 	ldr	r1, [pc, #-60]	; 102db1b0 <display_on_tftlcd+0xf10>
102db1e8:	e1d420b0 	ldrh	r2, [r4]
102db1ec:	e5973000 	ldr	r3, [r7]
			ST7735_drawString(96, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_OUT_value);
102db1f0:	e51f5070 	ldr	r5, [pc, #-112]	; 102db188 <display_on_tftlcd+0xee8>
			ST7735_drawString(72, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			previous_TDS_Sensor_Out_Temp_value = TDS_Sensor_Out_Temp_value;
			break;
		case TFT_STATE_DRAW_TDS_OUT_SENSOR_VALUE_IN_PPM:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_TDS_Sensor_OUT_value);
102db1f4:	e51f0034 	ldr	r0, [pc, #-52]	; 102db1c8 <display_on_tftlcd+0xf28>
102db1f8:	e12fff33 	blx	r3
			ST7735_drawString(96, 105,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102db1fc:	e3a03000 	mov	r3, #0
102db200:	e3a00060 	mov	r0, #96	; 0x60
102db204:	e3a01069 	mov	r1, #105	; 0x69
102db208:	e51f2048 	ldr	r2, [pc, #-72]	; 102db1c8 <display_on_tftlcd+0xf28>
102db20c:	e58d6000 	str	r6, [sp]
102db210:	ebfff771 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"%d",TDS_Sensor_OUT_value);
102db214:	e51f106c 	ldr	r1, [pc, #-108]	; 102db1b0 <display_on_tftlcd+0xf10>
102db218:	e1d520b0 	ldrh	r2, [r5]
102db21c:	e5973000 	ldr	r3, [r7]
102db220:	e51f0060 	ldr	r0, [pc, #-96]	; 102db1c8 <display_on_tftlcd+0xf28>
102db224:	e12fff33 	blx	r3
			ST7735_drawString(96, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
102db228:	e58d6000 	str	r6, [sp]
102db22c:	e3a00060 	mov	r0, #96	; 0x60
102db230:	eafffed2 	b	102dad80 <display_on_tftlcd+0xae0>
			ST7735_drawString(  0, 65, (char *)buffer, colWhite, 1);  //GPS information
			strcpy(last_latlong,(char *)buffer);
			break;
			//Recoverable faults..
		case TFT_STATE_DRAW_STRING_E1:
			ST7735_setRotation(0x60);
102db234:	e3a00060 	mov	r0, #96	; 0x60
102db238:	ebfff6ed 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(5, 120, "E1", colOrangeRed, 1);  // Start point Right - top
102db23c:	e3a03001 	mov	r3, #1
102db240:	e58d3000 	str	r3, [sp]
102db244:	e3a00005 	mov	r0, #5
102db248:	e3a01078 	mov	r1, #120	; 0x78
102db24c:	e51f20c8 	ldr	r2, [pc, #-200]	; 102db18c <display_on_tftlcd+0xeec>
102db250:	e51f308c 	ldr	r3, [pc, #-140]	; 102db1cc <display_on_tftlcd+0xf2c>
102db254:	ebfff760 	bl	102d8fdc <ST7735_drawString>
			break;
102db258:	eafffcc4 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_CLEAR_STRING_E1:
			ST7735_setRotation(0x60);
102db25c:	e3a00060 	mov	r0, #96	; 0x60
102db260:	ebfff6e3 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(5, 120, "E1", colBlack, 1);  // Start point Right - top
102db264:	e3a03001 	mov	r3, #1
102db268:	e58d3000 	str	r3, [sp]
102db26c:	e3a00005 	mov	r0, #5
102db270:	e3a01078 	mov	r1, #120	; 0x78
102db274:	e51f20f0 	ldr	r2, [pc, #-240]	; 102db18c <display_on_tftlcd+0xeec>
102db278:	e3a03000 	mov	r3, #0
102db27c:	ebfff756 	bl	102d8fdc <ST7735_drawString>
			break;
102db280:	eafffcba 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_STRING_E3:
			ST7735_setRotation(0x60);
			ST7735_drawString(105, 120, "E3", colOrangeRed, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_E4:
			ST7735_setRotation(0x60);
102db284:	e3a00060 	mov	r0, #96	; 0x60
102db288:	ebfff6d9 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(105, 120, "E4", colOrangeRed, 1);  // Start point Right - top
102db28c:	e3a03001 	mov	r3, #1
102db290:	e58d3000 	str	r3, [sp]
102db294:	e3a00069 	mov	r0, #105	; 0x69
102db298:	e3a01078 	mov	r1, #120	; 0x78
102db29c:	e51f2114 	ldr	r2, [pc, #-276]	; 102db190 <display_on_tftlcd+0xef0>
102db2a0:	e51f30dc 	ldr	r3, [pc, #-220]	; 102db1cc <display_on_tftlcd+0xf2c>
102db2a4:	ebfff74c 	bl	102d8fdc <ST7735_drawString>
			break;
102db2a8:	eafffcb0 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_CLEAR_STRING_E1:
			ST7735_setRotation(0x60);
			ST7735_drawString(5, 120, "E1", colBlack, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_E5:
			ST7735_setRotation(0x60);
102db2ac:	e3a00060 	mov	r0, #96	; 0x60
102db2b0:	ebfff6cf 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(25, 120, "E5", colOrangeRed, 1);  // Start point Right - top
102db2b4:	e3a03001 	mov	r3, #1
102db2b8:	e58d3000 	str	r3, [sp]
102db2bc:	e3a00019 	mov	r0, #25
102db2c0:	e3a01078 	mov	r1, #120	; 0x78
102db2c4:	e51f2138 	ldr	r2, [pc, #-312]	; 102db194 <display_on_tftlcd+0xef4>
102db2c8:	e51f3104 	ldr	r3, [pc, #-260]	; 102db1cc <display_on_tftlcd+0xf2c>
102db2cc:	ebfff742 	bl	102d8fdc <ST7735_drawString>
			break;
102db2d0:	eafffca6 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_CLEAR_STRING_E5:
			ST7735_setRotation(0x60);
102db2d4:	e3a00060 	mov	r0, #96	; 0x60
102db2d8:	ebfff6c5 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(25, 120, "E5", colBlack, 1);  // Start point Right - top
102db2dc:	e3a03001 	mov	r3, #1
102db2e0:	e58d3000 	str	r3, [sp]
102db2e4:	e3a00019 	mov	r0, #25
102db2e8:	e3a01078 	mov	r1, #120	; 0x78
102db2ec:	e51f2160 	ldr	r2, [pc, #-352]	; 102db194 <display_on_tftlcd+0xef4>
102db2f0:	e3a03000 	mov	r3, #0
102db2f4:	ebfff738 	bl	102d8fdc <ST7735_drawString>
			break;
102db2f8:	eafffc9c 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_STRING_E4:
			ST7735_setRotation(0x60);
			ST7735_drawString(105, 120, "E4", colOrangeRed, 1);  // Start point Right - top
			break;
		case TFT_STATE_DRAW_STRING_E6:
			ST7735_setRotation(0x60);
102db2fc:	e3a00060 	mov	r0, #96	; 0x60
102db300:	ebfff6bb 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(105, 120, "E6", colOrangeRed, 1);  // Start point Right - top
102db304:	e3a03001 	mov	r3, #1
102db308:	e58d3000 	str	r3, [sp]
102db30c:	e3a00069 	mov	r0, #105	; 0x69
102db310:	e3a01078 	mov	r1, #120	; 0x78
102db314:	e51f2184 	ldr	r2, [pc, #-388]	; 102db198 <display_on_tftlcd+0xef8>
102db318:	e51f3154 	ldr	r3, [pc, #-340]	; 102db1cc <display_on_tftlcd+0xf2c>
102db31c:	ebfff72e 	bl	102d8fdc <ST7735_drawString>
			break;
102db320:	eafffc92 	b	102da570 <display_on_tftlcd+0x2d0>
			ST7735_setRotation(0x60);
			ST7735_drawString(45, 120, "E15", colBlack, 1);  // Start point Right - top
			break;
			// Now persistent faults to display
		case TFT_STATE_DRAW_STRING_E2:
			ST7735_setRotation(0x60);
102db324:	e3a00060 	mov	r0, #96	; 0x60
102db328:	ebfff6b1 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(105, 120, "E2", colOrangeRed, 1);  // Start point Right - top
102db32c:	e3a03001 	mov	r3, #1
102db330:	e58d3000 	str	r3, [sp]
102db334:	e3a00069 	mov	r0, #105	; 0x69
102db338:	e3a01078 	mov	r1, #120	; 0x78
102db33c:	e51f21a8 	ldr	r2, [pc, #-424]	; 102db19c <display_on_tftlcd+0xefc>
102db340:	e51f317c 	ldr	r3, [pc, #-380]	; 102db1cc <display_on_tftlcd+0xf2c>
102db344:	ebfff724 	bl	102d8fdc <ST7735_drawString>
			break;
102db348:	eafffc88 	b	102da570 <display_on_tftlcd+0x2d0>
		case TFT_STATE_DRAW_STRING_E3:
			ST7735_setRotation(0x60);
102db34c:	e3a00060 	mov	r0, #96	; 0x60
102db350:	ebfff6a7 	bl	102d8df4 <ST7735_setRotation>
			ST7735_drawString(105, 120, "E3", colOrangeRed, 1);  // Start point Right - top
102db354:	e3a03001 	mov	r3, #1
102db358:	e58d3000 	str	r3, [sp]
102db35c:	e3a00069 	mov	r0, #105	; 0x69
102db360:	e3a01078 	mov	r1, #120	; 0x78
102db364:	e51f21cc 	ldr	r2, [pc, #-460]	; 102db1a0 <display_on_tftlcd+0xf00>
102db368:	e51f31a4 	ldr	r3, [pc, #-420]	; 102db1cc <display_on_tftlcd+0xf2c>
102db36c:	ebfff71a 	bl	102d8fdc <ST7735_drawString>
			break;
102db370:	eafffc7e 	b	102da570 <display_on_tftlcd+0x2d0>
			ST7735_drawString(126, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			Previous_Purification_ON_Counter = Purification_ON_Counter;
			break;
		case TFT_STATE_DRAW_AMC_TIMER:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_amc_timer);
102db374:	e51f61d8 	ldr	r6, [pc, #-472]	; 102db1a4 <display_on_tftlcd+0xf04>
102db378:	e51f41d8 	ldr	r4, [pc, #-472]	; 102db1a8 <display_on_tftlcd+0xf08>
			Ql_sprintf((char *)buffer,"%d",Purification_ON_Counter);
			ST7735_drawString(126, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			Previous_Purification_ON_Counter = Purification_ON_Counter;
			break;
		case TFT_STATE_DRAW_AMC_TIMER:
			ST7735_setRotation(0x60);
102db37c:	e3a00060 	mov	r0, #96	; 0x60
102db380:	ebfff69b 	bl	102d8df4 <ST7735_setRotation>
			Ql_sprintf((char *)buffer,"%d",previous_amc_timer);
			ST7735_drawString(138, 75,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102db384:	e3a07001 	mov	r7, #1
			ST7735_drawString(126, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			Previous_Purification_ON_Counter = Purification_ON_Counter;
			break;
		case TFT_STATE_DRAW_AMC_TIMER:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_amc_timer);
102db388:	e51f11e0 	ldr	r1, [pc, #-480]	; 102db1b0 <display_on_tftlcd+0xf10>
102db38c:	e1d420b0 	ldrh	r2, [r4]
102db390:	e5963000 	ldr	r3, [r6]
102db394:	e51f01d4 	ldr	r0, [pc, #-468]	; 102db1c8 <display_on_tftlcd+0xf28>
			ST7735_drawString(138, 75,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			Ql_sprintf((char *)buffer,"%d",amc_timer);
102db398:	e51f51f4 	ldr	r5, [pc, #-500]	; 102db1ac <display_on_tftlcd+0xf0c>
			ST7735_drawString(126, 105,(char *)buffer, colWhite, 1);  // Start point Right - top
			Previous_Purification_ON_Counter = Purification_ON_Counter;
			break;
		case TFT_STATE_DRAW_AMC_TIMER:
			ST7735_setRotation(0x60);
			Ql_sprintf((char *)buffer,"%d",previous_amc_timer);
102db39c:	e12fff33 	blx	r3
			ST7735_drawString(138, 75,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
102db3a0:	e3a0008a 	mov	r0, #138	; 0x8a
102db3a4:	e3a0104b 	mov	r1, #75	; 0x4b
102db3a8:	e51f21e8 	ldr	r2, [pc, #-488]	; 102db1c8 <display_on_tftlcd+0xf28>
102db3ac:	e3a03000 	mov	r3, #0
102db3b0:	e58d7000 	str	r7, [sp]
102db3b4:	ebfff708 	bl	102d8fdc <ST7735_drawString>
			Ql_sprintf((char *)buffer,"%d",amc_timer);
102db3b8:	e5963000 	ldr	r3, [r6]
102db3bc:	e51f01fc 	ldr	r0, [pc, #-508]	; 102db1c8 <display_on_tftlcd+0xf28>
102db3c0:	e51f1218 	ldr	r1, [pc, #-536]	; 102db1b0 <display_on_tftlcd+0xf10>
102db3c4:	e1d520b0 	ldrh	r2, [r5]
102db3c8:	e12fff33 	blx	r3
			if(Status_Byte & AMC_MODE_ON) // AMC mode is ON
102db3cc:	e51f3220 	ldr	r3, [pc, #-544]	; 102db1b4 <display_on_tftlcd+0xf14>
102db3d0:	e5d33000 	ldrb	r3, [r3]
102db3d4:	e3130020 	tst	r3, #32
102db3d8:	0a00000e 	beq	102db418 <display_on_tftlcd+0x1178>
			{
				if(AMC_Status_Byte & AMC_PHASE_1_START)
102db3dc:	e51f322c 	ldr	r3, [pc, #-556]	; 102db1b8 <display_on_tftlcd+0xf18>
102db3e0:	e5d33000 	ldrb	r3, [r3]
102db3e4:	e3130002 	tst	r3, #2
102db3e8:	1a000016 	bne	102db448 <display_on_tftlcd+0x11a8>
					ST7735_drawString(138, 75,(char *)buffer, colYellow, 1);  // Start point Right - top
				else if(AMC_Status_Byte & AMC_PROCESS_BUILDING_PRESSURE)
102db3ec:	e3130004 	tst	r3, #4
102db3f0:	1a00001b 	bne	102db464 <display_on_tftlcd+0x11c4>
					ST7735_drawString(138, 75,(char *)buffer, colOrangeRed, 1);  // Start point Right - top
				else if(AMC_Status_Byte & AMC_MEMBRANE_CLEANING)
102db3f4:	e3130008 	tst	r3, #8
102db3f8:	0a000006 	beq	102db418 <display_on_tftlcd+0x1178>
					ST7735_drawString(138, 75,(char *)buffer, colLightGreen, 1);  // Start point Right - top
102db3fc:	e58d7000 	str	r7, [sp]
102db400:	e3a0008a 	mov	r0, #138	; 0x8a
102db404:	e3a0104b 	mov	r1, #75	; 0x4b
102db408:	e51f2248 	ldr	r2, [pc, #-584]	; 102db1c8 <display_on_tftlcd+0xf28>
102db40c:	e51f3258 	ldr	r3, [pc, #-600]	; 102db1bc <display_on_tftlcd+0xf1c>
102db410:	ebfff6f1 	bl	102d8fdc <ST7735_drawString>
102db414:	eafffe5d 	b	102dad90 <display_on_tftlcd+0xaf0>
				else
					ST7735_drawString(138, 75,(char *)buffer, colWhite, 1);  // Start point Right - top
102db418:	e3a03001 	mov	r3, #1
102db41c:	e58d3000 	str	r3, [sp]
102db420:	e3a0008a 	mov	r0, #138	; 0x8a
102db424:	e3a0104b 	mov	r1, #75	; 0x4b
102db428:	eafffe55 	b	102dad84 <display_on_tftlcd+0xae4>
			Ql_sprintf((char *)buffer,"%d",previous_flowrate);
			ST7735_drawString(132, 95, (char *)buffer, colBlack, 1);
			Ql_sprintf((char *)buffer,"%d",water_flow_rate_ml_minute);
			if( water_flow_rate_ml_minute >= 80)
			{
				ST7735_drawString(132, 95, (char *)buffer, colAqua, 1);  //Flow rate in mL per minute
102db42c:	e58d7000 	str	r7, [sp]
102db430:	e3a00084 	mov	r0, #132	; 0x84
102db434:	e3a0105f 	mov	r1, #95	; 0x5f
102db438:	e51f2278 	ldr	r2, [pc, #-632]	; 102db1c8 <display_on_tftlcd+0xf28>
102db43c:	e51f3284 	ldr	r3, [pc, #-644]	; 102db1c0 <display_on_tftlcd+0xf20>
102db440:	ebfff6e5 	bl	102d8fdc <ST7735_drawString>
102db444:	eafffe95 	b	102daea0 <display_on_tftlcd+0xc00>
			ST7735_drawString(138, 75,(char *)buffer, colBlack, 1);  // Start point Right - top // Erase last message string
			Ql_sprintf((char *)buffer,"%d",amc_timer);
			if(Status_Byte & AMC_MODE_ON) // AMC mode is ON
			{
				if(AMC_Status_Byte & AMC_PHASE_1_START)
					ST7735_drawString(138, 75,(char *)buffer, colYellow, 1);  // Start point Right - top
102db448:	e58d7000 	str	r7, [sp]
102db44c:	e3a0008a 	mov	r0, #138	; 0x8a
102db450:	e3a0104b 	mov	r1, #75	; 0x4b
102db454:	e51f2294 	ldr	r2, [pc, #-660]	; 102db1c8 <display_on_tftlcd+0xf28>
102db458:	e51f329c 	ldr	r3, [pc, #-668]	; 102db1c4 <display_on_tftlcd+0xf24>
102db45c:	ebfff6de 	bl	102d8fdc <ST7735_drawString>
102db460:	eafffe4a 	b	102dad90 <display_on_tftlcd+0xaf0>
				else if(AMC_Status_Byte & AMC_PROCESS_BUILDING_PRESSURE)
					ST7735_drawString(138, 75,(char *)buffer, colOrangeRed, 1);  // Start point Right - top
102db464:	e58d7000 	str	r7, [sp]
102db468:	e3a0008a 	mov	r0, #138	; 0x8a
102db46c:	e3a0104b 	mov	r1, #75	; 0x4b
102db470:	e51f22b0 	ldr	r2, [pc, #-688]	; 102db1c8 <display_on_tftlcd+0xf28>
102db474:	e51f32b0 	ldr	r3, [pc, #-688]	; 102db1cc <display_on_tftlcd+0xf2c>
102db478:	ebfff6d7 	bl	102d8fdc <ST7735_drawString>
102db47c:	eafffe43 	b	102dad90 <display_on_tftlcd+0xaf0>

102db480 <ATResponse_SSL_handler_close>:
	sslsendParam->return_val = RIL_ATRSP_CONTINUE;
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_close(char* line, u32 len, void* userdata)
{
102db480:	e92d4070 	push	{r4, r5, r6, lr}
	char *head = Ql_RIL_FindString(line, len, "CLOSE OK");
102db484:	e59f2034 	ldr	r2, [pc, #52]	; 102db4c0 <ATResponse_SSL_handler_close+0x40>
102db488:	e59f4034 	ldr	r4, [pc, #52]	; 102db4c4 <ATResponse_SSL_handler_close+0x44>
	sslsendParam->return_val = RIL_ATRSP_CONTINUE;
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_close(char* line, u32 len, void* userdata)
{
102db48c:	e1a06000 	mov	r6, r0
102db490:	e1a05001 	mov	r5, r1
	char *head = Ql_RIL_FindString(line, len, "CLOSE OK");
102db494:	e12fff34 	blx	r4
	if(head)
102db498:	e3500000 	cmp	r0, #0
102db49c:	0a000001 	beq	102db4a8 <ATResponse_SSL_handler_close+0x28>
	{
		return	RIL_ATRSP_SUCCESS;
102db4a0:	e3a00000 	mov	r0, #0
	{
		return	RIL_ATRSP_FAILED;
	}

	return RIL_ATRSP_FAILED; //continue wait
}
102db4a4:	e8bd8070 	pop	{r4, r5, r6, pc}
	char *head = Ql_RIL_FindString(line, len, "CLOSE OK");
	if(head)
	{
		return	RIL_ATRSP_SUCCESS;
	}
	head = Ql_RIL_FindString(line, len, "ERROR:");//fail
102db4a8:	e1a00006 	mov	r0, r6
102db4ac:	e1a01005 	mov	r1, r5
102db4b0:	e59f2010 	ldr	r2, [pc, #16]	; 102db4c8 <ATResponse_SSL_handler_close+0x48>
102db4b4:	e12fff34 	blx	r4
	if(head)
	{
		return	RIL_ATRSP_FAILED;
102db4b8:	e3e00000 	mvn	r0, #0
102db4bc:	e8bd8070 	pop	{r4, r5, r6, pc}
102db4c0:	102ef9f0 	.word	0x102ef9f0
102db4c4:	102cce98 	.word	0x102cce98
102db4c8:	102ef9fc 	.word	0x102ef9fc

102db4cc <ATResponse_SSL_handler_state>:
}

static s32 ATResponse_SSL_handler_state(char* line, u32 len, void* userdata)
{
	SSL_SocStateParam *sslsocStateParam = (SSL_SocStateParam *)userdata;
	char tmp_buf[15] = "\0";
102db4cc:	e59fc194 	ldr	ip, [pc, #404]	; 102db668 <ATResponse_SSL_handler_state+0x19c>
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_state(char* line, u32 len, void* userdata)
{
102db4d0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	SSL_SocStateParam *sslsocStateParam = (SSL_SocStateParam *)userdata;
	char tmp_buf[15] = "\0";
102db4d4:	e3a03000 	mov	r3, #0
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_state(char* line, u32 len, void* userdata)
{
102db4d8:	e24dd010 	sub	sp, sp, #16
	SSL_SocStateParam *sslsocStateParam = (SSL_SocStateParam *)userdata;
	char tmp_buf[15] = "\0";
102db4dc:	e1dcc0b0 	ldrh	ip, [ip]
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_state(char* line, u32 len, void* userdata)
{
102db4e0:	e1a08002 	mov	r8, r2
	SSL_SocStateParam *sslsocStateParam = (SSL_SocStateParam *)userdata;
	char tmp_buf[15] = "\0";

	char *head = Ql_RIL_FindString(line, len, "\r\n+QSSLSTATE:");
102db4e4:	e59f4180 	ldr	r4, [pc, #384]	; 102db66c <ATResponse_SSL_handler_state+0x1a0>
102db4e8:	e59f2180 	ldr	r2, [pc, #384]	; 102db670 <ATResponse_SSL_handler_state+0x1a4>
}

static s32 ATResponse_SSL_handler_state(char* line, u32 len, void* userdata)
{
	SSL_SocStateParam *sslsocStateParam = (SSL_SocStateParam *)userdata;
	char tmp_buf[15] = "\0";
102db4ec:	e1a07003 	mov	r7, r3
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_state(char* line, u32 len, void* userdata)
{
102db4f0:	e1a06000 	mov	r6, r0
102db4f4:	e1a05001 	mov	r5, r1
	SSL_SocStateParam *sslsocStateParam = (SSL_SocStateParam *)userdata;
	char tmp_buf[15] = "\0";
102db4f8:	e1cdc0b0 	strh	ip, [sp]
102db4fc:	e1cd30b2 	strh	r3, [sp, #2]
102db500:	e1cd30b4 	strh	r3, [sp, #4]
102db504:	e1cd30b6 	strh	r3, [sp, #6]
102db508:	e1cd30b8 	strh	r3, [sp, #8]
102db50c:	e1cd30ba 	strh	r3, [sp, #10]
102db510:	e1cd30bc 	strh	r3, [sp, #12]
102db514:	e5cd300e 	strb	r3, [sp, #14]

	char *head = Ql_RIL_FindString(line, len, "\r\n+QSSLSTATE:");
102db518:	e12fff34 	blx	r4
	if(head)
102db51c:	e3500000 	cmp	r0, #0
102db520:	0a000015 	beq	102db57c <ATResponse_SSL_handler_state+0xb0>
	{
		Ql_sprintf(tmp_buf, "\r\n+QSSLSTATE: %d", sslsocStateParam->ssid);
102db524:	e59f3148 	ldr	r3, [pc, #328]	; 102db674 <ATResponse_SSL_handler_state+0x1a8>
102db528:	e59f1148 	ldr	r1, [pc, #328]	; 102db678 <ATResponse_SSL_handler_state+0x1ac>
102db52c:	e5933000 	ldr	r3, [r3]
102db530:	e5982000 	ldr	r2, [r8]
102db534:	e1a0000d 	mov	r0, sp
102db538:	e12fff33 	blx	r3
		head = Ql_RIL_FindString(line, len, tmp_buf);
102db53c:	e1a00006 	mov	r0, r6
102db540:	e1a01005 	mov	r1, r5
102db544:	e1a0200d 	mov	r2, sp
102db548:	e12fff34 	blx	r4
		if(head)
102db54c:	e3500000 	cmp	r0, #0
102db550:	0a000006 	beq	102db570 <ATResponse_SSL_handler_state+0xa4>
		{
			head = Ql_RIL_FindString(line, len, "INITIAL");
102db554:	e1a00006 	mov	r0, r6
102db558:	e1a01005 	mov	r1, r5
102db55c:	e59f2118 	ldr	r2, [pc, #280]	; 102db67c <ATResponse_SSL_handler_state+0x1b0>
102db560:	e12fff34 	blx	r4
			if(head)
102db564:	e3500000 	cmp	r0, #0
102db568:	0a000011 	beq	102db5b4 <ATResponse_SSL_handler_state+0xe8>
			{
				sslsocStateParam->sslSocState = SSL_SOC_INITIAL;
102db56c:	e5c87004 	strb	r7, [r8, #4]
				return RIL_ATRSP_CONTINUE;
102db570:	e3a00001 	mov	r0, #1
	{
		return  RIL_ATRSP_SUCCESS;
	}

	return RIL_ATRSP_CONTINUE; //continue wait
}
102db574:	e28dd010 	add	sp, sp, #16
102db578:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
			}
		}

		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
102db57c:	e1a00006 	mov	r0, r6
102db580:	e1a01005 	mov	r1, r5
102db584:	e59f20f4 	ldr	r2, [pc, #244]	; 102db680 <ATResponse_SSL_handler_state+0x1b4>
102db588:	e12fff34 	blx	r4
	if(head)
102db58c:	e3500000 	cmp	r0, #0
	{
		return  RIL_ATRSP_FAILED;
102db590:	13e00000 	mvnne	r0, #0
		}

		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
	if(head)
102db594:	1afffff6 	bne	102db574 <ATResponse_SSL_handler_state+0xa8>
	{
		return  RIL_ATRSP_FAILED;
	}
	head = Ql_RIL_FindString(line, len, "OK");
102db598:	e1a00006 	mov	r0, r6
102db59c:	e1a01005 	mov	r1, r5
102db5a0:	e59f20dc 	ldr	r2, [pc, #220]	; 102db684 <ATResponse_SSL_handler_state+0x1b8>
102db5a4:	e12fff34 	blx	r4
	if(head)
102db5a8:	e2700001 	rsbs	r0, r0, #1
102db5ac:	33a00000 	movcc	r0, #0
102db5b0:	eaffffef 	b	102db574 <ATResponse_SSL_handler_state+0xa8>
			if(head)
			{
				sslsocStateParam->sslSocState = SSL_SOC_INITIAL;
				return RIL_ATRSP_CONTINUE;
			}
			head = Ql_RIL_FindString(line, len, "CONNECTING");
102db5b4:	e1a00006 	mov	r0, r6
102db5b8:	e1a01005 	mov	r1, r5
102db5bc:	e59f20c4 	ldr	r2, [pc, #196]	; 102db688 <ATResponse_SSL_handler_state+0x1bc>
102db5c0:	e12fff34 	blx	r4
			if(head)
102db5c4:	e3500000 	cmp	r0, #0
			{
				sslsocStateParam->sslSocState = SSL_SOC_CONNECTING;
102db5c8:	13a00001 	movne	r0, #1
102db5cc:	15c80004 	strbne	r0, [r8, #4]
102db5d0:	1affffe7 	bne	102db574 <ATResponse_SSL_handler_state+0xa8>
				return RIL_ATRSP_CONTINUE;
			}
			head = Ql_RIL_FindString(line, len, "CONNECTED");
102db5d4:	e1a00006 	mov	r0, r6
102db5d8:	e1a01005 	mov	r1, r5
102db5dc:	e59f20a8 	ldr	r2, [pc, #168]	; 102db68c <ATResponse_SSL_handler_state+0x1c0>
102db5e0:	e12fff34 	blx	r4
			if(head)
102db5e4:	e3500000 	cmp	r0, #0
			{
				sslsocStateParam->sslSocState = SSL_SOC_CONNECTED;
102db5e8:	13a03002 	movne	r3, #2
102db5ec:	15c83004 	strbne	r3, [r8, #4]
				return RIL_ATRSP_CONTINUE;
102db5f0:	13a00001 	movne	r0, #1
102db5f4:	1affffde 	bne	102db574 <ATResponse_SSL_handler_state+0xa8>
			}
			head = Ql_RIL_FindString(line, len, "REMOTE CLOSING");
102db5f8:	e1a00006 	mov	r0, r6
102db5fc:	e1a01005 	mov	r1, r5
102db600:	e59f2088 	ldr	r2, [pc, #136]	; 102db690 <ATResponse_SSL_handler_state+0x1c4>
102db604:	e12fff34 	blx	r4
			if(head)
102db608:	e3500000 	cmp	r0, #0
			{
				sslsocStateParam->sslSocState = SSL_SOC_REMOTECLOSING;
102db60c:	13a03003 	movne	r3, #3
102db610:	15c83004 	strbne	r3, [r8, #4]
				return RIL_ATRSP_CONTINUE;
102db614:	13a00001 	movne	r0, #1
102db618:	1affffd5 	bne	102db574 <ATResponse_SSL_handler_state+0xa8>
			}
			head = Ql_RIL_FindString(line, len, "CLOSING");
102db61c:	e1a00006 	mov	r0, r6
102db620:	e1a01005 	mov	r1, r5
102db624:	e59f2068 	ldr	r2, [pc, #104]	; 102db694 <ATResponse_SSL_handler_state+0x1c8>
102db628:	e12fff34 	blx	r4
			if(head)
102db62c:	e3500000 	cmp	r0, #0
			{
				sslsocStateParam->sslSocState = SSL_SOC_CLOSING;
102db630:	13a03004 	movne	r3, #4
102db634:	15c83004 	strbne	r3, [r8, #4]
				return RIL_ATRSP_CONTINUE;
102db638:	13a00001 	movne	r0, #1
102db63c:	1affffcc 	bne	102db574 <ATResponse_SSL_handler_state+0xa8>
			}
			head = Ql_RIL_FindString(line, len, "CLOSED");
102db640:	e1a00006 	mov	r0, r6
102db644:	e1a01005 	mov	r1, r5
102db648:	e59f2048 	ldr	r2, [pc, #72]	; 102db698 <ATResponse_SSL_handler_state+0x1cc>
102db64c:	e12fff34 	blx	r4
			if(head)
102db650:	e3500000 	cmp	r0, #0
102db654:	0affffc5 	beq	102db570 <ATResponse_SSL_handler_state+0xa4>
			{
				sslsocStateParam->sslSocState = SSL_SOC_CLOSED;
102db658:	e3a03005 	mov	r3, #5
102db65c:	e5c83004 	strb	r3, [r8, #4]
				return RIL_ATRSP_CONTINUE;
102db660:	e3a00001 	mov	r0, #1
102db664:	eaffffc2 	b	102db574 <ATResponse_SSL_handler_state+0xa8>
102db668:	102eb038 	.word	0x102eb038
102db66c:	102cce98 	.word	0x102cce98
102db670:	102efa04 	.word	0x102efa04
102db674:	f03de540 	.word	0xf03de540
102db678:	102efa14 	.word	0x102efa14
102db67c:	102efa28 	.word	0x102efa28
102db680:	102ede00 	.word	0x102ede00
102db684:	102ee5e8 	.word	0x102ee5e8
102db688:	102ee5b8 	.word	0x102ee5b8
102db68c:	102efa30 	.word	0x102efa30
102db690:	102efa3c 	.word	0x102efa3c
102db694:	102efa4c 	.word	0x102efa4c
102db698:	102efa54 	.word	0x102efa54

102db69c <ATResponse_SSL_handler_CERTIFICATE_WRITE>:
 *
 * Return: see function below
 *
 *****************************************************************/
static s32 ATResponse_SSL_handler_CERTIFICATE_WRITE(char* line, u32 len, void* userdata)
{
102db69c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	SSL_WriteCert *sslwriteCert = (SSL_WriteCert *)userdata;
	char* pHead = NULL;
//#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line);
102db6a0:	e59f414c 	ldr	r4, [pc, #332]	; 102db7f4 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x158>
 *
 * Return: see function below
 *
 *****************************************************************/
static s32 ATResponse_SSL_handler_CERTIFICATE_WRITE(char* line, u32 len, void* userdata)
{
102db6a4:	e1a05000 	mov	r5, r0
102db6a8:	e1a07001 	mov	r7, r1
	SSL_WriteCert *sslwriteCert = (SSL_WriteCert *)userdata;
	char* pHead = NULL;
//#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line);
102db6ac:	e59f3144 	ldr	r3, [pc, #324]	; 102db7f8 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x15c>
102db6b0:	e3a01000 	mov	r1, #0
 *
 * Return: see function below
 *
 *****************************************************************/
static s32 ATResponse_SSL_handler_CERTIFICATE_WRITE(char* line, u32 len, void* userdata)
{
102db6b4:	e1a08002 	mov	r8, r2
	SSL_WriteCert *sslwriteCert = (SSL_WriteCert *)userdata;
	char* pHead = NULL;
//#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line);
102db6b8:	e1a00004 	mov	r0, r4
102db6bc:	e3a02c02 	mov	r2, #512	; 0x200
102db6c0:	e12fff33 	blx	r3
102db6c4:	e59f3130 	ldr	r3, [pc, #304]	; 102db7fc <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x160>
102db6c8:	e59f1130 	ldr	r1, [pc, #304]	; 102db800 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x164>
102db6cc:	e1a02005 	mov	r2, r5
102db6d0:	e5933000 	ldr	r3, [r3]
102db6d4:	e1a00004 	mov	r0, r4
102db6d8:	e12fff33 	blx	r3
102db6dc:	e59f3120 	ldr	r3, [pc, #288]	; 102db804 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x168>
102db6e0:	e1a00004 	mov	r0, r4
102db6e4:	e12fff33 	blx	r3
102db6e8:	e1a01004 	mov	r1, r4
102db6ec:	e59f3114 	ldr	r3, [pc, #276]	; 102db808 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x16c>
//#endif
	pHead = Ql_RIL_FindString(line, len, "CONNECT");
102db6f0:	e59f6114 	ldr	r6, [pc, #276]	; 102db80c <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x170>
static s32 ATResponse_SSL_handler_CERTIFICATE_WRITE(char* line, u32 len, void* userdata)
{
	SSL_WriteCert *sslwriteCert = (SSL_WriteCert *)userdata;
	char* pHead = NULL;
//#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line);
102db6f4:	e1a02000 	mov	r2, r0
102db6f8:	e3a0000a 	mov	r0, #10
102db6fc:	e12fff33 	blx	r3
//#endif
	pHead = Ql_RIL_FindString(line, len, "CONNECT");
102db700:	e1a00005 	mov	r0, r5
102db704:	e1a01007 	mov	r1, r7
102db708:	e59f2100 	ldr	r2, [pc, #256]	; 102db810 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x174>
102db70c:	e12fff36 	blx	r6
	if (pHead)
102db710:	e3500000 	cmp	r0, #0
102db714:	0a000007 	beq	102db738 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x9c>
	{
		Ql_Sleep(1000);//Do not move
102db718:	e3a00ffa 	mov	r0, #1000	; 0x3e8
102db71c:	e59f30f0 	ldr	r3, [pc, #240]	; 102db814 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x178>
102db720:	e12fff33 	blx	r3
		if (write_flag == 1)
102db724:	e5d44200 	ldrb	r4, [r4, #512]	; 0x200
102db728:	e3540001 	cmp	r4, #1
102db72c:	0a00000f 	beq	102db770 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0xd4>
		{
			Ql_RIL_WriteDataToCore((u8*)sslwriteCert->cert_name, sslwriteCert->cert_len);
		}
		return RIL_ATRSP_CONTINUE;	// wait for OK
102db730:	e3a00001 	mov	r0, #1
102db734:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	}
	pHead = Ql_RIL_FindString(line, len, "+QSECWRITE:");
102db738:	e1a00005 	mov	r0, r5
102db73c:	e1a01007 	mov	r1, r7
102db740:	e59f20d0 	ldr	r2, [pc, #208]	; 102db818 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x17c>
102db744:	e12fff36 	blx	r6
	if (pHead)
102db748:	e2504000 	subs	r4, r0, #0
102db74c:	1afffff7 	bne	102db730 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x94>
	{
		return RIL_ATRSP_CONTINUE;
	}
	pHead = Ql_RIL_FindString(line, len, "OK");
102db750:	e1a00005 	mov	r0, r5
102db754:	e1a01007 	mov	r1, r7
102db758:	e59f20bc 	ldr	r2, [pc, #188]	; 102db81c <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x180>
102db75c:	e12fff36 	blx	r6
	if (pHead)
102db760:	e3500000 	cmp	r0, #0
102db764:	0a000006 	beq	102db784 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0xe8>
	{
		return RIL_ATRSP_SUCCESS;
102db768:	e1a00004 	mov	r0, r4
			Ql_sscanf(line, "%*[^: ]: %d[^\r\n]", (s32*)sslwriteCert->errCode);
		}
		return RIL_ATRSP_FAILED;
	}
	return RIL_ATRSP_CONTINUE;	// Just wait for the specified results above
}
102db76c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	if (pHead)
	{
		Ql_Sleep(1000);//Do not move
		if (write_flag == 1)
		{
			Ql_RIL_WriteDataToCore((u8*)sslwriteCert->cert_name, sslwriteCert->cert_len);
102db770:	e9980003 	ldmib	r8, {r0, r1}
102db774:	e59f30a4 	ldr	r3, [pc, #164]	; 102db820 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x184>
102db778:	e12fff33 	blx	r3
		}
		return RIL_ATRSP_CONTINUE;	// wait for OK
102db77c:	e1a00004 	mov	r0, r4
102db780:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	pHead = Ql_RIL_FindString(line, len, "OK");
	if (pHead)
	{
		return RIL_ATRSP_SUCCESS;
	}
	pHead = Ql_RIL_FindString(line, len, "ERROR");
102db784:	e1a00005 	mov	r0, r5
102db788:	e1a01007 	mov	r1, r7
102db78c:	e59f2090 	ldr	r2, [pc, #144]	; 102db824 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x188>
102db790:	e12fff36 	blx	r6
	if (pHead)
102db794:	e3500000 	cmp	r0, #0
102db798:	0a000005 	beq	102db7b4 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x118>
	{
		if (sslwriteCert->errCode != NULL)
102db79c:	e598300c 	ldr	r3, [r8, #12]
102db7a0:	e3530000 	cmp	r3, #0
102db7a4:	0a000010 	beq	102db7ec <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x150>
		{
			*((s32*)sslwriteCert->errCode) = RIL_AT_FAILED;
102db7a8:	e3e00000 	mvn	r0, #0
102db7ac:	e5830000 	str	r0, [r3]
102db7b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		}
		return RIL_ATRSP_FAILED;
	}
	pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");
102db7b4:	e1a00005 	mov	r0, r5
102db7b8:	e1a01007 	mov	r1, r7
102db7bc:	e59f2064 	ldr	r2, [pc, #100]	; 102db828 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x18c>
102db7c0:	e12fff36 	blx	r6
	if (pHead)
102db7c4:	e3500000 	cmp	r0, #0
102db7c8:	0affffd8 	beq	102db730 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x94>
	{
		if (sslwriteCert->errCode != NULL)
102db7cc:	e598200c 	ldr	r2, [r8, #12]
102db7d0:	e3520000 	cmp	r2, #0
102db7d4:	0a000004 	beq	102db7ec <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x150>
		{
			Ql_sscanf(line, "%*[^: ]: %d[^\r\n]", (s32*)sslwriteCert->errCode);
102db7d8:	e59f304c 	ldr	r3, [pc, #76]	; 102db82c <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x190>
102db7dc:	e1a00005 	mov	r0, r5
102db7e0:	e5933000 	ldr	r3, [r3]
102db7e4:	e59f1044 	ldr	r1, [pc, #68]	; 102db830 <ATResponse_SSL_handler_CERTIFICATE_WRITE+0x194>
102db7e8:	e12fff33 	blx	r3
		}
		return RIL_ATRSP_FAILED;
102db7ec:	e3e00000 	mvn	r0, #0
102db7f0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102db7f4:	f03d6584 	.word	0xf03d6584
102db7f8:	102e58f4 	.word	0x102e58f4
102db7fc:	f03de540 	.word	0xf03de540
102db800:	102efa90 	.word	0x102efa90
102db804:	102e57a4 	.word	0x102e57a4
102db808:	102e6230 	.word	0x102e6230
102db80c:	102cce98 	.word	0x102cce98
102db810:	102ee40c 	.word	0x102ee40c
102db814:	102e5b10 	.word	0x102e5b10
102db818:	102efa5c 	.word	0x102efa5c
102db81c:	102ee5e8 	.word	0x102ee5e8
102db820:	102e53c8 	.word	0x102e53c8
102db824:	102ede00 	.word	0x102ede00
102db828:	102ede08 	.word	0x102ede08
102db82c:	f03de548 	.word	0xf03de548
102db830:	102ee414 	.word	0x102ee414

102db834 <ATResponse_SSL_handler_open>:
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_open(char* line, u32 len, void* userdata)
{
102db834:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102db838:	e1a05002 	mov	r5, r2
102db83c:	e24dd010 	sub	sp, sp, #16
	ST_AT_TCPparam *tcpParam = (ST_AT_TCPparam *)userdata;

	char *head = Ql_RIL_FindString(line, len, tcpParam->prefix); //continue wait
102db840:	e5922000 	ldr	r2, [r2]
102db844:	e59f4104 	ldr	r4, [pc, #260]	; 102db950 <ATResponse_SSL_handler_open+0x11c>
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_open(char* line, u32 len, void* userdata)
{
102db848:	e1a08000 	mov	r8, r0
102db84c:	e1a07001 	mov	r7, r1
	ST_AT_TCPparam *tcpParam = (ST_AT_TCPparam *)userdata;

	char *head = Ql_RIL_FindString(line, len, tcpParam->prefix); //continue wait
102db850:	e12fff34 	blx	r4
#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line);
#endif
	if(head)
102db854:	e2506000 	subs	r6, r0, #0
102db858:	0a000020 	beq	102db8e0 <ATResponse_SSL_handler_open+0xac>
	{
		char strTmp[10];
		char* p1 = NULL;
		char* p2 = NULL;
		Ql_memset(strTmp, 0, sizeof(strTmp));
102db85c:	e3a0200a 	mov	r2, #10
102db860:	e59f30ec 	ldr	r3, [pc, #236]	; 102db954 <ATResponse_SSL_handler_open+0x120>
102db864:	e3a01000 	mov	r1, #0
102db868:	e28d0004 	add	r0, sp, #4
102db86c:	e12fff33 	blx	r3
		p1 = Ql_strstr(head, ":");
102db870:	e1a00006 	mov	r0, r6
102db874:	e59f10dc 	ldr	r1, [pc, #220]	; 102db958 <ATResponse_SSL_handler_open+0x124>
102db878:	e59f60dc 	ldr	r6, [pc, #220]	; 102db95c <ATResponse_SSL_handler_open+0x128>
102db87c:	e12fff36 	blx	r6
		p2 = Ql_strstr(p1 + 1, "\r\n");
102db880:	e59f10d8 	ldr	r1, [pc, #216]	; 102db960 <ATResponse_SSL_handler_open+0x12c>
	{
		char strTmp[10];
		char* p1 = NULL;
		char* p2 = NULL;
		Ql_memset(strTmp, 0, sizeof(strTmp));
		p1 = Ql_strstr(head, ":");
102db884:	e1a04000 	mov	r4, r0
		p2 = Ql_strstr(p1 + 1, "\r\n");
102db888:	e2800001 	add	r0, r0, #1
102db88c:	e12fff36 	blx	r6
		if (p1 && p2)
102db890:	e3500000 	cmp	r0, #0
102db894:	13540000 	cmpne	r4, #0
102db898:	1a000005 	bne	102db8b4 <ATResponse_SSL_handler_open+0x80>
102db89c:	e5950004 	ldr	r0, [r5, #4]
		{
			Ql_memcpy(strTmp, p1 + 4, p2 - p1 - 4);
			tcpParam->data= Ql_atoi(strTmp);
		}
		if(tcpParam->data == 0)
102db8a0:	e3500000 	cmp	r0, #0
			return  RIL_ATRSP_SUCCESS;
102db8a4:	13e00000 	mvnne	r0, #0
102db8a8:	03a00000 	moveq	r0, #0
	if(head)
	{
		return  RIL_ATRSP_FAILED;
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}
102db8ac:	e28dd010 	add	sp, sp, #16
102db8b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		Ql_memset(strTmp, 0, sizeof(strTmp));
		p1 = Ql_strstr(head, ":");
		p2 = Ql_strstr(p1 + 1, "\r\n");
		if (p1 && p2)
		{
			Ql_memcpy(strTmp, p1 + 4, p2 - p1 - 4);
102db8b4:	e0642000 	rsb	r2, r4, r0
102db8b8:	e2841004 	add	r1, r4, #4
102db8bc:	e2422004 	sub	r2, r2, #4
102db8c0:	e59f309c 	ldr	r3, [pc, #156]	; 102db964 <ATResponse_SSL_handler_open+0x130>
102db8c4:	e28d0004 	add	r0, sp, #4
102db8c8:	e12fff33 	blx	r3
			tcpParam->data= Ql_atoi(strTmp);
102db8cc:	e28d0004 	add	r0, sp, #4
102db8d0:	e59f3090 	ldr	r3, [pc, #144]	; 102db968 <ATResponse_SSL_handler_open+0x134>
102db8d4:	e12fff33 	blx	r3
102db8d8:	e5850004 	str	r0, [r5, #4]
102db8dc:	eaffffef 	b	102db8a0 <ATResponse_SSL_handler_open+0x6c>
		if(tcpParam->data == 0)
			return  RIL_ATRSP_SUCCESS;
		else
			return  RIL_ATRSP_FAILED;
	}
	head = Ql_RIL_FindString(line, len, "OK");
102db8e0:	e1a00008 	mov	r0, r8
102db8e4:	e1a01007 	mov	r1, r7
102db8e8:	e59f207c 	ldr	r2, [pc, #124]	; 102db96c <ATResponse_SSL_handler_open+0x138>
102db8ec:	e12fff34 	blx	r4
	if(head)
102db8f0:	e3500000 	cmp	r0, #0
102db8f4:	0a000001 	beq	102db900 <ATResponse_SSL_handler_open+0xcc>
	{
		return  RIL_ATRSP_CONTINUE;
102db8f8:	e3a00001 	mov	r0, #1
102db8fc:	eaffffea 	b	102db8ac <ATResponse_SSL_handler_open+0x78>
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
102db900:	e1a00008 	mov	r0, r8
102db904:	e1a01007 	mov	r1, r7
102db908:	e59f2060 	ldr	r2, [pc, #96]	; 102db970 <ATResponse_SSL_handler_open+0x13c>
102db90c:	e12fff34 	blx	r4
	if(head)
102db910:	e3500000 	cmp	r0, #0
102db914:	1a00000b 	bne	102db948 <ATResponse_SSL_handler_open+0x114>
	{
		return  RIL_ATRSP_FAILED;
	}
	head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102db918:	e1a00008 	mov	r0, r8
102db91c:	e1a01007 	mov	r1, r7
102db920:	e59f204c 	ldr	r2, [pc, #76]	; 102db974 <ATResponse_SSL_handler_open+0x140>
102db924:	e12fff34 	blx	r4
	if(head)
102db928:	e3500000 	cmp	r0, #0
102db92c:	1a000005 	bne	102db948 <ATResponse_SSL_handler_open+0x114>
	{
		return  RIL_ATRSP_FAILED;
	}
	head = Ql_RIL_FindString(line, len, "+CMS ERROR:");//fail
102db930:	e1a00008 	mov	r0, r8
102db934:	e1a01007 	mov	r1, r7
102db938:	e59f2038 	ldr	r2, [pc, #56]	; 102db978 <ATResponse_SSL_handler_open+0x144>
102db93c:	e12fff34 	blx	r4
	if(head)
102db940:	e3500000 	cmp	r0, #0
102db944:	0affffeb 	beq	102db8f8 <ATResponse_SSL_handler_open+0xc4>
		return  RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
	if(head)
	{
		return  RIL_ATRSP_FAILED;
102db948:	e3e00000 	mvn	r0, #0
102db94c:	eaffffd6 	b	102db8ac <ATResponse_SSL_handler_open+0x78>
102db950:	102cce98 	.word	0x102cce98
102db954:	102e58f4 	.word	0x102e58f4
102db958:	102efa10 	.word	0x102efa10
102db95c:	102e5a04 	.word	0x102e5a04
102db960:	102ee78c 	.word	0x102ee78c
102db964:	102e597c 	.word	0x102e597c
102db968:	102e5a8c 	.word	0x102e5a8c
102db96c:	102ee5e8 	.word	0x102ee5e8
102db970:	102ede00 	.word	0x102ede00
102db974:	102ede08 	.word	0x102ede08
102db978:	102ede24 	.word	0x102ede24

102db97c <ATResponse_SSL_handler_CERTIFICATE_READ>:
 *
 * Return: see function below
 *
 *****************************************************************/
static s32 ATResponse_SSL_handler_CERTIFICATE_READ(char* line, u32 len, void* userdata)
{
102db97c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
102db980:	e1a06002 	mov	r6, r2
102db984:	e24dd014 	sub	sp, sp, #20
	ST_AT_TCPparam *tcpParam = (ST_AT_TCPparam *)userdata;
	char *head = Ql_RIL_FindString(line, len, tcpParam->prefix); //continue wait
102db988:	e5922000 	ldr	r2, [r2]
102db98c:	e59f713c 	ldr	r7, [pc, #316]	; 102dbad0 <ATResponse_SSL_handler_CERTIFICATE_READ+0x154>
 *
 * Return: see function below
 *
 *****************************************************************/
static s32 ATResponse_SSL_handler_CERTIFICATE_READ(char* line, u32 len, void* userdata)
{
102db990:	e1a08000 	mov	r8, r0
102db994:	e1a0a001 	mov	sl, r1
	ST_AT_TCPparam *tcpParam = (ST_AT_TCPparam *)userdata;
	char *head = Ql_RIL_FindString(line, len, tcpParam->prefix); //continue wait
102db998:	e12fff37 	blx	r7
//#ifdef AT_CMD_MSG
	APP_DEBUG("ATResponse_SSL_handler_CERTIFICATE_READ %s\r\n",line);
102db99c:	e59f5130 	ldr	r5, [pc, #304]	; 102dbad4 <ATResponse_SSL_handler_CERTIFICATE_READ+0x158>
102db9a0:	e3a01000 	mov	r1, #0
102db9a4:	e3a02c02 	mov	r2, #512	; 0x200
 *
 *****************************************************************/
static s32 ATResponse_SSL_handler_CERTIFICATE_READ(char* line, u32 len, void* userdata)
{
	ST_AT_TCPparam *tcpParam = (ST_AT_TCPparam *)userdata;
	char *head = Ql_RIL_FindString(line, len, tcpParam->prefix); //continue wait
102db9a8:	e1a04000 	mov	r4, r0
//#ifdef AT_CMD_MSG
	APP_DEBUG("ATResponse_SSL_handler_CERTIFICATE_READ %s\r\n",line);
102db9ac:	e59f0124 	ldr	r0, [pc, #292]	; 102dbad8 <ATResponse_SSL_handler_CERTIFICATE_READ+0x15c>
102db9b0:	e12fff35 	blx	r5
102db9b4:	e59f3120 	ldr	r3, [pc, #288]	; 102dbadc <ATResponse_SSL_handler_CERTIFICATE_READ+0x160>
102db9b8:	e59f1120 	ldr	r1, [pc, #288]	; 102dbae0 <ATResponse_SSL_handler_CERTIFICATE_READ+0x164>
102db9bc:	e1a02008 	mov	r2, r8
102db9c0:	e5933000 	ldr	r3, [r3]
102db9c4:	e59f010c 	ldr	r0, [pc, #268]	; 102dbad8 <ATResponse_SSL_handler_CERTIFICATE_READ+0x15c>
102db9c8:	e12fff33 	blx	r3
102db9cc:	e59f3110 	ldr	r3, [pc, #272]	; 102dbae4 <ATResponse_SSL_handler_CERTIFICATE_READ+0x168>
102db9d0:	e59f0100 	ldr	r0, [pc, #256]	; 102dbad8 <ATResponse_SSL_handler_CERTIFICATE_READ+0x15c>
102db9d4:	e12fff33 	blx	r3
102db9d8:	e59f10f8 	ldr	r1, [pc, #248]	; 102dbad8 <ATResponse_SSL_handler_CERTIFICATE_READ+0x15c>
102db9dc:	e59f3104 	ldr	r3, [pc, #260]	; 102dbae8 <ATResponse_SSL_handler_CERTIFICATE_READ+0x16c>
102db9e0:	e1a02000 	mov	r2, r0
102db9e4:	e3a0000a 	mov	r0, #10
102db9e8:	e12fff33 	blx	r3
//#endif
	if(head)
102db9ec:	e3540000 	cmp	r4, #0
102db9f0:	0a00001b 	beq	102dba64 <ATResponse_SSL_handler_CERTIFICATE_READ+0xe8>
	{
		char strTmp[10];
		char* p1 = NULL;
		char* p2 = NULL;
		Ql_memset(strTmp, 0x0, sizeof(strTmp));
102db9f4:	e3a0200a 	mov	r2, #10
102db9f8:	e3a01000 	mov	r1, #0
102db9fc:	e28d0004 	add	r0, sp, #4
102dba00:	e12fff35 	blx	r5
		p1 = Ql_strstr(head, ":");
102dba04:	e1a00004 	mov	r0, r4
102dba08:	e59f10dc 	ldr	r1, [pc, #220]	; 102dbaec <ATResponse_SSL_handler_CERTIFICATE_READ+0x170>
102dba0c:	e59f50dc 	ldr	r5, [pc, #220]	; 102dbaf0 <ATResponse_SSL_handler_CERTIFICATE_READ+0x174>
102dba10:	e12fff35 	blx	r5
		p2 = Ql_strstr(p1 + 1, ",");
102dba14:	e59f10d8 	ldr	r1, [pc, #216]	; 102dbaf4 <ATResponse_SSL_handler_CERTIFICATE_READ+0x178>
	{
		char strTmp[10];
		char* p1 = NULL;
		char* p2 = NULL;
		Ql_memset(strTmp, 0x0, sizeof(strTmp));
		p1 = Ql_strstr(head, ":");
102dba18:	e1a04000 	mov	r4, r0
		p2 = Ql_strstr(p1 + 1, ",");
102dba1c:	e2800001 	add	r0, r0, #1
102dba20:	e12fff35 	blx	r5
		if (p1 && p2)
102dba24:	e3500000 	cmp	r0, #0
102dba28:	13540000 	cmpne	r4, #0
102dba2c:	0a000009 	beq	102dba58 <ATResponse_SSL_handler_CERTIFICATE_READ+0xdc>
		{
			Ql_memcpy(strTmp, p1 + 2, p2 - p1 - 2);
102dba30:	e0642000 	rsb	r2, r4, r0
102dba34:	e2841002 	add	r1, r4, #2
102dba38:	e2422002 	sub	r2, r2, #2
102dba3c:	e59f30b4 	ldr	r3, [pc, #180]	; 102dbaf8 <ATResponse_SSL_handler_CERTIFICATE_READ+0x17c>
102dba40:	e28d0004 	add	r0, sp, #4
102dba44:	e12fff33 	blx	r3
			tcpParam->data= Ql_atoi(strTmp);
102dba48:	e28d0004 	add	r0, sp, #4
102dba4c:	e59f30a8 	ldr	r3, [pc, #168]	; 102dbafc <ATResponse_SSL_handler_CERTIFICATE_READ+0x180>
102dba50:	e12fff33 	blx	r3
102dba54:	e5860004 	str	r0, [r6, #4]
	head = Ql_RIL_FindString(line, len, "+CMS ERROR:");//fail
	if(head)
	{
		return  RIL_ATRSP_FAILED;
	}
	return RIL_ATRSP_CONTINUE; //continue wait
102dba58:	e3a00001 	mov	r0, #1
}
102dba5c:	e28dd014 	add	sp, sp, #20
102dba60:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
			Ql_memcpy(strTmp, p1 + 2, p2 - p1 - 2);
			tcpParam->data= Ql_atoi(strTmp);
		}
		return  RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "OK");
102dba64:	e1a00008 	mov	r0, r8
102dba68:	e1a0100a 	mov	r1, sl
102dba6c:	e59f208c 	ldr	r2, [pc, #140]	; 102dbb00 <ATResponse_SSL_handler_CERTIFICATE_READ+0x184>
102dba70:	e12fff37 	blx	r7
	if(head)
102dba74:	e3500000 	cmp	r0, #0
	{
		return  RIL_ATRSP_SUCCESS;
102dba78:	11a00004 	movne	r0, r4
			tcpParam->data= Ql_atoi(strTmp);
		}
		return  RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "OK");
	if(head)
102dba7c:	1afffff6 	bne	102dba5c <ATResponse_SSL_handler_CERTIFICATE_READ+0xe0>
	{
		return  RIL_ATRSP_SUCCESS;
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
102dba80:	e1a00008 	mov	r0, r8
102dba84:	e1a0100a 	mov	r1, sl
102dba88:	e59f2074 	ldr	r2, [pc, #116]	; 102dbb04 <ATResponse_SSL_handler_CERTIFICATE_READ+0x188>
102dba8c:	e12fff37 	blx	r7
	if(head)
102dba90:	e3500000 	cmp	r0, #0
102dba94:	1a00000b 	bne	102dbac8 <ATResponse_SSL_handler_CERTIFICATE_READ+0x14c>
	{
		return  RIL_ATRSP_FAILED;
	}
	head = Ql_RIL_FindString(line, len, "+CME ERROR:");//fail
102dba98:	e1a00008 	mov	r0, r8
102dba9c:	e1a0100a 	mov	r1, sl
102dbaa0:	e59f2060 	ldr	r2, [pc, #96]	; 102dbb08 <ATResponse_SSL_handler_CERTIFICATE_READ+0x18c>
102dbaa4:	e12fff37 	blx	r7
	if(head)
102dbaa8:	e3500000 	cmp	r0, #0
102dbaac:	1a000005 	bne	102dbac8 <ATResponse_SSL_handler_CERTIFICATE_READ+0x14c>
	{
		return  RIL_ATRSP_FAILED;
	}
	head = Ql_RIL_FindString(line, len, "+CMS ERROR:");//fail
102dbab0:	e1a00008 	mov	r0, r8
102dbab4:	e1a0100a 	mov	r1, sl
102dbab8:	e59f204c 	ldr	r2, [pc, #76]	; 102dbb0c <ATResponse_SSL_handler_CERTIFICATE_READ+0x190>
102dbabc:	e12fff37 	blx	r7
	if(head)
102dbac0:	e3500000 	cmp	r0, #0
102dbac4:	0affffe3 	beq	102dba58 <ATResponse_SSL_handler_CERTIFICATE_READ+0xdc>
		return  RIL_ATRSP_SUCCESS;
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
	if(head)
	{
		return  RIL_ATRSP_FAILED;
102dbac8:	e3e00000 	mvn	r0, #0
102dbacc:	eaffffe2 	b	102dba5c <ATResponse_SSL_handler_CERTIFICATE_READ+0xe0>
102dbad0:	102cce98 	.word	0x102cce98
102dbad4:	102e58f4 	.word	0x102e58f4
102dbad8:	f03d6584 	.word	0xf03d6584
102dbadc:	f03de540 	.word	0xf03de540
102dbae0:	102efa68 	.word	0x102efa68
102dbae4:	102e57a4 	.word	0x102e57a4
102dbae8:	102e6230 	.word	0x102e6230
102dbaec:	102efa10 	.word	0x102efa10
102dbaf0:	102e5a04 	.word	0x102e5a04
102dbaf4:	102ee830 	.word	0x102ee830
102dbaf8:	102e597c 	.word	0x102e597c
102dbafc:	102e5a8c 	.word	0x102e5a8c
102dbb00:	102ee5e8 	.word	0x102ee5e8
102dbb04:	102ede00 	.word	0x102ede00
102dbb08:	102ede08 	.word	0x102ede08
102dbb0c:	102ede24 	.word	0x102ede24

102dbb10 <ATResponse_SSL_handler_recv>:
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_recv(char* line, u32 len, void* userdata)
{
102dbb10:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102dbb14:	e1a07002 	mov	r7, r2
	char *head ;

#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line); // If enabled this debug message there will be error in buffer filling in steps below :-) so use this debug only to varify the received data..
#endif
	head = Ql_RIL_FindString(line, len, "\r\n+QSSLRECV:");
102dbb18:	e59f41fc 	ldr	r4, [pc, #508]	; 102dbd1c <ATResponse_SSL_handler_recv+0x20c>
102dbb1c:	e59f21fc 	ldr	r2, [pc, #508]	; 102dbd20 <ATResponse_SSL_handler_recv+0x210>
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_recv(char* line, u32 len, void* userdata)
{
102dbb20:	e1a06000 	mov	r6, r0
102dbb24:	e1a05001 	mov	r5, r1
	char *head ;

#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line); // If enabled this debug message there will be error in buffer filling in steps below :-) so use this debug only to varify the received data..
#endif
	head = Ql_RIL_FindString(line, len, "\r\n+QSSLRECV:");
102dbb28:	e12fff34 	blx	r4
	if(head)
102dbb2c:	e3500000 	cmp	r0, #0
102dbb30:	0a000001 	beq	102dbb3c <ATResponse_SSL_handler_recv+0x2c>
		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "Content-Type:"); // Ignore content type header
	if(head)
	{
		return RIL_ATRSP_CONTINUE;
102dbb34:	e3a00001 	mov	r0, #1
102dbb38:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	head = Ql_RIL_FindString(line, len, "\r\n+QSSLRECV:");
	if(head)
	{
		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
102dbb3c:	e1a00006 	mov	r0, r6
102dbb40:	e1a01005 	mov	r1, r5
102dbb44:	e59f21d8 	ldr	r2, [pc, #472]	; 102dbd24 <ATResponse_SSL_handler_recv+0x214>
102dbb48:	e12fff34 	blx	r4
	if(head)
102dbb4c:	e3500000 	cmp	r0, #0
102dbb50:	1a00000a 	bne	102dbb80 <ATResponse_SSL_handler_recv+0x70>
	{
		sslrecvParam->err_state = TRUE;
		return  RIL_ATRSP_FAILED;
	}

	head = Ql_RIL_FindString(line, len, "HTTP"); // For DPS resonse on HTTP we need to ignore few header.  Special exlcision to continue because "OK" string is included in this message :-)
102dbb54:	e1a00006 	mov	r0, r6
102dbb58:	e1a01005 	mov	r1, r5
102dbb5c:	e59f21c4 	ldr	r2, [pc, #452]	; 102dbd28 <ATResponse_SSL_handler_recv+0x218>
102dbb60:	e12fff34 	blx	r4
	if(head)
102dbb64:	e3500000 	cmp	r0, #0
102dbb68:	0a000008 	beq	102dbb90 <ATResponse_SSL_handler_recv+0x80>
	{
		sslrecvParam->length += len;
102dbb6c:	e5973000 	ldr	r3, [r7]

		return RIL_ATRSP_CONTINUE;
102dbb70:	e3a00001 	mov	r0, #1
	}

	head = Ql_RIL_FindString(line, len, "HTTP"); // For DPS resonse on HTTP we need to ignore few header.  Special exlcision to continue because "OK" string is included in this message :-)
	if(head)
	{
		sslrecvParam->length += len;
102dbb74:	e0835005 	add	r5, r3, r5
102dbb78:	e5875000 	str	r5, [r7]

		return RIL_ATRSP_CONTINUE;
102dbb7c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
	if(head)
	{
		sslrecvParam->err_state = TRUE;
102dbb80:	e3a03001 	mov	r3, #1
102dbb84:	e5c73004 	strb	r3, [r7, #4]
		return  RIL_ATRSP_FAILED;
102dbb88:	e3e00000 	mvn	r0, #0
102dbb8c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	{
		sslrecvParam->length += len;

		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "Date:"); // Ignore Date header
102dbb90:	e1a00006 	mov	r0, r6
102dbb94:	e1a01005 	mov	r1, r5
102dbb98:	e59f218c 	ldr	r2, [pc, #396]	; 102dbd2c <ATResponse_SSL_handler_recv+0x21c>
102dbb9c:	e12fff34 	blx	r4
	if(head)
102dbba0:	e3500000 	cmp	r0, #0
102dbba4:	1affffe2 	bne	102dbb34 <ATResponse_SSL_handler_recv+0x24>
	{
		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "Content-Type:"); // Ignore content type header
102dbba8:	e1a00006 	mov	r0, r6
102dbbac:	e1a01005 	mov	r1, r5
102dbbb0:	e59f2178 	ldr	r2, [pc, #376]	; 102dbd30 <ATResponse_SSL_handler_recv+0x220>
102dbbb4:	e12fff34 	blx	r4
	if(head)
102dbbb8:	e3500000 	cmp	r0, #0
102dbbbc:	1affffdc 	bne	102dbb34 <ATResponse_SSL_handler_recv+0x24>
	{
		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "Transfer-Encoding:"); // Ignore Transfer-Encoding header
102dbbc0:	e1a00006 	mov	r0, r6
102dbbc4:	e1a01005 	mov	r1, r5
102dbbc8:	e59f2164 	ldr	r2, [pc, #356]	; 102dbd34 <ATResponse_SSL_handler_recv+0x224>
102dbbcc:	e12fff34 	blx	r4
	if(head)
102dbbd0:	e3500000 	cmp	r0, #0
102dbbd4:	1affffd6 	bne	102dbb34 <ATResponse_SSL_handler_recv+0x24>
	{
		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "x-ms-request-id:"); // Ignore request-id header
102dbbd8:	e1a00006 	mov	r0, r6
102dbbdc:	e1a01005 	mov	r1, r5
102dbbe0:	e59f2150 	ldr	r2, [pc, #336]	; 102dbd38 <ATResponse_SSL_handler_recv+0x228>
102dbbe4:	e12fff34 	blx	r4
	if(head)
102dbbe8:	e3500000 	cmp	r0, #0
102dbbec:	1affffd0 	bne	102dbb34 <ATResponse_SSL_handler_recv+0x24>
	{
		return RIL_ATRSP_CONTINUE;
	}
	head = Ql_RIL_FindString(line, len, "Strict-Transport-Security:"); // Ignore security header
102dbbf0:	e1a00006 	mov	r0, r6
102dbbf4:	e1a01005 	mov	r1, r5
102dbbf8:	e59f213c 	ldr	r2, [pc, #316]	; 102dbd3c <ATResponse_SSL_handler_recv+0x22c>
102dbbfc:	e12fff34 	blx	r4
	if(head)
102dbc00:	e3500000 	cmp	r0, #0
102dbc04:	1affffca 	bne	102dbb34 <ATResponse_SSL_handler_recv+0x24>
	{
		return RIL_ATRSP_CONTINUE;
	}
	//------- END of DPS header packets received on HTTP , identify and ignore-----------
	head = Ql_RIL_FindString(line, len, "OK");
102dbc08:	e1a00006 	mov	r0, r6
102dbc0c:	e1a01005 	mov	r1, r5
102dbc10:	e59f2128 	ldr	r2, [pc, #296]	; 102dbd40 <ATResponse_SSL_handler_recv+0x230>
102dbc14:	e12fff34 	blx	r4
	if(head)
102dbc18:	e3500000 	cmp	r0, #0
102dbc1c:	0a000011 	beq	102dbc68 <ATResponse_SSL_handler_recv+0x158>
	{	// count '6' means last 6 bytes "<CR><LF>OK<CR><LF>"
		if(len < 6 )
102dbc20:	e3550005 	cmp	r5, #5
102dbc24:	8a000029 	bhi	102dbcd0 <ATResponse_SSL_handler_recv+0x1c0>
		{
			sslrecvParam->length += (6-len);
102dbc28:	e5970000 	ldr	r0, [r7]
102dbc2c:	e59f2110 	ldr	r2, [pc, #272]	; 102dbd44 <ATResponse_SSL_handler_recv+0x234>
102dbc30:	e2800006 	add	r0, r0, #6
102dbc34:	e5921204 	ldr	r1, [r2, #516]	; 0x204
102dbc38:	e0650000 	rsb	r0, r5, r0
		return  RIL_ATRSP_FAILED;
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_recv(char* line, u32 len, void* userdata)
102dbc3c:	e3a03000 	mov	r3, #0
102dbc40:	e282cf82 	add	ip, r2, #520	; 0x208
	head = Ql_RIL_FindString(line, len, "OK");
	if(head)
	{	// count '6' means last 6 bytes "<CR><LF>OK<CR><LF>"
		if(len < 6 )
		{
			sslrecvParam->length += (6-len);
102dbc44:	e5870000 	str	r0, [r7]
		return  RIL_ATRSP_FAILED;
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_recv(char* line, u32 len, void* userdata)
102dbc48:	e2454007 	sub	r4, r5, #7
102dbc4c:	e08cc001 	add	ip, ip, r1
		{
			sslrecvParam->length += (6-len);
			for(int i=0; i<(6-len); i++)
			{
				g_recvd_data_len--;
				g_buf_recvd_data[g_recvd_data_len] = '\0';
102dbc50:	e1a00003 	mov	r0, r3
102dbc54:	e2433001 	sub	r3, r3, #1
	if(head)
	{	// count '6' means last 6 bytes "<CR><LF>OK<CR><LF>"
		if(len < 6 )
		{
			sslrecvParam->length += (6-len);
			for(int i=0; i<(6-len); i++)
102dbc58:	e1530004 	cmp	r3, r4
102dbc5c:	0a000016 	beq	102dbcbc <ATResponse_SSL_handler_recv+0x1ac>
			{
				g_recvd_data_len--;
				g_buf_recvd_data[g_recvd_data_len] = '\0';
102dbc60:	e7cc0003 	strb	r0, [ip, r3]
102dbc64:	eafffffa 	b	102dbc54 <ATResponse_SSL_handler_recv+0x144>
		}
		// Ql_memcpy(userdata,line,g_recvd_data_len);

		return  RIL_ATRSP_SUCCESS;
	}
	head = Ql_RIL_FindString(line, len, "+CMS ERROR:");//fail
102dbc68:	e1a00006 	mov	r0, r6
102dbc6c:	e1a01005 	mov	r1, r5
102dbc70:	e59f20d0 	ldr	r2, [pc, #208]	; 102dbd48 <ATResponse_SSL_handler_recv+0x238>
102dbc74:	e12fff34 	blx	r4
	if(head)
102dbc78:	e3500000 	cmp	r0, #0
102dbc7c:	1a000024 	bne	102dbd14 <ATResponse_SSL_handler_recv+0x204>
	}

	// Non of above condition means Only DATA is in buffer. Read it.
	{
		// Ql_memcpy(userdata,line,len);
		sslrecvParam->length += len;
102dbc80:	e5972000 	ldr	r2, [r7]

		for(int i=0; i<len; i++, g_recvd_data_len++)
102dbc84:	e3a03000 	mov	r3, #0
	}

	// Non of above condition means Only DATA is in buffer. Read it.
	{
		// Ql_memcpy(userdata,line,len);
		sslrecvParam->length += len;
102dbc88:	e0822005 	add	r2, r2, r5
102dbc8c:	e5872000 	str	r2, [r7]

		for(int i=0; i<len; i++, g_recvd_data_len++)
		{
			g_buf_recvd_data[g_recvd_data_len] = line[i];
102dbc90:	e59f20ac 	ldr	r2, [pc, #172]	; 102dbd44 <ATResponse_SSL_handler_recv+0x234>
	// Non of above condition means Only DATA is in buffer. Read it.
	{
		// Ql_memcpy(userdata,line,len);
		sslrecvParam->length += len;

		for(int i=0; i<len; i++, g_recvd_data_len++)
102dbc94:	e1530005 	cmp	r3, r5
102dbc98:	0affffa5 	beq	102dbb34 <ATResponse_SSL_handler_recv+0x24>
		{
			g_buf_recvd_data[g_recvd_data_len] = line[i];
102dbc9c:	e5921204 	ldr	r1, [r2, #516]	; 0x204
102dbca0:	e7d6c003 	ldrb	ip, [r6, r3]
102dbca4:	e0820001 	add	r0, r2, r1
	// Non of above condition means Only DATA is in buffer. Read it.
	{
		// Ql_memcpy(userdata,line,len);
		sslrecvParam->length += len;

		for(int i=0; i<len; i++, g_recvd_data_len++)
102dbca8:	e2811001 	add	r1, r1, #1
102dbcac:	e2833001 	add	r3, r3, #1
		{
			g_buf_recvd_data[g_recvd_data_len] = line[i];
102dbcb0:	e5c0c208 	strb	ip, [r0, #520]	; 0x208
	// Non of above condition means Only DATA is in buffer. Read it.
	{
		// Ql_memcpy(userdata,line,len);
		sslrecvParam->length += len;

		for(int i=0; i<len; i++, g_recvd_data_len++)
102dbcb4:	e5821204 	str	r1, [r2, #516]	; 0x204
102dbcb8:	eafffff5 	b	102dbc94 <ATResponse_SSL_handler_recv+0x184>
		return  RIL_ATRSP_FAILED;
	}
	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_recv(char* line, u32 len, void* userdata)
102dbcbc:	e2455006 	sub	r5, r5, #6
102dbcc0:	e0851001 	add	r1, r5, r1
102dbcc4:	e5821204 	str	r1, [r2, #516]	; 0x204
			}

		}
		// Ql_memcpy(userdata,line,g_recvd_data_len);

		return  RIL_ATRSP_SUCCESS;
102dbcc8:	e3a00000 	mov	r0, #0
102dbccc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

			}
		}
		else
		{
			sslrecvParam->length += (len-6);
102dbcd0:	e5972000 	ldr	r2, [r7]

			for(int i=0; i<(len-6); i++, g_recvd_data_len++)
102dbcd4:	e3a03000 	mov	r3, #0

			}
		}
		else
		{
			sslrecvParam->length += (len-6);
102dbcd8:	e2422006 	sub	r2, r2, #6
102dbcdc:	e0822005 	add	r2, r2, r5
102dbce0:	e5872000 	str	r2, [r7]

			for(int i=0; i<(len-6); i++, g_recvd_data_len++)
			{
				g_buf_recvd_data[g_recvd_data_len] = line[i];
102dbce4:	e59f2058 	ldr	r2, [pc, #88]	; 102dbd44 <ATResponse_SSL_handler_recv+0x234>
102dbce8:	e2455006 	sub	r5, r5, #6
		}
		else
		{
			sslrecvParam->length += (len-6);

			for(int i=0; i<(len-6); i++, g_recvd_data_len++)
102dbcec:	e1530005 	cmp	r3, r5
102dbcf0:	2afffff4 	bcs	102dbcc8 <ATResponse_SSL_handler_recv+0x1b8>
			{
				g_buf_recvd_data[g_recvd_data_len] = line[i];
102dbcf4:	e5921204 	ldr	r1, [r2, #516]	; 0x204
102dbcf8:	e7d6c003 	ldrb	ip, [r6, r3]
102dbcfc:	e0820001 	add	r0, r2, r1
		}
		else
		{
			sslrecvParam->length += (len-6);

			for(int i=0; i<(len-6); i++, g_recvd_data_len++)
102dbd00:	e2811001 	add	r1, r1, #1
102dbd04:	e2833001 	add	r3, r3, #1
			{
				g_buf_recvd_data[g_recvd_data_len] = line[i];
102dbd08:	e5c0c208 	strb	ip, [r0, #520]	; 0x208
		}
		else
		{
			sslrecvParam->length += (len-6);

			for(int i=0; i<(len-6); i++, g_recvd_data_len++)
102dbd0c:	e5821204 	str	r1, [r2, #516]	; 0x204
102dbd10:	eafffff5 	b	102dbcec <ATResponse_SSL_handler_recv+0x1dc>
		return  RIL_ATRSP_SUCCESS;
	}
	head = Ql_RIL_FindString(line, len, "+CMS ERROR:");//fail
	if(head)
	{
		return  RIL_ATRSP_FAILED;
102dbd14:	e3e00000 	mvn	r0, #0

		}

	}
	return RIL_ATRSP_CONTINUE; //continue wait
}
102dbd18:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102dbd1c:	102cce98 	.word	0x102cce98
102dbd20:	102efa98 	.word	0x102efa98
102dbd24:	102ede00 	.word	0x102ede00
102dbd28:	102efaa8 	.word	0x102efaa8
102dbd2c:	102efab0 	.word	0x102efab0
102dbd30:	102efab8 	.word	0x102efab8
102dbd34:	102efac8 	.word	0x102efac8
102dbd38:	102efadc 	.word	0x102efadc
102dbd3c:	102efaf0 	.word	0x102efaf0
102dbd40:	102ee5e8 	.word	0x102ee5e8
102dbd44:	f03d6584 	.word	0xf03d6584
102dbd48:	102ede24 	.word	0x102ede24

102dbd4c <ATResponse_SSL_handler_CERTIFICATE_DEL>:
 *
 * Return: see function below
 *
 *****************************************************************/
static s32 ATResponse_SSL_handler_CERTIFICATE_DEL(char* line, u32 len, void* userdata)
{
102dbd4c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102dbd50:	e1a05002 	mov	r5, r2
	char* pHead = NULL;
#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line);
#endif
	pHead = Ql_RIL_FindString(line, len, "OK");
102dbd54:	e59f4090 	ldr	r4, [pc, #144]	; 102dbdec <ATResponse_SSL_handler_CERTIFICATE_DEL+0xa0>
102dbd58:	e59f2090 	ldr	r2, [pc, #144]	; 102dbdf0 <ATResponse_SSL_handler_CERTIFICATE_DEL+0xa4>
 *
 * Return: see function below
 *
 *****************************************************************/
static s32 ATResponse_SSL_handler_CERTIFICATE_DEL(char* line, u32 len, void* userdata)
{
102dbd5c:	e1a06000 	mov	r6, r0
102dbd60:	e1a07001 	mov	r7, r1
	char* pHead = NULL;
#ifdef AT_CMD_MSG
	APP_DEBUG("%s\r\n",line);
#endif
	pHead = Ql_RIL_FindString(line, len, "OK");
102dbd64:	e12fff34 	blx	r4
	if (pHead)
102dbd68:	e3500000 	cmp	r0, #0
102dbd6c:	0a000001 	beq	102dbd78 <ATResponse_SSL_handler_CERTIFICATE_DEL+0x2c>
	{
		return RIL_ATRSP_SUCCESS;
102dbd70:	e3a00000 	mov	r0, #0
102dbd74:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}
	pHead = Ql_RIL_FindString(line, len, "ERROR");
102dbd78:	e1a00006 	mov	r0, r6
102dbd7c:	e1a01007 	mov	r1, r7
102dbd80:	e59f206c 	ldr	r2, [pc, #108]	; 102dbdf4 <ATResponse_SSL_handler_CERTIFICATE_DEL+0xa8>
102dbd84:	e12fff34 	blx	r4
	if (pHead)
102dbd88:	e3500000 	cmp	r0, #0
102dbd8c:	0a000004 	beq	102dbda4 <ATResponse_SSL_handler_CERTIFICATE_DEL+0x58>
	{
		if (userdata != NULL)
102dbd90:	e3550000 	cmp	r5, #0
102dbd94:	0a000010 	beq	102dbddc <ATResponse_SSL_handler_CERTIFICATE_DEL+0x90>
		{
			*((s32*)userdata) = RIL_AT_FAILED;
102dbd98:	e3e00000 	mvn	r0, #0
102dbd9c:	e5850000 	str	r0, [r5]
102dbda0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		}
		return RIL_ATRSP_FAILED;
	}
	pHead = Ql_RIL_FindString(line, len, "+CME ERROR:");
102dbda4:	e1a00006 	mov	r0, r6
102dbda8:	e1a01007 	mov	r1, r7
102dbdac:	e59f2044 	ldr	r2, [pc, #68]	; 102dbdf8 <ATResponse_SSL_handler_CERTIFICATE_DEL+0xac>
102dbdb0:	e12fff34 	blx	r4
	if (pHead)
102dbdb4:	e3500000 	cmp	r0, #0
102dbdb8:	0a000009 	beq	102dbde4 <ATResponse_SSL_handler_CERTIFICATE_DEL+0x98>
	{
		if (userdata != NULL)
102dbdbc:	e3550000 	cmp	r5, #0
102dbdc0:	0a000005 	beq	102dbddc <ATResponse_SSL_handler_CERTIFICATE_DEL+0x90>
		{
			Ql_sscanf(line, "%*[^: ]: %d[^\r\n]", (s32*)userdata);
102dbdc4:	e59f3030 	ldr	r3, [pc, #48]	; 102dbdfc <ATResponse_SSL_handler_CERTIFICATE_DEL+0xb0>
102dbdc8:	e1a00006 	mov	r0, r6
102dbdcc:	e5933000 	ldr	r3, [r3]
102dbdd0:	e59f1028 	ldr	r1, [pc, #40]	; 102dbe00 <ATResponse_SSL_handler_CERTIFICATE_DEL+0xb4>
102dbdd4:	e1a02005 	mov	r2, r5
102dbdd8:	e12fff33 	blx	r3
102dbddc:	e3e00000 	mvn	r0, #0
102dbde0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		}
		return RIL_ATRSP_FAILED;
	}
	return RIL_ATRSP_CONTINUE;	// Just wait for the specified results above
102dbde4:	e3a00001 	mov	r0, #1
}
102dbde8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102dbdec:	102cce98 	.word	0x102cce98
102dbdf0:	102ee5e8 	.word	0x102ee5e8
102dbdf4:	102ede00 	.word	0x102ede00
102dbdf8:	102ede08 	.word	0x102ede08
102dbdfc:	f03de548 	.word	0xf03de548
102dbe00:	102ee414 	.word	0x102ee414

102dbe04 <ATResponse_SSL_handler_send>:

	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_send(char* line, u32 len, void* userdata)
{
102dbe04:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102dbe08:	e1a04002 	mov	r4, r2
	SSL_SendParam *sslsendParam = (SSL_SendParam *)userdata;
	char *head ;

	head = Ql_RIL_FindString(line, len, "\r\n>");
102dbe0c:	e59f509c 	ldr	r5, [pc, #156]	; 102dbeb0 <ATResponse_SSL_handler_send+0xac>
102dbe10:	e59f209c 	ldr	r2, [pc, #156]	; 102dbeb4 <ATResponse_SSL_handler_send+0xb0>

	return RIL_ATRSP_CONTINUE; //continue wait
}

static s32 ATResponse_SSL_handler_send(char* line, u32 len, void* userdata)
{
102dbe14:	e1a07000 	mov	r7, r0
102dbe18:	e1a06001 	mov	r6, r1
	SSL_SendParam *sslsendParam = (SSL_SendParam *)userdata;
	char *head ;

	head = Ql_RIL_FindString(line, len, "\r\n>");
102dbe1c:	e12fff35 	blx	r5
	if(head)
102dbe20:	e3500000 	cmp	r0, #0
102dbe24:	0a000005 	beq	102dbe40 <ATResponse_SSL_handler_send+0x3c>
	{
		Ql_RIL_WriteDataToCore ((u8 *)sslsendParam->prefix,sslsendParam->length);
102dbe28:	e8940003 	ldm	r4, {r0, r1}
102dbe2c:	e59f3084 	ldr	r3, [pc, #132]	; 102dbeb8 <ATResponse_SSL_handler_send+0xb4>
102dbe30:	e12fff33 	blx	r3
		sslsendParam->return_val = RIL_ATRSP_CONTINUE;
102dbe34:	e3a00001 	mov	r0, #1
102dbe38:	e5840008 	str	r0, [r4, #8]
		return RIL_ATRSP_CONTINUE;
102dbe3c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	}
	head = Ql_RIL_FindString(line, len, "ERROR");
102dbe40:	e1a00007 	mov	r0, r7
102dbe44:	e1a01006 	mov	r1, r6
102dbe48:	e59f206c 	ldr	r2, [pc, #108]	; 102dbebc <ATResponse_SSL_handler_send+0xb8>
102dbe4c:	e12fff35 	blx	r5
	if(head)
102dbe50:	e2508000 	subs	r8, r0, #0
102dbe54:	1a000008 	bne	102dbe7c <ATResponse_SSL_handler_send+0x78>
	{
		sslsendParam->return_val = RIL_ATRSP_FAILED;
		return  RIL_ATRSP_FAILED;
	}
	head = Ql_RIL_FindString(line, len, "SEND OK");//fail
102dbe58:	e1a00007 	mov	r0, r7
102dbe5c:	e1a01006 	mov	r1, r6
102dbe60:	e59f2058 	ldr	r2, [pc, #88]	; 102dbec0 <ATResponse_SSL_handler_send+0xbc>
102dbe64:	e12fff35 	blx	r5
	if(head)
102dbe68:	e3500000 	cmp	r0, #0
102dbe6c:	0a000005 	beq	102dbe88 <ATResponse_SSL_handler_send+0x84>
	{
		sslsendParam->return_val = RIL_ATRSP_SUCCESS;
102dbe70:	e5848008 	str	r8, [r4, #8]
		return  RIL_ATRSP_SUCCESS;
102dbe74:	e1a00008 	mov	r0, r8
102dbe78:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	}
	head = Ql_RIL_FindString(line, len, "+CMS ERROR:");//fail
	if(head)
	{
		sslsendParam->return_val = RIL_ATRSP_FAILED;
102dbe7c:	e3e00000 	mvn	r0, #0
102dbe80:	e5840008 	str	r0, [r4, #8]
102dbe84:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	if(head)
	{
		sslsendParam->return_val = RIL_ATRSP_SUCCESS;
		return  RIL_ATRSP_SUCCESS;
	}
	head = Ql_RIL_FindString(line, len, "+CMS ERROR:");//fail
102dbe88:	e1a00007 	mov	r0, r7
102dbe8c:	e1a01006 	mov	r1, r6
102dbe90:	e59f202c 	ldr	r2, [pc, #44]	; 102dbec4 <ATResponse_SSL_handler_send+0xc0>
102dbe94:	e12fff35 	blx	r5
	if(head)
102dbe98:	e3500000 	cmp	r0, #0
102dbe9c:	1afffff6 	bne	102dbe7c <ATResponse_SSL_handler_send+0x78>
	{
		sslsendParam->return_val = RIL_ATRSP_FAILED;
		return  RIL_ATRSP_FAILED;
	}

	sslsendParam->return_val = RIL_ATRSP_CONTINUE;
102dbea0:	e3a03001 	mov	r3, #1
	return RIL_ATRSP_CONTINUE; //continue wait
102dbea4:	e1a00003 	mov	r0, r3
	{
		sslsendParam->return_val = RIL_ATRSP_FAILED;
		return  RIL_ATRSP_FAILED;
	}

	sslsendParam->return_val = RIL_ATRSP_CONTINUE;
102dbea8:	e5843008 	str	r3, [r4, #8]
	return RIL_ATRSP_CONTINUE; //continue wait
}
102dbeac:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102dbeb0:	102cce98 	.word	0x102cce98
102dbeb4:	102efb0c 	.word	0x102efb0c
102dbeb8:	102e53c8 	.word	0x102e53c8
102dbebc:	102ede00 	.word	0x102ede00
102dbec0:	102efb10 	.word	0x102efb10
102dbec4:	102ede24 	.word	0x102ede24

102dbec8 <RIL_SSL_QSSLCERTIFICATE_DEL>:
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCERTIFICATE_DEL(u8 *cert_type)
{
102dbec8:	e92d4030 	push	{r4, r5, lr}
102dbecc:	e24ddf4f 	sub	sp, sp, #316	; 0x13c
	char strAT[300];
	s32  ret = RIL_AT_FAILED;
	s32  errCode = RIL_AT_FAILED;
102dbed0:	e3e03000 	mvn	r3, #0
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCERTIFICATE_DEL(u8 *cert_type)
{
102dbed4:	e1a05000 	mov	r5, r0
	char strAT[300];
	s32  ret = RIL_AT_FAILED;
	s32  errCode = RIL_AT_FAILED;
	Ql_memset(strAT, 0, sizeof(strAT));
102dbed8:	e59f406c 	ldr	r4, [pc, #108]	; 102dbf4c <RIL_SSL_QSSLCERTIFICATE_DEL+0x84>
102dbedc:	e3a01000 	mov	r1, #0
102dbee0:	e3a02f4b 	mov	r2, #300	; 0x12c
102dbee4:	e28d000c 	add	r0, sp, #12
 *****************************************************************/
s32 RIL_SSL_QSSLCERTIFICATE_DEL(u8 *cert_type)
{
	char strAT[300];
	s32  ret = RIL_AT_FAILED;
	s32  errCode = RIL_AT_FAILED;
102dbee8:	e58d3008 	str	r3, [sp, #8]
	Ql_memset(strAT, 0, sizeof(strAT));
102dbeec:	e12fff34 	blx	r4

	//Delete certificate irrespective of whether available or not
	Ql_memset(strAT, 0, sizeof(strAT));
102dbef0:	e28d000c 	add	r0, sp, #12
102dbef4:	e3a01000 	mov	r1, #0
102dbef8:	e3a02f4b 	mov	r2, #300	; 0x12c
102dbefc:	e12fff34 	blx	r4
	Ql_sprintf(strAT, "AT+QSECDEL=\"NVRAM:%s\"\n", cert_type);
102dbf00:	e59f3048 	ldr	r3, [pc, #72]	; 102dbf50 <RIL_SSL_QSSLCERTIFICATE_DEL+0x88>
102dbf04:	e1a02005 	mov	r2, r5
102dbf08:	e59f1044 	ldr	r1, [pc, #68]	; 102dbf54 <RIL_SSL_QSSLCERTIFICATE_DEL+0x8c>
102dbf0c:	e5933000 	ldr	r3, [r3]
102dbf10:	e28d000c 	add	r0, sp, #12
102dbf14:	e12fff33 	blx	r3
	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_SSL_handler_CERTIFICATE_DEL,&errCode,0);
102dbf18:	e28d000c 	add	r0, sp, #12
102dbf1c:	e59f3034 	ldr	r3, [pc, #52]	; 102dbf58 <RIL_SSL_QSSLCERTIFICATE_DEL+0x90>
102dbf20:	e12fff33 	blx	r3
102dbf24:	e3a03000 	mov	r3, #0
102dbf28:	e58d3000 	str	r3, [sp]
102dbf2c:	e59f2028 	ldr	r2, [pc, #40]	; 102dbf5c <RIL_SSL_QSSLCERTIFICATE_DEL+0x94>
102dbf30:	e28d3008 	add	r3, sp, #8
102dbf34:	e59fc024 	ldr	ip, [pc, #36]	; 102dbf60 <RIL_SSL_QSSLCERTIFICATE_DEL+0x98>
102dbf38:	e1a01000 	mov	r1, r0
102dbf3c:	e28d000c 	add	r0, sp, #12
102dbf40:	e12fff3c 	blx	ip

#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
	return ret;
}
102dbf44:	e28ddf4f 	add	sp, sp, #316	; 0x13c
102dbf48:	e8bd8030 	pop	{r4, r5, pc}
102dbf4c:	102e58f4 	.word	0x102e58f4
102dbf50:	f03de540 	.word	0xf03de540
102dbf54:	102efb18 	.word	0x102efb18
102dbf58:	102e57a4 	.word	0x102e57a4
102dbf5c:	102dbd4c 	.word	0x102dbd4c
102dbf60:	102e5168 	.word	0x102e5168

102dbf64 <RIL_SSL_QSSLCERTIFICATE_WRITE>:
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCERTIFICATE_WRITE(u8 *cert_type, u8 *cert_name, u32 cert_len, u8 timeout)
{
102dbf64:	e92d4010 	push	{r4, lr}
102dbf68:	e1a04003 	mov	r4, r3
102dbf6c:	e24ddf52 	sub	sp, sp, #328	; 0x148
	SSL_WriteCert sslwriteCert;

	sslwriteCert.cert_name = cert_name;
	sslwriteCert.cert_type = cert_type;
	sslwriteCert.cert_len = cert_len;
	sslwriteCert.errCode = RIL_AT_FAILED;
102dbf70:	e3e03000 	mvn	r3, #0
{
	char strAT[300];
	s32  ret = RIL_AT_SUCCESS;
	SSL_WriteCert sslwriteCert;

	sslwriteCert.cert_name = cert_name;
102dbf74:	e58d1010 	str	r1, [sp, #16]
	sslwriteCert.cert_type = cert_type;
102dbf78:	e58d000c 	str	r0, [sp, #12]
	sslwriteCert.cert_len = cert_len;
102dbf7c:	e58d2014 	str	r2, [sp, #20]
	sslwriteCert.errCode = RIL_AT_FAILED;
102dbf80:	e58d3018 	str	r3, [sp, #24]

	//Upload certificate
	Ql_memset(strAT, 0, sizeof(strAT));
102dbf84:	e3a01000 	mov	r1, #0
102dbf88:	e3a02f4b 	mov	r2, #300	; 0x12c
102dbf8c:	e28d001c 	add	r0, sp, #28
102dbf90:	e59f3060 	ldr	r3, [pc, #96]	; 102dbff8 <RIL_SSL_QSSLCERTIFICATE_WRITE+0x94>
102dbf94:	e12fff33 	blx	r3
	write_flag= 1;
102dbf98:	e59f005c 	ldr	r0, [pc, #92]	; 102dbffc <RIL_SSL_QSSLCERTIFICATE_WRITE+0x98>
102dbf9c:	e3a0c001 	mov	ip, #1
102dbfa0:	e5c0c200 	strb	ip, [r0, #512]	; 0x200
	Ql_sprintf(strAT, "AT+QSECWRITE=\"NVRAM:%s\",%d,%d\n",sslwriteCert.cert_type, sslwriteCert.cert_len, timeout);
102dbfa4:	e59f0054 	ldr	r0, [pc, #84]	; 102dc000 <RIL_SSL_QSSLCERTIFICATE_WRITE+0x9c>
102dbfa8:	e59d200c 	ldr	r2, [sp, #12]
102dbfac:	e59f1050 	ldr	r1, [pc, #80]	; 102dc004 <RIL_SSL_QSSLCERTIFICATE_WRITE+0xa0>
102dbfb0:	e59d3014 	ldr	r3, [sp, #20]
102dbfb4:	e58d4000 	str	r4, [sp]
102dbfb8:	e590c000 	ldr	ip, [r0]
102dbfbc:	e28d001c 	add	r0, sp, #28
102dbfc0:	e12fff3c 	blx	ip
	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT), ATResponse_SSL_handler_CERTIFICATE_WRITE, (void *)&sslwriteCert, 0);
102dbfc4:	e28d001c 	add	r0, sp, #28
102dbfc8:	e59f3038 	ldr	r3, [pc, #56]	; 102dc008 <RIL_SSL_QSSLCERTIFICATE_WRITE+0xa4>
102dbfcc:	e12fff33 	blx	r3
102dbfd0:	e3a03000 	mov	r3, #0
102dbfd4:	e58d3000 	str	r3, [sp]
102dbfd8:	e59f202c 	ldr	r2, [pc, #44]	; 102dc00c <RIL_SSL_QSSLCERTIFICATE_WRITE+0xa8>
102dbfdc:	e28d300c 	add	r3, sp, #12
102dbfe0:	e59fc028 	ldr	ip, [pc, #40]	; 102dc010 <RIL_SSL_QSSLCERTIFICATE_WRITE+0xac>
102dbfe4:	e1a01000 	mov	r1, r0
102dbfe8:	e28d001c 	add	r0, sp, #28
102dbfec:	e12fff3c 	blx	ip
#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif

	return ret;
}
102dbff0:	e28ddf52 	add	sp, sp, #328	; 0x148
102dbff4:	e8bd8010 	pop	{r4, pc}
102dbff8:	102e58f4 	.word	0x102e58f4
102dbffc:	f03d6584 	.word	0xf03d6584
102dc000:	f03de540 	.word	0xf03de540
102dc004:	102efb30 	.word	0x102efb30
102dc008:	102e57a4 	.word	0x102e57a4
102dc00c:	102db69c 	.word	0x102db69c
102dc010:	102e5168 	.word	0x102e5168

102dc014 <RIL_SSL_QSSLCERTIFICATE_READ>:
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCERTIFICATE_READ(u8 *cert_type)
{
102dc014:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	char strAT[300];
	s32  ret = RIL_AT_SUCCESS;
	ST_AT_TCPparam tcpParam;

	tcpParam.prefix="+QSECREAD:";
102dc018:	e59f30c8 	ldr	r3, [pc, #200]	; 102dc0e8 <RIL_SSL_QSSLCERTIFICATE_READ+0xd4>
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCERTIFICATE_READ(u8 *cert_type)
{
102dc01c:	e24ddd05 	sub	sp, sp, #320	; 0x140
	tcpParam.prefix="+QSECREAD:";
	tcpParam.data = 255;

	// Check Certificate
	Ql_memset(strAT, 0, sizeof(strAT));
	Ql_sprintf(strAT, "AT+QSECREAD=\"NVRAM:%s\"\n", cert_type);
102dc020:	e59f60c4 	ldr	r6, [pc, #196]	; 102dc0ec <RIL_SSL_QSSLCERTIFICATE_READ+0xd8>
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCERTIFICATE_READ(u8 *cert_type)
{
102dc024:	e1a04000 	mov	r4, r0

	tcpParam.prefix="+QSECREAD:";
	tcpParam.data = 255;

	// Check Certificate
	Ql_memset(strAT, 0, sizeof(strAT));
102dc028:	e59f70c0 	ldr	r7, [pc, #192]	; 102dc0f0 <RIL_SSL_QSSLCERTIFICATE_READ+0xdc>
{
	char strAT[300];
	s32  ret = RIL_AT_SUCCESS;
	ST_AT_TCPparam tcpParam;

	tcpParam.prefix="+QSECREAD:";
102dc02c:	e58d300c 	str	r3, [sp, #12]
	tcpParam.data = 255;

	// Check Certificate
	Ql_memset(strAT, 0, sizeof(strAT));
102dc030:	e3a01000 	mov	r1, #0
	char strAT[300];
	s32  ret = RIL_AT_SUCCESS;
	ST_AT_TCPparam tcpParam;

	tcpParam.prefix="+QSECREAD:";
	tcpParam.data = 255;
102dc034:	e3a030ff 	mov	r3, #255	; 0xff

	// Check Certificate
	Ql_memset(strAT, 0, sizeof(strAT));
102dc038:	e3a02f4b 	mov	r2, #300	; 0x12c
102dc03c:	e28d0014 	add	r0, sp, #20
	char strAT[300];
	s32  ret = RIL_AT_SUCCESS;
	ST_AT_TCPparam tcpParam;

	tcpParam.prefix="+QSECREAD:";
	tcpParam.data = 255;
102dc040:	e58d3010 	str	r3, [sp, #16]

	// Check Certificate
	Ql_memset(strAT, 0, sizeof(strAT));
102dc044:	e12fff37 	blx	r7
	Ql_sprintf(strAT, "AT+QSECREAD=\"NVRAM:%s\"\n", cert_type);
102dc048:	e1a02004 	mov	r2, r4
102dc04c:	e5963000 	ldr	r3, [r6]
102dc050:	e59f109c 	ldr	r1, [pc, #156]	; 102dc0f4 <RIL_SSL_QSSLCERTIFICATE_READ+0xe0>
102dc054:	e28d0014 	add	r0, sp, #20
102dc058:	e12fff33 	blx	r3
	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_SSL_handler_CERTIFICATE_READ,&tcpParam,0);
102dc05c:	e59f5094 	ldr	r5, [pc, #148]	; 102dc0f8 <RIL_SSL_QSSLCERTIFICATE_READ+0xe4>
102dc060:	e28d0014 	add	r0, sp, #20
102dc064:	e12fff35 	blx	r5
102dc068:	e3a08000 	mov	r8, #0
102dc06c:	e28d300c 	add	r3, sp, #12
102dc070:	e59fc084 	ldr	ip, [pc, #132]	; 102dc0fc <RIL_SSL_QSSLCERTIFICATE_READ+0xe8>
102dc074:	e59f2084 	ldr	r2, [pc, #132]	; 102dc100 <RIL_SSL_QSSLCERTIFICATE_READ+0xec>
102dc078:	e58d8000 	str	r8, [sp]
102dc07c:	e1a01000 	mov	r1, r0
102dc080:	e28d0014 	add	r0, sp, #20
102dc084:	e12fff3c 	blx	ip

//#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
102dc088:	e1a01008 	mov	r1, r8
102dc08c:	e3a02c02 	mov	r2, #512	; 0x200
	tcpParam.data = 255;

	// Check Certificate
	Ql_memset(strAT, 0, sizeof(strAT));
	Ql_sprintf(strAT, "AT+QSECREAD=\"NVRAM:%s\"\n", cert_type);
	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_SSL_handler_CERTIFICATE_READ,&tcpParam,0);
102dc090:	e1a04000 	mov	r4, r0

//#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
102dc094:	e59f0068 	ldr	r0, [pc, #104]	; 102dc104 <RIL_SSL_QSSLCERTIFICATE_READ+0xf0>
102dc098:	e12fff37 	blx	r7
102dc09c:	e59f3064 	ldr	r3, [pc, #100]	; 102dc108 <RIL_SSL_QSSLCERTIFICATE_READ+0xf4>
102dc0a0:	e1540008 	cmp	r4, r8
102dc0a4:	e59f2060 	ldr	r2, [pc, #96]	; 102dc10c <RIL_SSL_QSSLCERTIFICATE_READ+0xf8>
102dc0a8:	e596c000 	ldr	ip, [r6]
102dc0ac:	01a02003 	moveq	r2, r3
102dc0b0:	e59f1058 	ldr	r1, [pc, #88]	; 102dc110 <RIL_SSL_QSSLCERTIFICATE_READ+0xfc>
102dc0b4:	e28d3014 	add	r3, sp, #20
102dc0b8:	e59f0044 	ldr	r0, [pc, #68]	; 102dc104 <RIL_SSL_QSSLCERTIFICATE_READ+0xf0>
102dc0bc:	e12fff3c 	blx	ip
102dc0c0:	e59f003c 	ldr	r0, [pc, #60]	; 102dc104 <RIL_SSL_QSSLCERTIFICATE_READ+0xf0>
102dc0c4:	e12fff35 	blx	r5
102dc0c8:	e59f1034 	ldr	r1, [pc, #52]	; 102dc104 <RIL_SSL_QSSLCERTIFICATE_READ+0xf0>
102dc0cc:	e59f3040 	ldr	r3, [pc, #64]	; 102dc114 <RIL_SSL_QSSLCERTIFICATE_READ+0x100>
102dc0d0:	e1a02000 	mov	r2, r0
102dc0d4:	e3a0000a 	mov	r0, #10
102dc0d8:	e12fff33 	blx	r3
//#endif

	return ret;
}
102dc0dc:	e1a00004 	mov	r0, r4
102dc0e0:	e28ddd05 	add	sp, sp, #320	; 0x140
102dc0e4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102dc0e8:	102efb58 	.word	0x102efb58
102dc0ec:	f03de540 	.word	0xf03de540
102dc0f0:	102e58f4 	.word	0x102e58f4
102dc0f4:	102efb64 	.word	0x102efb64
102dc0f8:	102e57a4 	.word	0x102e57a4
102dc0fc:	102e5168 	.word	0x102e5168
102dc100:	102db97c 	.word	0x102db97c
102dc104:	f03d6584 	.word	0xf03d6584
102dc108:	102ef9dc 	.word	0x102ef9dc
102dc10c:	102efb50 	.word	0x102efb50
102dc110:	102efb7c 	.word	0x102efb7c
102dc114:	102e6230 	.word	0x102e6230

102dc118 <RIL_SSL_QSSLCFG>:
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCFG(void)
{
102dc118:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
	s32 ret = RIL_AT_SUCCESS;
	char strAT[300];
	if(FLAG.SSL_CONFIGURED == FALSE) // Configure the SSL parameyters only if they are not configured earlier
102dc11c:	e59f5248 	ldr	r5, [pc, #584]	; 102dc36c <RIL_SSL_QSSLCFG+0x254>
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCFG(void)
{
102dc120:	e24ddf4f 	sub	sp, sp, #316	; 0x13c
	s32 ret = RIL_AT_SUCCESS;
	char strAT[300];
	if(FLAG.SSL_CONFIGURED == FALSE) // Configure the SSL parameyters only if they are not configured earlier
102dc124:	e5d54016 	ldrb	r4, [r5, #22]
102dc128:	e3540000 	cmp	r4, #0
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCFG(void)
{
	s32 ret = RIL_AT_SUCCESS;
102dc12c:	13a04000 	movne	r4, #0
	char strAT[300];
	if(FLAG.SSL_CONFIGURED == FALSE) // Configure the SSL parameyters only if they are not configured earlier
102dc130:	0a000002 	beq	102dc140 <RIL_SSL_QSSLCFG+0x28>
*/
		if(ret == RIL_AT_SUCCESS)
			FLAG.SSL_CONFIGURED = TRUE;// Mark the respective flag as true
	}
	return ret;
}
102dc134:	e1a00004 	mov	r0, r4
102dc138:	e28ddf4f 	add	sp, sp, #316	; 0x13c
102dc13c:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
#ifdef SECURE_SOCKET
		APP_DEBUG("\n\r<-- Configure SSL parameters -->\r\n");
#endif
		//Configure root Certificate
		Ql_memset(strAT, 0, sizeof(strAT));
		Ql_sprintf(strAT, "AT+QSSLCFG=\"cacert\",%d,\"NVRAM:CA0\"\n",CID_HOST_AZURE);
102dc140:	e59f8228 	ldr	r8, [pc, #552]	; 102dc370 <RIL_SSL_QSSLCFG+0x258>
	{
#ifdef SECURE_SOCKET
		APP_DEBUG("\n\r<-- Configure SSL parameters -->\r\n");
#endif
		//Configure root Certificate
		Ql_memset(strAT, 0, sizeof(strAT));
102dc144:	e1a01004 	mov	r1, r4
102dc148:	e3a02f4b 	mov	r2, #300	; 0x12c
102dc14c:	e28d000c 	add	r0, sp, #12
102dc150:	e59fa21c 	ldr	sl, [pc, #540]	; 102dc374 <RIL_SSL_QSSLCFG+0x25c>
102dc154:	e12fff3a 	blx	sl
		Ql_sprintf(strAT, "AT+QSSLCFG=\"cacert\",%d,\"NVRAM:CA0\"\n",CID_HOST_AZURE);
102dc158:	e1a02004 	mov	r2, r4
102dc15c:	e59f1214 	ldr	r1, [pc, #532]	; 102dc378 <RIL_SSL_QSSLCFG+0x260>
102dc160:	e5983000 	ldr	r3, [r8]
102dc164:	e28d000c 	add	r0, sp, #12
102dc168:	e12fff33 	blx	r3

		ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102dc16c:	e59f7208 	ldr	r7, [pc, #520]	; 102dc37c <RIL_SSL_QSSLCFG+0x264>
102dc170:	e28d000c 	add	r0, sp, #12
102dc174:	e12fff37 	blx	r7
102dc178:	e59f6200 	ldr	r6, [pc, #512]	; 102dc380 <RIL_SSL_QSSLCFG+0x268>
102dc17c:	e1a02004 	mov	r2, r4
102dc180:	e58d4000 	str	r4, [sp]
102dc184:	e1a03004 	mov	r3, r4
102dc188:	e1a01000 	mov	r1, r0
102dc18c:	e28d000c 	add	r0, sp, #12
102dc190:	e12fff36 	blx	r6
#ifdef SECURE_SOCKET
		APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif

		//Configure Client Certificate
		if(ret == RIL_AT_SUCCESS)
102dc194:	e2504000 	subs	r4, r0, #0
102dc198:	1affffe5 	bne	102dc134 <RIL_SSL_QSSLCFG+0x1c>
		{
			Ql_memset(strAT, 0, sizeof(strAT));
102dc19c:	e1a01004 	mov	r1, r4
102dc1a0:	e3a02f4b 	mov	r2, #300	; 0x12c
102dc1a4:	e28d000c 	add	r0, sp, #12
102dc1a8:	e12fff3a 	blx	sl
			Ql_sprintf(strAT, "AT+QSSLCFG=\"clientcert\",%d,\"NVRAM:CC0\"\n",CID_HOST_AZURE);
102dc1ac:	e1a02004 	mov	r2, r4
102dc1b0:	e59f11cc 	ldr	r1, [pc, #460]	; 102dc384 <RIL_SSL_QSSLCFG+0x26c>
102dc1b4:	e5983000 	ldr	r3, [r8]
102dc1b8:	e28d000c 	add	r0, sp, #12
102dc1bc:	e12fff33 	blx	r3

			ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102dc1c0:	e28d000c 	add	r0, sp, #12
102dc1c4:	e12fff37 	blx	r7
102dc1c8:	e1a02004 	mov	r2, r4
102dc1cc:	e58d4000 	str	r4, [sp]
102dc1d0:	e1a03004 	mov	r3, r4
102dc1d4:	e1a01000 	mov	r1, r0
102dc1d8:	e28d000c 	add	r0, sp, #12
102dc1dc:	e12fff36 	blx	r6
			APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
		}

		//Configure Client key Certificate
		if(ret == RIL_AT_SUCCESS)
102dc1e0:	e2504000 	subs	r4, r0, #0
102dc1e4:	1affffd2 	bne	102dc134 <RIL_SSL_QSSLCFG+0x1c>
		{
			Ql_memset(strAT, 0, sizeof(strAT));
102dc1e8:	e1a01004 	mov	r1, r4
102dc1ec:	e3a02f4b 	mov	r2, #300	; 0x12c
102dc1f0:	e28d000c 	add	r0, sp, #12
102dc1f4:	e12fff3a 	blx	sl
			Ql_sprintf(strAT, "AT+QSSLCFG=\"clientkey\",%d,\"NVRAM:CK0\"\n",CID_HOST_AZURE);
102dc1f8:	e1a02004 	mov	r2, r4
102dc1fc:	e59f1184 	ldr	r1, [pc, #388]	; 102dc388 <RIL_SSL_QSSLCFG+0x270>
102dc200:	e5983000 	ldr	r3, [r8]
102dc204:	e28d000c 	add	r0, sp, #12
102dc208:	e12fff33 	blx	r3

			ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102dc20c:	e28d000c 	add	r0, sp, #12
102dc210:	e12fff37 	blx	r7
102dc214:	e1a02004 	mov	r2, r4
102dc218:	e58d4000 	str	r4, [sp]
102dc21c:	e1a03004 	mov	r3, r4
102dc220:	e1a01000 	mov	r1, r0
102dc224:	e28d000c 	add	r0, sp, #12
102dc228:	e12fff36 	blx	r6
			APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
		}

		//Enable Chain certificate
		if(ret == RIL_AT_SUCCESS)
102dc22c:	e2504000 	subs	r4, r0, #0
102dc230:	1affffbf 	bne	102dc134 <RIL_SSL_QSSLCFG+0x1c>
		{
			Ql_memset(strAT, 0, sizeof(strAT));
102dc234:	e3a02f4b 	mov	r2, #300	; 0x12c
102dc238:	e1a01004 	mov	r1, r4
102dc23c:	e28d000c 	add	r0, sp, #12
102dc240:	e12fff3a 	blx	sl
			Ql_sprintf(strAT, "AT+QSSLCFG=\"certchain\",1\n");
102dc244:	e59f1140 	ldr	r1, [pc, #320]	; 102dc38c <RIL_SSL_QSSLCFG+0x274>
102dc248:	e5983000 	ldr	r3, [r8]
102dc24c:	e28d000c 	add	r0, sp, #12
102dc250:	e12fff33 	blx	r3

			ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102dc254:	e28d000c 	add	r0, sp, #12
102dc258:	e12fff37 	blx	r7
102dc25c:	e1a02004 	mov	r2, r4
102dc260:	e58d4000 	str	r4, [sp]
102dc264:	e1a03004 	mov	r3, r4
102dc268:	e1a01000 	mov	r1, r0
102dc26c:	e28d000c 	add	r0, sp, #12
102dc270:	e12fff36 	blx	r6
			APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
		}

		//Ignore certificate time
		if(ret == RIL_AT_SUCCESS)
102dc274:	e2504000 	subs	r4, r0, #0
102dc278:	1affffad 	bne	102dc134 <RIL_SSL_QSSLCFG+0x1c>
		{
			Ql_memset(strAT, 0, sizeof(strAT));
102dc27c:	e3a02f4b 	mov	r2, #300	; 0x12c
102dc280:	e1a01004 	mov	r1, r4
102dc284:	e28d000c 	add	r0, sp, #12
102dc288:	e12fff3a 	blx	sl
			Ql_sprintf(strAT, "AT+QSSLCFG=\"ignorertctime\",1\n");
102dc28c:	e59f10fc 	ldr	r1, [pc, #252]	; 102dc390 <RIL_SSL_QSSLCFG+0x278>
102dc290:	e5983000 	ldr	r3, [r8]
102dc294:	e28d000c 	add	r0, sp, #12
102dc298:	e12fff33 	blx	r3

			ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102dc29c:	e28d000c 	add	r0, sp, #12
102dc2a0:	e12fff37 	blx	r7
102dc2a4:	e1a02004 	mov	r2, r4
102dc2a8:	e58d4000 	str	r4, [sp]
102dc2ac:	e1a03004 	mov	r3, r4
102dc2b0:	e1a01000 	mov	r1, r0
102dc2b4:	e28d000c 	add	r0, sp, #12
102dc2b8:	e12fff36 	blx	r6
			APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
		}

		//Set SSL version
		if(ret == RIL_AT_SUCCESS)
102dc2bc:	e2504000 	subs	r4, r0, #0
102dc2c0:	1affff9b 	bne	102dc134 <RIL_SSL_QSSLCFG+0x1c>
		{
			Ql_memset(strAT, 0, sizeof(strAT));
102dc2c4:	e1a01004 	mov	r1, r4
102dc2c8:	e3a02f4b 	mov	r2, #300	; 0x12c
102dc2cc:	e28d000c 	add	r0, sp, #12
102dc2d0:	e12fff3a 	blx	sl
			Ql_sprintf(strAT, "AT+QSSLCFG=\"sslversion\",%d,%d\n",CID_HOST_AZURE,SSL_VERSION_4);
102dc2d4:	e1a02004 	mov	r2, r4
102dc2d8:	e59f10b4 	ldr	r1, [pc, #180]	; 102dc394 <RIL_SSL_QSSLCFG+0x27c>
102dc2dc:	e3a03004 	mov	r3, #4
102dc2e0:	e598c000 	ldr	ip, [r8]
102dc2e4:	e28d000c 	add	r0, sp, #12
102dc2e8:	e12fff3c 	blx	ip

			ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102dc2ec:	e28d000c 	add	r0, sp, #12
102dc2f0:	e12fff37 	blx	r7
102dc2f4:	e1a02004 	mov	r2, r4
102dc2f8:	e58d4000 	str	r4, [sp]
102dc2fc:	e1a03004 	mov	r3, r4
102dc300:	e1a01000 	mov	r1, r0
102dc304:	e28d000c 	add	r0, sp, #12
102dc308:	e12fff36 	blx	r6
			APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
		}

		//Set Sec_level
		if(ret == RIL_AT_SUCCESS)
102dc30c:	e2504000 	subs	r4, r0, #0
102dc310:	1affff87 	bne	102dc134 <RIL_SSL_QSSLCFG+0x1c>
		{
			Ql_memset(strAT, 0, sizeof(strAT));
102dc314:	e1a01004 	mov	r1, r4
102dc318:	e3a02f4b 	mov	r2, #300	; 0x12c
102dc31c:	e28d000c 	add	r0, sp, #12
102dc320:	e12fff3a 	blx	sl
			Ql_sprintf(strAT, "AT+QSSLCFG=\"seclevel\",%d,%d\n",CID_HOST_AZURE,SECURITY_LEVEL_2);
102dc324:	e1a02004 	mov	r2, r4
102dc328:	e59f1068 	ldr	r1, [pc, #104]	; 102dc398 <RIL_SSL_QSSLCFG+0x280>
102dc32c:	e3a03002 	mov	r3, #2
102dc330:	e598c000 	ldr	ip, [r8]
102dc334:	e28d000c 	add	r0, sp, #12
102dc338:	e12fff3c 	blx	ip

			ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),NULL,NULL,0);
102dc33c:	e28d000c 	add	r0, sp, #12
102dc340:	e12fff37 	blx	r7
102dc344:	e1a03004 	mov	r3, r4
102dc348:	e1a02004 	mov	r2, r4
102dc34c:	e58d4000 	str	r4, [sp]
102dc350:	e1a01000 	mov	r1, r0
102dc354:	e28d000c 	add	r0, sp, #12
102dc358:	e12fff36 	blx	r6
#ifdef SECURE_SOCKET
			APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
		}
*/
		if(ret == RIL_AT_SUCCESS)
102dc35c:	e2504000 	subs	r4, r0, #0
			FLAG.SSL_CONFIGURED = TRUE;// Mark the respective flag as true
102dc360:	03a03001 	moveq	r3, #1
102dc364:	05c53016 	strbeq	r3, [r5, #22]
102dc368:	eaffff71 	b	102dc134 <RIL_SSL_QSSLCFG+0x1c>
102dc36c:	f03da5f0 	.word	0xf03da5f0
102dc370:	f03de540 	.word	0xf03de540
102dc374:	102e58f4 	.word	0x102e58f4
102dc378:	102efb98 	.word	0x102efb98
102dc37c:	102e57a4 	.word	0x102e57a4
102dc380:	102e5168 	.word	0x102e5168
102dc384:	102efbbc 	.word	0x102efbbc
102dc388:	102efbe4 	.word	0x102efbe4
102dc38c:	102efc0c 	.word	0x102efc0c
102dc390:	102efc28 	.word	0x102efc28
102dc394:	102efc48 	.word	0x102efc48
102dc398:	102efc68 	.word	0x102efc68

102dc39c <RIL_SSL_QSSLOPEN>:
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLOPEN(u8* hostName, u32 port,u8 ssid,u8 ctxindex, u8 mode)
{
102dc39c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102dc3a0:	e24dd0e4 	sub	sp, sp, #228	; 0xe4
102dc3a4:	e1a05000 	mov	r5, r0
102dc3a8:	e1a04001 	mov	r4, r1
102dc3ac:	e1a06002 	mov	r6, r2
	u32 timeout = 300;	// Sec. Default 90
	s32 ret = RIL_AT_SUCCESS;
	ST_AT_TCPparam tcpParam;
	char strAT[200];

	Ql_memset(strAT, 0, sizeof(strAT));
102dc3b0:	e3a01000 	mov	r1, #0
102dc3b4:	e3a020c8 	mov	r2, #200	; 0xc8
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLOPEN(u8* hostName, u32 port,u8 ssid,u8 ctxindex, u8 mode)
{
102dc3b8:	e1a07003 	mov	r7, r3
	u32 timeout = 300;	// Sec. Default 90
	s32 ret = RIL_AT_SUCCESS;
	ST_AT_TCPparam tcpParam;
	char strAT[200];

	Ql_memset(strAT, 0, sizeof(strAT));
102dc3bc:	e28d0018 	add	r0, sp, #24
102dc3c0:	e59f3094 	ldr	r3, [pc, #148]	; 102dc45c <RIL_SSL_QSSLOPEN+0xc0>
102dc3c4:	e12fff33 	blx	r3
	Ql_sprintf(strAT, "AT+QSSLOPEN=%d,%d,\"%s\",%d,%d\n", ssid,ctxindex,hostName, port,mode, timeout);
102dc3c8:	e5dd00f8 	ldrb	r0, [sp, #248]	; 0xf8
102dc3cc:	e58d0008 	str	r0, [sp, #8]
102dc3d0:	e3a00f4b 	mov	r0, #300	; 0x12c
102dc3d4:	e58d000c 	str	r0, [sp, #12]
102dc3d8:	e59f0080 	ldr	r0, [pc, #128]	; 102dc460 <RIL_SSL_QSSLOPEN+0xc4>
102dc3dc:	e59f1080 	ldr	r1, [pc, #128]	; 102dc464 <RIL_SSL_QSSLOPEN+0xc8>
102dc3e0:	e1a02006 	mov	r2, r6
102dc3e4:	e1a03007 	mov	r3, r7
102dc3e8:	e58d5000 	str	r5, [sp]
102dc3ec:	e58d4004 	str	r4, [sp, #4]
102dc3f0:	e590c000 	ldr	ip, [r0]
102dc3f4:	e28d0018 	add	r0, sp, #24
102dc3f8:	e12fff3c 	blx	ip
	tcpParam.prefix="+QSSLOPEN:";
102dc3fc:	e59f3064 	ldr	r3, [pc, #100]	; 102dc468 <RIL_SSL_QSSLOPEN+0xcc>
102dc400:	e58d3010 	str	r3, [sp, #16]
	tcpParam.data = 255;
102dc404:	e3a030ff 	mov	r3, #255	; 0xff
102dc408:	e58d3014 	str	r3, [sp, #20]

	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_SSL_handler_open,(void* )&tcpParam,0);
102dc40c:	e28d0018 	add	r0, sp, #24
102dc410:	e59f3054 	ldr	r3, [pc, #84]	; 102dc46c <RIL_SSL_QSSLOPEN+0xd0>
102dc414:	e12fff33 	blx	r3
102dc418:	e3a03000 	mov	r3, #0
102dc41c:	e58d3000 	str	r3, [sp]
102dc420:	e59f2048 	ldr	r2, [pc, #72]	; 102dc470 <RIL_SSL_QSSLOPEN+0xd4>
102dc424:	e28d3010 	add	r3, sp, #16
102dc428:	e59fc044 	ldr	ip, [pc, #68]	; 102dc474 <RIL_SSL_QSSLOPEN+0xd8>
102dc42c:	e1a01000 	mov	r1, r0
102dc430:	e28d0018 	add	r0, sp, #24
102dc434:	e12fff3c 	blx	ip
#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
	if(ret != RIL_AT_SUCCESS)
102dc438:	e3500000 	cmp	r0, #0
102dc43c:	1a000004 	bne	102dc454 <RIL_SSL_QSSLOPEN+0xb8>
	{
		return ret;
	}
	else if(tcpParam.data != 0)
102dc440:	e59d0014 	ldr	r0, [sp, #20]
102dc444:	e3500000 	cmp	r0, #0
	{
		FLAG.SSL_CONNECTION_STATE = TRUE;
102dc448:	159f3028 	ldrne	r3, [pc, #40]	; 102dc478 <RIL_SSL_QSSLOPEN+0xdc>
102dc44c:	13a02001 	movne	r2, #1
102dc450:	15c32010 	strbne	r2, [r3, #16]
	}
	return tcpParam.data;
}
102dc454:	e28dd0e4 	add	sp, sp, #228	; 0xe4
102dc458:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
102dc45c:	102e58f4 	.word	0x102e58f4
102dc460:	f03de540 	.word	0xf03de540
102dc464:	102efc88 	.word	0x102efc88
102dc468:	102efca8 	.word	0x102efca8
102dc46c:	102e57a4 	.word	0x102e57a4
102dc470:	102db834 	.word	0x102db834
102dc474:	102e5168 	.word	0x102e5168
102dc478:	f03da5f0 	.word	0xf03da5f0

102dc47c <RIL_SSL_QSSLSEND>:
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLSEND(u8 ssid,u8 *data,u32 length)
{
102dc47c:	e92d4070 	push	{r4, r5, r6, lr}
102dc480:	e24dd0e0 	sub	sp, sp, #224	; 0xe0
102dc484:	e1a04002 	mov	r4, r2
102dc488:	e1a06000 	mov	r6, r0
102dc48c:	e1a05001 	mov	r5, r1
	SSL_SendParam sslsendParam;
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];

	Ql_memset(strAT, 0, sizeof(strAT));
102dc490:	e3a020c8 	mov	r2, #200	; 0xc8
102dc494:	e3a01000 	mov	r1, #0
102dc498:	e28d0018 	add	r0, sp, #24
102dc49c:	e59f3058 	ldr	r3, [pc, #88]	; 102dc4fc <RIL_SSL_QSSLSEND+0x80>
102dc4a0:	e12fff33 	blx	r3
	sslsendParam.prefix=data;
	sslsendParam.length= length;
	Ql_sprintf(strAT, "AT+QSSLSEND=%d,%d\n", ssid,length);
102dc4a4:	e59f0054 	ldr	r0, [pc, #84]	; 102dc500 <RIL_SSL_QSSLSEND+0x84>
102dc4a8:	e1a02006 	mov	r2, r6
102dc4ac:	e590c000 	ldr	ip, [r0]
102dc4b0:	e59f104c 	ldr	r1, [pc, #76]	; 102dc504 <RIL_SSL_QSSLSEND+0x88>
102dc4b4:	e1a03004 	mov	r3, r4
	SSL_SendParam sslsendParam;
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];

	Ql_memset(strAT, 0, sizeof(strAT));
	sslsendParam.prefix=data;
102dc4b8:	e58d500c 	str	r5, [sp, #12]
	sslsendParam.length= length;
102dc4bc:	e58d4010 	str	r4, [sp, #16]
	Ql_sprintf(strAT, "AT+QSSLSEND=%d,%d\n", ssid,length);
102dc4c0:	e28d0018 	add	r0, sp, #24
102dc4c4:	e12fff3c 	blx	ip
	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_SSL_handler_send,(void* )&sslsendParam,0);
102dc4c8:	e28d0018 	add	r0, sp, #24
102dc4cc:	e59f3034 	ldr	r3, [pc, #52]	; 102dc508 <RIL_SSL_QSSLSEND+0x8c>
102dc4d0:	e12fff33 	blx	r3
102dc4d4:	e3a03000 	mov	r3, #0
102dc4d8:	e58d3000 	str	r3, [sp]
102dc4dc:	e59f2028 	ldr	r2, [pc, #40]	; 102dc50c <RIL_SSL_QSSLSEND+0x90>
102dc4e0:	e28d300c 	add	r3, sp, #12
102dc4e4:	e59fc024 	ldr	ip, [pc, #36]	; 102dc510 <RIL_SSL_QSSLSEND+0x94>
102dc4e8:	e1a01000 	mov	r1, r0
102dc4ec:	e28d0018 	add	r0, sp, #24
102dc4f0:	e12fff3c 	blx	ip
#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
	return ret;
}
102dc4f4:	e28dd0e0 	add	sp, sp, #224	; 0xe0
102dc4f8:	e8bd8070 	pop	{r4, r5, r6, pc}
102dc4fc:	102e58f4 	.word	0x102e58f4
102dc500:	f03de540 	.word	0xf03de540
102dc504:	102efcb4 	.word	0x102efcb4
102dc508:	102e57a4 	.word	0x102e57a4
102dc50c:	102dbe04 	.word	0x102dbe04
102dc510:	102e5168 	.word	0x102e5168

102dc514 <RIL_SSL_QSSLRECV>:
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLRECV(u16 cid_ssid, SSL_RecvParam *recvd_data)
{
102dc514:	e92d4030 	push	{r4, r5, lr}
102dc518:	e24dd0d4 	sub	sp, sp, #212	; 0xd4
102dc51c:	e1a04000 	mov	r4, r0
102dc520:	e1a05001 	mov	r5, r1
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];

	Ql_memset(strAT, 0, sizeof(strAT));
102dc524:	e3a020c8 	mov	r2, #200	; 0xc8
102dc528:	e3a01000 	mov	r1, #0
102dc52c:	e28d0008 	add	r0, sp, #8
102dc530:	e59f3058 	ldr	r3, [pc, #88]	; 102dc590 <RIL_SSL_QSSLRECV+0x7c>
102dc534:	e12fff33 	blx	r3
	Ql_sprintf(strAT, "AT+QSSLRECV=%d,%d,%d\n", (cid_ssid>>8) ,(cid_ssid & 0xFF),SSL_SOC_MAX_DATA_LENGTH); // Higher byte of cid_ssid is cid and lower byte is ssid
102dc538:	e59f0054 	ldr	r0, [pc, #84]	; 102dc594 <RIL_SSL_QSSLRECV+0x80>
102dc53c:	e58d0000 	str	r0, [sp]
102dc540:	e59f0050 	ldr	r0, [pc, #80]	; 102dc598 <RIL_SSL_QSSLRECV+0x84>
102dc544:	e1a02424 	lsr	r2, r4, #8
102dc548:	e590c000 	ldr	ip, [r0]
102dc54c:	e20430ff 	and	r3, r4, #255	; 0xff
102dc550:	e59f1044 	ldr	r1, [pc, #68]	; 102dc59c <RIL_SSL_QSSLRECV+0x88>
102dc554:	e28d0008 	add	r0, sp, #8
102dc558:	e12fff3c 	blx	ip
	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_SSL_handler_recv,recvd_data,0);
102dc55c:	e28d0008 	add	r0, sp, #8
102dc560:	e59f3038 	ldr	r3, [pc, #56]	; 102dc5a0 <RIL_SSL_QSSLRECV+0x8c>
102dc564:	e12fff33 	blx	r3
102dc568:	e3a03000 	mov	r3, #0
102dc56c:	e58d3000 	str	r3, [sp]
102dc570:	e59f202c 	ldr	r2, [pc, #44]	; 102dc5a4 <RIL_SSL_QSSLRECV+0x90>
102dc574:	e1a03005 	mov	r3, r5
102dc578:	e59fc028 	ldr	ip, [pc, #40]	; 102dc5a8 <RIL_SSL_QSSLRECV+0x94>
102dc57c:	e1a01000 	mov	r1, r0
102dc580:	e28d0008 	add	r0, sp, #8
102dc584:	e12fff3c 	blx	ip
#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
	return ret;
}
102dc588:	e28dd0d4 	add	sp, sp, #212	; 0xd4
102dc58c:	e8bd8030 	pop	{r4, r5, pc}
102dc590:	102e58f4 	.word	0x102e58f4
102dc594:	000005b4 	.word	0x000005b4
102dc598:	f03de540 	.word	0xf03de540
102dc59c:	102efcc8 	.word	0x102efcc8
102dc5a0:	102e57a4 	.word	0x102e57a4
102dc5a4:	102dbb10 	.word	0x102dbb10
102dc5a8:	102e5168 	.word	0x102e5168

102dc5ac <RIL_SSL_QSSLSTATE>:
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLSTATE(SSL_SocStateParam *ssl_state_data)
{
102dc5ac:	e92d4010 	push	{r4, lr}
102dc5b0:	e24dd0d0 	sub	sp, sp, #208	; 0xd0
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];

	Ql_memset(strAT, 0, sizeof(strAT));
102dc5b4:	e3a020c8 	mov	r2, #200	; 0xc8
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLSTATE(SSL_SocStateParam *ssl_state_data)
{
102dc5b8:	e1a04000 	mov	r4, r0
	s32 ret = RIL_AT_SUCCESS;
	char strAT[200];

	Ql_memset(strAT, 0, sizeof(strAT));
102dc5bc:	e3a01000 	mov	r1, #0
102dc5c0:	e28d0008 	add	r0, sp, #8
102dc5c4:	e59f3048 	ldr	r3, [pc, #72]	; 102dc614 <RIL_SSL_QSSLSTATE+0x68>
102dc5c8:	e12fff33 	blx	r3
	Ql_sprintf(strAT, "AT+QSSLSTATE\n");
102dc5cc:	e59f3044 	ldr	r3, [pc, #68]	; 102dc618 <RIL_SSL_QSSLSTATE+0x6c>
102dc5d0:	e59f1044 	ldr	r1, [pc, #68]	; 102dc61c <RIL_SSL_QSSLSTATE+0x70>
102dc5d4:	e5933000 	ldr	r3, [r3]
102dc5d8:	e28d0008 	add	r0, sp, #8
102dc5dc:	e12fff33 	blx	r3

	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_SSL_handler_state,ssl_state_data,0);
102dc5e0:	e28d0008 	add	r0, sp, #8
102dc5e4:	e59f3034 	ldr	r3, [pc, #52]	; 102dc620 <RIL_SSL_QSSLSTATE+0x74>
102dc5e8:	e12fff33 	blx	r3
102dc5ec:	e3a03000 	mov	r3, #0
102dc5f0:	e58d3000 	str	r3, [sp]
102dc5f4:	e59f2028 	ldr	r2, [pc, #40]	; 102dc624 <RIL_SSL_QSSLSTATE+0x78>
102dc5f8:	e1a03004 	mov	r3, r4
102dc5fc:	e59fc024 	ldr	ip, [pc, #36]	; 102dc628 <RIL_SSL_QSSLSTATE+0x7c>
102dc600:	e1a01000 	mov	r1, r0
102dc604:	e28d0008 	add	r0, sp, #8
102dc608:	e12fff3c 	blx	ip
#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
	return ret;
}
102dc60c:	e28dd0d0 	add	sp, sp, #208	; 0xd0
102dc610:	e8bd8010 	pop	{r4, pc}
102dc614:	102e58f4 	.word	0x102e58f4
102dc618:	f03de540 	.word	0xf03de540
102dc61c:	102efce0 	.word	0x102efce0
102dc620:	102e57a4 	.word	0x102e57a4
102dc624:	102db4cc 	.word	0x102db4cc
102dc628:	102e5168 	.word	0x102e5168

102dc62c <RIL_SSL_QSSLCLOSE>:
 *
 * Return: SUCCESS , FAIL
 *
 *****************************************************************/
s32 RIL_SSL_QSSLCLOSE(u8 ssid)
{
102dc62c:	e92d4010 	push	{r4, lr}
102dc630:	e24dd0d0 	sub	sp, sp, #208	; 0xd0
102dc634:	e1a04000 	mov	r4, r0
	s32 ret = RIL_AT_SUCCESS;
	 char strAT[200];

	Ql_memset(strAT, 0, sizeof(strAT));
102dc638:	e3a01000 	mov	r1, #0
102dc63c:	e3a020c8 	mov	r2, #200	; 0xc8
102dc640:	e28d0008 	add	r0, sp, #8
102dc644:	e59f3048 	ldr	r3, [pc, #72]	; 102dc694 <RIL_SSL_QSSLCLOSE+0x68>
102dc648:	e12fff33 	blx	r3
	Ql_sprintf(strAT, "AT+QSSLCLOSE=%d\n", ssid);
102dc64c:	e59f3044 	ldr	r3, [pc, #68]	; 102dc698 <RIL_SSL_QSSLCLOSE+0x6c>
102dc650:	e1a02004 	mov	r2, r4
102dc654:	e59f1040 	ldr	r1, [pc, #64]	; 102dc69c <RIL_SSL_QSSLCLOSE+0x70>
102dc658:	e5933000 	ldr	r3, [r3]
102dc65c:	e28d0008 	add	r0, sp, #8
102dc660:	e12fff33 	blx	r3
	ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_SSL_handler_close,NULL,0);
102dc664:	e28d0008 	add	r0, sp, #8
102dc668:	e59f3030 	ldr	r3, [pc, #48]	; 102dc6a0 <RIL_SSL_QSSLCLOSE+0x74>
102dc66c:	e12fff33 	blx	r3
102dc670:	e3a03000 	mov	r3, #0
102dc674:	e58d3000 	str	r3, [sp]
102dc678:	e59f2024 	ldr	r2, [pc, #36]	; 102dc6a4 <RIL_SSL_QSSLCLOSE+0x78>
102dc67c:	e59fc024 	ldr	ip, [pc, #36]	; 102dc6a8 <RIL_SSL_QSSLCLOSE+0x7c>
102dc680:	e1a01000 	mov	r1, r0
102dc684:	e28d0008 	add	r0, sp, #8
102dc688:	e12fff3c 	blx	ip
#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]Send AT:%s -->\r\n",(ret==0)?"SUCCESS":"FAIL",strAT);
#endif
	return ret;
}
102dc68c:	e28dd0d0 	add	sp, sp, #208	; 0xd0
102dc690:	e8bd8010 	pop	{r4, pc}
102dc694:	102e58f4 	.word	0x102e58f4
102dc698:	f03de540 	.word	0xf03de540
102dc69c:	102efcf0 	.word	0x102efcf0
102dc6a0:	102e57a4 	.word	0x102e57a4
102dc6a4:	102db480 	.word	0x102db480
102dc6a8:	102e5168 	.word	0x102e5168

102dc6ac <SSL_Recv_Data>:
 *
 *****************************************************************/
s32 SSL_Recv_Data(u16 cid_ssid)
{
	s32 ret = -1;
	SSL_RecvParam sslrecvParam = NULL_sslrecvParam;
102dc6ac:	e59f2294 	ldr	r2, [pc, #660]	; 102dc948 <SSL_Recv_Data+0x29c>
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 SSL_Recv_Data(u16 cid_ssid)
{
102dc6b0:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
102dc6b4:	e1a05000 	mov	r5, r0
	s32 ret = -1;
	SSL_RecvParam sslrecvParam = NULL_sslrecvParam;
102dc6b8:	e8920003 	ldm	r2, {r0, r1}
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 SSL_Recv_Data(u16 cid_ssid)
{
102dc6bc:	e24dd00c 	sub	sp, sp, #12
	s32 ret = -1;
	SSL_RecvParam sslrecvParam = NULL_sslrecvParam;
102dc6c0:	e88d0003 	stm	sp, {r0, r1}

	Ql_memset(g_buf_recvd_data, 0x0, sizeof(g_buf_recvd_data));
102dc6c4:	e59f2280 	ldr	r2, [pc, #640]	; 102dc94c <SSL_Recv_Data+0x2a0>
102dc6c8:	e3a01000 	mov	r1, #0
102dc6cc:	e59f027c 	ldr	r0, [pc, #636]	; 102dc950 <SSL_Recv_Data+0x2a4>
102dc6d0:	e59f627c 	ldr	r6, [pc, #636]	; 102dc954 <SSL_Recv_Data+0x2a8>
102dc6d4:	e12fff36 	blx	r6

	ret = RIL_SSL_QSSLRECV(cid_ssid, &sslrecvParam);
102dc6d8:	e1a00005 	mov	r0, r5
102dc6dc:	e1a0100d 	mov	r1, sp
102dc6e0:	ebffff8b 	bl	102dc514 <RIL_SSL_QSSLRECV>
	if(ret == RIL_ATRSP_SUCCESS) //If message received ..then proceess it
102dc6e4:	e2504000 	subs	r4, r0, #0
102dc6e8:	1a000008 	bne	102dc710 <SSL_Recv_Data+0x64>
	{
		if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE) // Response received from Azure DPS as a response to DPS autoprovisioning REST API message sent earlier
102dc6ec:	e59f7264 	ldr	r7, [pc, #612]	; 102dc958 <SSL_Recv_Data+0x2ac>
102dc6f0:	e5d73017 	ldrb	r3, [r7, #23]
102dc6f4:	e3530000 	cmp	r3, #0
102dc6f8:	0a00000a 	beq	102dc728 <SSL_Recv_Data+0x7c>
		else // Response is received from Azure IoT Hub
		{
#ifdef SECURE_SOCKET
			APP_DEBUG("\n\r<-- Read AZURE_IOTHUB message -->\r\n");
#endif
			Ql_OS_SendMessage(0,MSG_ID_GW_STATE,GW_STATE_PROCESS_SUBCRIBED_DATA, (cid_ssid & 0xFF));
102dc6fc:	e20530ff 	and	r3, r5, #255	; 0xff
102dc700:	e59f1254 	ldr	r1, [pc, #596]	; 102dc95c <SSL_Recv_Data+0x2b0>
102dc704:	e3a02001 	mov	r2, #1
102dc708:	e59fc250 	ldr	ip, [pc, #592]	; 102dc960 <SSL_Recv_Data+0x2b4>
102dc70c:	e12fff3c 	blx	ip
		}
	}

	g_recvd_data_len = 0;
102dc710:	e59f324c 	ldr	r3, [pc, #588]	; 102dc964 <SSL_Recv_Data+0x2b8>
102dc714:	e3a02000 	mov	r2, #0
102dc718:	e5832204 	str	r2, [r3, #516]	; 0x204

	return ret;
}
102dc71c:	e1a00004 	mov	r0, r4
102dc720:	e28dd00c 	add	sp, sp, #12
102dc724:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
	cJSON *root = NULL;
	cJSON *tmp = NULL;
	cJSON *tmpobj = NULL;

	// Strip out the headers and point to the start of actual jason packet of the Azure DPS response
	DPSstring = Ql_strstr(g_buf_recvd_data, "{\"");
102dc728:	e59f0220 	ldr	r0, [pc, #544]	; 102dc950 <SSL_Recv_Data+0x2a4>
102dc72c:	e59f1234 	ldr	r1, [pc, #564]	; 102dc968 <SSL_Recv_Data+0x2bc>
102dc730:	e59f3234 	ldr	r3, [pc, #564]	; 102dc96c <SSL_Recv_Data+0x2c0>
102dc734:	e12fff33 	blx	r3

	if(DPSstring != NULL)
102dc738:	e2505000 	subs	r5, r0, #0
102dc73c:	0a000032 	beq	102dc80c <SSL_Recv_Data+0x160>
	{
		cJSON_InitHooks(NULL); //init function pointers to Ql_MEM_Alloc calloc realloc
102dc740:	e1a00004 	mov	r0, r4
102dc744:	e59f3224 	ldr	r3, [pc, #548]	; 102dc970 <SSL_Recv_Data+0x2c4>
102dc748:	e12fff33 	blx	r3
		root = cJSON_Parse(DPSstring);
102dc74c:	e1a00005 	mov	r0, r5
102dc750:	e59f321c 	ldr	r3, [pc, #540]	; 102dc974 <SSL_Recv_Data+0x2c8>
102dc754:	e12fff33 	blx	r3

		//1. Read enrollmentGroupId information
		tmp = cJSON_GetObjectItem(root, "x509");
102dc758:	e59f5218 	ldr	r5, [pc, #536]	; 102dc978 <SSL_Recv_Data+0x2cc>
102dc75c:	e59f1218 	ldr	r1, [pc, #536]	; 102dc97c <SSL_Recv_Data+0x2d0>
	DPSstring = Ql_strstr(g_buf_recvd_data, "{\"");

	if(DPSstring != NULL)
	{
		cJSON_InitHooks(NULL); //init function pointers to Ql_MEM_Alloc calloc realloc
		root = cJSON_Parse(DPSstring);
102dc760:	e1a08000 	mov	r8, r0

		//1. Read enrollmentGroupId information
		tmp = cJSON_GetObjectItem(root, "x509");
102dc764:	e12fff35 	blx	r5
		if(tmp != NULL)
102dc768:	e3500000 	cmp	r0, #0
102dc76c:	0a000046 	beq	102dc88c <SSL_Recv_Data+0x1e0>
		{
			tmpobj = cJSON_GetObjectItem(tmp, "enrollmentGroupId");
102dc770:	e59f1208 	ldr	r1, [pc, #520]	; 102dc980 <SSL_Recv_Data+0x2d4>
102dc774:	e12fff35 	blx	r5
			if(tmpobj != NULL)
102dc778:	e3500000 	cmp	r0, #0
102dc77c:	0a000065 	beq	102dc918 <SSL_Recv_Data+0x26c>
				ret = RIL_AT_FAILED;

			//2. Read RegisrtationID information
			if(ret == RIL_AT_SUCCESS)
			{
				tmp = cJSON_GetObjectItem(root, "registrationId");
102dc780:	e1a00008 	mov	r0, r8
102dc784:	e59f11f8 	ldr	r1, [pc, #504]	; 102dc984 <SSL_Recv_Data+0x2d8>
102dc788:	e12fff35 	blx	r5
				if(tmp != NULL)
102dc78c:	e3500000 	cmp	r0, #0
102dc790:	0a000060 	beq	102dc918 <SSL_Recv_Data+0x26c>
					ret = RIL_AT_FAILED;
			}
			//3. Read DeviceID information
			if(ret == RIL_AT_SUCCESS)
			{
				tmp = cJSON_GetObjectItem(root, "deviceId");
102dc794:	e1a00008 	mov	r0, r8
102dc798:	e59f11e8 	ldr	r1, [pc, #488]	; 102dc988 <SSL_Recv_Data+0x2dc>
102dc79c:	e12fff35 	blx	r5
				if(tmp != NULL)
102dc7a0:	e3500000 	cmp	r0, #0
102dc7a4:	0a00005b 	beq	102dc918 <SSL_Recv_Data+0x26c>
				{
					Ql_strcpy(AZURE_IoT_device_ID,tmp->valuestring);
102dc7a8:	e5901010 	ldr	r1, [r0, #16]
102dc7ac:	e59fa1d8 	ldr	sl, [pc, #472]	; 102dc98c <SSL_Recv_Data+0x2e0>
102dc7b0:	e59f01d8 	ldr	r0, [pc, #472]	; 102dc990 <SSL_Recv_Data+0x2e4>
102dc7b4:	e12fff3a 	blx	sl
			}

			//4. Read assigned_Hub information
			if(ret == RIL_AT_SUCCESS)
			{
				tmp = cJSON_GetObjectItem(root, "assignedHub");
102dc7b8:	e1a00008 	mov	r0, r8
102dc7bc:	e59f11d0 	ldr	r1, [pc, #464]	; 102dc994 <SSL_Recv_Data+0x2e8>
102dc7c0:	e12fff35 	blx	r5
				if(tmp != NULL)
102dc7c4:	e3500000 	cmp	r0, #0
102dc7c8:	0a000052 	beq	102dc918 <SSL_Recv_Data+0x26c>
				{
					Ql_strcpy(AZURE_assigned_IoT_Hub,tmp->valuestring);
102dc7cc:	e5901010 	ldr	r1, [r0, #16]
102dc7d0:	e59f01c0 	ldr	r0, [pc, #448]	; 102dc998 <SSL_Recv_Data+0x2ec>
102dc7d4:	e12fff3a 	blx	sl
			}

			//5. Read Status information
			if(ret == RIL_AT_SUCCESS)
			{
				tmp = cJSON_GetObjectItem(root, "status");
102dc7d8:	e1a00008 	mov	r0, r8
102dc7dc:	e59f11b8 	ldr	r1, [pc, #440]	; 102dc99c <SSL_Recv_Data+0x2f0>
102dc7e0:	e12fff35 	blx	r5
				if(tmp != NULL)
102dc7e4:	e3500000 	cmp	r0, #0
102dc7e8:	0a00004a 	beq	102dc918 <SSL_Recv_Data+0x26c>
			}

			//6. Read SubStatus information
			if(ret == RIL_AT_SUCCESS)
			{
				tmp = cJSON_GetObjectItem(root, "substatus");
102dc7ec:	e1a00008 	mov	r0, r8
102dc7f0:	e59f11a8 	ldr	r1, [pc, #424]	; 102dc9a0 <SSL_Recv_Data+0x2f4>
102dc7f4:	e12fff35 	blx	r5
				if(tmp != NULL)
102dc7f8:	e3500000 	cmp	r0, #0
102dc7fc:	0a000045 	beq	102dc918 <SSL_Recv_Data+0x26c>
					Ql_OS_SendMessage(0, MSG_ID_SOCKET_CONNECTION,SSID_HOST_AZURE,0);
				}
			}
			ret = RIL_AT_FAILED;
		}
		cJSON_Delete(root);
102dc800:	e1a00008 	mov	r0, r8
102dc804:	e59f3198 	ldr	r3, [pc, #408]	; 102dc9a4 <SSL_Recv_Data+0x2f8>
102dc808:	e12fff33 	blx	r3
	}

	if(ret == RIL_AT_SUCCESS)
	{
		//Prepare MQTT connection strings.
		Ql_sprintf(DEVICE_USER_ID, "%s/%s/?api-version=2018-06-30",AZURE_assigned_IoT_Hub,AZURE_IoT_device_ID); // API verison is must to have device twin properties communication
102dc80c:	e59f5194 	ldr	r5, [pc, #404]	; 102dc9a8 <SSL_Recv_Data+0x2fc>
102dc810:	e59f3178 	ldr	r3, [pc, #376]	; 102dc990 <SSL_Recv_Data+0x2e4>
102dc814:	e595c000 	ldr	ip, [r5]
102dc818:	e59f118c 	ldr	r1, [pc, #396]	; 102dc9ac <SSL_Recv_Data+0x300>
102dc81c:	e59f2174 	ldr	r2, [pc, #372]	; 102dc998 <SSL_Recv_Data+0x2ec>
102dc820:	e59f0188 	ldr	r0, [pc, #392]	; 102dc9b0 <SSL_Recv_Data+0x304>
102dc824:	e12fff3c 	blx	ip
		Ql_sprintf(DEVICE_CLIENT_ID, "%s",AZURE_IoT_device_ID);
102dc828:	e59f1184 	ldr	r1, [pc, #388]	; 102dc9b4 <SSL_Recv_Data+0x308>
102dc82c:	e59f215c 	ldr	r2, [pc, #348]	; 102dc990 <SSL_Recv_Data+0x2e4>
102dc830:	e5953000 	ldr	r3, [r5]
102dc834:	e59f017c 	ldr	r0, [pc, #380]	; 102dc9b8 <SSL_Recv_Data+0x30c>
102dc838:	e12fff33 	blx	r3
		Store_IoT_Persistent_Data();   //Write permanent data to flash file for AZURE_assigned_IoT_Hub
102dc83c:	e59f3178 	ldr	r3, [pc, #376]	; 102dc9bc <SSL_Recv_Data+0x310>
102dc840:	e12fff33 	blx	r3
		FLAG.AUTOPROVISIONING_COMPLETE = TRUE;
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102dc844:	e3a02002 	mov	r2, #2
102dc848:	e1a03002 	mov	r3, r2
102dc84c:	e59f1108 	ldr	r1, [pc, #264]	; 102dc95c <SSL_Recv_Data+0x2b0>
	{
		//Prepare MQTT connection strings.
		Ql_sprintf(DEVICE_USER_ID, "%s/%s/?api-version=2018-06-30",AZURE_assigned_IoT_Hub,AZURE_IoT_device_ID); // API verison is must to have device twin properties communication
		Ql_sprintf(DEVICE_CLIENT_ID, "%s",AZURE_IoT_device_ID);
		Store_IoT_Persistent_Data();   //Write permanent data to flash file for AZURE_assigned_IoT_Hub
		FLAG.AUTOPROVISIONING_COMPLETE = TRUE;
102dc850:	e3a0c001 	mov	ip, #1
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102dc854:	e3a00003 	mov	r0, #3
102dc858:	e59f5100 	ldr	r5, [pc, #256]	; 102dc960 <SSL_Recv_Data+0x2b4>
	{
		//Prepare MQTT connection strings.
		Ql_sprintf(DEVICE_USER_ID, "%s/%s/?api-version=2018-06-30",AZURE_assigned_IoT_Hub,AZURE_IoT_device_ID); // API verison is must to have device twin properties communication
		Ql_sprintf(DEVICE_CLIENT_ID, "%s",AZURE_IoT_device_ID);
		Store_IoT_Persistent_Data();   //Write permanent data to flash file for AZURE_assigned_IoT_Hub
		FLAG.AUTOPROVISIONING_COMPLETE = TRUE;
102dc85c:	e5c7c017 	strb	ip, [r7, #23]
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102dc860:	e12fff35 	blx	r5
		Ql_OS_SendMessage(0, MSG_ID_SOCKET_CONNECTION,SSID_HOST_AZURE,0);//To connect Azure IoT Hub connection
102dc864:	e3a00000 	mov	r0, #0
102dc868:	e59f1150 	ldr	r1, [pc, #336]	; 102dc9c0 <SSL_Recv_Data+0x314>
102dc86c:	e1a02000 	mov	r2, r0
102dc870:	e1a03000 	mov	r3, r0
102dc874:	e12fff35 	blx	r5
#ifdef SECURE_SOCKET
			APP_DEBUG("\n\r<-- Read AZURE_DPS message -->\r\n");
#endif
			ret = Azure_DPS_Response_Process();

			Ql_memset(g_buf_recvd_data, 0x0, sizeof(g_buf_recvd_data));
102dc878:	e3a01000 	mov	r1, #0
102dc87c:	e59f20c8 	ldr	r2, [pc, #200]	; 102dc94c <SSL_Recv_Data+0x2a0>
102dc880:	e59f00c8 	ldr	r0, [pc, #200]	; 102dc950 <SSL_Recv_Data+0x2a4>
102dc884:	e12fff36 	blx	r6
102dc888:	eaffffa0 	b	102dc710 <SSL_Recv_Data+0x64>
					ret = RIL_AT_FAILED;
			}
		}
		else //Parse error message
		{
			tmp = cJSON_GetObjectItem(root, "message");
102dc88c:	e1a00008 	mov	r0, r8
102dc890:	e59f112c 	ldr	r1, [pc, #300]	; 102dc9c4 <SSL_Recv_Data+0x318>
102dc894:	e12fff35 	blx	r5
			if(tmp != NULL)
102dc898:	e2504000 	subs	r4, r0, #0
102dc89c:	0a00000b 	beq	102dc8d0 <SSL_Recv_Data+0x224>
			{
				if(Ql_strcmp(tmp->valuestring, "Registration not found") == 0) // Device is not registered yet
102dc8a0:	e5940010 	ldr	r0, [r4, #16]
102dc8a4:	e59f111c 	ldr	r1, [pc, #284]	; 102dc9c8 <SSL_Recv_Data+0x31c>
102dc8a8:	e59fa11c 	ldr	sl, [pc, #284]	; 102dc9cc <SSL_Recv_Data+0x320>
102dc8ac:	e12fff3a 	blx	sl
102dc8b0:	e2502000 	subs	r2, r0, #0
102dc8b4:	1a00001c 	bne	102dc92c <SSL_Recv_Data+0x280>
				{
#ifdef SECURE_SOCKET
					APP_DEBUG("\n\r<-- Device Not Yet Registered -->\n\r");
#endif
					FLAG.DEVICE_NOT_REGISTERED = TRUE; //Next connect with Azure DPS is to register the device for first time
102dc8b8:	e3a0c001 	mov	ip, #1
102dc8bc:	e5c7c01a 	strb	ip, [r7, #26]
					//Schedule to connect with Azure DPS to register the device for first time
					Ql_OS_SendMessage(0, MSG_ID_SOCKET_CONNECTION,SSID_HOST_AZURE,0);
102dc8c0:	e59f10f8 	ldr	r1, [pc, #248]	; 102dc9c0 <SSL_Recv_Data+0x314>
102dc8c4:	e1a03002 	mov	r3, r2
102dc8c8:	e59fc090 	ldr	ip, [pc, #144]	; 102dc960 <SSL_Recv_Data+0x2b4>
102dc8cc:	e12fff3c 	blx	ip
			//		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE);
					FLAG.DEVICE_UNAUTHORISED = TRUE;
				}
			}

			tmp = cJSON_GetObjectItem(root, "status");
102dc8d0:	e1a00008 	mov	r0, r8
102dc8d4:	e59f10c0 	ldr	r1, [pc, #192]	; 102dc99c <SSL_Recv_Data+0x2f0>
102dc8d8:	e12fff35 	blx	r5
			if(tmp != NULL)
102dc8dc:	e3500000 	cmp	r0, #0
102dc8e0:	0a00000c 	beq	102dc918 <SSL_Recv_Data+0x26c>
			{
				if(Ql_strcmp(tmp->valuestring, "assigning") == 0) // Device is registered and is in assigning status
102dc8e4:	e5900010 	ldr	r0, [r0, #16]
102dc8e8:	e59f10e0 	ldr	r1, [pc, #224]	; 102dc9d0 <SSL_Recv_Data+0x324>
102dc8ec:	e59f30d8 	ldr	r3, [pc, #216]	; 102dc9cc <SSL_Recv_Data+0x320>
102dc8f0:	e12fff33 	blx	r3
102dc8f4:	e250c000 	subs	ip, r0, #0
102dc8f8:	1a000006 	bne	102dc918 <SSL_Recv_Data+0x26c>
					APP_DEBUG("\n\r<-- Device Registered -->\n\r");
#endif
					FLAG.DEVICE_UNAUTHORISED = FALSE;
					FLAG.DEVICE_NOT_REGISTERED = FALSE; //Next connect with Azure DPS is to preview the device IoT Hub confguration
					//Schedule to connect with Azure DPS to preview the device IoT Hub confguration
					Ql_OS_SendMessage(0, MSG_ID_SOCKET_CONNECTION,SSID_HOST_AZURE,0);
102dc8fc:	e1a0200c 	mov	r2, ip
102dc900:	e1a0300c 	mov	r3, ip
				if(Ql_strcmp(tmp->valuestring, "assigning") == 0) // Device is registered and is in assigning status
				{
#ifdef SECURE_SOCKET
					APP_DEBUG("\n\r<-- Device Registered -->\n\r");
#endif
					FLAG.DEVICE_UNAUTHORISED = FALSE;
102dc904:	e5c7c01b 	strb	ip, [r7, #27]
					FLAG.DEVICE_NOT_REGISTERED = FALSE; //Next connect with Azure DPS is to preview the device IoT Hub confguration
102dc908:	e5c7c01a 	strb	ip, [r7, #26]
					//Schedule to connect with Azure DPS to preview the device IoT Hub confguration
					Ql_OS_SendMessage(0, MSG_ID_SOCKET_CONNECTION,SSID_HOST_AZURE,0);
102dc90c:	e59f10ac 	ldr	r1, [pc, #172]	; 102dc9c0 <SSL_Recv_Data+0x314>
102dc910:	e59fc048 	ldr	ip, [pc, #72]	; 102dc960 <SSL_Recv_Data+0x2b4>
102dc914:	e12fff3c 	blx	ip
				}
			}
			ret = RIL_AT_FAILED;
		}
		cJSON_Delete(root);
102dc918:	e1a00008 	mov	r0, r8
102dc91c:	e59f3080 	ldr	r3, [pc, #128]	; 102dc9a4 <SSL_Recv_Data+0x2f8>
102dc920:	e12fff33 	blx	r3
102dc924:	e3e04000 	mvn	r4, #0
102dc928:	eaffffd2 	b	102dc878 <SSL_Recv_Data+0x1cc>
#endif
					FLAG.DEVICE_NOT_REGISTERED = TRUE; //Next connect with Azure DPS is to register the device for first time
					//Schedule to connect with Azure DPS to register the device for first time
					Ql_OS_SendMessage(0, MSG_ID_SOCKET_CONNECTION,SSID_HOST_AZURE,0);
				}
				else if(Ql_strcmp(tmp->valuestring, "Unauthorized") == 0) // Device is Unauthorised..
102dc92c:	e5940010 	ldr	r0, [r4, #16]
102dc930:	e59f109c 	ldr	r1, [pc, #156]	; 102dc9d4 <SSL_Recv_Data+0x328>
102dc934:	e12fff3a 	blx	sl
102dc938:	e3500000 	cmp	r0, #0
					APP_DEBUG("\n\r<-- Device Unauthorised -->\n\r");
#endif
					// Certificates are not present or not valid then Display Internal Fault F3 on LCD
			//		Ql_sprintf((char *)&Internal_error_code,"F4");
			//		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE);
					FLAG.DEVICE_UNAUTHORISED = TRUE;
102dc93c:	03a03001 	moveq	r3, #1
102dc940:	05c7301b 	strbeq	r3, [r7, #27]
102dc944:	eaffffe1 	b	102dc8d0 <SSL_Recv_Data+0x224>
102dc948:	f03da094 	.word	0xf03da094
102dc94c:	00003908 	.word	0x00003908
102dc950:	f03d678c 	.word	0xf03d678c
102dc954:	102e58f4 	.word	0x102e58f4
102dc958:	f03da5f0 	.word	0xf03da5f0
102dc95c:	000010c8 	.word	0x000010c8
102dc960:	102e5cb4 	.word	0x102e5cb4
102dc964:	f03d6584 	.word	0xf03d6584
102dc968:	102efd04 	.word	0x102efd04
102dc96c:	102e5a04 	.word	0x102e5a04
102dc970:	102d6ec8 	.word	0x102d6ec8
102dc974:	102d7750 	.word	0x102d7750
102dc978:	102d7880 	.word	0x102d7880
102dc97c:	102efd08 	.word	0x102efd08
102dc980:	102efd10 	.word	0x102efd10
102dc984:	102efd94 	.word	0x102efd94
102dc988:	102efda4 	.word	0x102efda4
102dc98c:	102e55fc 	.word	0x102e55fc
102dc990:	f03d5dfc 	.word	0xf03d5dfc
102dc994:	102efd24 	.word	0x102efd24
102dc998:	f03d5e34 	.word	0xf03d5e34
102dc99c:	102efd30 	.word	0x102efd30
102dc9a0:	102efdb0 	.word	0x102efdb0
102dc9a4:	102d6f68 	.word	0x102d6f68
102dc9a8:	f03de540 	.word	0xf03de540
102dc9ac:	102efd74 	.word	0x102efd74
102dc9b0:	f03d574c 	.word	0xf03d574c
102dc9b4:	102ef04c 	.word	0x102ef04c
102dc9b8:	f03d5730 	.word	0xf03d5730
102dc9bc:	102d3988 	.word	0x102d3988
102dc9c0:	000010c9 	.word	0x000010c9
102dc9c4:	102efd38 	.word	0x102efd38
102dc9c8:	102efd40 	.word	0x102efd40
102dc9cc:	102e581c 	.word	0x102e581c
102dc9d0:	102efd68 	.word	0x102efd68
102dc9d4:	102efd58 	.word	0x102efd58

102dc9d8 <SSL_Check_SOC_State>:

	return ret;
}

s32 SSL_Check_SOC_State(u8 ssid)
{
102dc9d8:	e92d4030 	push	{r4, r5, lr}
102dc9dc:	e24dd00c 	sub	sp, sp, #12
102dc9e0:	e1a04000 	mov	r4, r0
	s32 ret = -RIL_AT_FAILED;
	SSL_SocStateParam sslstateParam;

	sslstateParam.ssid = ssid;
102dc9e4:	e28d0008 	add	r0, sp, #8
102dc9e8:	e5204008 	str	r4, [r0, #-8]!
	ret = RIL_SSL_QSSLSTATE(&sslstateParam); // The function call back will change the sslstateParam.sslSocState parameter state
102dc9ec:	e1a0000d 	mov	r0, sp
102dc9f0:	ebfffeed 	bl	102dc5ac <RIL_SSL_QSSLSTATE>

	if(ret == 0)
102dc9f4:	e2505000 	subs	r5, r0, #0
		ret = sslstateParam.sslSocState; // Assign actual socket status when returned a AT command execution success..
102dc9f8:	05dd5004 	ldrbeq	r5, [sp, #4]

#ifdef DEBUG_MSG
	if(ssid == SSID_HOST_AZURE)
102dc9fc:	e3540000 	cmp	r4, #0
102dca00:	0a00000b 	beq	102dca34 <SSL_Check_SOC_State+0x5c>
	{
		APP_DEBUG("<-- SSL Socket status:");
	}

	if(sslstateParam.sslSocState == 0)
102dca04:	e5dd1004 	ldrb	r1, [sp, #4]
102dca08:	e3510000 	cmp	r1, #0
102dca0c:	0a00001d 	beq	102dca88 <SSL_Check_SOC_State+0xb0>
	{
		APP_DEBUG(" Initial -->\r\n");
	}
	else if(sslstateParam.sslSocState == 1)
102dca10:	e3510001 	cmp	r1, #1
102dca14:	0a000034 	beq	102dcaec <SSL_Check_SOC_State+0x114>
	{
		APP_DEBUG(" Opening -->\r\n");
	}
	else if(sslstateParam.sslSocState == 2)
102dca18:	e3510002 	cmp	r1, #2
102dca1c:	0a000039 	beq	102dcb08 <SSL_Check_SOC_State+0x130>
	{
		APP_DEBUG(" Connected -->\r\n");
	}
	else if(sslstateParam.sslSocState == 4)
102dca20:	e3510004 	cmp	r1, #4
102dca24:	0a000029 	beq	102dcad0 <SSL_Check_SOC_State+0xf8>
		APP_DEBUG(" Closing -->\r\n");
	}
#endif

	return ret;
}
102dca28:	e1a00005 	mov	r0, r5
102dca2c:	e28dd00c 	add	sp, sp, #12
102dca30:	e8bd8030 	pop	{r4, r5, pc}
		ret = sslstateParam.sslSocState; // Assign actual socket status when returned a AT command execution success..

#ifdef DEBUG_MSG
	if(ssid == SSID_HOST_AZURE)
	{
		APP_DEBUG("<-- SSL Socket status:");
102dca34:	e3a02c02 	mov	r2, #512	; 0x200
102dca38:	e1a01004 	mov	r1, r4
102dca3c:	e59f30e0 	ldr	r3, [pc, #224]	; 102dcb24 <SSL_Check_SOC_State+0x14c>
102dca40:	e59f00e0 	ldr	r0, [pc, #224]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dca44:	e12fff33 	blx	r3
102dca48:	e59f30dc 	ldr	r3, [pc, #220]	; 102dcb2c <SSL_Check_SOC_State+0x154>
102dca4c:	e59f10dc 	ldr	r1, [pc, #220]	; 102dcb30 <SSL_Check_SOC_State+0x158>
102dca50:	e5933000 	ldr	r3, [r3]
102dca54:	e59f00cc 	ldr	r0, [pc, #204]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dca58:	e12fff33 	blx	r3
102dca5c:	e59f30d0 	ldr	r3, [pc, #208]	; 102dcb34 <SSL_Check_SOC_State+0x15c>
102dca60:	e59f00c0 	ldr	r0, [pc, #192]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dca64:	e12fff33 	blx	r3
102dca68:	e59f10b8 	ldr	r1, [pc, #184]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dca6c:	e59f30c4 	ldr	r3, [pc, #196]	; 102dcb38 <SSL_Check_SOC_State+0x160>
102dca70:	e1a02000 	mov	r2, r0
102dca74:	e3a0000a 	mov	r0, #10
102dca78:	e12fff33 	blx	r3
	}

	if(sslstateParam.sslSocState == 0)
102dca7c:	e5dd1004 	ldrb	r1, [sp, #4]
102dca80:	e3510000 	cmp	r1, #0
102dca84:	1affffe1 	bne	102dca10 <SSL_Check_SOC_State+0x38>
	{
		APP_DEBUG(" Initial -->\r\n");
102dca88:	e3a02c02 	mov	r2, #512	; 0x200
102dca8c:	e59f0094 	ldr	r0, [pc, #148]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dca90:	e59f308c 	ldr	r3, [pc, #140]	; 102dcb24 <SSL_Check_SOC_State+0x14c>
102dca94:	e12fff33 	blx	r3
102dca98:	e59f109c 	ldr	r1, [pc, #156]	; 102dcb3c <SSL_Check_SOC_State+0x164>
	{
		APP_DEBUG(" Connected -->\r\n");
	}
	else if(sslstateParam.sslSocState == 4)
	{
		APP_DEBUG(" Closing -->\r\n");
102dca9c:	e59f3088 	ldr	r3, [pc, #136]	; 102dcb2c <SSL_Check_SOC_State+0x154>
102dcaa0:	e59f0080 	ldr	r0, [pc, #128]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dcaa4:	e5933000 	ldr	r3, [r3]
102dcaa8:	e12fff33 	blx	r3
102dcaac:	e59f3080 	ldr	r3, [pc, #128]	; 102dcb34 <SSL_Check_SOC_State+0x15c>
102dcab0:	e59f0070 	ldr	r0, [pc, #112]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dcab4:	e12fff33 	blx	r3
102dcab8:	e59f1068 	ldr	r1, [pc, #104]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dcabc:	e59f3074 	ldr	r3, [pc, #116]	; 102dcb38 <SSL_Check_SOC_State+0x160>
102dcac0:	e1a02000 	mov	r2, r0
102dcac4:	e3a0000a 	mov	r0, #10
102dcac8:	e12fff33 	blx	r3
102dcacc:	eaffffd5 	b	102dca28 <SSL_Check_SOC_State+0x50>
102dcad0:	e3a01000 	mov	r1, #0
102dcad4:	e3a02c02 	mov	r2, #512	; 0x200
102dcad8:	e59f0048 	ldr	r0, [pc, #72]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dcadc:	e59f3040 	ldr	r3, [pc, #64]	; 102dcb24 <SSL_Check_SOC_State+0x14c>
102dcae0:	e12fff33 	blx	r3
102dcae4:	e59f1054 	ldr	r1, [pc, #84]	; 102dcb40 <SSL_Check_SOC_State+0x168>
102dcae8:	eaffffeb 	b	102dca9c <SSL_Check_SOC_State+0xc4>
	{
		APP_DEBUG(" Initial -->\r\n");
	}
	else if(sslstateParam.sslSocState == 1)
	{
		APP_DEBUG(" Opening -->\r\n");
102dcaec:	e3a01000 	mov	r1, #0
102dcaf0:	e3a02c02 	mov	r2, #512	; 0x200
102dcaf4:	e59f002c 	ldr	r0, [pc, #44]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dcaf8:	e59f3024 	ldr	r3, [pc, #36]	; 102dcb24 <SSL_Check_SOC_State+0x14c>
102dcafc:	e12fff33 	blx	r3
102dcb00:	e59f103c 	ldr	r1, [pc, #60]	; 102dcb44 <SSL_Check_SOC_State+0x16c>
102dcb04:	eaffffe4 	b	102dca9c <SSL_Check_SOC_State+0xc4>
	}
	else if(sslstateParam.sslSocState == 2)
	{
		APP_DEBUG(" Connected -->\r\n");
102dcb08:	e3a01000 	mov	r1, #0
102dcb0c:	e3a02c02 	mov	r2, #512	; 0x200
102dcb10:	e59f0010 	ldr	r0, [pc, #16]	; 102dcb28 <SSL_Check_SOC_State+0x150>
102dcb14:	e59f3008 	ldr	r3, [pc, #8]	; 102dcb24 <SSL_Check_SOC_State+0x14c>
102dcb18:	e12fff33 	blx	r3
102dcb1c:	e59f1024 	ldr	r1, [pc, #36]	; 102dcb48 <SSL_Check_SOC_State+0x170>
102dcb20:	eaffffdd 	b	102dca9c <SSL_Check_SOC_State+0xc4>
102dcb24:	102e58f4 	.word	0x102e58f4
102dcb28:	f03d6584 	.word	0xf03d6584
102dcb2c:	f03de540 	.word	0xf03de540
102dcb30:	102efdbc 	.word	0x102efdbc
102dcb34:	102e57a4 	.word	0x102e57a4
102dcb38:	102e6230 	.word	0x102e6230
102dcb3c:	102efdd4 	.word	0x102efdd4
102dcb40:	102efe08 	.word	0x102efe08
102dcb44:	102efde4 	.word	0x102efde4
102dcb48:	102efdf4 	.word	0x102efdf4

102dcb4c <GPRS_Deactivate>:
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 GPRS_Deactivate(void)
{
102dcb4c:	e92d4008 	push	{r3, lr}
	s32 ret = RIL_AT_FAILED;

	ret = RIL_NW_ClosePDPContext();
102dcb50:	e59f3010 	ldr	r3, [pc, #16]	; 102dcb68 <GPRS_Deactivate+0x1c>
102dcb54:	e12fff33 	blx	r3
#ifdef SECURE_SOCKET
	APP_DEBUG("<-- [%s]GPRS Deactivate -->\r\n",(ret==0)?"SUCCESS":"FAIL");
#endif
	FLAG.GPRS_ACTIVE = FALSE;
102dcb58:	e59f300c 	ldr	r3, [pc, #12]	; 102dcb6c <GPRS_Deactivate+0x20>
102dcb5c:	e3a02000 	mov	r2, #0
102dcb60:	e5c32000 	strb	r2, [r3]

	return ret;
}
102dcb64:	e8bd8008 	pop	{r3, pc}
102dcb68:	102cb7c0 	.word	0x102cb7c0
102dcb6c:	f03da5f0 	.word	0xf03da5f0

102dcb70 <Connect_Azure_IoT>:
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 Connect_Azure_IoT(void)
{
102dcb70:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s32 ret = RIL_AT_FAILED;

	if(FLAG.GPRS_ACTIVE == FALSE ) // Do not try to connect if GPRS state is not active
102dcb74:	e59f4294 	ldr	r4, [pc, #660]	; 102dce10 <Connect_Azure_IoT+0x2a0>
 *
 * Return: SUCCESS, FAIL
 *
 *****************************************************************/
s32 Connect_Azure_IoT(void)
{
102dcb78:	e24dd00c 	sub	sp, sp, #12
	s32 ret = RIL_AT_FAILED;

	if(FLAG.GPRS_ACTIVE == FALSE ) // Do not try to connect if GPRS state is not active
102dcb7c:	e5d43000 	ldrb	r3, [r4]
102dcb80:	e3530000 	cmp	r3, #0
102dcb84:	0a000097 	beq	102dcde8 <Connect_Azure_IoT+0x278>
		return ret;

	//X509 certificates should be already present when code comes, Just to make it sure by re-confirm
	if(FLAG.SSL_X509_CERTPRESENT == FALSE)
102dcb88:	e5d43015 	ldrb	r3, [r4, #21]
102dcb8c:	e3530000 	cmp	r3, #0
102dcb90:	0a000094 	beq	102dcde8 <Connect_Azure_IoT+0x278>
		return ret;

	// SSL parameters need to be configured once before first connection attempt
	if(FLAG.SSL_CONFIGURED == FALSE)
102dcb94:	e5d43016 	ldrb	r3, [r4, #22]
102dcb98:	e3530000 	cmp	r3, #0
102dcb9c:	0a00007f 	beq	102dcda0 <Connect_Azure_IoT+0x230>
	if(FLAG.SSL_CONFIGURED == FALSE)
		return ret;

	//Open SSL session
	//Check if autoprovisioning is complete or not..
	if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE) // Auto provisioning is not done so do it in first place.
102dcba0:	e5d45017 	ldrb	r5, [r4, #23]
102dcba4:	e59f7264 	ldr	r7, [pc, #612]	; 102dce10 <Connect_Azure_IoT+0x2a0>
102dcba8:	e3550000 	cmp	r5, #0
102dcbac:	1a000042 	bne	102dccbc <Connect_Azure_IoT+0x14c>
	{
		//Close any earlier open unresponded sessions if any
		RIL_SSL_QSSLCLOSE(SSID_HOST_AZURE);
102dcbb0:	e1a00005 	mov	r0, r5

		// if Connection is closed then establish it a fresh
		if(FLAG.SSL_CONNECTION_STATE ==  FALSE)// if Connection is closed then establish it
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r<-- Open SSL connection - Azure DPS : ");
102dcbb4:	e59f9258 	ldr	r9, [pc, #600]	; 102dce14 <Connect_Azure_IoT+0x2a4>
	//Open SSL session
	//Check if autoprovisioning is complete or not..
	if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE) // Auto provisioning is not done so do it in first place.
	{
		//Close any earlier open unresponded sessions if any
		RIL_SSL_QSSLCLOSE(SSID_HOST_AZURE);
102dcbb8:	ebfffe9b 	bl	102dc62c <RIL_SSL_QSSLCLOSE>

		// if Connection is closed then establish it a fresh
		if(FLAG.SSL_CONNECTION_STATE ==  FALSE)// if Connection is closed then establish it
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r<-- Open SSL connection - Azure DPS : ");
102dcbbc:	e59fb254 	ldr	fp, [pc, #596]	; 102dce18 <Connect_Azure_IoT+0x2a8>
102dcbc0:	e3a02c02 	mov	r2, #512	; 0x200
102dcbc4:	e1a01005 	mov	r1, r5
102dcbc8:	e59f024c 	ldr	r0, [pc, #588]	; 102dce1c <Connect_Azure_IoT+0x2ac>
	//Check if autoprovisioning is complete or not..
	if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE) // Auto provisioning is not done so do it in first place.
	{
		//Close any earlier open unresponded sessions if any
		RIL_SSL_QSSLCLOSE(SSID_HOST_AZURE);
		FLAG.SSL_CONNECTION_STATE = FALSE;
102dcbcc:	e5c75010 	strb	r5, [r7, #16]

		// if Connection is closed then establish it a fresh
		if(FLAG.SSL_CONNECTION_STATE ==  FALSE)// if Connection is closed then establish it
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r<-- Open SSL connection - Azure DPS : ");
102dcbd0:	e12fff3b 	blx	fp
102dcbd4:	e5993000 	ldr	r3, [r9]
102dcbd8:	e59f1240 	ldr	r1, [pc, #576]	; 102dce20 <Connect_Azure_IoT+0x2b0>
102dcbdc:	e59f0238 	ldr	r0, [pc, #568]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcbe0:	e12fff33 	blx	r3
102dcbe4:	e59f8238 	ldr	r8, [pc, #568]	; 102dce24 <Connect_Azure_IoT+0x2b4>
102dcbe8:	e59f022c 	ldr	r0, [pc, #556]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcbec:	e12fff38 	blx	r8
102dcbf0:	e59fa230 	ldr	sl, [pc, #560]	; 102dce28 <Connect_Azure_IoT+0x2b8>
102dcbf4:	e59f1220 	ldr	r1, [pc, #544]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcbf8:	e1a02000 	mov	r2, r0
102dcbfc:	e3a0000a 	mov	r0, #10
102dcc00:	e12fff3a 	blx	sl
#endif
			Refresh_Communication_inprogress_Symbol(colGray);//colGray;colOrangeRed
102dcc04:	e59f0220 	ldr	r0, [pc, #544]	; 102dce2c <Connect_Azure_IoT+0x2bc>
102dcc08:	e59f3220 	ldr	r3, [pc, #544]	; 102dce30 <Connect_Azure_IoT+0x2c0>
102dcc0c:	e12fff33 	blx	r3

			ret = RIL_SSL_QSSLOPEN(AZURE_DPS_HOST, AZURE_DPS_HOST_PORT, SSID_HOST_AZURE, CID_HOST_AZURE, CONNECT_MODE_TRANSPERENT);
102dcc10:	e59f121c 	ldr	r1, [pc, #540]	; 102dce34 <Connect_Azure_IoT+0x2c4>
102dcc14:	e1a02005 	mov	r2, r5
102dcc18:	e58d5000 	str	r5, [sp]
102dcc1c:	e59f0214 	ldr	r0, [pc, #532]	; 102dce38 <Connect_Azure_IoT+0x2c8>
102dcc20:	e1a03005 	mov	r3, r5
102dcc24:	ebfffddc 	bl	102dc39c <RIL_SSL_QSSLOPEN>
			FLAG.SSL_CONNECTION_STATE = (ret == RIL_AT_SUCCESS) ? TRUE : FALSE ;
#ifdef DEBUG_MSG
			if(ret == RIL_AT_SUCCESS)
			{
				APP_DEBUG("Success-->\n\r");
102dcc28:	e3a02c02 	mov	r2, #512	; 0x200
			APP_DEBUG("\n\r<-- Open SSL connection - Azure DPS : ");
#endif
			Refresh_Communication_inprogress_Symbol(colGray);//colGray;colOrangeRed

			ret = RIL_SSL_QSSLOPEN(AZURE_DPS_HOST, AZURE_DPS_HOST_PORT, SSID_HOST_AZURE, CID_HOST_AZURE, CONNECT_MODE_TRANSPERENT);
			FLAG.SSL_CONNECTION_STATE = (ret == RIL_AT_SUCCESS) ? TRUE : FALSE ;
102dcc2c:	e2701001 	rsbs	r1, r0, #1
102dcc30:	33a01000 	movcc	r1, #0
#ifdef DEBUG_MSG
			if(ret == RIL_AT_SUCCESS)
102dcc34:	e3510000 	cmp	r1, #0
			APP_DEBUG("\n\r<-- Open SSL connection - Azure DPS : ");
#endif
			Refresh_Communication_inprogress_Symbol(colGray);//colGray;colOrangeRed

			ret = RIL_SSL_QSSLOPEN(AZURE_DPS_HOST, AZURE_DPS_HOST_PORT, SSID_HOST_AZURE, CID_HOST_AZURE, CONNECT_MODE_TRANSPERENT);
			FLAG.SSL_CONNECTION_STATE = (ret == RIL_AT_SUCCESS) ? TRUE : FALSE ;
102dcc38:	e1a06000 	mov	r6, r0
102dcc3c:	e5c71010 	strb	r1, [r7, #16]
#ifdef DEBUG_MSG
			if(ret == RIL_AT_SUCCESS)
102dcc40:	1a00005e 	bne	102dcdc0 <Connect_Azure_IoT+0x250>
			{
				APP_DEBUG("Success-->\n\r");
			}	
			else
			{	
				APP_DEBUG("Fail-->\n\r");
102dcc44:	e59f01d0 	ldr	r0, [pc, #464]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcc48:	e12fff3b 	blx	fp
102dcc4c:	e59f11e8 	ldr	r1, [pc, #488]	; 102dce3c <Connect_Azure_IoT+0x2cc>
102dcc50:	e5993000 	ldr	r3, [r9]
102dcc54:	e59f01c0 	ldr	r0, [pc, #448]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcc58:	e12fff33 	blx	r3
102dcc5c:	e59f01b8 	ldr	r0, [pc, #440]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcc60:	e12fff38 	blx	r8
102dcc64:	e59f11b0 	ldr	r1, [pc, #432]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcc68:	e1a02000 	mov	r2, r0
102dcc6c:	e3a0000a 	mov	r0, #10
102dcc70:	e12fff3a 	blx	sl
			}	
#endif
		}
		//When Session is established.. send the REST message
		if(FLAG.SSL_CONNECTION_STATE == TRUE)
102dcc74:	e5d43010 	ldrb	r3, [r4, #16]
102dcc78:	e59f2190 	ldr	r2, [pc, #400]	; 102dce10 <Connect_Azure_IoT+0x2a0>
102dcc7c:	e3530001 	cmp	r3, #1
102dcc80:	1a00004b 	bne	102dcdb4 <Connect_Azure_IoT+0x244>
		{
#ifdef SECURE_SOCKET
			APP_DEBUG("\n\r<-- Send REST message to Azure DPS to register device first time -->\r\n");
#endif
			if((FLAG.DEVICE_NOT_REGISTERED == TRUE) // If device is not yet registered then it need to be registered first
102dcc84:	e5d2301a 	ldrb	r3, [r2, #26]
102dcc88:	e3530001 	cmp	r3, #1
102dcc8c:	0a000057 	beq	102dcdf0 <Connect_Azure_IoT+0x280>
				||(FLAG.DEVICE_UNAUTHORISED == TRUE))// Devices when deleted fron IoT Hub might show unregistered.. so let them also process through DPS connect
102dcc90:	e5d2301b 	ldrb	r3, [r2, #27]
102dcc94:	e3530001 	cmp	r3, #1
102dcc98:	0a000054 	beq	102dcdf0 <Connect_Azure_IoT+0x280>
			else //Device is already registered then just get the IoT Hub configuration information
			{
#ifdef SECURE_SOCKET
				APP_DEBUG("\n\r<-- Send REST message to Azure DPS to get IoT Hub configuration of a registered device -->\r\n");
#endif
				ret = RIL_SSL_QSSLSEND(SSID_HOST_AZURE,  REST_MESSAGE_POST, Ql_strlen(REST_MESSAGE_POST));
102dcc9c:	e59f019c 	ldr	r0, [pc, #412]	; 102dce40 <Connect_Azure_IoT+0x2d0>
102dcca0:	e12fff38 	blx	r8
102dcca4:	e59f1194 	ldr	r1, [pc, #404]	; 102dce40 <Connect_Azure_IoT+0x2d0>
102dcca8:	e1a02000 	mov	r2, r0
102dccac:	e3a00000 	mov	r0, #0
#endif
			FLAG.SSL_CONNECTION_STATE = (ret == RIL_AT_SUCCESS) ? TRUE : FALSE ;
		}
	}
	return ret;
}
102dccb0:	e28dd00c 	add	sp, sp, #12
102dccb4:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
			else //Device is already registered then just get the IoT Hub configuration information
			{
#ifdef SECURE_SOCKET
				APP_DEBUG("\n\r<-- Send REST message to Azure DPS to get IoT Hub configuration of a registered device -->\r\n");
#endif
				ret = RIL_SSL_QSSLSEND(SSID_HOST_AZURE,  REST_MESSAGE_POST, Ql_strlen(REST_MESSAGE_POST));
102dccb8:	eafffdef 	b	102dc47c <RIL_SSL_QSSLSEND>
	}
	else
	{
		//Close any earlier open sessions if any
		RIL_SSL_QSSLCLOSE(SSID_HOST_AZURE);
		FLAG.SSL_CONNECTION_STATE = FALSE;
102dccbc:	e3a05000 	mov	r5, #0
		}
	}
	else
	{
		//Close any earlier open sessions if any
		RIL_SSL_QSSLCLOSE(SSID_HOST_AZURE);
102dccc0:	e1a00005 	mov	r0, r5

		// if Connection is closed then establish it a fresh
		if(FLAG.SSL_CONNECTION_STATE ==  FALSE)
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r<-- Open SSL connection - Azure IoT Hub : ");
102dccc4:	e59fa148 	ldr	sl, [pc, #328]	; 102dce14 <Connect_Azure_IoT+0x2a4>
		}
	}
	else
	{
		//Close any earlier open sessions if any
		RIL_SSL_QSSLCLOSE(SSID_HOST_AZURE);
102dccc8:	ebfffe57 	bl	102dc62c <RIL_SSL_QSSLCLOSE>

		// if Connection is closed then establish it a fresh
		if(FLAG.SSL_CONNECTION_STATE ==  FALSE)
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r<-- Open SSL connection - Azure IoT Hub : ");
102dcccc:	e59f9144 	ldr	r9, [pc, #324]	; 102dce18 <Connect_Azure_IoT+0x2a8>
102dccd0:	e3a02c02 	mov	r2, #512	; 0x200
102dccd4:	e1a01005 	mov	r1, r5
102dccd8:	e59f013c 	ldr	r0, [pc, #316]	; 102dce1c <Connect_Azure_IoT+0x2ac>
	}
	else
	{
		//Close any earlier open sessions if any
		RIL_SSL_QSSLCLOSE(SSID_HOST_AZURE);
		FLAG.SSL_CONNECTION_STATE = FALSE;
102dccdc:	e5c75010 	strb	r5, [r7, #16]

		// if Connection is closed then establish it a fresh
		if(FLAG.SSL_CONNECTION_STATE ==  FALSE)
		{
#ifdef DEBUG_MSG
			APP_DEBUG("\n\r<-- Open SSL connection - Azure IoT Hub : ");
102dcce0:	e12fff39 	blx	r9
102dcce4:	e59a3000 	ldr	r3, [sl]
102dcce8:	e59f1154 	ldr	r1, [pc, #340]	; 102dce44 <Connect_Azure_IoT+0x2d4>
102dccec:	e59f0128 	ldr	r0, [pc, #296]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dccf0:	e12fff33 	blx	r3
102dccf4:	e59f8128 	ldr	r8, [pc, #296]	; 102dce24 <Connect_Azure_IoT+0x2b4>
102dccf8:	e59f011c 	ldr	r0, [pc, #284]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dccfc:	e12fff38 	blx	r8
102dcd00:	e59f7120 	ldr	r7, [pc, #288]	; 102dce28 <Connect_Azure_IoT+0x2b8>
102dcd04:	e59f1110 	ldr	r1, [pc, #272]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcd08:	e1a02000 	mov	r2, r0
102dcd0c:	e3a0000a 	mov	r0, #10
102dcd10:	e12fff37 	blx	r7
#endif
			//Draw Network not connected symbol to start
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
102dcd14:	e3a02002 	mov	r2, #2
102dcd18:	e1a03002 	mov	r3, r2
102dcd1c:	e59f1124 	ldr	r1, [pc, #292]	; 102dce48 <Connect_Azure_IoT+0x2d8>
102dcd20:	e59fc124 	ldr	ip, [pc, #292]	; 102dce4c <Connect_Azure_IoT+0x2dc>
102dcd24:	e3a00003 	mov	r0, #3
102dcd28:	e12fff3c 	blx	ip
			Refresh_Communication_inprogress_Symbol(colOrangeRed);
102dcd2c:	e59f011c 	ldr	r0, [pc, #284]	; 102dce50 <Connect_Azure_IoT+0x2e0>
102dcd30:	e59f30f8 	ldr	r3, [pc, #248]	; 102dce30 <Connect_Azure_IoT+0x2c0>
102dcd34:	e12fff33 	blx	r3
			ret = RIL_SSL_QSSLOPEN(AZURE_assigned_IoT_Hub, AZURE_IOTHUB_HOST_PORT, SSID_HOST_AZURE, CID_HOST_AZURE, CONNECT_MODE_TRANSPERENT);
102dcd38:	e1a02005 	mov	r2, r5
102dcd3c:	e58d5000 	str	r5, [sp]
102dcd40:	e59f010c 	ldr	r0, [pc, #268]	; 102dce54 <Connect_Azure_IoT+0x2e4>
102dcd44:	e59f110c 	ldr	r1, [pc, #268]	; 102dce58 <Connect_Azure_IoT+0x2e8>
102dcd48:	e1a03005 	mov	r3, r5
102dcd4c:	ebfffd92 	bl	102dc39c <RIL_SSL_QSSLOPEN>
#ifdef DEBUG_MSG
			if(ret == RIL_AT_SUCCESS)
			{
				APP_DEBUG("Success-->\n\r");
102dcd50:	e3a02c02 	mov	r2, #512	; 0x200
			//Draw Network not connected symbol to start
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_CLOUD_CON_OFF_SYMBOL);
			Refresh_Communication_inprogress_Symbol(colOrangeRed);
			ret = RIL_SSL_QSSLOPEN(AZURE_assigned_IoT_Hub, AZURE_IOTHUB_HOST_PORT, SSID_HOST_AZURE, CID_HOST_AZURE, CONNECT_MODE_TRANSPERENT);
#ifdef DEBUG_MSG
			if(ret == RIL_AT_SUCCESS)
102dcd54:	e2506000 	subs	r6, r0, #0
102dcd58:	0a00001d 	beq	102dcdd4 <Connect_Azure_IoT+0x264>
			{
				APP_DEBUG("Success-->\n\r");
			}	
			else
			{	
				APP_DEBUG("Fail-->\n\r");
102dcd5c:	e1a01005 	mov	r1, r5
102dcd60:	e59f00b4 	ldr	r0, [pc, #180]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcd64:	e12fff39 	blx	r9
102dcd68:	e59f10cc 	ldr	r1, [pc, #204]	; 102dce3c <Connect_Azure_IoT+0x2cc>
102dcd6c:	e59a3000 	ldr	r3, [sl]
102dcd70:	e59f00a4 	ldr	r0, [pc, #164]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcd74:	e12fff33 	blx	r3
102dcd78:	e59f009c 	ldr	r0, [pc, #156]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcd7c:	e12fff38 	blx	r8
102dcd80:	e59f1094 	ldr	r1, [pc, #148]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcd84:	e1a02000 	mov	r2, r0
102dcd88:	e3a0000a 	mov	r0, #10
102dcd8c:	e12fff37 	blx	r7
			}
#endif
			FLAG.SSL_CONNECTION_STATE = (ret == RIL_AT_SUCCESS) ? TRUE : FALSE ;
102dcd90:	e2763001 	rsbs	r3, r6, #1
102dcd94:	33a03000 	movcc	r3, #0
102dcd98:	e5c43010 	strb	r3, [r4, #16]
102dcd9c:	ea000004 	b	102dcdb4 <Connect_Azure_IoT+0x244>
	if(FLAG.SSL_X509_CERTPRESENT == FALSE)
		return ret;

	// SSL parameters need to be configured once before first connection attempt
	if(FLAG.SSL_CONFIGURED == FALSE)
		ret = RIL_SSL_QSSLCFG();
102dcda0:	ebfffcdc 	bl	102dc118 <RIL_SSL_QSSLCFG>

	//The flag will become true when successful, Check if SSL configutation is complete or not
	if(FLAG.SSL_CONFIGURED == FALSE)
102dcda4:	e5d43016 	ldrb	r3, [r4, #22]
102dcda8:	e3530000 	cmp	r3, #0
	if(FLAG.SSL_X509_CERTPRESENT == FALSE)
		return ret;

	// SSL parameters need to be configured once before first connection attempt
	if(FLAG.SSL_CONFIGURED == FALSE)
		ret = RIL_SSL_QSSLCFG();
102dcdac:	e1a06000 	mov	r6, r0

	//The flag will become true when successful, Check if SSL configutation is complete or not
	if(FLAG.SSL_CONFIGURED == FALSE)
102dcdb0:	1affff7a 	bne	102dcba0 <Connect_Azure_IoT+0x30>
#endif
			FLAG.SSL_CONNECTION_STATE = (ret == RIL_AT_SUCCESS) ? TRUE : FALSE ;
		}
	}
	return ret;
}
102dcdb4:	e1a00006 	mov	r0, r6
102dcdb8:	e28dd00c 	add	sp, sp, #12
102dcdbc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ret = RIL_SSL_QSSLOPEN(AZURE_DPS_HOST, AZURE_DPS_HOST_PORT, SSID_HOST_AZURE, CID_HOST_AZURE, CONNECT_MODE_TRANSPERENT);
			FLAG.SSL_CONNECTION_STATE = (ret == RIL_AT_SUCCESS) ? TRUE : FALSE ;
#ifdef DEBUG_MSG
			if(ret == RIL_AT_SUCCESS)
			{
				APP_DEBUG("Success-->\n\r");
102dcdc0:	e1a01005 	mov	r1, r5
102dcdc4:	e59f0050 	ldr	r0, [pc, #80]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcdc8:	e12fff3b 	blx	fp
102dcdcc:	e59f1088 	ldr	r1, [pc, #136]	; 102dce5c <Connect_Azure_IoT+0x2ec>
102dcdd0:	eaffff9e 	b	102dcc50 <Connect_Azure_IoT+0xe0>
			Refresh_Communication_inprogress_Symbol(colOrangeRed);
			ret = RIL_SSL_QSSLOPEN(AZURE_assigned_IoT_Hub, AZURE_IOTHUB_HOST_PORT, SSID_HOST_AZURE, CID_HOST_AZURE, CONNECT_MODE_TRANSPERENT);
#ifdef DEBUG_MSG
			if(ret == RIL_AT_SUCCESS)
			{
				APP_DEBUG("Success-->\n\r");
102dcdd4:	e1a01006 	mov	r1, r6
102dcdd8:	e59f003c 	ldr	r0, [pc, #60]	; 102dce1c <Connect_Azure_IoT+0x2ac>
102dcddc:	e12fff39 	blx	r9
102dcde0:	e59f1074 	ldr	r1, [pc, #116]	; 102dce5c <Connect_Azure_IoT+0x2ec>
102dcde4:	eaffffe0 	b	102dcd6c <Connect_Azure_IoT+0x1fc>
s32 Connect_Azure_IoT(void)
{
	s32 ret = RIL_AT_FAILED;

	if(FLAG.GPRS_ACTIVE == FALSE ) // Do not try to connect if GPRS state is not active
		return ret;
102dcde8:	e3e06000 	mvn	r6, #0
102dcdec:	eafffff0 	b	102dcdb4 <Connect_Azure_IoT+0x244>
			APP_DEBUG("\n\r<-- Send REST message to Azure DPS to register device first time -->\r\n");
#endif
			if((FLAG.DEVICE_NOT_REGISTERED == TRUE) // If device is not yet registered then it need to be registered first
				||(FLAG.DEVICE_UNAUTHORISED == TRUE))// Devices when deleted fron IoT Hub might show unregistered.. so let them also process through DPS connect
			{
				ret = RIL_SSL_QSSLSEND(SSID_HOST_AZURE,  REST_MESSAGE_PUT, Ql_strlen(REST_MESSAGE_PUT));
102dcdf0:	e59f0068 	ldr	r0, [pc, #104]	; 102dce60 <Connect_Azure_IoT+0x2f0>
102dcdf4:	e12fff38 	blx	r8
102dcdf8:	e59f1060 	ldr	r1, [pc, #96]	; 102dce60 <Connect_Azure_IoT+0x2f0>
102dcdfc:	e1a02000 	mov	r2, r0
102dce00:	e3a00000 	mov	r0, #0
#endif
			FLAG.SSL_CONNECTION_STATE = (ret == RIL_AT_SUCCESS) ? TRUE : FALSE ;
		}
	}
	return ret;
}
102dce04:	e28dd00c 	add	sp, sp, #12
102dce08:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
			APP_DEBUG("\n\r<-- Send REST message to Azure DPS to register device first time -->\r\n");
#endif
			if((FLAG.DEVICE_NOT_REGISTERED == TRUE) // If device is not yet registered then it need to be registered first
				||(FLAG.DEVICE_UNAUTHORISED == TRUE))// Devices when deleted fron IoT Hub might show unregistered.. so let them also process through DPS connect
			{
				ret = RIL_SSL_QSSLSEND(SSID_HOST_AZURE,  REST_MESSAGE_PUT, Ql_strlen(REST_MESSAGE_PUT));
102dce0c:	eafffd9a 	b	102dc47c <RIL_SSL_QSSLSEND>
102dce10:	f03da5f0 	.word	0xf03da5f0
102dce14:	f03de540 	.word	0xf03de540
102dce18:	102e58f4 	.word	0x102e58f4
102dce1c:	f03d6584 	.word	0xf03d6584
102dce20:	102efe18 	.word	0x102efe18
102dce24:	102e57a4 	.word	0x102e57a4
102dce28:	102e6230 	.word	0x102e6230
102dce2c:	00007bef 	.word	0x00007bef
102dce30:	102d9bf4 	.word	0x102d9bf4
102dce34:	000001bb 	.word	0x000001bb
102dce38:	102efe44 	.word	0x102efe44
102dce3c:	102efe7c 	.word	0x102efe7c
102dce40:	f03da1c8 	.word	0xf03da1c8
102dce44:	102efe88 	.word	0x102efe88
102dce48:	000010c8 	.word	0x000010c8
102dce4c:	102e5cb4 	.word	0x102e5cb4
102dce50:	0000fa20 	.word	0x0000fa20
102dce54:	f03d5e34 	.word	0xf03d5e34
102dce58:	000022b3 	.word	0x000022b3
102dce5c:	102efe6c 	.word	0x102efe6c
102dce60:	f03da09c 	.word	0xf03da09c

102dce64 <Connect_Azure_IoT_host_socket>:
 *
 * Return  Status
 *
 *****************************************************************/
s32 Connect_Azure_IoT_host_socket(u8 host_id)
{
102dce64:	e92d4038 	push	{r3, r4, r5, lr}
	s32 ret = RIL_AT_FAILED;

	if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE)
102dce68:	e59f4054 	ldr	r4, [pc, #84]	; 102dcec4 <Connect_Azure_IoT_host_socket+0x60>
 *
 * Return  Status
 *
 *****************************************************************/
s32 Connect_Azure_IoT_host_socket(u8 host_id)
{
102dce6c:	e1a05000 	mov	r5, r0
	s32 ret = RIL_AT_FAILED;

	if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE)
102dce70:	e5d40017 	ldrb	r0, [r4, #23]
102dce74:	e3500000 	cmp	r0, #0
102dce78:	0a00000a 	beq	102dcea8 <Connect_Azure_IoT_host_socket+0x44>
	{
		//Draw Network not connected symbol to start
		Refresh_Cloud_Connectivity_Symbol(0);
	}

	switch(host_id)
102dce7c:	e3550000 	cmp	r5, #0
 * Return  Status
 *
 *****************************************************************/
s32 Connect_Azure_IoT_host_socket(u8 host_id)
{
	s32 ret = RIL_AT_FAILED;
102dce80:	13e05000 	mvnne	r5, #0
	{
		//Draw Network not connected symbol to start
		Refresh_Cloud_Connectivity_Symbol(0);
	}

	switch(host_id)
102dce84:	1a000005 	bne	102dcea0 <Connect_Azure_IoT_host_socket+0x3c>
	{
		case SSID_HOST_AZURE:
			ret = Connect_Azure_IoT(); // Connect to Azure IoT ( DPS -> Hub)
102dce88:	ebffff38 	bl	102dcb70 <Connect_Azure_IoT>
			if(ret == 0 && (FLAG.AUTOPROVISIONING_COMPLETE == TRUE)) // The above functions returned true with provisioning complete
102dce8c:	e2505000 	subs	r5, r0, #0
102dce90:	1a000002 	bne	102dcea0 <Connect_Azure_IoT_host_socket+0x3c>
102dce94:	e5d41017 	ldrb	r1, [r4, #23]
102dce98:	e3510001 	cmp	r1, #1
102dce9c:	0a000004 	beq	102dceb4 <Connect_Azure_IoT_host_socket+0x50>
			}
		break;
	}

	return ret;
}
102dcea0:	e1a00005 	mov	r0, r5
102dcea4:	e8bd8038 	pop	{r3, r4, r5, pc}
	s32 ret = RIL_AT_FAILED;

	if(FLAG.AUTOPROVISIONING_COMPLETE == FALSE)
	{
		//Draw Network not connected symbol to start
		Refresh_Cloud_Connectivity_Symbol(0);
102dcea8:	e59f3018 	ldr	r3, [pc, #24]	; 102dcec8 <Connect_Azure_IoT_host_socket+0x64>
102dceac:	e12fff33 	blx	r3
102dceb0:	eafffff1 	b	102dce7c <Connect_Azure_IoT_host_socket+0x18>
			if(ret == 0 && (FLAG.AUTOPROVISIONING_COMPLETE == TRUE)) // The above functions returned true with provisioning complete
			{
#ifdef SECURE_SOCKET
				APP_DEBUG("<-- Sending MQTT Connection req : AZURE IOT HUB -->\r\n");
#endif
				MQTT_Send_CONN_DISCONN_Request(SSID_HOST_AZURE, MQTT_ON);
102dceb4:	e59f3010 	ldr	r3, [pc, #16]	; 102dcecc <Connect_Azure_IoT_host_socket+0x68>
102dceb8:	e12fff33 	blx	r3
			}
		break;
	}

	return ret;
}
102dcebc:	e1a00005 	mov	r0, r5
102dcec0:	e8bd8038 	pop	{r3, r4, r5, pc}
102dcec4:	f03da5f0 	.word	0xf03da5f0
102dcec8:	102d9b48 	.word	0x102d9b48
102dcecc:	102ce534 	.word	0x102ce534

102dced0 <SSL_Send_Data>:
	return RIL_ATRSP_CONTINUE; //continue to wait

}

s32 SSL_Send_Data(u8 ssid, char * payload, s32 payloa_len)
{
102dced0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s32 ret = 0;
	s32 data_send_len = 0;
	s32 offset = 0;
102dced4:	e3a06000 	mov	r6, #0
	return RIL_ATRSP_CONTINUE; //continue to wait

}

s32 SSL_Send_Data(u8 ssid, char * payload, s32 payloa_len)
{
102dced8:	e24dd00c 	sub	sp, sp, #12
		APP_DEBUG("<-- Reconnecting Socket..- ");
		if(ssid == SSID_HOST_AZURE)
			APP_DEBUG("AZURE_IOT_HUB -->\r\n");

#endif
		FLAG.SSL_CONNECTION_STATE = FALSE; // Clear the flag before re-attempting the connection
102dcedc:	e59fa084 	ldr	sl, [pc, #132]	; 102dcf68 <SSL_Send_Data+0x98>
102dcee0:	e59fb084 	ldr	fp, [pc, #132]	; 102dcf6c <SSL_Send_Data+0x9c>
		offset += data_send_len;
		payloa_len = payloa_len-data_send_len;

		if(payloa_len != 0)
		{
			Ql_Sleep(1250);
102dcee4:	e59f7084 	ldr	r7, [pc, #132]	; 102dcf70 <SSL_Send_Data+0xa0>
	return RIL_ATRSP_CONTINUE; //continue to wait

}

s32 SSL_Send_Data(u8 ssid, char * payload, s32 payloa_len)
{
102dcee8:	e1a05000 	mov	r5, r0
102dceec:	e58d1004 	str	r1, [sp, #4]
102dcef0:	e1a04002 	mov	r4, r2
		APP_DEBUG("<-- Reconnecting Socket..- ");
		if(ssid == SSID_HOST_AZURE)
			APP_DEBUG("AZURE_IOT_HUB -->\r\n");

#endif
		FLAG.SSL_CONNECTION_STATE = FALSE; // Clear the flag before re-attempting the connection
102dcef4:	e1a08006 	mov	r8, r6
102dcef8:	ea00000e 	b	102dcf38 <SSL_Send_Data+0x68>
		ret = Connect_Azure_IoT_host_socket(ssid);
	}

	if(ret == 0)
		ret = RIL_SSL_QSSLSEND(ssid, ((u8 *)payload + offset) ,(u32)data_send_len);
102dcefc:	e59d3004 	ldr	r3, [sp, #4]
102dcf00:	e154000b 	cmp	r4, fp
102dcf04:	b1a09004 	movlt	r9, r4
102dcf08:	a1a0900b 	movge	r9, fp
102dcf0c:	e0831006 	add	r1, r3, r6
102dcf10:	e1a02009 	mov	r2, r9
102dcf14:	e1a00005 	mov	r0, r5
102dcf18:	ebfffd57 	bl	102dc47c <RIL_SSL_QSSLSEND>
	{
		return ret;
	}
	else
	{
		offset += data_send_len;
102dcf1c:	e0866009 	add	r6, r6, r9
	}

	if(ret == 0)
		ret = RIL_SSL_QSSLSEND(ssid, ((u8 *)payload + offset) ,(u32)data_send_len);

	if(ret != RIL_ATRSP_SUCCESS) //If send is failed return from here..
102dcf20:	e2502000 	subs	r2, r0, #0
		offset += data_send_len;
		payloa_len = payloa_len-data_send_len;

		if(payloa_len != 0)
		{
			Ql_Sleep(1250);
102dcf24:	e59f0048 	ldr	r0, [pc, #72]	; 102dcf74 <SSL_Send_Data+0xa4>
	}

	if(ret == 0)
		ret = RIL_SSL_QSSLSEND(ssid, ((u8 *)payload + offset) ,(u32)data_send_len);

	if(ret != RIL_ATRSP_SUCCESS) //If send is failed return from here..
102dcf28:	1a00000b 	bne	102dcf5c <SSL_Send_Data+0x8c>
	else
	{
		offset += data_send_len;
		payloa_len = payloa_len-data_send_len;

		if(payloa_len != 0)
102dcf2c:	e0544009 	subs	r4, r4, r9
102dcf30:	0a000009 	beq	102dcf5c <SSL_Send_Data+0x8c>
		{
			Ql_Sleep(1250);
102dcf34:	e12fff37 	blx	r7
	else{
		data_send_len = payloa_len;
	}

	//Check Server connected or not and do a reattempt to connect is found not connected
	if(SSL_SOC_CONNECTED != SSL_Check_SOC_State(ssid)) // State is not connected.. attempt to reconnect
102dcf38:	e1a00005 	mov	r0, r5
102dcf3c:	ebfffea5 	bl	102dc9d8 <SSL_Check_SOC_State>
102dcf40:	e3500002 	cmp	r0, #2
		if(ssid == SSID_HOST_AZURE)
			APP_DEBUG("AZURE_IOT_HUB -->\r\n");

#endif
		FLAG.SSL_CONNECTION_STATE = FALSE; // Clear the flag before re-attempting the connection
		ret = Connect_Azure_IoT_host_socket(ssid);
102dcf44:	e1a00005 	mov	r0, r5
	else{
		data_send_len = payloa_len;
	}

	//Check Server connected or not and do a reattempt to connect is found not connected
	if(SSL_SOC_CONNECTED != SSL_Check_SOC_State(ssid)) // State is not connected.. attempt to reconnect
102dcf48:	0affffeb 	beq	102dcefc <SSL_Send_Data+0x2c>
		APP_DEBUG("<-- Reconnecting Socket..- ");
		if(ssid == SSID_HOST_AZURE)
			APP_DEBUG("AZURE_IOT_HUB -->\r\n");

#endif
		FLAG.SSL_CONNECTION_STATE = FALSE; // Clear the flag before re-attempting the connection
102dcf4c:	e5ca8010 	strb	r8, [sl, #16]
		ret = Connect_Azure_IoT_host_socket(ssid);
102dcf50:	ebffffc3 	bl	102dce64 <Connect_Azure_IoT_host_socket>
	}

	if(ret == 0)
102dcf54:	e2502000 	subs	r2, r0, #0
102dcf58:	0affffe7 	beq	102dcefc <SSL_Send_Data+0x2c>
			Ql_Sleep(1250);
			goto SEND_REMAIN;
		}
	}
	return ret;
}
102dcf5c:	e1a00002 	mov	r0, r2
102dcf60:	e28dd00c 	add	sp, sp, #12
102dcf64:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
102dcf68:	f03da5f0 	.word	0xf03da5f0
102dcf6c:	000005b4 	.word	0x000005b4
102dcf70:	102e5b10 	.word	0x102e5b10
102dcf74:	000004e2 	.word	0x000004e2

102dcf78 <TCP_Socket_Read_Data_SSL>:
	return ret;
}


s32 TCP_Socket_Read_Data_SSL (u8 *buff, s32 len)
{
102dcf78:	e92d4038 	push	{r3, r4, r5, lr}
	Ql_memset((void*)buff, FALSE, sizeof(buff));
102dcf7c:	e3a02004 	mov	r2, #4
	return ret;
}


s32 TCP_Socket_Read_Data_SSL (u8 *buff, s32 len)
{
102dcf80:	e1a04001 	mov	r4, r1
	Ql_memset((void*)buff, FALSE, sizeof(buff));
102dcf84:	e59f305c 	ldr	r3, [pc, #92]	; 102dcfe8 <TCP_Socket_Read_Data_SSL+0x70>
102dcf88:	e3a01000 	mov	r1, #0
	return ret;
}


s32 TCP_Socket_Read_Data_SSL (u8 *buff, s32 len)
{
102dcf8c:	e1a05000 	mov	r5, r0
	Ql_memset((void*)buff, FALSE, sizeof(buff));
102dcf90:	e12fff33 	blx	r3

	g_recvd_data_last_read_pos = (g_recvd_data_last_read_pos+len)-1;
102dcf94:	e59fc050 	ldr	ip, [pc, #80]	; 102dcfec <TCP_Socket_Read_Data_SSL+0x74>

	for(int i=0; i<len; i++)
102dcf98:	e3540000 	cmp	r4, #0

s32 TCP_Socket_Read_Data_SSL (u8 *buff, s32 len)
{
	Ql_memset((void*)buff, FALSE, sizeof(buff));

	g_recvd_data_last_read_pos = (g_recvd_data_last_read_pos+len)-1;
102dcf9c:	e59c2000 	ldr	r2, [ip]
102dcfa0:	e0842002 	add	r2, r4, r2
102dcfa4:	e2422001 	sub	r2, r2, #1
102dcfa8:	e58c2000 	str	r2, [ip]

	for(int i=0; i<len; i++)
102dcfac:	da00000b 	ble	102dcfe0 <TCP_Socket_Read_Data_SSL+0x68>
102dcfb0:	e59f1038 	ldr	r1, [pc, #56]	; 102dcff0 <TCP_Socket_Read_Data_SSL+0x78>
102dcfb4:	e3a03000 	mov	r3, #0
	{
		buff[i] = g_buf_recvd_data[g_recvd_data_last_read_pos+i];
102dcfb8:	e0812002 	add	r2, r1, r2
102dcfbc:	e0822003 	add	r2, r2, r3
102dcfc0:	e5d22208 	ldrb	r2, [r2, #520]	; 0x208
102dcfc4:	e7c52003 	strb	r2, [r5, r3]
		g_recvd_data_last_read_pos++;
102dcfc8:	e59c2000 	ldr	r2, [ip]
{
	Ql_memset((void*)buff, FALSE, sizeof(buff));

	g_recvd_data_last_read_pos = (g_recvd_data_last_read_pos+len)-1;

	for(int i=0; i<len; i++)
102dcfcc:	e2833001 	add	r3, r3, #1
	{
		buff[i] = g_buf_recvd_data[g_recvd_data_last_read_pos+i];
		g_recvd_data_last_read_pos++;
102dcfd0:	e2822001 	add	r2, r2, #1
{
	Ql_memset((void*)buff, FALSE, sizeof(buff));

	g_recvd_data_last_read_pos = (g_recvd_data_last_read_pos+len)-1;

	for(int i=0; i<len; i++)
102dcfd4:	e1530004 	cmp	r3, r4
	{
		buff[i] = g_buf_recvd_data[g_recvd_data_last_read_pos+i];
		g_recvd_data_last_read_pos++;
102dcfd8:	e58c2000 	str	r2, [ip]
{
	Ql_memset((void*)buff, FALSE, sizeof(buff));

	g_recvd_data_last_read_pos = (g_recvd_data_last_read_pos+len)-1;

	for(int i=0; i<len; i++)
102dcfdc:	1afffff5 	bne	102dcfb8 <TCP_Socket_Read_Data_SSL+0x40>
		g_recvd_data_last_read_pos++;
	}


	return len;
}
102dcfe0:	e1a00004 	mov	r0, r4
102dcfe4:	e8bd8038 	pop	{r3, r4, r5, pc}
102dcfe8:	102e58f4 	.word	0x102e58f4
102dcfec:	f03d5bd0 	.word	0xf03d5bd0
102dcff0:	f03d6584 	.word	0xf03d6584

102dcff4 <Callback_OnIPCTimer>:
 *           void
 * Return:
 *           void
 *****************************************************************/
void Callback_OnIPCTimer(u32 timerId, void* param)
{
102dcff4:	e92d4038 	push	{r3, r4, r5, lr}
	// Increment differnet periodic counters
	IPC_Sequence_Counter++;
102dcff8:	e59f4098 	ldr	r4, [pc, #152]	; 102dd098 <Callback_OnIPCTimer+0xa4>
 *           void
 * Return:
 *           void
 *****************************************************************/
void Callback_OnIPCTimer(u32 timerId, void* param)
{
102dcffc:	e1a05000 	mov	r5, r0
	// Increment differnet periodic counters
	IPC_Sequence_Counter++;
102dd000:	e1d430b0 	ldrh	r3, [r4]
102dd004:	e1a00004 	mov	r0, r4
102dd008:	e2833001 	add	r3, r3, #1

	//#ifdef IPC_DEBUG_MSG
	APP_DEBUG("\r\n<-- IPC Transmit Event : %d ",IPC_Sequence_Counter);
102dd00c:	e3a01000 	mov	r1, #0
102dd010:	e3a02c02 	mov	r2, #512	; 0x200
 *           void
 *****************************************************************/
void Callback_OnIPCTimer(u32 timerId, void* param)
{
	// Increment differnet periodic counters
	IPC_Sequence_Counter++;
102dd014:	e0c030b4 	strh	r3, [r0], #4

	//#ifdef IPC_DEBUG_MSG
	APP_DEBUG("\r\n<-- IPC Transmit Event : %d ",IPC_Sequence_Counter);
102dd018:	e59f307c 	ldr	r3, [pc, #124]	; 102dd09c <Callback_OnIPCTimer+0xa8>
102dd01c:	e12fff33 	blx	r3
102dd020:	e59f3078 	ldr	r3, [pc, #120]	; 102dd0a0 <Callback_OnIPCTimer+0xac>
102dd024:	e1a00004 	mov	r0, r4
102dd028:	e59f1074 	ldr	r1, [pc, #116]	; 102dd0a4 <Callback_OnIPCTimer+0xb0>
102dd02c:	e0d020b4 	ldrh	r2, [r0], #4
102dd030:	e5933000 	ldr	r3, [r3]
102dd034:	e12fff33 	blx	r3
102dd038:	e59f3068 	ldr	r3, [pc, #104]	; 102dd0a8 <Callback_OnIPCTimer+0xb4>
102dd03c:	e2840004 	add	r0, r4, #4
102dd040:	e12fff33 	blx	r3
102dd044:	e59f3060 	ldr	r3, [pc, #96]	; 102dd0ac <Callback_OnIPCTimer+0xb8>
102dd048:	e2841004 	add	r1, r4, #4
102dd04c:	e1a02000 	mov	r2, r0
102dd050:	e3a0000a 	mov	r0, #10
102dd054:	e12fff33 	blx	r3
	//#endif
	// Below are periodic IPC communication schedules..
	if(timerId == Timer_SendTimeOut)
102dd058:	e59f3050 	ldr	r3, [pc, #80]	; 102dd0b0 <Callback_OnIPCTimer+0xbc>
102dd05c:	e5933000 	ldr	r3, [r3]
102dd060:	e1550003 	cmp	r5, r3
102dd064:	0a000005 	beq	102dd080 <Callback_OnIPCTimer+0x8c>
		}
		if(IPC_Response_missing_count)
			IPC_Response_missing_count--; // Decrement the IPC response counter
	}
	// End of else if(IPC_Response_missing_count)
	if(IPC_Sequence_Counter == 3600) // Reset the counter every 1 hour .. note that this IPC periodic loop is 1 Sec execute
102dd068:	e1d430b0 	ldrh	r3, [r4]
102dd06c:	e3530ee1 	cmp	r3, #3600	; 0xe10
		IPC_Sequence_Counter = 0;
102dd070:	059f3020 	ldreq	r3, [pc, #32]	; 102dd098 <Callback_OnIPCTimer+0xa4>
102dd074:	03a02000 	moveq	r2, #0
102dd078:	01c320b0 	strheq	r2, [r3]
102dd07c:	e8bd8038 	pop	{r3, r4, r5, pc}
		// Below are periodic events are scheduled..
		if(IPC_Sequence_Counter && ((IPC_Sequence_Counter % 60)== 0)) // Execute one minute sequences
		{
			//SMS_SendSMS_Text("+918796608727","13",0,"This is Quectel M66",20,NULL);
		}
		if(IPC_Response_missing_count)
102dd080:	e59f302c 	ldr	r3, [pc, #44]	; 102dd0b4 <Callback_OnIPCTimer+0xc0>
102dd084:	e5d32000 	ldrb	r2, [r3]
102dd088:	e3520000 	cmp	r2, #0
			IPC_Response_missing_count--; // Decrement the IPC response counter
102dd08c:	12422001 	subne	r2, r2, #1
102dd090:	15c32000 	strbne	r2, [r3]
102dd094:	eafffff3 	b	102dd068 <Callback_OnIPCTimer+0x74>
102dd098:	f03da2f4 	.word	0xf03da2f4
102dd09c:	102e58f4 	.word	0x102e58f4
102dd0a0:	f03de540 	.word	0xf03de540
102dd0a4:	102efeb8 	.word	0x102efeb8
102dd0a8:	102e57a4 	.word	0x102e57a4
102dd0ac:	102e6230 	.word	0x102e6230
102dd0b0:	f03d2028 	.word	0xf03d2028
102dd0b4:	f03d4680 	.word	0xf03d4680

102dd0b8 <format_water_balance_buffer>:
 * Return: void
 *
 *****************************************************************/
void format_water_balance_buffer(unsigned int water_bal, char *c)
{
	char local_buff[7] = "       "; // Blank string
102dd0b8:	e59f3168 	ldr	r3, [pc, #360]	; 102dd228 <format_water_balance_buffer+0x170>
 *
 * Return: void
 *
 *****************************************************************/
void format_water_balance_buffer(unsigned int water_bal, char *c)
{
102dd0bc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102dd0c0:	e1a02000 	mov	r2, r0
102dd0c4:	e1a04001 	mov	r4, r1
	char local_buff[7] = "       "; // Blank string
102dd0c8:	e8930003 	ldm	r3, {r0, r1}
 *
 * Return: void
 *
 *****************************************************************/
void format_water_balance_buffer(unsigned int water_bal, char *c)
{
102dd0cc:	e24dd00c 	sub	sp, sp, #12
	char local_buff[7] = "       "; // Blank string
102dd0d0:	e1a03821 	lsr	r3, r1, #16
102dd0d4:	e5cd3006 	strb	r3, [sp, #6]
	unsigned char string_length, temp;
	//      Ql_itoa(water_bal, local_buff, 10);
	Ql_sprintf((char *)&local_buff,"%d",water_bal);
102dd0d8:	e59f314c 	ldr	r3, [pc, #332]	; 102dd22c <format_water_balance_buffer+0x174>
 * Return: void
 *
 *****************************************************************/
void format_water_balance_buffer(unsigned int water_bal, char *c)
{
	char local_buff[7] = "       "; // Blank string
102dd0dc:	e58d0000 	str	r0, [sp]
102dd0e0:	e1cd10b4 	strh	r1, [sp, #4]
	unsigned char string_length, temp;
	//      Ql_itoa(water_bal, local_buff, 10);
	Ql_sprintf((char *)&local_buff,"%d",water_bal);
102dd0e4:	e5933000 	ldr	r3, [r3]
102dd0e8:	e59f1140 	ldr	r1, [pc, #320]	; 102dd230 <format_water_balance_buffer+0x178>
102dd0ec:	e1a0000d 	mov	r0, sp
102dd0f0:	e12fff33 	blx	r3

	string_length = strlen(local_buff);
102dd0f4:	e1a0000d 	mov	r0, sp
102dd0f8:	e59f3134 	ldr	r3, [pc, #308]	; 102dd234 <format_water_balance_buffer+0x17c>
102dd0fc:	e12fff33 	blx	r3
	for(temp = 0; temp<string_length;temp++)
102dd100:	e21000ff 	ands	r0, r0, #255	; 0xff
102dd104:	0a00002b 	beq	102dd1b8 <format_water_balance_buffer+0x100>
102dd108:	e2402001 	sub	r2, r0, #1
102dd10c:	e3a03000 	mov	r3, #0
					c[temp+4] = 'C';
				c[temp+5] = '\0';
			}
			else
			{	c[temp] = '.';
			c[temp+1] = local_buff[temp];
102dd110:	e28db008 	add	fp, sp, #8
			c[temp+2] = ' ';
			if(Water_Unit_index_get == 0)
102dd114:	e59fa11c 	ldr	sl, [pc, #284]	; 102dd238 <format_water_balance_buffer+0x180>
				else if(Water_Unit_index_get == 2)
					c[temp+4] = 'C';
				c[temp+5] = '\0';
			}
			else
			{	c[temp] = '.';
102dd118:	e3a0802e 	mov	r8, #46	; 0x2e
			c[temp+1] = local_buff[temp];
102dd11c:	e0841002 	add	r1, r4, r2
102dd120:	e08b7002 	add	r7, fp, r2
			c[temp+2] = ' ';
102dd124:	e3a06020 	mov	r6, #32
				c[temp+3] = 'L';
			else if(Water_Unit_index_get == 1)
				c[temp+3] = 'G';
			else if(Water_Unit_index_get == 2)
				c[temp+3] = 'C';
			c[temp+4] = '\0';
102dd128:	e1a05003 	mov	r5, r3
			else
			{	c[temp] = '.';
			c[temp+1] = local_buff[temp];
			c[temp+2] = ' ';
			if(Water_Unit_index_get == 0)
				c[temp+3] = 'L';
102dd12c:	e3a0904c 	mov	r9, #76	; 0x4c
102dd130:	ea000007 	b	102dd154 <format_water_balance_buffer+0x9c>
			c[temp+4] = '\0';
			}
			temp = string_length; //Just to go out of for loop
		}
		else
			c[temp] = local_buff[temp];
102dd134:	e28db008 	add	fp, sp, #8
102dd138:	e08bc003 	add	ip, fp, r3
102dd13c:	e55cc008 	ldrb	ip, [ip, #-8]
102dd140:	e7c4c003 	strb	ip, [r4, r3]
	unsigned char string_length, temp;
	//      Ql_itoa(water_bal, local_buff, 10);
	Ql_sprintf((char *)&local_buff,"%d",water_bal);

	string_length = strlen(local_buff);
	for(temp = 0; temp<string_length;temp++)
102dd144:	e2833001 	add	r3, r3, #1
102dd148:	e20330ff 	and	r3, r3, #255	; 0xff
102dd14c:	e1500003 	cmp	r0, r3
102dd150:	9a000018 	bls	102dd1b8 <format_water_balance_buffer+0x100>
	{
		if(temp == (string_length-1))//last char in the string then insert a decimal point
102dd154:	e1530002 	cmp	r3, r2
102dd158:	1afffff5 	bne	102dd134 <format_water_balance_buffer+0x7c>
		{
			if(string_length == 1)// for values less than 1 add a leading zero before decimal point
102dd15c:	e3500001 	cmp	r0, #1
102dd160:	0a000016 	beq	102dd1c0 <format_water_balance_buffer+0x108>
					c[temp+4] = 'C';
				c[temp+5] = '\0';
			}
			else
			{	c[temp] = '.';
			c[temp+1] = local_buff[temp];
102dd164:	e5573008 	ldrb	r3, [r7, #-8]
				else if(Water_Unit_index_get == 2)
					c[temp+4] = 'C';
				c[temp+5] = '\0';
			}
			else
			{	c[temp] = '.';
102dd168:	e7c48002 	strb	r8, [r4, r2]
			c[temp+1] = local_buff[temp];
102dd16c:	e5c13001 	strb	r3, [r1, #1]
			c[temp+2] = ' ';
102dd170:	e5c16002 	strb	r6, [r1, #2]
			if(Water_Unit_index_get == 0)
102dd174:	e59a3204 	ldr	r3, [sl, #516]	; 0x204
102dd178:	e3530000 	cmp	r3, #0
				c[temp+3] = 'L';
102dd17c:	05c19003 	strbeq	r9, [r1, #3]
			}
			else
			{	c[temp] = '.';
			c[temp+1] = local_buff[temp];
			c[temp+2] = ' ';
			if(Water_Unit_index_get == 0)
102dd180:	0a000006 	beq	102dd1a0 <format_water_balance_buffer+0xe8>
				c[temp+3] = 'L';
			else if(Water_Unit_index_get == 1)
102dd184:	e3530001 	cmp	r3, #1
				c[temp+3] = 'G';
102dd188:	03a03047 	moveq	r3, #71	; 0x47
102dd18c:	05c13003 	strbeq	r3, [r1, #3]
			{	c[temp] = '.';
			c[temp+1] = local_buff[temp];
			c[temp+2] = ' ';
			if(Water_Unit_index_get == 0)
				c[temp+3] = 'L';
			else if(Water_Unit_index_get == 1)
102dd190:	0a000002 	beq	102dd1a0 <format_water_balance_buffer+0xe8>
				c[temp+3] = 'G';
			else if(Water_Unit_index_get == 2)
102dd194:	e3530002 	cmp	r3, #2
				c[temp+3] = 'C';
102dd198:	03a0b043 	moveq	fp, #67	; 0x43
102dd19c:	05c1b003 	strbeq	fp, [r1, #3]
			c[temp+4] = '\0';
102dd1a0:	e1a03000 	mov	r3, r0
	unsigned char string_length, temp;
	//      Ql_itoa(water_bal, local_buff, 10);
	Ql_sprintf((char *)&local_buff,"%d",water_bal);

	string_length = strlen(local_buff);
	for(temp = 0; temp<string_length;temp++)
102dd1a4:	e2833001 	add	r3, r3, #1
102dd1a8:	e20330ff 	and	r3, r3, #255	; 0xff
102dd1ac:	e1500003 	cmp	r0, r3
				c[temp+3] = 'L';
			else if(Water_Unit_index_get == 1)
				c[temp+3] = 'G';
			else if(Water_Unit_index_get == 2)
				c[temp+3] = 'C';
			c[temp+4] = '\0';
102dd1b0:	e5c15004 	strb	r5, [r1, #4]
	unsigned char string_length, temp;
	//      Ql_itoa(water_bal, local_buff, 10);
	Ql_sprintf((char *)&local_buff,"%d",water_bal);

	string_length = strlen(local_buff);
	for(temp = 0; temp<string_length;temp++)
102dd1b4:	8affffe6 	bhi	102dd154 <format_water_balance_buffer+0x9c>
			temp = string_length; //Just to go out of for loop
		}
		else
			c[temp] = local_buff[temp];
	}
}
102dd1b8:	e28dd00c 	add	sp, sp, #12
102dd1bc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		{
			if(string_length == 1)// for values less than 1 add a leading zero before decimal point
			{
				c[temp] = '0';
				c[temp+1] = '.';
				c[temp+2] = local_buff[temp];
102dd1c0:	e28dc008 	add	ip, sp, #8
	{
		if(temp == (string_length-1))//last char in the string then insert a decimal point
		{
			if(string_length == 1)// for values less than 1 add a leading zero before decimal point
			{
				c[temp] = '0';
102dd1c4:	e3a01030 	mov	r1, #48	; 0x30
102dd1c8:	e7e41003 	strb	r1, [r4, r3]!
				c[temp+1] = '.';
				c[temp+2] = local_buff[temp];
102dd1cc:	e08c2003 	add	r2, ip, r3
		if(temp == (string_length-1))//last char in the string then insert a decimal point
		{
			if(string_length == 1)// for values less than 1 add a leading zero before decimal point
			{
				c[temp] = '0';
				c[temp+1] = '.';
102dd1d0:	e3a0302e 	mov	r3, #46	; 0x2e
102dd1d4:	e5c43001 	strb	r3, [r4, #1]
				c[temp+2] = local_buff[temp];
				c[temp+3] = ' ';
102dd1d8:	e3a03020 	mov	r3, #32
102dd1dc:	e5c43003 	strb	r3, [r4, #3]
				if(Water_Unit_index_get == 0)
102dd1e0:	e59f3050 	ldr	r3, [pc, #80]	; 102dd238 <format_water_balance_buffer+0x180>
		{
			if(string_length == 1)// for values less than 1 add a leading zero before decimal point
			{
				c[temp] = '0';
				c[temp+1] = '.';
				c[temp+2] = local_buff[temp];
102dd1e4:	e5522008 	ldrb	r2, [r2, #-8]
102dd1e8:	e5c42002 	strb	r2, [r4, #2]
				c[temp+3] = ' ';
				if(Water_Unit_index_get == 0)
102dd1ec:	e5933204 	ldr	r3, [r3, #516]	; 0x204
102dd1f0:	e3530000 	cmp	r3, #0
					c[temp+4] = 'L';
102dd1f4:	03a0304c 	moveq	r3, #76	; 0x4c
102dd1f8:	05c43004 	strbeq	r3, [r4, #4]
			{
				c[temp] = '0';
				c[temp+1] = '.';
				c[temp+2] = local_buff[temp];
				c[temp+3] = ' ';
				if(Water_Unit_index_get == 0)
102dd1fc:	0a000006 	beq	102dd21c <format_water_balance_buffer+0x164>
					c[temp+4] = 'L';
				else if(Water_Unit_index_get == 1)
102dd200:	e3530001 	cmp	r3, #1
					c[temp+4] = 'G';
102dd204:	03a03047 	moveq	r3, #71	; 0x47
102dd208:	05c43004 	strbeq	r3, [r4, #4]
				c[temp+1] = '.';
				c[temp+2] = local_buff[temp];
				c[temp+3] = ' ';
				if(Water_Unit_index_get == 0)
					c[temp+4] = 'L';
				else if(Water_Unit_index_get == 1)
102dd20c:	0a000002 	beq	102dd21c <format_water_balance_buffer+0x164>
					c[temp+4] = 'G';
				else if(Water_Unit_index_get == 2)
102dd210:	e3530002 	cmp	r3, #2
					c[temp+4] = 'C';
102dd214:	03a03043 	moveq	r3, #67	; 0x43
102dd218:	05c43004 	strbeq	r3, [r4, #4]
				c[temp+5] = '\0';
102dd21c:	e3a03000 	mov	r3, #0
102dd220:	e5c43005 	strb	r3, [r4, #5]
102dd224:	eaffffe3 	b	102dd1b8 <format_water_balance_buffer+0x100>
102dd228:	102eb048 	.word	0x102eb048
102dd22c:	f03de540 	.word	0xf03de540
102dd230:	102edef4 	.word	0x102edef4
102dd234:	102dff65 	.word	0x102dff65
102dd238:	f03da2f4 	.word	0xf03da2f4

102dd23c <Transform>:
 *
 *****************************************************************/
void Transform(u8 InByte)
{
	u8 Bit;
	InByte = magic_byte[InByte];
102dd23c:	e59f3060 	ldr	r3, [pc, #96]	; 102dd2a4 <Transform+0x68>
102dd240:	e59fc060 	ldr	ip, [pc, #96]	; 102dd2a8 <Transform+0x6c>
102dd244:	e0830000 	add	r0, r3, r0
102dd248:	e3a03f82 	mov	r3, #520	; 0x208
102dd24c:	e5d02008 	ldrb	r2, [r0, #8]
102dd250:	e19c30b3 	ldrh	r3, [ip, r3]
102dd254:	e3a01008 	mov	r1, #8
	for(Bit=0;Bit<8;Bit++) // Process for all bits in the InByte
	{
		if( BIT0(InByte) != BIT0(CRC2) ) // If new bit xor bit 0 of CRC does not match
102dd258:	e0230002 	eor	r0, r3, r2
102dd25c:	e3100001 	tst	r0, #1

			SetBITF(CRC2);//After the shift direction Bit0 the new bit 15 becomes 1
		}
		else
		{
			CRC2 = ( CRC2 / 2 );
102dd260:	01a030a3 	lsreq	r3, r3, #1
{
	u8 Bit;
	InByte = magic_byte[InByte];
	for(Bit=0;Bit<8;Bit++) // Process for all bits in the InByte
	{
		if( BIT0(InByte) != BIT0(CRC2) ) // If new bit xor bit 0 of CRC does not match
102dd264:	0a000007 	beq	102dd288 <Transform+0x4c>
		{
			if( !BIT1(CRC2) ) // If bit 1 of CRC is zero
102dd268:	e3130002 	tst	r3, #2
				SetBIT1(CRC2);
			else
				ResetBIT1(CRC2);
102dd26c:	e3c30002 	bic	r0, r3, #2
	for(Bit=0;Bit<8;Bit++) // Process for all bits in the InByte
	{
		if( BIT0(InByte) != BIT0(CRC2) ) // If new bit xor bit 0 of CRC does not match
		{
			if( !BIT1(CRC2) ) // If bit 1 of CRC is zero
				SetBIT1(CRC2);
102dd270:	03830002 	orreq	r0, r3, #2
			else
				ResetBIT1(CRC2);
			if( !BITE(CRC2) ) // If bit 14 of CRC is zero
102dd274:	e3100901 	tst	r0, #16384	; 0x4000
				SetBITE(CRC2);
			else
				ResetBITE(CRC2);
102dd278:	e3c03901 	bic	r3, r0, #16384	; 0x4000
			if( !BIT1(CRC2) ) // If bit 1 of CRC is zero
				SetBIT1(CRC2);
			else
				ResetBIT1(CRC2);
			if( !BITE(CRC2) ) // If bit 14 of CRC is zero
				SetBITE(CRC2);
102dd27c:	03803901 	orreq	r3, r0, #16384	; 0x4000
			else
				ResetBITE(CRC2);
			CRC2 = ( CRC2 / 2 );
102dd280:	e1a030a3 	lsr	r3, r3, #1

			SetBITF(CRC2);//After the shift direction Bit0 the new bit 15 becomes 1
102dd284:	e3833902 	orr	r3, r3, #32768	; 0x8000
102dd288:	e2411001 	sub	r1, r1, #1
 *****************************************************************/
void Transform(u8 InByte)
{
	u8 Bit;
	InByte = magic_byte[InByte];
	for(Bit=0;Bit<8;Bit++) // Process for all bits in the InByte
102dd28c:	e21110ff 	ands	r1, r1, #255	; 0xff
		else
		{
			CRC2 = ( CRC2 / 2 );
			ResetBITF(CRC2);
		}
		InByte = InByte / 2;
102dd290:	e1a020a2 	lsr	r2, r2, #1
 *****************************************************************/
void Transform(u8 InByte)
{
	u8 Bit;
	InByte = magic_byte[InByte];
	for(Bit=0;Bit<8;Bit++) // Process for all bits in the InByte
102dd294:	1affffef 	bne	102dd258 <Transform+0x1c>
102dd298:	e3a02f82 	mov	r2, #520	; 0x208
102dd29c:	e18c30b2 	strh	r3, [ip, r2]
102dd2a0:	e12fff1e 	bx	lr
102dd2a4:	102eb048 	.word	0x102eb048
102dd2a8:	f03da2f4 	.word	0xf03da2f4

102dd2ac <InitIPComm>:
 *****************************************************************/
static void IPC_TIMER_INIT(void)
{
	s32 ret;

	ret = Ql_Timer_Register(Timer_SendTimeOut, Callback_OnIPCTimer, NULL);
102dd2ac:	e59f30b8 	ldr	r3, [pc, #184]	; 102dd36c <InitIPComm+0xc0>
 *
 * Return:
 *           void
 *****************************************************************/
s32 InitIPComm(void)
{
102dd2b0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 *****************************************************************/
static void IPC_TIMER_INIT(void)
{
	s32 ret;

	ret = Ql_Timer_Register(Timer_SendTimeOut, Callback_OnIPCTimer, NULL);
102dd2b4:	e59f10b4 	ldr	r1, [pc, #180]	; 102dd370 <InitIPComm+0xc4>
102dd2b8:	e3a02000 	mov	r2, #0
102dd2bc:	e5930000 	ldr	r0, [r3]
102dd2c0:	e59f30ac 	ldr	r3, [pc, #172]	; 102dd374 <InitIPComm+0xc8>
102dd2c4:	e12fff33 	blx	r3
	APP_DEBUG("\r<-- success, Ql_Timer_Register : Timer_SendTimeOut, ret : %d -->\r\n",ret);
102dd2c8:	e59f70a8 	ldr	r7, [pc, #168]	; 102dd378 <InitIPComm+0xcc>
102dd2cc:	e3a01000 	mov	r1, #0
102dd2d0:	e3a02c02 	mov	r2, #512	; 0x200
102dd2d4:	e59f80a0 	ldr	r8, [pc, #160]	; 102dd37c <InitIPComm+0xd0>
102dd2d8:	e59f60a0 	ldr	r6, [pc, #160]	; 102dd380 <InitIPComm+0xd4>
102dd2dc:	e59f50a0 	ldr	r5, [pc, #160]	; 102dd384 <InitIPComm+0xd8>
 *****************************************************************/
static void IPC_TIMER_INIT(void)
{
	s32 ret;

	ret = Ql_Timer_Register(Timer_SendTimeOut, Callback_OnIPCTimer, NULL);
102dd2e0:	e1a04000 	mov	r4, r0
	APP_DEBUG("\r<-- success, Ql_Timer_Register : Timer_SendTimeOut, ret : %d -->\r\n",ret);
102dd2e4:	e59f009c 	ldr	r0, [pc, #156]	; 102dd388 <InitIPComm+0xdc>
102dd2e8:	e12fff38 	blx	r8
102dd2ec:	e59f1098 	ldr	r1, [pc, #152]	; 102dd38c <InitIPComm+0xe0>
102dd2f0:	e1a02004 	mov	r2, r4
102dd2f4:	e5973000 	ldr	r3, [r7]
102dd2f8:	e59f0088 	ldr	r0, [pc, #136]	; 102dd388 <InitIPComm+0xdc>
102dd2fc:	e12fff33 	blx	r3
102dd300:	e59f0080 	ldr	r0, [pc, #128]	; 102dd388 <InitIPComm+0xdc>
102dd304:	e12fff36 	blx	r6
102dd308:	e59f1078 	ldr	r1, [pc, #120]	; 102dd388 <InitIPComm+0xdc>
102dd30c:	e1a02000 	mov	r2, r0
102dd310:	e3a0000a 	mov	r0, #10
102dd314:	e12fff35 	blx	r5
#ifdef INOUT
	if(ret <0)
102dd318:	e3540000 	cmp	r4, #0
102dd31c:	ba000001 	blt	102dd328 <InitIPComm+0x7c>

	//IPC_UART_INIT(IPC_BAUDRATE);
	IPC_TIMER_INIT();

	return ret;
}
102dd320:	e3a00000 	mov	r0, #0
102dd324:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	ret = Ql_Timer_Register(Timer_SendTimeOut, Callback_OnIPCTimer, NULL);
	APP_DEBUG("\r<-- success, Ql_Timer_Register : Timer_SendTimeOut, ret : %d -->\r\n",ret);
#ifdef INOUT
	if(ret <0)
	{
		APP_DEBUG("\r<-- Error, Ql_Timer_Register : Timer_SendTimeOut, ret : %d -->\r\n",ret);
102dd328:	e3a01000 	mov	r1, #0
102dd32c:	e3a02c02 	mov	r2, #512	; 0x200
102dd330:	e59f0050 	ldr	r0, [pc, #80]	; 102dd388 <InitIPComm+0xdc>
102dd334:	e12fff38 	blx	r8
102dd338:	e1a02004 	mov	r2, r4
102dd33c:	e5973000 	ldr	r3, [r7]
102dd340:	e59f1048 	ldr	r1, [pc, #72]	; 102dd390 <InitIPComm+0xe4>
102dd344:	e59f003c 	ldr	r0, [pc, #60]	; 102dd388 <InitIPComm+0xdc>
102dd348:	e12fff33 	blx	r3
102dd34c:	e59f0034 	ldr	r0, [pc, #52]	; 102dd388 <InitIPComm+0xdc>
102dd350:	e12fff36 	blx	r6
102dd354:	e59f102c 	ldr	r1, [pc, #44]	; 102dd388 <InitIPComm+0xdc>
102dd358:	e1a02000 	mov	r2, r0
102dd35c:	e3a0000a 	mov	r0, #10
102dd360:	e12fff35 	blx	r5

	//IPC_UART_INIT(IPC_BAUDRATE);
	IPC_TIMER_INIT();

	return ret;
}
102dd364:	e3a00000 	mov	r0, #0
102dd368:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102dd36c:	f03d2028 	.word	0xf03d2028
102dd370:	102dcff4 	.word	0x102dcff4
102dd374:	102e6010 	.word	0x102e6010
102dd378:	f03de540 	.word	0xf03de540
102dd37c:	102e58f4 	.word	0x102e58f4
102dd380:	102e57a4 	.word	0x102e57a4
102dd384:	102e6230 	.word	0x102e6230
102dd388:	f03da2f8 	.word	0xf03da2f8
102dd38c:	102efed8 	.word	0x102efed8
102dd390:	102eff1c 	.word	0x102eff1c

102dd394 <Send_IPC_Command>:
 *
 * Return: void
 *
 *****************************************************************/
void Send_IPC_Command(int CmdID)
{
102dd394:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
	u16 buflen = 0;
	u8 loop_ = 0;
	u8 packet_checksum =0;
	u8 UART_IPC_Write_Buffer[MAX_PACKET_SIZE] = {0x00};
102dd398:	e3a01000 	mov	r1, #0
 *
 * Return: void
 *
 *****************************************************************/
void Send_IPC_Command(int CmdID)
{
102dd39c:	e24dd014 	sub	sp, sp, #20
	u8 packet_checksum =0;
	u8 UART_IPC_Write_Buffer[MAX_PACKET_SIZE] = {0x00};

	UART_IPC_Write_Buffer[buflen++] = 0xFF; // Start byte is always 0xFF
	UART_IPC_Write_Buffer[buflen++] = 0x00; // Start with 0x00 in this.. will be update later once command bytes are fill in
	UART_IPC_Write_Buffer[buflen++] = CmdID;
102dd3a0:	e20050ff 	and	r5, r0, #255	; 0xff
	u16 buflen = 0;
	u8 loop_ = 0;
	u8 packet_checksum =0;
	u8 UART_IPC_Write_Buffer[MAX_PACKET_SIZE] = {0x00};

	UART_IPC_Write_Buffer[buflen++] = 0xFF; // Start byte is always 0xFF
102dd3a4:	e3e03000 	mvn	r3, #0
	UART_IPC_Write_Buffer[buflen++] = 0x00; // Start with 0x00 in this.. will be update later once command bytes are fill in
	UART_IPC_Write_Buffer[buflen++] = CmdID;

	switch(CmdID)
102dd3a8:	e3500049 	cmp	r0, #73	; 0x49
void Send_IPC_Command(int CmdID)
{
	u16 buflen = 0;
	u8 loop_ = 0;
	u8 packet_checksum =0;
	u8 UART_IPC_Write_Buffer[MAX_PACKET_SIZE] = {0x00};
102dd3ac:	e58d1000 	str	r1, [sp]
102dd3b0:	e58d1004 	str	r1, [sp, #4]
102dd3b4:	e58d1008 	str	r1, [sp, #8]
102dd3b8:	e58d100c 	str	r1, [sp, #12]

	UART_IPC_Write_Buffer[buflen++] = 0xFF; // Start byte is always 0xFF
102dd3bc:	e5cd3000 	strb	r3, [sp]
	UART_IPC_Write_Buffer[buflen++] = 0x00; // Start with 0x00 in this.. will be update later once command bytes are fill in
	UART_IPC_Write_Buffer[buflen++] = CmdID;
102dd3c0:	e5cd5002 	strb	r5, [sp, #2]

	switch(CmdID)
102dd3c4:	0a00009e 	beq	102dd644 <Send_IPC_Command+0x2b0>
102dd3c8:	e350004e 	cmp	r0, #78	; 0x4e
102dd3cc:	0a000092 	beq	102dd61c <Send_IPC_Command+0x288>
102dd3d0:	e3500043 	cmp	r0, #67	; 0x43
102dd3d4:	0a000054 	beq	102dd52c <Send_IPC_Command+0x198>
		break;
	}
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;

	if(CmdID == CMD_SET_CONFIG) // For all config set commands the CRC2 checksum calculation is used.
102dd3d8:	e3a05004 	mov	r5, #4
102dd3dc:	e1a00001 	mov	r0, r1
102dd3e0:	e1a08005 	mov	r8, r5
102dd3e4:	e3a04003 	mov	r4, #3
102dd3e8:	e3a0e002 	mov	lr, #2
	case CMD_GET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Read;
		break;
	}
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;
102dd3ec:	e3a01000 	mov	r1, #0
102dd3f0:	e3a03001 	mov	r3, #1
102dd3f4:	ea000000 	b	102dd3fc <Send_IPC_Command+0x68>
102dd3f8:	e55c0010 	ldrb	r0, [ip, #-16]
		packet_checksum ^=((CRC2>>8) & 0xFF);
	}
	else // Simple checksum
	{
		//compute and Update the checksum byte
		for(loop_ = 1 ; loop_ <= (2 + UART_IPC_Write_Buffer[1]);loop_++)
102dd3fc:	e2833001 	add	r3, r3, #1
102dd400:	e20330ff 	and	r3, r3, #255	; 0xff
102dd404:	e28d2010 	add	r2, sp, #16
		{
			packet_checksum += UART_IPC_Write_Buffer[loop_];
102dd408:	e0811000 	add	r1, r1, r0
		packet_checksum ^=((CRC2>>8) & 0xFF);
	}
	else // Simple checksum
	{
		//compute and Update the checksum byte
		for(loop_ = 1 ; loop_ <= (2 + UART_IPC_Write_Buffer[1]);loop_++)
102dd40c:	e153000e 	cmp	r3, lr
102dd410:	e082c003 	add	ip, r2, r3
		{
			packet_checksum += UART_IPC_Write_Buffer[loop_];
102dd414:	e20110ff 	and	r1, r1, #255	; 0xff
		packet_checksum ^=((CRC2>>8) & 0xFF);
	}
	else // Simple checksum
	{
		//compute and Update the checksum byte
		for(loop_ = 1 ; loop_ <= (2 + UART_IPC_Write_Buffer[1]);loop_++)
102dd418:	dafffff6 	ble	102dd3f8 <Send_IPC_Command+0x64>
		{
			packet_checksum += UART_IPC_Write_Buffer[loop_];
		}
		packet_checksum = (u8)((0x100-packet_checksum)&0xFF);
102dd41c:	e2613000 	rsb	r3, r1, #0
	}
	UART_IPC_Write_Buffer[buflen++] = packet_checksum;
102dd420:	e28d0010 	add	r0, sp, #16
102dd424:	e080c004 	add	ip, r0, r4

	Ql_UART_Write(UART_PORT_IPC, UART_IPC_Write_Buffer, buflen);
102dd428:	e1a02005 	mov	r2, r5
102dd42c:	e1a0100d 	mov	r1, sp
102dd430:	e59f522c 	ldr	r5, [pc, #556]	; 102dd664 <Send_IPC_Command+0x2d0>
102dd434:	e3a0000c 	mov	r0, #12
#ifdef IPC_DEBUG_MSG
	APP_DEBUG("\r<--UART Send Data:");
102dd438:	e59f7228 	ldr	r7, [pc, #552]	; 102dd668 <Send_IPC_Command+0x2d4>
		{
			packet_checksum += UART_IPC_Write_Buffer[loop_];
		}
		packet_checksum = (u8)((0x100-packet_checksum)&0xFF);
	}
	UART_IPC_Write_Buffer[buflen++] = packet_checksum;
102dd43c:	e54c3010 	strb	r3, [ip, #-16]

	Ql_UART_Write(UART_PORT_IPC, UART_IPC_Write_Buffer, buflen);
#ifdef IPC_DEBUG_MSG
	APP_DEBUG("\r<--UART Send Data:");
102dd440:	e59fa224 	ldr	sl, [pc, #548]	; 102dd66c <Send_IPC_Command+0x2d8>
		}
		packet_checksum = (u8)((0x100-packet_checksum)&0xFF);
	}
	UART_IPC_Write_Buffer[buflen++] = packet_checksum;

	Ql_UART_Write(UART_PORT_IPC, UART_IPC_Write_Buffer, buflen);
102dd444:	e12fff35 	blx	r5
#ifdef IPC_DEBUG_MSG
	APP_DEBUG("\r<--UART Send Data:");
102dd448:	e3a02c02 	mov	r2, #512	; 0x200
102dd44c:	e3a01000 	mov	r1, #0
102dd450:	e59f0218 	ldr	r0, [pc, #536]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd454:	e12fff3a 	blx	sl
102dd458:	e59f1214 	ldr	r1, [pc, #532]	; 102dd674 <Send_IPC_Command+0x2e0>
102dd45c:	e5973000 	ldr	r3, [r7]
102dd460:	e59f0208 	ldr	r0, [pc, #520]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd464:	e12fff33 	blx	r3
102dd468:	e59f6208 	ldr	r6, [pc, #520]	; 102dd678 <Send_IPC_Command+0x2e4>
102dd46c:	e59f01fc 	ldr	r0, [pc, #508]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd470:	e12fff36 	blx	r6
102dd474:	e59f11f4 	ldr	r1, [pc, #500]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd478:	e3a04000 	mov	r4, #0
102dd47c:	e1a02000 	mov	r2, r0
102dd480:	e3a0000a 	mov	r0, #10
102dd484:	e12fff35 	blx	r5
	for(loop_=0; loop_<buflen; loop_++)
	{
		APP_DEBUG("0x%2.2x ", UART_IPC_Write_Buffer[loop_]);
102dd488:	e3a01000 	mov	r1, #0
102dd48c:	e3a02c02 	mov	r2, #512	; 0x200
102dd490:	e59f01d8 	ldr	r0, [pc, #472]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd494:	e12fff3a 	blx	sl
102dd498:	e28d2010 	add	r2, sp, #16
102dd49c:	e0823004 	add	r3, r2, r4
102dd4a0:	e5532010 	ldrb	r2, [r3, #-16]
102dd4a4:	e59f11d0 	ldr	r1, [pc, #464]	; 102dd67c <Send_IPC_Command+0x2e8>
102dd4a8:	e5973000 	ldr	r3, [r7]
102dd4ac:	e59f01bc 	ldr	r0, [pc, #444]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd4b0:	e12fff33 	blx	r3
102dd4b4:	e59f01b4 	ldr	r0, [pc, #436]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd4b8:	e12fff36 	blx	r6
	UART_IPC_Write_Buffer[buflen++] = packet_checksum;

	Ql_UART_Write(UART_PORT_IPC, UART_IPC_Write_Buffer, buflen);
#ifdef IPC_DEBUG_MSG
	APP_DEBUG("\r<--UART Send Data:");
	for(loop_=0; loop_<buflen; loop_++)
102dd4bc:	e2844001 	add	r4, r4, #1
	{
		APP_DEBUG("0x%2.2x ", UART_IPC_Write_Buffer[loop_]);
102dd4c0:	e59f11a8 	ldr	r1, [pc, #424]	; 102dd670 <Send_IPC_Command+0x2dc>
	UART_IPC_Write_Buffer[buflen++] = packet_checksum;

	Ql_UART_Write(UART_PORT_IPC, UART_IPC_Write_Buffer, buflen);
#ifdef IPC_DEBUG_MSG
	APP_DEBUG("\r<--UART Send Data:");
	for(loop_=0; loop_<buflen; loop_++)
102dd4c4:	e20440ff 	and	r4, r4, #255	; 0xff
	{
		APP_DEBUG("0x%2.2x ", UART_IPC_Write_Buffer[loop_]);
102dd4c8:	e1a02000 	mov	r2, r0
102dd4cc:	e3a0000a 	mov	r0, #10
102dd4d0:	e12fff35 	blx	r5
	UART_IPC_Write_Buffer[buflen++] = packet_checksum;

	Ql_UART_Write(UART_PORT_IPC, UART_IPC_Write_Buffer, buflen);
#ifdef IPC_DEBUG_MSG
	APP_DEBUG("\r<--UART Send Data:");
	for(loop_=0; loop_<buflen; loop_++)
102dd4d4:	e1540008 	cmp	r4, r8
102dd4d8:	3affffea 	bcc	102dd488 <Send_IPC_Command+0xf4>
	{
		APP_DEBUG("0x%2.2x ", UART_IPC_Write_Buffer[loop_]);
	}
	APP_DEBUG("-->\r\n");
102dd4dc:	e3a02c02 	mov	r2, #512	; 0x200
102dd4e0:	e3a01000 	mov	r1, #0
102dd4e4:	e59f3180 	ldr	r3, [pc, #384]	; 102dd66c <Send_IPC_Command+0x2d8>
102dd4e8:	e59f0180 	ldr	r0, [pc, #384]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd4ec:	e12fff33 	blx	r3
102dd4f0:	e59f3170 	ldr	r3, [pc, #368]	; 102dd668 <Send_IPC_Command+0x2d4>
102dd4f4:	e59f1184 	ldr	r1, [pc, #388]	; 102dd680 <Send_IPC_Command+0x2ec>
102dd4f8:	e5933000 	ldr	r3, [r3]
102dd4fc:	e59f016c 	ldr	r0, [pc, #364]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd500:	e12fff33 	blx	r3
102dd504:	e59f316c 	ldr	r3, [pc, #364]	; 102dd678 <Send_IPC_Command+0x2e4>
102dd508:	e59f0160 	ldr	r0, [pc, #352]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd50c:	e12fff33 	blx	r3
102dd510:	e59f1158 	ldr	r1, [pc, #344]	; 102dd670 <Send_IPC_Command+0x2dc>
102dd514:	e59f3148 	ldr	r3, [pc, #328]	; 102dd664 <Send_IPC_Command+0x2d0>
102dd518:	e1a02000 	mov	r2, r0
102dd51c:	e3a0000a 	mov	r0, #10
102dd520:	e12fff33 	blx	r3
#endif
}
102dd524:	e28dd014 	add	sp, sp, #20
102dd528:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
	case CMD_GET_IDENTITY:
		UART_IPC_Write_Buffer[buflen++] = CRC_Token;
		CRC_Token = magic_byte[CRC_Token];
		break;
	case CMD_SET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_PID];
102dd52c:	e59f6150 	ldr	r6, [pc, #336]	; 102dd684 <Send_IPC_Command+0x2f0>
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;

	if(CmdID == CMD_SET_CONFIG) // For all config set commands the CRC2 checksum calculation is used.
	{
		CRC2 =water_balance;// Reset the CRC at the start of the frame with current water balance data
102dd530:	e59f4150 	ldr	r4, [pc, #336]	; 102dd688 <Send_IPC_Command+0x2f4>
102dd534:	e59f3150 	ldr	r3, [pc, #336]	; 102dd68c <Send_IPC_Command+0x2f8>
		CRC_Token = magic_byte[CRC_Token];
		break;
	case CMD_SET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_PID];
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_DATA0];
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_DATA1];
102dd538:	e5d62002 	ldrb	r2, [r6, #2]
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;

	if(CmdID == CMD_SET_CONFIG) // For all config set commands the CRC2 checksum calculation is used.
	{
		CRC2 =water_balance;// Reset the CRC at the start of the frame with current water balance data
102dd53c:	e5933000 	ldr	r3, [r3]
	case CMD_GET_IDENTITY:
		UART_IPC_Write_Buffer[buflen++] = CRC_Token;
		CRC_Token = magic_byte[CRC_Token];
		break;
	case CMD_SET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_PID];
102dd540:	e5d6c000 	ldrb	ip, [r6]
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_DATA0];
102dd544:	e5d61001 	ldrb	r1, [r6, #1]
	UART_IPC_Write_Buffer[1] = buflen - 3;

	if(CmdID == CMD_SET_CONFIG) // For all config set commands the CRC2 checksum calculation is used.
	{
		CRC2 =water_balance;// Reset the CRC at the start of the frame with current water balance data
		Transform(CRC_Token);
102dd548:	e5d4020a 	ldrb	r0, [r4, #522]	; 0x20a
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;

	if(CmdID == CMD_SET_CONFIG) // For all config set commands the CRC2 checksum calculation is used.
	{
		CRC2 =water_balance;// Reset the CRC at the start of the frame with current water balance data
102dd54c:	e3a07f82 	mov	r7, #520	; 0x208
		CRC_Token = magic_byte[CRC_Token];
		break;
	case CMD_SET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_PID];
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_DATA0];
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_DATA1];
102dd550:	e5cd2005 	strb	r2, [sp, #5]
	case CMD_GET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Read;
		break;
	}
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;
102dd554:	e3a02003 	mov	r2, #3

	if(CmdID == CMD_SET_CONFIG) // For all config set commands the CRC2 checksum calculation is used.
	{
		CRC2 =water_balance;// Reset the CRC at the start of the frame with current water balance data
102dd558:	e18430b7 	strh	r3, [r4, r7]
	case CMD_GET_IDENTITY:
		UART_IPC_Write_Buffer[buflen++] = CRC_Token;
		CRC_Token = magic_byte[CRC_Token];
		break;
	case CMD_SET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_PID];
102dd55c:	e5cdc003 	strb	ip, [sp, #3]
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_DATA0];
102dd560:	e5cd1004 	strb	r1, [sp, #4]
	case CMD_GET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Read;
		break;
	}
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;
102dd564:	e5cd2001 	strb	r2, [sp, #1]

	if(CmdID == CMD_SET_CONFIG) // For all config set commands the CRC2 checksum calculation is used.
	{
		CRC2 =water_balance;// Reset the CRC at the start of the frame with current water balance data
		Transform(CRC_Token);
102dd568:	ebffff33 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[0]);
102dd56c:	e5d4020c 	ldrb	r0, [r4, #524]	; 0x20c
102dd570:	ebffff31 	bl	102dd23c <Transform>
		Transform(CmdID);
102dd574:	e1a00005 	mov	r0, r5
102dd578:	ebffff2f 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[10]);
102dd57c:	e5d40216 	ldrb	r0, [r4, #534]	; 0x216
102dd580:	ebffff2d 	bl	102dd23c <Transform>
		Transform(configuration_Data_Write[CONFIG_PID]);
102dd584:	e5d60000 	ldrb	r0, [r6]
102dd588:	ebffff2b 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[1]);
102dd58c:	e5d4020d 	ldrb	r0, [r4, #525]	; 0x20d
102dd590:	ebffff29 	bl	102dd23c <Transform>
		Transform(UART_IPC_Write_Buffer[1]);
102dd594:	e5dd0001 	ldrb	r0, [sp, #1]
102dd598:	ebffff27 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[9]);
102dd59c:	e5d40215 	ldrb	r0, [r4, #533]	; 0x215
102dd5a0:	ebffff25 	bl	102dd23c <Transform>
		Transform(configuration_Data_Write[CONFIG_DATA0]);
102dd5a4:	e5d60001 	ldrb	r0, [r6, #1]
102dd5a8:	ebffff23 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[2]);
102dd5ac:	e5d4020e 	ldrb	r0, [r4, #526]	; 0x20e
102dd5b0:	ebffff21 	bl	102dd23c <Transform>
		Transform(configuration_Data_Write[CONFIG_DATA1]);
102dd5b4:	e5d60002 	ldrb	r0, [r6, #2]
102dd5b8:	ebffff1f 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[8]);
102dd5bc:	e5d40214 	ldrb	r0, [r4, #532]	; 0x214
102dd5c0:	ebffff1d 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[3]);
102dd5c4:	e5d4020f 	ldrb	r0, [r4, #527]	; 0x20f
102dd5c8:	ebffff1b 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[7]);
102dd5cc:	e5d40213 	ldrb	r0, [r4, #531]	; 0x213
102dd5d0:	ebffff19 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[4]);
		Transform(Purification_ON_Counter & 0xFF);
102dd5d4:	e3a05f87 	mov	r5, #540	; 0x21c
		Transform(Control_Module_Indentity_data[2]);
		Transform(configuration_Data_Write[CONFIG_DATA1]);
		Transform(Control_Module_Indentity_data[8]);
		Transform(Control_Module_Indentity_data[3]);
		Transform(Control_Module_Indentity_data[7]);
		Transform(Control_Module_Indentity_data[4]);
102dd5d8:	e5d40210 	ldrb	r0, [r4, #528]	; 0x210
102dd5dc:	ebffff16 	bl	102dd23c <Transform>
		Transform(Purification_ON_Counter & 0xFF);
102dd5e0:	e7d40005 	ldrb	r0, [r4, r5]
102dd5e4:	ebffff14 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[6]);
102dd5e8:	e5d40212 	ldrb	r0, [r4, #530]	; 0x212
102dd5ec:	ebffff12 	bl	102dd23c <Transform>
		Transform((Purification_ON_Counter>>8) & 0xFF);
102dd5f0:	e19400b5 	ldrh	r0, [r4, r5]
	case CMD_GET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Read;
		break;
	}
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;
102dd5f4:	e3a05007 	mov	r5, #7
		Transform(Control_Module_Indentity_data[3]);
		Transform(Control_Module_Indentity_data[7]);
		Transform(Control_Module_Indentity_data[4]);
		Transform(Purification_ON_Counter & 0xFF);
		Transform(Control_Module_Indentity_data[6]);
		Transform((Purification_ON_Counter>>8) & 0xFF);
102dd5f8:	e1a00420 	lsr	r0, r0, #8
102dd5fc:	ebffff0e 	bl	102dd23c <Transform>
		Transform(Control_Module_Indentity_data[5]);
102dd600:	e5d40211 	ldrb	r0, [r4, #529]	; 0x211
102dd604:	ebffff0c 	bl	102dd23c <Transform>

		packet_checksum = (CRC2 & 0xFF);
102dd608:	e19430b7 	ldrh	r3, [r4, r7]
	case CMD_GET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Read;
		break;
	}
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;
102dd60c:	e1a08005 	mov	r8, r5
		Transform(Control_Module_Indentity_data[6]);
		Transform((Purification_ON_Counter>>8) & 0xFF);
		Transform(Control_Module_Indentity_data[5]);

		packet_checksum = (CRC2 & 0xFF);
		packet_checksum ^=((CRC2>>8) & 0xFF);
102dd610:	e0233423 	eor	r3, r3, r3, lsr #8
	case CMD_GET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Read;
		break;
	}
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;
102dd614:	e3a04006 	mov	r4, #6
102dd618:	eaffff80 	b	102dd420 <Send_IPC_Command+0x8c>
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_PID];
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_DATA0];
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Write[CONFIG_DATA1];
		break;
	case CMD_GET_CONFIG:
		UART_IPC_Write_Buffer[buflen++] = configuration_Data_Read;
102dd61c:	e59f306c 	ldr	r3, [pc, #108]	; 102dd690 <Send_IPC_Command+0x2fc>
102dd620:	e5d33000 	ldrb	r3, [r3]
102dd624:	e5cd3003 	strb	r3, [sp, #3]
		break;
	}
	//Update the number of bytes data value
	UART_IPC_Write_Buffer[1] = buflen - 3;
102dd628:	e3a00001 	mov	r0, #1
102dd62c:	e3a05005 	mov	r5, #5
102dd630:	e5cd0001 	strb	r0, [sp, #1]
102dd634:	e1a08005 	mov	r8, r5
102dd638:	e3a04004 	mov	r4, #4
102dd63c:	e3a0e003 	mov	lr, #3
102dd640:	eaffff69 	b	102dd3ec <Send_IPC_Command+0x58>
	UART_IPC_Write_Buffer[buflen++] = CmdID;

	switch(CmdID)
	{
	case CMD_GET_IDENTITY:
		UART_IPC_Write_Buffer[buflen++] = CRC_Token;
102dd644:	e59f303c 	ldr	r3, [pc, #60]	; 102dd688 <Send_IPC_Command+0x2f4>
		CRC_Token = magic_byte[CRC_Token];
102dd648:	e59f1044 	ldr	r1, [pc, #68]	; 102dd694 <Send_IPC_Command+0x300>
	UART_IPC_Write_Buffer[buflen++] = CmdID;

	switch(CmdID)
	{
	case CMD_GET_IDENTITY:
		UART_IPC_Write_Buffer[buflen++] = CRC_Token;
102dd64c:	e5d3220a 	ldrb	r2, [r3, #522]	; 0x20a
102dd650:	e5cd2003 	strb	r2, [sp, #3]
		CRC_Token = magic_byte[CRC_Token];
102dd654:	e0812002 	add	r2, r1, r2
102dd658:	e5d22008 	ldrb	r2, [r2, #8]
102dd65c:	e5c3220a 	strb	r2, [r3, #522]	; 0x20a
		break;
102dd660:	eafffff0 	b	102dd628 <Send_IPC_Command+0x294>
102dd664:	102e6230 	.word	0x102e6230
102dd668:	f03de540 	.word	0xf03de540
102dd66c:	102e58f4 	.word	0x102e58f4
102dd670:	f03da2f8 	.word	0xf03da2f8
102dd674:	102eff60 	.word	0x102eff60
102dd678:	102e57a4 	.word	0x102e57a4
102dd67c:	102eff74 	.word	0x102eff74
102dd680:	102ef6f0 	.word	0x102ef6f0
102dd684:	f03de538 	.word	0xf03de538
102dd688:	f03da2f4 	.word	0xf03da2f4
102dd68c:	f03d5bf4 	.word	0xf03d5bf4
102dd690:	f03de536 	.word	0xf03de536
102dd694:	102eb048 	.word	0x102eb048

102dd698 <READ_ACK>:
 *
 * Return: UART READ BYTE
 *
 *****************************************************************/
u16 READ_ACK(void)
{
102dd698:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	s32 rdLen = -1;
	unsigned int count = 0;
	u8 UART_IPC_Read_Buffer = 0x00;
102dd69c:	e3a03000 	mov	r3, #0
 *
 * Return: UART READ BYTE
 *
 *****************************************************************/
u16 READ_ACK(void)
{
102dd6a0:	e24dd00c 	sub	sp, sp, #12
102dd6a4:	e59f7054 	ldr	r7, [pc, #84]	; 102dd700 <READ_ACK+0x68>
	s32 rdLen = -1;
	unsigned int count = 0;
	u8 UART_IPC_Read_Buffer = 0x00;

	while(rdLen <= 0 && count < 60000)
102dd6a8:	e59f6054 	ldr	r6, [pc, #84]	; 102dd704 <READ_ACK+0x6c>
 *****************************************************************/
u16 READ_ACK(void)
{
	s32 rdLen = -1;
	unsigned int count = 0;
	u8 UART_IPC_Read_Buffer = 0x00;
102dd6ac:	e28d5008 	add	r5, sp, #8
 *
 *****************************************************************/
u16 READ_ACK(void)
{
	s32 rdLen = -1;
	unsigned int count = 0;
102dd6b0:	e1a04003 	mov	r4, r3
	u8 UART_IPC_Read_Buffer = 0x00;
102dd6b4:	e5653001 	strb	r3, [r5, #-1]!

	while(rdLen <= 0 && count < 60000)
	{
		count++;
		rdLen = Ql_UART_Read(UART_PORT_IPC, &UART_IPC_Read_Buffer, 1);
102dd6b8:	e3a0000c 	mov	r0, #12
102dd6bc:	e1a01005 	mov	r1, r5
102dd6c0:	e3a02001 	mov	r2, #1
102dd6c4:	e12fff37 	blx	r7
	unsigned int count = 0;
	u8 UART_IPC_Read_Buffer = 0x00;

	while(rdLen <= 0 && count < 60000)
	{
		count++;
102dd6c8:	e2844001 	add	r4, r4, #1
{
	s32 rdLen = -1;
	unsigned int count = 0;
	u8 UART_IPC_Read_Buffer = 0x00;

	while(rdLen <= 0 && count < 60000)
102dd6cc:	e3500000 	cmp	r0, #0
102dd6d0:	c3a03000 	movgt	r3, #0
102dd6d4:	d3a03001 	movle	r3, #1
102dd6d8:	e1540006 	cmp	r4, r6
102dd6dc:	83a03000 	movhi	r3, #0
102dd6e0:	e3530000 	cmp	r3, #0
102dd6e4:	1afffff3 	bne	102dd6b8 <READ_ACK+0x20>
		rdLen = Ql_UART_Read(UART_PORT_IPC, &UART_IPC_Read_Buffer, 1);
	}
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("count:%d\r\n",count);
#endif
	if(rdLen <= 0)
102dd6e8:	e3500000 	cmp	r0, #0
		return count;
102dd6ec:	d1a00804 	lslle	r0, r4, #16
102dd6f0:	d1a00820 	lsrle	r0, r0, #16
	else
	{
#ifdef DEBUG_BOOT_MSG
		APP_DEBUG("get Read Echo:%d:%x:\r\n",rdLen,UART_IPC_Read_Buffer);
#endif
		return (u16) UART_IPC_Read_Buffer;
102dd6f4:	c5dd0007 	ldrbgt	r0, [sp, #7]
	}
}
102dd6f8:	e28dd00c 	add	sp, sp, #12
102dd6fc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
102dd700:	102e62a0 	.word	0x102e62a0
102dd704:	0000ea5f 	.word	0x0000ea5f

102dd708 <SET_RESET_BOOTLOADER_BTYE>:
 *
 * Return: void
 *
 *****************************************************************/
void SET_RESET_BOOTLOADER_BTYE(unsigned char set_reset)
{
102dd708:	e92d4030 	push	{r4, r5, lr}
	u8 command[5] = {0xFF, 0x01, 0x4E, 0x00, 0x00};
102dd70c:	e3a05005 	mov	r5, #5
 *
 * Return: void
 *
 *****************************************************************/
void SET_RESET_BOOTLOADER_BTYE(unsigned char set_reset)
{
102dd710:	e24dd00c 	sub	sp, sp, #12
102dd714:	e1a04000 	mov	r4, r0
	u8 command[5] = {0xFF, 0x01, 0x4E, 0x00, 0x00};
102dd718:	e1a02005 	mov	r2, r5
102dd71c:	e59f104c 	ldr	r1, [pc, #76]	; 102dd770 <SET_RESET_BOOTLOADER_BTYE+0x68>
102dd720:	e1a0000d 	mov	r0, sp
102dd724:	e59f3048 	ldr	r3, [pc, #72]	; 102dd774 <SET_RESET_BOOTLOADER_BTYE+0x6c>
102dd728:	e12fff33 	blx	r3

	command[3] = set_reset;

	for(index = 1;index < 4; index++)
	{
		sum += command[index];
102dd72c:	e5dd2002 	ldrb	r2, [sp, #2]
102dd730:	e5dd3001 	ldrb	r3, [sp, #1]


#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("SET_RESET_BOOTLOADER_BTYE:%x:\r\n",command[4]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 5);
102dd734:	e1a0100d 	mov	r1, sp

	command[3] = set_reset;

	for(index = 1;index < 4; index++)
	{
		sum += command[index];
102dd738:	e0823003 	add	r3, r2, r3
102dd73c:	e0833004 	add	r3, r3, r4
		APP_DEBUG("\r\n<-- SUM: and data %d 0x%2.2x-->\r\n",sum,command[index]);
#endif
	}

	//checksum is 2s complement of given sum
	command[4] = 256 - sum;
102dd740:	e2633000 	rsb	r3, r3, #0
102dd744:	e5cd3004 	strb	r3, [sp, #4]


#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("SET_RESET_BOOTLOADER_BTYE:%x:\r\n",command[4]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 5);
102dd748:	e1a02005 	mov	r2, r5
102dd74c:	e59f3024 	ldr	r3, [pc, #36]	; 102dd778 <SET_RESET_BOOTLOADER_BTYE+0x70>
102dd750:	e3a0000c 	mov	r0, #12
	u8 command[5] = {0xFF, 0x01, 0x4E, 0x00, 0x00};
	u8 *p = &command[0];
	u8 index = 0;
	u32 sum = 0;

	command[3] = set_reset;
102dd754:	e5cd4003 	strb	r4, [sp, #3]


#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("SET_RESET_BOOTLOADER_BTYE:%x:\r\n",command[4]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 5);
102dd758:	e12fff33 	blx	r3
	Ql_Sleep(200);          //wait to receive command on STM8
102dd75c:	e3a000c8 	mov	r0, #200	; 0xc8
102dd760:	e59f3014 	ldr	r3, [pc, #20]	; 102dd77c <SET_RESET_BOOTLOADER_BTYE+0x74>
102dd764:	e12fff33 	blx	r3

}
102dd768:	e28dd00c 	add	sp, sp, #12
102dd76c:	e8bd8030 	pop	{r4, r5, pc}
102dd770:	102eb150 	.word	0x102eb150
102dd774:	102df8c9 	.word	0x102df8c9
102dd778:	102e6230 	.word	0x102e6230
102dd77c:	102e5b10 	.word	0x102e5b10

102dd780 <SYNCHR_COMMAND>:
 *
 * Return: return Echo (ACK or NACK)
 *
 *****************************************************************/
u8 SYNCHR_COMMAND(void)
{
102dd780:	e92d4010 	push	{r4, lr}
	u8 data = 0x7F;
	u8 *p = &data;
	u8 UART_IPC_Read_Buffer[2] = {0x00};
102dd784:	e3a03000 	mov	r3, #0
 *
 * Return: return Echo (ACK or NACK)
 *
 *****************************************************************/
u8 SYNCHR_COMMAND(void)
{
102dd788:	e24dd008 	sub	sp, sp, #8
	u8 *p = &data;
	u8 UART_IPC_Read_Buffer[2] = {0x00};
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("SYNCHR_COMMAND \r\n");
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 1);
102dd78c:	e28d1003 	add	r1, sp, #3
102dd790:	e3a02001 	mov	r2, #1
 *****************************************************************/
u8 SYNCHR_COMMAND(void)
{
	u8 data = 0x7F;
	u8 *p = &data;
	u8 UART_IPC_Read_Buffer[2] = {0x00};
102dd794:	e1cd30b4 	strh	r3, [sp, #4]
 * Return: return Echo (ACK or NACK)
 *
 *****************************************************************/
u8 SYNCHR_COMMAND(void)
{
	u8 data = 0x7F;
102dd798:	e3a0407f 	mov	r4, #127	; 0x7f
	u8 *p = &data;
	u8 UART_IPC_Read_Buffer[2] = {0x00};
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("SYNCHR_COMMAND \r\n");
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 1);
102dd79c:	e59f3054 	ldr	r3, [pc, #84]	; 102dd7f8 <SYNCHR_COMMAND+0x78>
102dd7a0:	e3a0000c 	mov	r0, #12
 * Return: return Echo (ACK or NACK)
 *
 *****************************************************************/
u8 SYNCHR_COMMAND(void)
{
	u8 data = 0x7F;
102dd7a4:	e5cd4003 	strb	r4, [sp, #3]
	u8 *p = &data;
	u8 UART_IPC_Read_Buffer[2] = {0x00};
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("SYNCHR_COMMAND \r\n");
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 1);
102dd7a8:	e12fff33 	blx	r3
	Ql_Sleep(200);
102dd7ac:	e3a000c8 	mov	r0, #200	; 0xc8
102dd7b0:	e59f3044 	ldr	r3, [pc, #68]	; 102dd7fc <SYNCHR_COMMAND+0x7c>
102dd7b4:	e12fff33 	blx	r3
	Ql_UART_Read(UART_PORT_IPC, UART_IPC_Read_Buffer, sizeof(UART_IPC_Read_Buffer));
102dd7b8:	e59f3040 	ldr	r3, [pc, #64]	; 102dd800 <SYNCHR_COMMAND+0x80>
102dd7bc:	e3a0000c 	mov	r0, #12
102dd7c0:	e28d1004 	add	r1, sp, #4
102dd7c4:	e3a02002 	mov	r2, #2
102dd7c8:	e12fff33 	blx	r3
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("Read Echo6:%x:%x\r\n",UART_IPC_Read_Buffer[0],UART_IPC_Read_Buffer[1]);
#endif
	if(UART_IPC_Read_Buffer[0] == 0x79 || UART_IPC_Read_Buffer[1] == 0x79)
102dd7cc:	e5dd3004 	ldrb	r3, [sp, #4]
102dd7d0:	e3530079 	cmp	r3, #121	; 0x79
102dd7d4:	0a000005 	beq	102dd7f0 <SYNCHR_COMMAND+0x70>
102dd7d8:	e5dd3005 	ldrb	r3, [sp, #5]
102dd7dc:	e3530079 	cmp	r3, #121	; 0x79
102dd7e0:	0a000002 	beq	102dd7f0 <SYNCHR_COMMAND+0x70>
		return 0x79;
	else
		return 0x7F;
102dd7e4:	e1a00004 	mov	r0, r4
}
102dd7e8:	e28dd008 	add	sp, sp, #8
102dd7ec:	e8bd8010 	pop	{r4, pc}
	Ql_UART_Read(UART_PORT_IPC, UART_IPC_Read_Buffer, sizeof(UART_IPC_Read_Buffer));
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("Read Echo6:%x:%x\r\n",UART_IPC_Read_Buffer[0],UART_IPC_Read_Buffer[1]);
#endif
	if(UART_IPC_Read_Buffer[0] == 0x79 || UART_IPC_Read_Buffer[1] == 0x79)
		return 0x79;
102dd7f0:	e3a00079 	mov	r0, #121	; 0x79
102dd7f4:	eafffffb 	b	102dd7e8 <SYNCHR_COMMAND+0x68>
102dd7f8:	102e6230 	.word	0x102e6230
102dd7fc:	102e5b10 	.word	0x102e5b10
102dd800:	102e62a0 	.word	0x102e62a0

102dd804 <SEND_ECHO>:
 *
 * Return: void
 *
 *****************************************************************/
void SEND_ECHO(u8 command)
{
102dd804:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
102dd808:	e24dd00c 	sub	sp, sp, #12
102dd80c:	e28d1008 	add	r1, sp, #8
102dd810:	e5610001 	strb	r0, [r1, #-1]!
	u8 *p = &command;

	Ql_UART_Write(UART_PORT_IPC, p, 1);
102dd814:	e3a02001 	mov	r2, #1
102dd818:	e59f300c 	ldr	r3, [pc, #12]	; 102dd82c <SEND_ECHO+0x28>
102dd81c:	e3a0000c 	mov	r0, #12
102dd820:	e12fff33 	blx	r3
}
102dd824:	e28dd00c 	add	sp, sp, #12
102dd828:	e8bd8000 	ldmfd	sp!, {pc}
102dd82c:	102e6230 	.word	0x102e6230

102dd830 <GET_COMMAND>:
 *
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 GET_COMMAND(void)
{
102dd830:	e92d4010 	push	{r4, lr}
	u8 command[2] = {0x00, 0xFF};
102dd834:	e3a03000 	mov	r3, #0
 *
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 GET_COMMAND(void)
{
102dd838:	e24dd008 	sub	sp, sp, #8
	u8 command[2] = {0x00, 0xFF};
102dd83c:	e5cd3004 	strb	r3, [sp, #4]
102dd840:	e3e03000 	mvn	r3, #0
	u8 *p = &command[0];
	u8 UART_IPC_Read_Buffer = 0x00;
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("GET_COMMAND\r\n");
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102dd844:	e28d1004 	add	r1, sp, #4
102dd848:	e3a02002 	mov	r2, #2
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 GET_COMMAND(void)
{
	u8 command[2] = {0x00, 0xFF};
102dd84c:	e5cd3005 	strb	r3, [sp, #5]
	u8 *p = &command[0];
	u8 UART_IPC_Read_Buffer = 0x00;
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("GET_COMMAND\r\n");
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102dd850:	e3a0000c 	mov	r0, #12
102dd854:	e59f30e4 	ldr	r3, [pc, #228]	; 102dd940 <GET_COMMAND+0x110>
102dd858:	e12fff33 	blx	r3
	UART_IPC_Read_Buffer = READ_ACK();
102dd85c:	ebffff8d 	bl	102dd698 <READ_ACK>
102dd860:	e20040ff 	and	r4, r0, #255	; 0xff

	if(UART_IPC_Read_Buffer == 0x79)
102dd864:	e3540079 	cmp	r4, #121	; 0x79
102dd868:	0a000002 	beq	102dd878 <GET_COMMAND+0x48>
			}
		}
	}

	return UART_IPC_Read_Buffer;
}
102dd86c:	e1a00004 	mov	r0, r4
102dd870:	e28dd008 	add	sp, sp, #8
102dd874:	e8bd8010 	pop	{r4, pc}
	Ql_UART_Write(UART_PORT_IPC, p, 2);
	UART_IPC_Read_Buffer = READ_ACK();

	if(UART_IPC_Read_Buffer == 0x79)
	{
		SEND_ECHO(UART_IPC_Read_Buffer);
102dd878:	e1a00004 	mov	r0, r4
102dd87c:	ebffffe0 	bl	102dd804 <SEND_ECHO>
		UART_IPC_Read_Buffer = READ_ACK();
102dd880:	ebffff84 	bl	102dd698 <READ_ACK>
102dd884:	e20040ff 	and	r4, r0, #255	; 0xff
		if(UART_IPC_Read_Buffer == 0x05)
102dd888:	e3540005 	cmp	r4, #5
102dd88c:	1afffff6 	bne	102dd86c <GET_COMMAND+0x3c>
		{
			SEND_ECHO(UART_IPC_Read_Buffer);
102dd890:	e1a00004 	mov	r0, r4
102dd894:	ebffffda 	bl	102dd804 <SEND_ECHO>
			UART_IPC_Read_Buffer = READ_ACK();
102dd898:	ebffff7e 	bl	102dd698 <READ_ACK>
102dd89c:	e20040ff 	and	r4, r0, #255	; 0xff
			if(UART_IPC_Read_Buffer == 0x13)
102dd8a0:	e3540013 	cmp	r4, #19
102dd8a4:	1afffff0 	bne	102dd86c <GET_COMMAND+0x3c>
			{
				SEND_ECHO(UART_IPC_Read_Buffer);
102dd8a8:	e1a00004 	mov	r0, r4
102dd8ac:	ebffffd4 	bl	102dd804 <SEND_ECHO>
				UART_IPC_Read_Buffer = READ_ACK();
102dd8b0:	ebffff78 	bl	102dd698 <READ_ACK>
				if(UART_IPC_Read_Buffer == 0x00)
102dd8b4:	e21040ff 	ands	r4, r0, #255	; 0xff
102dd8b8:	1affffeb 	bne	102dd86c <GET_COMMAND+0x3c>
				{
					SEND_ECHO(UART_IPC_Read_Buffer);
102dd8bc:	e1a00004 	mov	r0, r4
102dd8c0:	ebffffcf 	bl	102dd804 <SEND_ECHO>
					UART_IPC_Read_Buffer = READ_ACK();
102dd8c4:	ebffff73 	bl	102dd698 <READ_ACK>
102dd8c8:	e20040ff 	and	r4, r0, #255	; 0xff
					if(UART_IPC_Read_Buffer == 0x11)
102dd8cc:	e3540011 	cmp	r4, #17
102dd8d0:	1affffe5 	bne	102dd86c <GET_COMMAND+0x3c>
					{
						SEND_ECHO(UART_IPC_Read_Buffer);
102dd8d4:	e1a00004 	mov	r0, r4
102dd8d8:	ebffffc9 	bl	102dd804 <SEND_ECHO>
						UART_IPC_Read_Buffer = READ_ACK();
102dd8dc:	ebffff6d 	bl	102dd698 <READ_ACK>
102dd8e0:	e20040ff 	and	r4, r0, #255	; 0xff
						if(UART_IPC_Read_Buffer == 0x21)
102dd8e4:	e3540021 	cmp	r4, #33	; 0x21
102dd8e8:	1affffdf 	bne	102dd86c <GET_COMMAND+0x3c>
						{
							SEND_ECHO(UART_IPC_Read_Buffer);
102dd8ec:	e1a00004 	mov	r0, r4
102dd8f0:	ebffffc3 	bl	102dd804 <SEND_ECHO>
							UART_IPC_Read_Buffer = READ_ACK();
102dd8f4:	ebffff67 	bl	102dd698 <READ_ACK>
102dd8f8:	e20040ff 	and	r4, r0, #255	; 0xff
							if(UART_IPC_Read_Buffer == 0x31)
102dd8fc:	e3540031 	cmp	r4, #49	; 0x31
102dd900:	1affffd9 	bne	102dd86c <GET_COMMAND+0x3c>
							{
								SEND_ECHO(UART_IPC_Read_Buffer);
102dd904:	e1a00004 	mov	r0, r4
102dd908:	ebffffbd 	bl	102dd804 <SEND_ECHO>
								UART_IPC_Read_Buffer = READ_ACK();
102dd90c:	ebffff61 	bl	102dd698 <READ_ACK>
102dd910:	e20040ff 	and	r4, r0, #255	; 0xff
								if(UART_IPC_Read_Buffer == 0x43)
102dd914:	e3540043 	cmp	r4, #67	; 0x43
102dd918:	1affffd3 	bne	102dd86c <GET_COMMAND+0x3c>
								{
									SEND_ECHO(UART_IPC_Read_Buffer);
102dd91c:	e1a00004 	mov	r0, r4
102dd920:	ebffffb7 	bl	102dd804 <SEND_ECHO>
									UART_IPC_Read_Buffer = READ_ACK();
102dd924:	ebffff5b 	bl	102dd698 <READ_ACK>
102dd928:	e20040ff 	and	r4, r0, #255	; 0xff
									if(UART_IPC_Read_Buffer == 0x79)
102dd92c:	e3540079 	cmp	r4, #121	; 0x79
102dd930:	1affffcd 	bne	102dd86c <GET_COMMAND+0x3c>
									{
										SEND_ECHO(UART_IPC_Read_Buffer);
102dd934:	e1a00004 	mov	r0, r4
102dd938:	ebffffb1 	bl	102dd804 <SEND_ECHO>
102dd93c:	eaffffca 	b	102dd86c <GET_COMMAND+0x3c>
102dd940:	102e6230 	.word	0x102e6230

102dd944 <WRITE_COMMAND>:
 *
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 WRITE_COMMAND(unsigned int address,unsigned char length, char data[])
{
102dd944:	e92d4070 	push	{r4, r5, r6, lr}
102dd948:	e24dd018 	sub	sp, sp, #24
102dd94c:	e5cd1007 	strb	r1, [sp, #7]
	u8 command[2] = {0x31, 0xCE};
102dd950:	e59f3128 	ldr	r3, [pc, #296]	; 102dda80 <WRITE_COMMAND+0x13c>
102dd954:	e59f1128 	ldr	r1, [pc, #296]	; 102dda84 <WRITE_COMMAND+0x140>
 *
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 WRITE_COMMAND(unsigned int address,unsigned char length, char data[])
{
102dd958:	e1a04000 	mov	r4, r0
102dd95c:	e1a05002 	mov	r5, r2
	u8 command[2] = {0x31, 0xCE};
102dd960:	e28d000c 	add	r0, sp, #12
102dd964:	e3a02002 	mov	r2, #2
102dd968:	e12fff33 	blx	r3
	u8 a[5]={0x00},i,checksum=0;
102dd96c:	e3a01000 	mov	r1, #0
 * Parameters: address, length of data and data array
 *
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 WRITE_COMMAND(unsigned int address,unsigned char length, char data[])
102dd970:	e28d200f 	add	r2, sp, #15
{
	u8 command[2] = {0x31, 0xCE};
	u8 a[5]={0x00},i,checksum=0;
102dd974:	e3a03018 	mov	r3, #24
102dd978:	e58d1010 	str	r1, [sp, #16]
102dd97c:	e5cd1014 	strb	r1, [sp, #20]

	u8 UART_IPC_Read_Buffer = 0x00;

	for(i=0;i<4;i++)
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
102dd980:	e1a0c334 	lsr	ip, r4, r3
102dd984:	e20cc0ff 	and	ip, ip, #255	; 0xff
102dd988:	e5e2c001 	strb	ip, [r2, #1]!
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
102dd98c:	e5dd1014 	ldrb	r1, [sp, #20]
102dd990:	e2433008 	sub	r3, r3, #8
102dd994:	e02cc001 	eor	ip, ip, r1
	u8 *s = (u8 *)&data[0];
	u8 *t = &checksum;

	u8 UART_IPC_Read_Buffer = 0x00;

	for(i=0;i<4;i++)
102dd998:	e3730008 	cmn	r3, #8
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
102dd99c:	e5cdc014 	strb	ip, [sp, #20]
	u8 *s = (u8 *)&data[0];
	u8 *t = &checksum;

	u8 UART_IPC_Read_Buffer = 0x00;

	for(i=0;i<4;i++)
102dd9a0:	1afffff6 	bne	102dd980 <WRITE_COMMAND+0x3c>
102dd9a4:	e3a00000 	mov	r0, #0
102dd9a8:	e5dd4007 	ldrb	r4, [sp, #7]
102dd9ac:	e1a03000 	mov	r3, r0
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
	}
	for(i=0;i<length+1;i++)
102dd9b0:	e283e001 	add	lr, r3, #1
		checksum = checksum ^ data[i];          //XOR operation for checksum
102dd9b4:	e7d5c003 	ldrb	ip, [r5, r3]
	for(i=0;i<4;i++)
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
	}
	for(i=0;i<length+1;i++)
102dd9b8:	e20e30ff 	and	r3, lr, #255	; 0xff
102dd9bc:	e1530004 	cmp	r3, r4
		checksum = checksum ^ data[i];          //XOR operation for checksum
102dd9c0:	e020000c 	eor	r0, r0, ip
	for(i=0;i<4;i++)
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
	}
	for(i=0;i<length+1;i++)
102dd9c4:	dafffff9 	ble	102dd9b0 <WRITE_COMMAND+0x6c>
		checksum = checksum ^ data[i];          //XOR operation for checksum

	checksum = checksum ^ length;                   //XOR operation for checksum
102dd9c8:	e0204004 	eor	r4, r0, r4
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("WRITE_COMMAND:%x:%x:%x:\r\n", address, checksum, data[0]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102dd9cc:	e28d100c 	add	r1, sp, #12
102dd9d0:	e3a02002 	mov	r2, #2
102dd9d4:	e3a0000c 	mov	r0, #12
102dd9d8:	e59f60a8 	ldr	r6, [pc, #168]	; 102dda88 <WRITE_COMMAND+0x144>
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
	}
	for(i=0;i<length+1;i++)
		checksum = checksum ^ data[i];          //XOR operation for checksum

	checksum = checksum ^ length;                   //XOR operation for checksum
102dd9dc:	e5cd400b 	strb	r4, [sp, #11]
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("WRITE_COMMAND:%x:%x:%x:\r\n", address, checksum, data[0]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102dd9e0:	e12fff36 	blx	r6
	UART_IPC_Read_Buffer = READ_ACK();
102dd9e4:	ebffff2b 	bl	102dd698 <READ_ACK>
102dd9e8:	e20040ff 	and	r4, r0, #255	; 0xff
	if(UART_IPC_Read_Buffer == 0x79)
102dd9ec:	e3540079 	cmp	r4, #121	; 0x79
102dd9f0:	0a000002 	beq	102dda00 <WRITE_COMMAND+0xbc>
			}
		}
	}

	return UART_IPC_Read_Buffer;
}
102dd9f4:	e1a00004 	mov	r0, r4
102dd9f8:	e28dd018 	add	sp, sp, #24
102dd9fc:	e8bd8070 	pop	{r4, r5, r6, pc}
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
	UART_IPC_Read_Buffer = READ_ACK();
	if(UART_IPC_Read_Buffer == 0x79)
	{
		SEND_ECHO(UART_IPC_Read_Buffer);
102dda00:	e1a00004 	mov	r0, r4
102dda04:	ebffff7e 	bl	102dd804 <SEND_ECHO>
		Ql_UART_Write(UART_PORT_IPC, q, 5);
102dda08:	e28d1010 	add	r1, sp, #16
102dda0c:	e3a02005 	mov	r2, #5
102dda10:	e3a0000c 	mov	r0, #12
102dda14:	e12fff36 	blx	r6
		UART_IPC_Read_Buffer = READ_ACK();
102dda18:	ebffff1e 	bl	102dd698 <READ_ACK>
102dda1c:	e20040ff 	and	r4, r0, #255	; 0xff
		if(UART_IPC_Read_Buffer == 0x79)
102dda20:	e3540079 	cmp	r4, #121	; 0x79
102dda24:	1afffff2 	bne	102dd9f4 <WRITE_COMMAND+0xb0>
		{
			SEND_ECHO(UART_IPC_Read_Buffer);
102dda28:	e1a00004 	mov	r0, r4
102dda2c:	ebffff74 	bl	102dd804 <SEND_ECHO>
			Ql_UART_Write(UART_PORT_IPC, r, 1);
102dda30:	e28d1007 	add	r1, sp, #7
102dda34:	e3a02001 	mov	r2, #1
102dda38:	e3a0000c 	mov	r0, #12
102dda3c:	e12fff36 	blx	r6
			Ql_UART_Write(UART_PORT_IPC, s, length+1);
102dda40:	e5dd2007 	ldrb	r2, [sp, #7]
102dda44:	e1a01005 	mov	r1, r5
102dda48:	e2822001 	add	r2, r2, #1
102dda4c:	e3a0000c 	mov	r0, #12
102dda50:	e12fff36 	blx	r6
			Ql_UART_Write(UART_PORT_IPC, t, 1);
102dda54:	e28d100b 	add	r1, sp, #11
102dda58:	e3a02001 	mov	r2, #1
102dda5c:	e3a0000c 	mov	r0, #12
102dda60:	e12fff36 	blx	r6
			UART_IPC_Read_Buffer = READ_ACK();
102dda64:	ebffff0b 	bl	102dd698 <READ_ACK>
102dda68:	e20040ff 	and	r4, r0, #255	; 0xff
			if(UART_IPC_Read_Buffer == 0x79)
102dda6c:	e3540079 	cmp	r4, #121	; 0x79
102dda70:	1affffdf 	bne	102dd9f4 <WRITE_COMMAND+0xb0>
			{
				SEND_ECHO(UART_IPC_Read_Buffer);
102dda74:	e1a00004 	mov	r0, r4
102dda78:	ebffff61 	bl	102dd804 <SEND_ECHO>
102dda7c:	eaffffdc 	b	102dd9f4 <WRITE_COMMAND+0xb0>
102dda80:	102df8c9 	.word	0x102df8c9
102dda84:	102eb158 	.word	0x102eb158
102dda88:	102e6230 	.word	0x102e6230

102dda8c <READ_COMMAND>:
 *
 * Return: void
 *
 *****************************************************************/
void READ_COMMAND(unsigned int address,unsigned char length)
{
102dda8c:	e92d4010 	push	{r4, lr}
102dda90:	e24dd018 	sub	sp, sp, #24
102dda94:	e5cd1007 	strb	r1, [sp, #7]
	u8 command[2] = {0x11, 0xEE};
102dda98:	e3a02002 	mov	r2, #2
102dda9c:	e59f1100 	ldr	r1, [pc, #256]	; 102ddba4 <READ_COMMAND+0x118>
102ddaa0:	e59f3100 	ldr	r3, [pc, #256]	; 102ddba8 <READ_COMMAND+0x11c>
 *
 * Return: void
 *
 *****************************************************************/
void READ_COMMAND(unsigned int address,unsigned char length)
{
102ddaa4:	e1a04000 	mov	r4, r0
	u8 command[2] = {0x11, 0xEE};
102ddaa8:	e28d000c 	add	r0, sp, #12
102ddaac:	e12fff33 	blx	r3
	unsigned char lenght_compliment;
	u8 a[5]={0x00},i;
102ddab0:	e3a02000 	mov	r2, #0
 * Parameters: address, length of data
 *
 * Return: void
 *
 *****************************************************************/
void READ_COMMAND(unsigned int address,unsigned char length)
102ddab4:	e28d100f 	add	r1, sp, #15
{
	u8 command[2] = {0x11, 0xEE};
	unsigned char lenght_compliment;
	u8 a[5]={0x00},i;
102ddab8:	e3a03018 	mov	r3, #24
102ddabc:	e58d2010 	str	r2, [sp, #16]
102ddac0:	e5cd2014 	strb	r2, [sp, #20]
	u8 *r = &length;
	u8 UART_IPC_Read_Buffer[0x2F] = {0x00};

	for(i=0;i<4;i++)
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
102ddac4:	e1a02334 	lsr	r2, r4, r3
102ddac8:	e20220ff 	and	r2, r2, #255	; 0xff
102ddacc:	e5e12001 	strb	r2, [r1, #1]!
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
102ddad0:	e5ddc014 	ldrb	ip, [sp, #20]
102ddad4:	e2433008 	sub	r3, r3, #8
102ddad8:	e022200c 	eor	r2, r2, ip
	u8 *p = &command[0];
	u8 *q = &a[0];
	u8 *r = &length;
	u8 UART_IPC_Read_Buffer[0x2F] = {0x00};

	for(i=0;i<4;i++)
102ddadc:	e3730008 	cmn	r3, #8
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
102ddae0:	e5cd2014 	strb	r2, [sp, #20]
	u8 *p = &command[0];
	u8 *q = &a[0];
	u8 *r = &length;
	u8 UART_IPC_Read_Buffer[0x2F] = {0x00};

	for(i=0;i<4;i++)
102ddae4:	1afffff6 	bne	102ddac4 <READ_COMMAND+0x38>
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
	}

	lenght_compliment = 0xFF - length;
102ddae8:	e5dd3007 	ldrb	r3, [sp, #7]
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("READ_COMMAND2:%x:%x:%x:%x:%x\r\n",a[4],a[3],a[2],a[1],a[0]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102ddaec:	e28d100c 	add	r1, sp, #12
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
	}

	lenght_compliment = 0xFF - length;
102ddaf0:	e1e03003 	mvn	r3, r3
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("READ_COMMAND2:%x:%x:%x:%x:%x\r\n",a[4],a[3],a[2],a[1],a[0]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102ddaf4:	e3a02002 	mov	r2, #2
102ddaf8:	e3a0000c 	mov	r0, #12
102ddafc:	e59f40a8 	ldr	r4, [pc, #168]	; 102ddbac <READ_COMMAND+0x120>
	{
		a[i] = (unsigned char) (address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
	}

	lenght_compliment = 0xFF - length;
102ddb00:	e5cd300b 	strb	r3, [sp, #11]
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("READ_COMMAND2:%x:%x:%x:%x:%x\r\n",a[4],a[3],a[2],a[1],a[0]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102ddb04:	e12fff34 	blx	r4
	UART_IPC_Read_Buffer[0] = READ_ACK();
102ddb08:	ebfffee2 	bl	102dd698 <READ_ACK>
	if(UART_IPC_Read_Buffer[0] == 0x79)
102ddb0c:	e20000ff 	and	r0, r0, #255	; 0xff
102ddb10:	e3500079 	cmp	r0, #121	; 0x79
102ddb14:	0a000001 	beq	102ddb20 <READ_COMMAND+0x94>
					SEND_ECHO(UART_IPC_Read_Buffer[i]);
				}
			}
		}
	}
}
102ddb18:	e28dd018 	add	sp, sp, #24
102ddb1c:	e8bd8010 	pop	{r4, pc}
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
	UART_IPC_Read_Buffer[0] = READ_ACK();
	if(UART_IPC_Read_Buffer[0] == 0x79)
	{
		SEND_ECHO(UART_IPC_Read_Buffer[0]);
102ddb20:	ebffff37 	bl	102dd804 <SEND_ECHO>
		Ql_UART_Write(UART_PORT_IPC, q, 5);
102ddb24:	e28d1010 	add	r1, sp, #16
102ddb28:	e3a02005 	mov	r2, #5
102ddb2c:	e3a0000c 	mov	r0, #12
102ddb30:	e12fff34 	blx	r4
		UART_IPC_Read_Buffer[0] = READ_ACK();
102ddb34:	ebfffed7 	bl	102dd698 <READ_ACK>
		if(UART_IPC_Read_Buffer[0] == 0x79)
102ddb38:	e20000ff 	and	r0, r0, #255	; 0xff
102ddb3c:	e3500079 	cmp	r0, #121	; 0x79
102ddb40:	1afffff4 	bne	102ddb18 <READ_COMMAND+0x8c>
		{
			SEND_ECHO(UART_IPC_Read_Buffer[0]);
102ddb44:	ebffff2e 	bl	102dd804 <SEND_ECHO>
			Ql_UART_Write(UART_PORT_IPC, r, 1);
102ddb48:	e28d1007 	add	r1, sp, #7
102ddb4c:	e3a02001 	mov	r2, #1
102ddb50:	e3a0000c 	mov	r0, #12
102ddb54:	e12fff34 	blx	r4
			r = &lenght_compliment;
			Ql_UART_Write(UART_PORT_IPC, r, 1);
102ddb58:	e28d100b 	add	r1, sp, #11
102ddb5c:	e3a02001 	mov	r2, #1
102ddb60:	e3a0000c 	mov	r0, #12
102ddb64:	e12fff34 	blx	r4
			UART_IPC_Read_Buffer[0] = READ_ACK();
102ddb68:	ebfffeca 	bl	102dd698 <READ_ACK>
			if(UART_IPC_Read_Buffer[0] == 0x79)
102ddb6c:	e20000ff 	and	r0, r0, #255	; 0xff
102ddb70:	e3500079 	cmp	r0, #121	; 0x79
102ddb74:	1affffe7 	bne	102ddb18 <READ_COMMAND+0x8c>
			{
				SEND_ECHO(UART_IPC_Read_Buffer[0]);
102ddb78:	ebffff21 	bl	102dd804 <SEND_ECHO>
				for(i=0;i<length+1;i++)
102ddb7c:	e3a04000 	mov	r4, #0
				{
					UART_IPC_Read_Buffer[i] = READ_ACK();
102ddb80:	ebfffec4 	bl	102dd698 <READ_ACK>
			Ql_UART_Write(UART_PORT_IPC, r, 1);
			UART_IPC_Read_Buffer[0] = READ_ACK();
			if(UART_IPC_Read_Buffer[0] == 0x79)
			{
				SEND_ECHO(UART_IPC_Read_Buffer[0]);
				for(i=0;i<length+1;i++)
102ddb84:	e2844001 	add	r4, r4, #1
102ddb88:	e20440ff 	and	r4, r4, #255	; 0xff
				{
					UART_IPC_Read_Buffer[i] = READ_ACK();
					SEND_ECHO(UART_IPC_Read_Buffer[i]);
102ddb8c:	e20000ff 	and	r0, r0, #255	; 0xff
102ddb90:	ebffff1b 	bl	102dd804 <SEND_ECHO>
			Ql_UART_Write(UART_PORT_IPC, r, 1);
			UART_IPC_Read_Buffer[0] = READ_ACK();
			if(UART_IPC_Read_Buffer[0] == 0x79)
			{
				SEND_ECHO(UART_IPC_Read_Buffer[0]);
				for(i=0;i<length+1;i++)
102ddb94:	e5dd3007 	ldrb	r3, [sp, #7]
102ddb98:	e1530004 	cmp	r3, r4
102ddb9c:	aafffff7 	bge	102ddb80 <READ_COMMAND+0xf4>
102ddba0:	eaffffdc 	b	102ddb18 <READ_COMMAND+0x8c>
102ddba4:	102eb15c 	.word	0x102eb15c
102ddba8:	102df8c9 	.word	0x102df8c9
102ddbac:	102e6230 	.word	0x102e6230

102ddbb0 <ERASE_SECTOR_COMMAND>:
 *
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 ERASE_SECTOR_COMMAND(unsigned char total_sec_to_erase, unsigned char start_num)
{
102ddbb0:	e92d4070 	push	{r4, r5, r6, lr}
102ddbb4:	e24dd010 	sub	sp, sp, #16
102ddbb8:	e1a04001 	mov	r4, r1
	u8 sec_num = total_sec_to_erase - 1;
102ddbbc:	e2406001 	sub	r6, r0, #1
	u8 command[2] = {0x43, 0xBC};
102ddbc0:	e59f10dc 	ldr	r1, [pc, #220]	; 102ddca4 <ERASE_SECTOR_COMMAND+0xf4>
102ddbc4:	e3a02002 	mov	r2, #2
102ddbc8:	e59f30d8 	ldr	r3, [pc, #216]	; 102ddca8 <ERASE_SECTOR_COMMAND+0xf8>
102ddbcc:	e1a0000d 	mov	r0, sp
102ddbd0:	e12fff33 	blx	r3
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 ERASE_SECTOR_COMMAND(unsigned char total_sec_to_erase, unsigned char start_num)
{
	u8 sec_num = total_sec_to_erase - 1;
102ddbd4:	e20660ff 	and	r6, r6, #255	; 0xff
	u8 command[2] = {0x43, 0xBC};
	u8 *p = &command[0];
	u8 sector_code[12] = {0x00} ,sector_checksum = 0;
102ddbd8:	e3a02000 	mov	r2, #0
	u8 i,UART_IPC_Read_Buffer = 0x00;
	u8 *q = &sector_code[0];

	sector_code[0] = sec_num;
	for(i=1;i<sec_num+2;i++)
102ddbdc:	e3a0c001 	mov	ip, #1
102ddbe0:	e2441001 	sub	r1, r4, #1
102ddbe4:	e086500c 	add	r5, r6, ip
102ddbe8:	e20110ff 	and	r1, r1, #255	; 0xff
102ddbec:	e1a0300c 	mov	r3, ip
u8 ERASE_SECTOR_COMMAND(unsigned char total_sec_to_erase, unsigned char start_num)
{
	u8 sec_num = total_sec_to_erase - 1;
	u8 command[2] = {0x43, 0xBC};
	u8 *p = &command[0];
	u8 sector_code[12] = {0x00} ,sector_checksum = 0;
102ddbf0:	e1a0e002 	mov	lr, r2
102ddbf4:	e58d2004 	str	r2, [sp, #4]
102ddbf8:	e58d2008 	str	r2, [sp, #8]
102ddbfc:	e58d200c 	str	r2, [sp, #12]
	u8 i,UART_IPC_Read_Buffer = 0x00;
	u8 *q = &sector_code[0];

	sector_code[0] = sec_num;
102ddc00:	e5cd6004 	strb	r6, [sp, #4]
	for(i=1;i<sec_num+2;i++)
102ddc04:	e2834001 	add	r4, r3, #1
 * Parameters: sec_num (total numbers of sector to be erase), start_num: start number of sector
 *
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 ERASE_SECTOR_COMMAND(unsigned char total_sec_to_erase, unsigned char start_num)
102ddc08:	e0810003 	add	r0, r1, r3
	u8 *q = &sector_code[0];

	sector_code[0] = sec_num;
	for(i=1;i<sec_num+2;i++)
	{
		sector_code[i] = i+start_num-1;
102ddc0c:	e28d2010 	add	r2, sp, #16
	u8 sector_code[12] = {0x00} ,sector_checksum = 0;
	u8 i,UART_IPC_Read_Buffer = 0x00;
	u8 *q = &sector_code[0];

	sector_code[0] = sec_num;
	for(i=1;i<sec_num+2;i++)
102ddc10:	e20430ff 	and	r3, r4, #255	; 0xff
 * Parameters: sec_num (total numbers of sector to be erase), start_num: start number of sector
 *
 * Return: IPC ACK or NACK
 *
 *****************************************************************/
u8 ERASE_SECTOR_COMMAND(unsigned char total_sec_to_erase, unsigned char start_num)
102ddc14:	e20000ff 	and	r0, r0, #255	; 0xff
	u8 *q = &sector_code[0];

	sector_code[0] = sec_num;
	for(i=1;i<sec_num+2;i++)
	{
		sector_code[i] = i+start_num-1;
102ddc18:	e082c00c 	add	ip, r2, ip
	u8 sector_code[12] = {0x00} ,sector_checksum = 0;
	u8 i,UART_IPC_Read_Buffer = 0x00;
	u8 *q = &sector_code[0];

	sector_code[0] = sec_num;
	for(i=1;i<sec_num+2;i++)
102ddc1c:	e1530005 	cmp	r3, r5
	{
		sector_code[i] = i+start_num-1;
102ddc20:	e54c000c 	strb	r0, [ip, #-12]
		sector_checksum = sector_checksum ^ sector_code[i];
102ddc24:	e020e00e 	eor	lr, r0, lr
	u8 sector_code[12] = {0x00} ,sector_checksum = 0;
	u8 i,UART_IPC_Read_Buffer = 0x00;
	u8 *q = &sector_code[0];

	sector_code[0] = sec_num;
	for(i=1;i<sec_num+2;i++)
102ddc28:	e1a0c003 	mov	ip, r3
102ddc2c:	dafffff4 	ble	102ddc04 <ERASE_SECTOR_COMMAND+0x54>
	{
		sector_code[i] = i+start_num-1;
		sector_checksum = sector_checksum ^ sector_code[i];
	}
	sector_checksum = sector_checksum ^ sec_num;
	sector_code[sec_num+2] = sector_checksum;
102ddc30:	e28dc010 	add	ip, sp, #16
	for(i=1;i<sec_num+2;i++)
	{
		sector_code[i] = i+start_num-1;
		sector_checksum = sector_checksum ^ sector_code[i];
	}
	sector_checksum = sector_checksum ^ sec_num;
102ddc34:	e02ee006 	eor	lr, lr, r6
	sector_code[sec_num+2] = sector_checksum;
102ddc38:	e08c3006 	add	r3, ip, r6
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("ERASE_SECTOR_COMMAND:%x\r\n",sector_checksum);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102ddc3c:	e1a0100d 	mov	r1, sp
102ddc40:	e3a02002 	mov	r2, #2
102ddc44:	e3a0000c 	mov	r0, #12
102ddc48:	e59f505c 	ldr	r5, [pc, #92]	; 102ddcac <ERASE_SECTOR_COMMAND+0xfc>
	{
		sector_code[i] = i+start_num-1;
		sector_checksum = sector_checksum ^ sector_code[i];
	}
	sector_checksum = sector_checksum ^ sec_num;
	sector_code[sec_num+2] = sector_checksum;
102ddc4c:	e543e00a 	strb	lr, [r3, #-10]
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("ERASE_SECTOR_COMMAND:%x\r\n",sector_checksum);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102ddc50:	e12fff35 	blx	r5
	UART_IPC_Read_Buffer = READ_ACK();
102ddc54:	ebfffe8f 	bl	102dd698 <READ_ACK>
102ddc58:	e20040ff 	and	r4, r0, #255	; 0xff
	if(UART_IPC_Read_Buffer == 0x79)
102ddc5c:	e3540079 	cmp	r4, #121	; 0x79
102ddc60:	0a000002 	beq	102ddc70 <ERASE_SECTOR_COMMAND+0xc0>
		{
			SEND_ECHO(UART_IPC_Read_Buffer);
		}
	}
	return UART_IPC_Read_Buffer;
}
102ddc64:	e1a00004 	mov	r0, r4
102ddc68:	e28dd010 	add	sp, sp, #16
102ddc6c:	e8bd8070 	pop	{r4, r5, r6, pc}
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
	UART_IPC_Read_Buffer = READ_ACK();
	if(UART_IPC_Read_Buffer == 0x79)
	{
		SEND_ECHO(UART_IPC_Read_Buffer);
102ddc70:	e1a00004 	mov	r0, r4
102ddc74:	ebfffee2 	bl	102dd804 <SEND_ECHO>
		Ql_UART_Write(UART_PORT_IPC, q, sec_num+3);
102ddc78:	e28d1004 	add	r1, sp, #4
102ddc7c:	e2862003 	add	r2, r6, #3
102ddc80:	e3a0000c 	mov	r0, #12
102ddc84:	e12fff35 	blx	r5
		UART_IPC_Read_Buffer = READ_ACK();
102ddc88:	ebfffe82 	bl	102dd698 <READ_ACK>
102ddc8c:	e20040ff 	and	r4, r0, #255	; 0xff
		if(UART_IPC_Read_Buffer == 0x79)
102ddc90:	e3540079 	cmp	r4, #121	; 0x79
102ddc94:	1afffff2 	bne	102ddc64 <ERASE_SECTOR_COMMAND+0xb4>
		{
			SEND_ECHO(UART_IPC_Read_Buffer);
102ddc98:	e1a00004 	mov	r0, r4
102ddc9c:	ebfffed8 	bl	102dd804 <SEND_ECHO>
102ddca0:	eaffffef 	b	102ddc64 <ERASE_SECTOR_COMMAND+0xb4>
102ddca4:	102eb160 	.word	0x102eb160
102ddca8:	102df8c9 	.word	0x102df8c9
102ddcac:	102e6230 	.word	0x102e6230

102ddcb0 <GO_COMMAND>:
 *
 * Return: void
 *
 *****************************************************************/
void GO_COMMAND(unsigned int jump_address)
{
102ddcb0:	e92d4010 	push	{r4, lr}
102ddcb4:	e24dd010 	sub	sp, sp, #16
	u8 command[2] = {0x21, 0xDE};
102ddcb8:	e59f10a0 	ldr	r1, [pc, #160]	; 102ddd60 <GO_COMMAND+0xb0>
102ddcbc:	e3a02002 	mov	r2, #2
102ddcc0:	e59f309c 	ldr	r3, [pc, #156]	; 102ddd64 <GO_COMMAND+0xb4>
 *
 * Return: void
 *
 *****************************************************************/
void GO_COMMAND(unsigned int jump_address)
{
102ddcc4:	e1a04000 	mov	r4, r0
	u8 command[2] = {0x21, 0xDE};
102ddcc8:	e28d0004 	add	r0, sp, #4
102ddccc:	e12fff33 	blx	r3
	u8 *p = &command[0];
	u8 UART_IPC_Read_Buffer = 0x00;
	u8 a[5] = {0x00}, i;
102ddcd0:	e3a02000 	mov	r2, #0
 * Parameters: void
 *
 * Return: void
 *
 *****************************************************************/
void GO_COMMAND(unsigned int jump_address)
102ddcd4:	e28d1007 	add	r1, sp, #7
{
	u8 command[2] = {0x21, 0xDE};
	u8 *p = &command[0];
	u8 UART_IPC_Read_Buffer = 0x00;
	u8 a[5] = {0x00}, i;
102ddcd8:	e3a03018 	mov	r3, #24
102ddcdc:	e58d2008 	str	r2, [sp, #8]
102ddce0:	e5cd200c 	strb	r2, [sp, #12]
	u8 *q = &a[0];

	for(i=0;i<4;i++)
	{
		a[i] = (unsigned char) (jump_address>>(24-(8*i)));
102ddce4:	e1a02334 	lsr	r2, r4, r3
102ddce8:	e20220ff 	and	r2, r2, #255	; 0xff
102ddcec:	e5e12001 	strb	r2, [r1, #1]!
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
102ddcf0:	e5ddc00c 	ldrb	ip, [sp, #12]
102ddcf4:	e2433008 	sub	r3, r3, #8
102ddcf8:	e022200c 	eor	r2, r2, ip
	u8 *p = &command[0];
	u8 UART_IPC_Read_Buffer = 0x00;
	u8 a[5] = {0x00}, i;
	u8 *q = &a[0];

	for(i=0;i<4;i++)
102ddcfc:	e3730008 	cmn	r3, #8
	{
		a[i] = (unsigned char) (jump_address>>(24-(8*i)));
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
102ddd00:	e5cd200c 	strb	r2, [sp, #12]
	u8 *p = &command[0];
	u8 UART_IPC_Read_Buffer = 0x00;
	u8 a[5] = {0x00}, i;
	u8 *q = &a[0];

	for(i=0;i<4;i++)
102ddd04:	1afffff6 	bne	102ddce4 <GO_COMMAND+0x34>
		a[4] = a[4] ^ a[i];             //XOR operation for checksum
	}
#ifdef DEBUG_BOOT_MSG
	APP_DEBUG("GO COMMAND:%x\r\n",a[4]);
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
102ddd08:	e28d1004 	add	r1, sp, #4
102ddd0c:	e3a02002 	mov	r2, #2
102ddd10:	e3a0000c 	mov	r0, #12
102ddd14:	e59f404c 	ldr	r4, [pc, #76]	; 102ddd68 <GO_COMMAND+0xb8>
102ddd18:	e12fff34 	blx	r4
	UART_IPC_Read_Buffer = READ_ACK();
102ddd1c:	ebfffe5d 	bl	102dd698 <READ_ACK>
	if(UART_IPC_Read_Buffer == 0x79)
102ddd20:	e20000ff 	and	r0, r0, #255	; 0xff
102ddd24:	e3500079 	cmp	r0, #121	; 0x79
102ddd28:	0a000001 	beq	102ddd34 <GO_COMMAND+0x84>
		if(UART_IPC_Read_Buffer == 0x79)
		{
			SEND_ECHO(UART_IPC_Read_Buffer);
		}
	}
}
102ddd2c:	e28dd010 	add	sp, sp, #16
102ddd30:	e8bd8010 	pop	{r4, pc}
#endif
	Ql_UART_Write(UART_PORT_IPC, p, 2);
	UART_IPC_Read_Buffer = READ_ACK();
	if(UART_IPC_Read_Buffer == 0x79)
	{
		SEND_ECHO(UART_IPC_Read_Buffer);
102ddd34:	ebfffeb2 	bl	102dd804 <SEND_ECHO>
		Ql_UART_Write(UART_PORT_IPC, q, 5);
102ddd38:	e28d1008 	add	r1, sp, #8
102ddd3c:	e3a02005 	mov	r2, #5
102ddd40:	e3a0000c 	mov	r0, #12
102ddd44:	e12fff34 	blx	r4
		UART_IPC_Read_Buffer = READ_ACK();
102ddd48:	ebfffe52 	bl	102dd698 <READ_ACK>
		if(UART_IPC_Read_Buffer == 0x79)
102ddd4c:	e20000ff 	and	r0, r0, #255	; 0xff
102ddd50:	e3500079 	cmp	r0, #121	; 0x79
102ddd54:	1afffff4 	bne	102ddd2c <GO_COMMAND+0x7c>
		{
			SEND_ECHO(UART_IPC_Read_Buffer);
102ddd58:	ebfffea9 	bl	102dd804 <SEND_ECHO>
102ddd5c:	eafffff2 	b	102ddd2c <GO_COMMAND+0x7c>
102ddd60:	102eb164 	.word	0x102eb164
102ddd64:	102df8c9 	.word	0x102df8c9
102ddd68:	102e6230 	.word	0x102e6230

102ddd6c <READ_IDENTITY>:
 *
 * Return: firmware upgrade required or not (true - yes, false - no)
 *
 *****************************************************************/
u8 READ_IDENTITY(void)
{
102ddd6c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
102ddd70:	e24dd05c 	sub	sp, sp, #92	; 0x5c
	u8 command[5] = {0xFF, 0x01, 0x49, 0x00, 0xb6}; //Hard coded Read identity command sequnce.
102ddd74:	e59f1280 	ldr	r1, [pc, #640]	; 102ddffc <READ_IDENTITY+0x290>
102ddd78:	e3a02005 	mov	r2, #5
102ddd7c:	e59f327c 	ldr	r3, [pc, #636]	; 102de000 <READ_IDENTITY+0x294>
102ddd80:	e28d002c 	add	r0, sp, #44	; 0x2c
102ddd84:	e12fff33 	blx	r3
	u16 i;
	u8 *p = &command[0];
	u16 UART_IPC_Read_Buffer[17] = {0x00};
102ddd88:	e3a03000 	mov	r3, #0
102ddd8c:	e58d3034 	str	r3, [sp, #52]	; 0x34
102ddd90:	e58d3038 	str	r3, [sp, #56]	; 0x38
102ddd94:	e58d303c 	str	r3, [sp, #60]	; 0x3c
102ddd98:	e58d3040 	str	r3, [sp, #64]	; 0x40
102ddd9c:	e58d3044 	str	r3, [sp, #68]	; 0x44
102ddda0:	e58d3048 	str	r3, [sp, #72]	; 0x48
102ddda4:	e58d304c 	str	r3, [sp, #76]	; 0x4c
102ddda8:	e58d3050 	str	r3, [sp, #80]	; 0x50
102dddac:	e1cd35b4 	strh	r3, [sp, #84]	; 0x54
	u8 HW_version = 0xff;
	u8 FW_version0 = 0xff;
	u8 FW_version1 = 0xff;
	u8 IPC_version = 0xff;
	READ_ACK();
	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
102dddb0:	e59f524c 	ldr	r5, [pc, #588]	; 102de004 <READ_IDENTITY+0x298>
	u16 UART_IPC_Read_Buffer[17] = {0x00};
	u8 HW_version = 0xff;
	u8 FW_version0 = 0xff;
	u8 FW_version1 = 0xff;
	u8 IPC_version = 0xff;
	READ_ACK();
102dddb4:	ebfffe37 	bl	102dd698 <READ_ACK>
	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
102dddb8:	e28d102c 	add	r1, sp, #44	; 0x2c
102dddbc:	e3a02005 	mov	r2, #5
102dddc0:	e3a0000c 	mov	r0, #12
102dddc4:	e12fff35 	blx	r5
	Ql_Sleep(500);		//wait for response to arrive
102dddc8:	e3a00f7d 	mov	r0, #500	; 0x1f4
102dddcc:	e59f3234 	ldr	r3, [pc, #564]	; 102de008 <READ_IDENTITY+0x29c>
102dddd0:	e12fff33 	blx	r3
	for(i=0;i<15;i++)
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
		if(UART_IPC_Read_Buffer[i] == 60000)
102dddd4:	e59f6230 	ldr	r6, [pc, #560]	; 102de00c <READ_IDENTITY+0x2a0>
102dddd8:	e28d4032 	add	r4, sp, #50	; 0x32
 * Parameters: void
 *
 * Return: firmware upgrade required or not (true - yes, false - no)
 *
 *****************************************************************/
u8 READ_IDENTITY(void)
102ddddc:	e28d7050 	add	r7, sp, #80	; 0x50
	READ_ACK();
	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
	Ql_Sleep(500);		//wait for response to arrive
	for(i=0;i<15;i++)
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
102ddde0:	ebfffe2c 	bl	102dd698 <READ_ACK>
		if(UART_IPC_Read_Buffer[i] == 60000)
102ddde4:	e1500006 	cmp	r0, r6
	READ_ACK();
	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
	Ql_Sleep(500);		//wait for response to arrive
	for(i=0;i<15;i++)
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
102ddde8:	e1e400b2 	strh	r0, [r4, #2]!
		if(UART_IPC_Read_Buffer[i] == 60000)
102dddec:	0a000063 	beq	102ddf80 <READ_IDENTITY+0x214>
	u8 FW_version1 = 0xff;
	u8 IPC_version = 0xff;
	READ_ACK();
	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
	Ql_Sleep(500);		//wait for response to arrive
	for(i=0;i<15;i++)
102dddf0:	e1540007 	cmp	r4, r7
102dddf4:	1afffff9 	bne	102ddde0 <READ_IDENTITY+0x74>
			display_please_wait();
			return 3;
		}

	}
	Water_Unit_index_get = UART_IPC_Read_Buffer[12]; // This is the water measurement unit configuration code
102dddf8:	e59fc210 	ldr	ip, [pc, #528]	; 102de010 <READ_IDENTITY+0x2a4>
102dddfc:	e1dd24bc 	ldrh	r2, [sp, #76]	; 0x4c
102dde00:	e58c2204 	str	r2, [ip, #516]	; 0x204
	Water_Unit_index_set = Water_Unit_index_get;
102dde04:	e59fc208 	ldr	ip, [pc, #520]	; 102de014 <READ_IDENTITY+0x2a8>
102dde08:	e59f3208 	ldr	r3, [pc, #520]	; 102de018 <READ_IDENTITY+0x2ac>
	FLAG.CON_IDENTITY_RECEIVED = TRUE;
102dde0c:	e59f9208 	ldr	r9, [pc, #520]	; 102de01c <READ_IDENTITY+0x2b0>
			return 3;
		}

	}
	Water_Unit_index_get = UART_IPC_Read_Buffer[12]; // This is the water measurement unit configuration code
	Water_Unit_index_set = Water_Unit_index_get;
102dde10:	e58c2000 	str	r2, [ip]
	FLAG.CON_IDENTITY_RECEIVED = TRUE;
102dde14:	e3a02001 	mov	r2, #1
 * Parameters: void
 *
 * Return: firmware upgrade required or not (true - yes, false - no)
 *
 *****************************************************************/
u8 READ_IDENTITY(void)
102dde18:	e2830b0a 	add	r0, r3, #10240	; 0x2800
102dde1c:	e2631000 	rsb	r1, r3, #0
		}

	}
	Water_Unit_index_get = UART_IPC_Read_Buffer[12]; // This is the water measurement unit configuration code
	Water_Unit_index_set = Water_Unit_index_get;
	FLAG.CON_IDENTITY_RECEIVED = TRUE;
102dde20:	e5c92013 	strb	r2, [r9, #19]
102dde24:	ea000001 	b	102dde30 <READ_IDENTITY+0xc4>
	// Extract the FW version of the new / updated code..from the control moudle FW copy available with Communication module
	// Scan through the entire FW copy and find a token of '<', '*', '!', '=' .. version info is right after it.
	for(i=0;i<MCU_FW_SIZE;i++)
102dde28:	e1530000 	cmp	r3, r0
102dde2c:	0a000016 	beq	102dde8c <READ_IDENTITY+0x120>
 * Parameters: void
 *
 * Return: firmware upgrade required or not (true - yes, false - no)
 *
 *****************************************************************/
u8 READ_IDENTITY(void)
102dde30:	e081c003 	add	ip, r1, r3
	FLAG.CON_IDENTITY_RECEIVED = TRUE;
	// Extract the FW version of the new / updated code..from the control moudle FW copy available with Communication module
	// Scan through the entire FW copy and find a token of '<', '*', '!', '=' .. version info is right after it.
	for(i=0;i<MCU_FW_SIZE;i++)
	{
		if(updated_code[i] == '<')
102dde34:	e5f32001 	ldrb	r2, [r3, #1]!
102dde38:	e352003c 	cmp	r2, #60	; 0x3c
102dde3c:	1afffff9 	bne	102dde28 <READ_IDENTITY+0xbc>
		{
			if(updated_code[i+1] == '*')
102dde40:	e5d32001 	ldrb	r2, [r3, #1]
102dde44:	e352002a 	cmp	r2, #42	; 0x2a
102dde48:	1afffff6 	bne	102dde28 <READ_IDENTITY+0xbc>
			{
				if(updated_code[i+2] == '!')
102dde4c:	e5d32002 	ldrb	r2, [r3, #2]
102dde50:	e3520021 	cmp	r2, #33	; 0x21
102dde54:	1afffff3 	bne	102dde28 <READ_IDENTITY+0xbc>
				{
					if(updated_code[i+3] == '=')
102dde58:	e5d32003 	ldrb	r2, [r3, #3]
102dde5c:	e352003d 	cmp	r2, #61	; 0x3d
102dde60:	1afffff0 	bne	102dde28 <READ_IDENTITY+0xbc>
					{
						HW_version =  updated_code[i+4];
102dde64:	e59f31b4 	ldr	r3, [pc, #436]	; 102de020 <READ_IDENTITY+0x2b4>
102dde68:	e083c00c 	add	ip, r3, ip
102dde6c:	e5dc712c 	ldrb	r7, [ip, #300]	; 0x12c
102dde70:	e5dc012e 	ldrb	r0, [ip, #302]	; 0x12e
102dde74:	e5dcb12d 	ldrb	fp, [ip, #301]	; 0x12d
102dde78:	e5dcc12f 	ldrb	ip, [ip, #303]	; 0x12f
102dde7c:	e58d0020 	str	r0, [sp, #32]
102dde80:	e58dc024 	str	ip, [sp, #36]	; 0x24
102dde84:	e1a04007 	mov	r4, r7
						FW_version0 = updated_code[i+5];
						FW_version1 = updated_code[i+6];
						IPC_version = updated_code[i+7];
						break;
102dde88:	ea000004 	b	102ddea0 <READ_IDENTITY+0x134>
	Water_Unit_index_get = UART_IPC_Read_Buffer[12]; // This is the water measurement unit configuration code
	Water_Unit_index_set = Water_Unit_index_get;
	FLAG.CON_IDENTITY_RECEIVED = TRUE;
	// Extract the FW version of the new / updated code..from the control moudle FW copy available with Communication module
	// Scan through the entire FW copy and find a token of '<', '*', '!', '=' .. version info is right after it.
	for(i=0;i<MCU_FW_SIZE;i++)
102dde8c:	e3a040ff 	mov	r4, #255	; 0xff
102dde90:	e1a0b004 	mov	fp, r4
102dde94:	e1a07004 	mov	r7, r4
102dde98:	e58d4024 	str	r4, [sp, #36]	; 0x24
102dde9c:	e58d4020 	str	r4, [sp, #32]
				}
			}
		}
	}
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Old FW version:%x:%x:%x:%x | New FW version:%x:%x:%x:%x:\r\n",UART_IPC_Read_Buffer[3],UART_IPC_Read_Buffer[4],UART_IPC_Read_Buffer[5],UART_IPC_Read_Buffer[6],HW_version,FW_version0,FW_version1,IPC_version);
102ddea0:	e3a01000 	mov	r1, #0
102ddea4:	e3a02c02 	mov	r2, #512	; 0x200
102ddea8:	e59f0174 	ldr	r0, [pc, #372]	; 102de024 <READ_IDENTITY+0x2b8>
102ddeac:	e59f8174 	ldr	r8, [pc, #372]	; 102de028 <READ_IDENTITY+0x2bc>
102ddeb0:	e12fff38 	blx	r8
102ddeb4:	e1dd13be 	ldrh	r1, [sp, #62]	; 0x3e
102ddeb8:	e58d101c 	str	r1, [sp, #28]
102ddebc:	e1dd04b0 	ldrh	r0, [sp, #64]	; 0x40
102ddec0:	e1ddc3bc 	ldrh	ip, [sp, #60]	; 0x3c
102ddec4:	e1dd63ba 	ldrh	r6, [sp, #58]	; 0x3a
102ddec8:	e59de01c 	ldr	lr, [sp, #28]
102ddecc:	e59fa158 	ldr	sl, [pc, #344]	; 102de02c <READ_IDENTITY+0x2c0>
102dded0:	e98d0881 	stmib	sp, {r0, r7, fp}
102dded4:	e58de000 	str	lr, [sp]
102dded8:	e59d0020 	ldr	r0, [sp, #32]
102ddedc:	e59de024 	ldr	lr, [sp, #36]	; 0x24
102ddee0:	e1a0300c 	mov	r3, ip
102ddee4:	e58dc018 	str	ip, [sp, #24]
102ddee8:	e59f1140 	ldr	r1, [pc, #320]	; 102de030 <READ_IDENTITY+0x2c4>
102ddeec:	e1a02006 	mov	r2, r6
102ddef0:	e58de014 	str	lr, [sp, #20]
102ddef4:	e58d0010 	str	r0, [sp, #16]
102ddef8:	e59a7000 	ldr	r7, [sl]
102ddefc:	e59f0120 	ldr	r0, [pc, #288]	; 102de024 <READ_IDENTITY+0x2b8>
102ddf00:	e12fff37 	blx	r7
102ddf04:	e59f7128 	ldr	r7, [pc, #296]	; 102de034 <READ_IDENTITY+0x2c8>
102ddf08:	e59f0114 	ldr	r0, [pc, #276]	; 102de024 <READ_IDENTITY+0x2b8>
102ddf0c:	e12fff37 	blx	r7
102ddf10:	e59f110c 	ldr	r1, [pc, #268]	; 102de024 <READ_IDENTITY+0x2b8>
102ddf14:	e1a02000 	mov	r2, r0
102ddf18:	e3a0000a 	mov	r0, #10
102ddf1c:	e12fff35 	blx	r5
#endif
	if((HW_version == UART_IPC_Read_Buffer[3]) && (FW_version0*10+FW_version1) != (UART_IPC_Read_Buffer[4]*10+UART_IPC_Read_Buffer[5]))
102ddf20:	e1560004 	cmp	r6, r4
102ddf24:	e59dc018 	ldr	ip, [sp, #24]
102ddf28:	0a000018 	beq	102ddf90 <READ_IDENTITY+0x224>

		return 1;
	}
	else
	{
		display_FW_Version_Info();
102ddf2c:	e59f3104 	ldr	r3, [pc, #260]	; 102de038 <READ_IDENTITY+0x2cc>
102ddf30:	e12fff33 	blx	r3
		FLAG.DIGNOSTIC_MODE = FALSE;
102ddf34:	e3a03000 	mov	r3, #0
#ifdef DEBUG_MSG
		APP_DEBUG("<-- firmware upgrade is not required-->\r\n");
102ddf38:	e3a02c02 	mov	r2, #512	; 0x200
102ddf3c:	e1a01003 	mov	r1, r3
102ddf40:	e59f00dc 	ldr	r0, [pc, #220]	; 102de024 <READ_IDENTITY+0x2b8>
		return 1;
	}
	else
	{
		display_FW_Version_Info();
		FLAG.DIGNOSTIC_MODE = FALSE;
102ddf44:	e5c9300a 	strb	r3, [r9, #10]
#ifdef DEBUG_MSG
		APP_DEBUG("<-- firmware upgrade is not required-->\r\n");
102ddf48:	e12fff38 	blx	r8
102ddf4c:	e59f10e8 	ldr	r1, [pc, #232]	; 102de03c <READ_IDENTITY+0x2d0>
102ddf50:	e59a3000 	ldr	r3, [sl]
102ddf54:	e59f00c8 	ldr	r0, [pc, #200]	; 102de024 <READ_IDENTITY+0x2b8>
102ddf58:	e12fff33 	blx	r3
102ddf5c:	e59f00c0 	ldr	r0, [pc, #192]	; 102de024 <READ_IDENTITY+0x2b8>
102ddf60:	e12fff37 	blx	r7
102ddf64:	e59f10b8 	ldr	r1, [pc, #184]	; 102de024 <READ_IDENTITY+0x2b8>
102ddf68:	e1a02000 	mov	r2, r0
102ddf6c:	e3a0000a 	mov	r0, #10
102ddf70:	e12fff35 	blx	r5
#endif
		return 2;
102ddf74:	e3a00002 	mov	r0, #2
	}
}
102ddf78:	e28dd05c 	add	sp, sp, #92	; 0x5c
102ddf7c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for(i=0;i<15;i++)
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
		if(UART_IPC_Read_Buffer[i] == 60000)
		{
			display_please_wait();
102ddf80:	e59f30b8 	ldr	r3, [pc, #184]	; 102de040 <READ_IDENTITY+0x2d4>
102ddf84:	e12fff33 	blx	r3
			return 3;
102ddf88:	e3a00003 	mov	r0, #3
102ddf8c:	eafffff9 	b	102ddf78 <READ_IDENTITY+0x20c>
		}
	}
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Old FW version:%x:%x:%x:%x | New FW version:%x:%x:%x:%x:\r\n",UART_IPC_Read_Buffer[3],UART_IPC_Read_Buffer[4],UART_IPC_Read_Buffer[5],UART_IPC_Read_Buffer[6],HW_version,FW_version0,FW_version1,IPC_version);
#endif
	if((HW_version == UART_IPC_Read_Buffer[3]) && (FW_version0*10+FW_version1) != (UART_IPC_Read_Buffer[4]*10+UART_IPC_Read_Buffer[5]))
102ddf90:	e59d0020 	ldr	r0, [sp, #32]
102ddf94:	e59d101c 	ldr	r1, [sp, #28]
102ddf98:	e08bb10b 	add	fp, fp, fp, lsl #2
102ddf9c:	e08c310c 	add	r3, ip, ip, lsl #2
102ddfa0:	e080208b 	add	r2, r0, fp, lsl #1
102ddfa4:	e0813083 	add	r3, r1, r3, lsl #1
102ddfa8:	e1520003 	cmp	r2, r3
102ddfac:	0affffde 	beq	102ddf2c <READ_IDENTITY+0x1c0>
	{
		display_please_wait();
102ddfb0:	e59f3088 	ldr	r3, [pc, #136]	; 102de040 <READ_IDENTITY+0x2d4>
102ddfb4:	e12fff33 	blx	r3
#ifdef DEBUG_MSG
		APP_DEBUG("<-- Upgrading the Firmware-->\r\n");
102ddfb8:	e3a02c02 	mov	r2, #512	; 0x200
102ddfbc:	e3a01000 	mov	r1, #0
102ddfc0:	e59f005c 	ldr	r0, [pc, #92]	; 102de024 <READ_IDENTITY+0x2b8>
102ddfc4:	e12fff38 	blx	r8
102ddfc8:	e59f1074 	ldr	r1, [pc, #116]	; 102de044 <READ_IDENTITY+0x2d8>
102ddfcc:	e59a3000 	ldr	r3, [sl]
102ddfd0:	e59f004c 	ldr	r0, [pc, #76]	; 102de024 <READ_IDENTITY+0x2b8>
102ddfd4:	e12fff33 	blx	r3
102ddfd8:	e59f0044 	ldr	r0, [pc, #68]	; 102de024 <READ_IDENTITY+0x2b8>
102ddfdc:	e12fff37 	blx	r7
102ddfe0:	e59f103c 	ldr	r1, [pc, #60]	; 102de024 <READ_IDENTITY+0x2b8>
102ddfe4:	e59f3018 	ldr	r3, [pc, #24]	; 102de004 <READ_IDENTITY+0x298>
102ddfe8:	e1a02000 	mov	r2, r0
102ddfec:	e3a0000a 	mov	r0, #10
102ddff0:	e12fff33 	blx	r3
#endif

		return 1;
102ddff4:	e3a00001 	mov	r0, #1
102ddff8:	eaffffde 	b	102ddf78 <READ_IDENTITY+0x20c>
102ddffc:	102eb168 	.word	0x102eb168
102de000:	102df8c9 	.word	0x102df8c9
102de004:	102e6230 	.word	0x102e6230
102de008:	102e5b10 	.word	0x102e5b10
102de00c:	0000ea60 	.word	0x0000ea60
102de010:	f03da2f4 	.word	0xf03da2f4
102de014:	f03d5bd4 	.word	0xf03d5bd4
102de018:	102eb16f 	.word	0x102eb16f
102de01c:	f03da5f0 	.word	0xf03da5f0
102de020:	102eb048 	.word	0x102eb048
102de024:	f03da2f8 	.word	0xf03da2f8
102de028:	102e58f4 	.word	0x102e58f4
102de02c:	f03de540 	.word	0xf03de540
102de030:	102eff80 	.word	0x102eff80
102de034:	102e57a4 	.word	0x102e57a4
102de038:	102da070 	.word	0x102da070
102de03c:	102effe4 	.word	0x102effe4
102de040:	102da024 	.word	0x102da024
102de044:	102effc4 	.word	0x102effc4

102de048 <FirmwareUpgrade>:
 *
 * Return: void
 *
 *****************************************************************/
void FirmwareUpgrade(void)
{
102de048:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u32 i;
	u8 FW_Upgrade_Attempt;
	FLAG.SKIP_POWER_OFF_ALERT = TRUE;// To avoid false power off alert capture
102de04c:	e59f6398 	ldr	r6, [pc, #920]	; 102de3ec <FirmwareUpgrade+0x3a4>

	for(FW_Upgrade_Attempt =0; (FW_Upgrade_Attempt < 2) && (FLAG.CON_STARTED_SUCCESS == FALSE);FW_Upgrade_Attempt++)
	{
		Ql_GPIO_SetLevel(PINNAME_RI, PINLEVEL_LOW); // Set RESET pin LOW
102de050:	e59f8398 	ldr	r8, [pc, #920]	; 102de3f0 <FirmwareUpgrade+0x3a8>
102de054:	e5d64020 	ldrb	r4, [r6, #32]
		Ql_Sleep(100);
102de058:	e59f7394 	ldr	r7, [pc, #916]	; 102de3f4 <FirmwareUpgrade+0x3ac>
			}
		}
		else
		{
#ifdef DEBUG_MSG
			APP_DEBUG("<-- Communication with CON Module Not established -->\r\n");
102de05c:	e59f9394 	ldr	r9, [pc, #916]	; 102de3f8 <FirmwareUpgrade+0x3b0>
102de060:	e59fa394 	ldr	sl, [pc, #916]	; 102de3fc <FirmwareUpgrade+0x3b4>
 *****************************************************************/
void FirmwareUpgrade(void)
{
	u32 i;
	u8 FW_Upgrade_Attempt;
	FLAG.SKIP_POWER_OFF_ALERT = TRUE;// To avoid false power off alert capture
102de064:	e3a03001 	mov	r3, #1
 *
 * Return: void
 *
 *****************************************************************/
void FirmwareUpgrade(void)
{
102de068:	e24dd00c 	sub	sp, sp, #12
	u32 i;
	u8 FW_Upgrade_Attempt;
	FLAG.SKIP_POWER_OFF_ALERT = TRUE;// To avoid false power off alert capture
102de06c:	e3a05000 	mov	r5, #0
#endif
			// Display Internal Fault F5 on LCD
			Ql_sprintf((char *)&Internal_error_code,"F5");
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE);
		}
		if(FLAG.CON_STARTED_SUCCESS == FALSE)
102de070:	e1a0b006 	mov	fp, r6
 *****************************************************************/
void FirmwareUpgrade(void)
{
	u32 i;
	u8 FW_Upgrade_Attempt;
	FLAG.SKIP_POWER_OFF_ALERT = TRUE;// To avoid false power off alert capture
102de074:	e5c63005 	strb	r3, [r6, #5]

	for(FW_Upgrade_Attempt =0; (FW_Upgrade_Attempt < 2) && (FLAG.CON_STARTED_SUCCESS == FALSE);FW_Upgrade_Attempt++)
102de078:	e3540000 	cmp	r4, #0
102de07c:	1a00003d 	bne	102de178 <FirmwareUpgrade+0x130>
	{
		Ql_GPIO_SetLevel(PINNAME_RI, PINLEVEL_LOW); // Set RESET pin LOW
102de080:	e1a01004 	mov	r1, r4
102de084:	e3a00002 	mov	r0, #2
102de088:	e12fff38 	blx	r8
		Ql_Sleep(100);
102de08c:	e3a00064 	mov	r0, #100	; 0x64
102de090:	e12fff37 	blx	r7
		Ql_GPIO_SetLevel(PINNAME_RI, PINLEVEL_HIGH); // Set RESET pin HIGH
102de094:	e3a01001 	mov	r1, #1
102de098:	e3a00002 	mov	r0, #2
102de09c:	e12fff38 	blx	r8
		Ql_Sleep(500);
102de0a0:	e3a00f7d 	mov	r0, #500	; 0x1f4
102de0a4:	e12fff37 	blx	r7

		//UART is already initialised..so start communicating ..

		if(SYNCHR_COMMAND()==0x79)
102de0a8:	ebfffdb4 	bl	102dd780 <SYNCHR_COMMAND>
102de0ac:	e3500079 	cmp	r0, #121	; 0x79
102de0b0:	0a000038 	beq	102de198 <FirmwareUpgrade+0x150>
			}
		}
		else
		{
#ifdef DEBUG_MSG
			APP_DEBUG("<-- Communication with CON Module Not established -->\r\n");
102de0b4:	e3a02c02 	mov	r2, #512	; 0x200
102de0b8:	e1a01004 	mov	r1, r4
102de0bc:	e59f033c 	ldr	r0, [pc, #828]	; 102de400 <FirmwareUpgrade+0x3b8>
102de0c0:	e12fff39 	blx	r9
102de0c4:	e59f1338 	ldr	r1, [pc, #824]	; 102de404 <FirmwareUpgrade+0x3bc>
102de0c8:	e59a3000 	ldr	r3, [sl]
102de0cc:	e59f032c 	ldr	r0, [pc, #812]	; 102de400 <FirmwareUpgrade+0x3b8>
102de0d0:	e12fff33 	blx	r3
102de0d4:	e59f332c 	ldr	r3, [pc, #812]	; 102de408 <FirmwareUpgrade+0x3c0>
102de0d8:	e59f0320 	ldr	r0, [pc, #800]	; 102de400 <FirmwareUpgrade+0x3b8>
102de0dc:	e12fff33 	blx	r3
102de0e0:	e59f1318 	ldr	r1, [pc, #792]	; 102de400 <FirmwareUpgrade+0x3b8>
102de0e4:	e59f3320 	ldr	r3, [pc, #800]	; 102de40c <FirmwareUpgrade+0x3c4>
102de0e8:	e1a02000 	mov	r2, r0
102de0ec:	e3a0000a 	mov	r0, #10
102de0f0:	e12fff33 	blx	r3
#endif
			// Display Internal Fault F5 on LCD
			Ql_sprintf((char *)&Internal_error_code,"F5");
102de0f4:	e59f1314 	ldr	r1, [pc, #788]	; 102de410 <FirmwareUpgrade+0x3c8>
102de0f8:	e59a3000 	ldr	r3, [sl]
102de0fc:	e59f0310 	ldr	r0, [pc, #784]	; 102de414 <FirmwareUpgrade+0x3cc>
102de100:	e12fff33 	blx	r3
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE);
102de104:	e3a00003 	mov	r0, #3
102de108:	e59f1308 	ldr	r1, [pc, #776]	; 102de418 <FirmwareUpgrade+0x3d0>
102de10c:	e3a02002 	mov	r2, #2
102de110:	e3a03015 	mov	r3, #21
102de114:	e59fc300 	ldr	ip, [pc, #768]	; 102de41c <FirmwareUpgrade+0x3d4>
102de118:	e12fff3c 	blx	ip
		}
		if(FLAG.CON_STARTED_SUCCESS == FALSE)
102de11c:	e5d64020 	ldrb	r4, [r6, #32]
102de120:	e3540000 	cmp	r4, #0
102de124:	0a000017 	beq	102de188 <FirmwareUpgrade+0x140>
102de128:	e2855001 	add	r5, r5, #1
{
	u32 i;
	u8 FW_Upgrade_Attempt;
	FLAG.SKIP_POWER_OFF_ALERT = TRUE;// To avoid false power off alert capture

	for(FW_Upgrade_Attempt =0; (FW_Upgrade_Attempt < 2) && (FLAG.CON_STARTED_SUCCESS == FALSE);FW_Upgrade_Attempt++)
102de12c:	e3550002 	cmp	r5, #2
102de130:	1affffd0 	bne	102de078 <FirmwareUpgrade+0x30>
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE);
		}
		if(FLAG.CON_STARTED_SUCCESS == FALSE)
			SET_RESET_BOOTLOADER_BTYE(PID_SET_BOOTLOADER_BTYE);// Lets do it for next attempt of FW upgrade
	}
	if(FLAG.CON_STARTED_SUCCESS == FALSE)// Control module failed to upgrade through 5 attepts..
102de134:	e3540000 	cmp	r4, #0
102de138:	1a00000e 	bne	102de178 <FirmwareUpgrade+0x130>
	{
		// Display Internal Fault F7 on LCD
		Ql_sprintf((char *)&Internal_error_code,"F7");
102de13c:	e59f32b8 	ldr	r3, [pc, #696]	; 102de3fc <FirmwareUpgrade+0x3b4>
102de140:	e59f12d8 	ldr	r1, [pc, #728]	; 102de420 <FirmwareUpgrade+0x3d8>
102de144:	e5933000 	ldr	r3, [r3]
102de148:	e59f02c4 	ldr	r0, [pc, #708]	; 102de414 <FirmwareUpgrade+0x3cc>
102de14c:	e12fff33 	blx	r3
		Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE);
102de150:	e1a02005 	mov	r2, r5
102de154:	e3a03015 	mov	r3, #21
102de158:	e3a00003 	mov	r0, #3
102de15c:	e59f12b4 	ldr	r1, [pc, #692]	; 102de418 <FirmwareUpgrade+0x3d0>
102de160:	e59fc2b4 	ldr	ip, [pc, #692]	; 102de41c <FirmwareUpgrade+0x3d4>
102de164:	e12fff3c 	blx	ip
		IPC_CMD_REQ_source |= SCHEDULE_IPC_GET_IDENTITY_CMD; // Get identification commmand forever..
102de168:	e59f32b4 	ldr	r3, [pc, #692]	; 102de424 <FirmwareUpgrade+0x3dc>
102de16c:	e5932220 	ldr	r2, [r3, #544]	; 0x220
102de170:	e3822040 	orr	r2, r2, #64	; 0x40
102de174:	e5832220 	str	r2, [r3, #544]	; 0x220
	}
	display_FW_Version_Info();
102de178:	e59f32a8 	ldr	r3, [pc, #680]	; 102de428 <FirmwareUpgrade+0x3e0>
102de17c:	e12fff33 	blx	r3
}
102de180:	e28dd00c 	add	sp, sp, #12
102de184:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			// Display Internal Fault F5 on LCD
			Ql_sprintf((char *)&Internal_error_code,"F5");
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_STRING_INTERNAL_ERROR_CODE);
		}
		if(FLAG.CON_STARTED_SUCCESS == FALSE)
			SET_RESET_BOOTLOADER_BTYE(PID_SET_BOOTLOADER_BTYE);// Lets do it for next attempt of FW upgrade
102de188:	e3a0000b 	mov	r0, #11
102de18c:	ebfffd5d 	bl	102dd708 <SET_RESET_BOOTLOADER_BTYE>
102de190:	e5db4020 	ldrb	r4, [fp, #32]
102de194:	eaffffe3 	b	102de128 <FirmwareUpgrade+0xe0>
		//UART is already initialised..so start communicating ..

		if(SYNCHR_COMMAND()==0x79)
		{
			//send command to get device supported command list
			SEND_ECHO(0x79);
102de198:	ebfffd99 	bl	102dd804 <SEND_ECHO>
			if(GET_COMMAND() == 0x79)
102de19c:	ebfffda3 	bl	102dd830 <GET_COMMAND>
102de1a0:	e3500079 	cmp	r0, #121	; 0x79
102de1a4:	1affffdc 	bne	102de11c <FirmwareUpgrade+0xd4>
			{
				if(GET_COMMAND() == 0x79)
102de1a8:	ebfffda0 	bl	102dd830 <GET_COMMAND>
102de1ac:	e3500079 	cmp	r0, #121	; 0x79
102de1b0:	1affffd9 	bne	102de11c <FirmwareUpgrade+0xd4>
				{
					//send command to erase code memory of controller.
					if(WRITE_COMMAND(0x00A0,0x7f,(char*)data_00A0) == 0x79)
102de1b4:	e3a000a0 	mov	r0, #160	; 0xa0
102de1b8:	e3a0107f 	mov	r1, #127	; 0x7f
102de1bc:	e59f2268 	ldr	r2, [pc, #616]	; 102de42c <FirmwareUpgrade+0x3e4>
102de1c0:	ebfffddf 	bl	102dd944 <WRITE_COMMAND>
102de1c4:	e3500079 	cmp	r0, #121	; 0x79
102de1c8:	1affffd3 	bne	102de11c <FirmwareUpgrade+0xd4>
					{
						if(WRITE_COMMAND(0x0120,0x7f,(char*)data_0120) == 0x79)
102de1cc:	e3a00e12 	mov	r0, #288	; 0x120
102de1d0:	e3a0107f 	mov	r1, #127	; 0x7f
102de1d4:	e59f2254 	ldr	r2, [pc, #596]	; 102de430 <FirmwareUpgrade+0x3e8>
102de1d8:	ebfffdd9 	bl	102dd944 <WRITE_COMMAND>
102de1dc:	e3500079 	cmp	r0, #121	; 0x79
102de1e0:	1affffcd 	bne	102de11c <FirmwareUpgrade+0xd4>
						{
							READ_COMMAND(0x01A0,0x2f);
102de1e4:	e3a00e1a 	mov	r0, #416	; 0x1a0
102de1e8:	e3a0102f 	mov	r1, #47	; 0x2f
102de1ec:	ebfffe26 	bl	102dda8c <READ_COMMAND>
							if(WRITE_COMMAND(0x01A0,0x2f,(char*)data_01A0) == 0x79)
102de1f0:	e3a00e1a 	mov	r0, #416	; 0x1a0
102de1f4:	e3a0102f 	mov	r1, #47	; 0x2f
102de1f8:	e59f2234 	ldr	r2, [pc, #564]	; 102de434 <FirmwareUpgrade+0x3ec>
102de1fc:	ebfffdd0 	bl	102dd944 <WRITE_COMMAND>
102de200:	e3500079 	cmp	r0, #121	; 0x79
102de204:	1affffc4 	bne	102de11c <FirmwareUpgrade+0xd4>
							{
								READ_COMMAND(0x00A0,0x7f);
102de208:	e3a000a0 	mov	r0, #160	; 0xa0
102de20c:	e3a0107f 	mov	r1, #127	; 0x7f
102de210:	ebfffe1d 	bl	102dda8c <READ_COMMAND>
								READ_COMMAND(0x0120,0x7f);
102de214:	e3a00e12 	mov	r0, #288	; 0x120
102de218:	e3a0107f 	mov	r1, #127	; 0x7f
102de21c:	ebfffe1a 	bl	102dda8c <READ_COMMAND>
								READ_COMMAND(0x01A0,0x2f);
102de220:	e3a00e1a 	mov	r0, #416	; 0x1a0
102de224:	e3a0102f 	mov	r1, #47	; 0x2f
102de228:	ebfffe17 	bl	102dda8c <READ_COMMAND>
								READ_COMMAND(0x0040,0x01);
102de22c:	e3a00040 	mov	r0, #64	; 0x40
102de230:	e3a01001 	mov	r1, #1
102de234:	ebfffe14 	bl	102dda8c <READ_COMMAND>
								if(ERASE_SECTOR_COMMAND(10,0x00) == 0x79)
102de238:	e3a0000a 	mov	r0, #10
102de23c:	e1a01004 	mov	r1, r4
102de240:	ebfffe5a 	bl	102ddbb0 <ERASE_SECTOR_COMMAND>
102de244:	e3500079 	cmp	r0, #121	; 0x79
102de248:	1affffb3 	bne	102de11c <FirmwareUpgrade+0xd4>
								{
									if(ERASE_SECTOR_COMMAND(10,0x0A)==0x79)
102de24c:	e3a0000a 	mov	r0, #10
102de250:	e1a01000 	mov	r1, r0
102de254:	ebfffe55 	bl	102ddbb0 <ERASE_SECTOR_COMMAND>
102de258:	e3500079 	cmp	r0, #121	; 0x79
102de25c:	1affffae 	bne	102de11c <FirmwareUpgrade+0xd4>
									{
										if(ERASE_SECTOR_COMMAND(10,0x14)==0x79)
102de260:	e3a0000a 	mov	r0, #10
102de264:	e3a01014 	mov	r1, #20
102de268:	ebfffe50 	bl	102ddbb0 <ERASE_SECTOR_COMMAND>
102de26c:	e3500079 	cmp	r0, #121	; 0x79
102de270:	1affffa9 	bne	102de11c <FirmwareUpgrade+0xd4>
										{
											if(ERASE_SECTOR_COMMAND(2,0x1E)==0x79)
102de274:	e3a00002 	mov	r0, #2
102de278:	e3a0101e 	mov	r1, #30
102de27c:	ebfffe4b 	bl	102ddbb0 <ERASE_SECTOR_COMMAND>
102de280:	e3500079 	cmp	r0, #121	; 0x79
102de284:	1affffa4 	bne	102de11c <FirmwareUpgrade+0xd4>
											{
												//send command for code download
												if(WRITE_COMMAND(0x00A0,0x7f,(char*)data_00A0)==0x79)
102de288:	e3a000a0 	mov	r0, #160	; 0xa0
102de28c:	e3a0107f 	mov	r1, #127	; 0x7f
102de290:	e59f2194 	ldr	r2, [pc, #404]	; 102de42c <FirmwareUpgrade+0x3e4>
102de294:	ebfffdaa 	bl	102dd944 <WRITE_COMMAND>
102de298:	e3500079 	cmp	r0, #121	; 0x79
102de29c:	1affff9e 	bne	102de11c <FirmwareUpgrade+0xd4>
												{
													if(WRITE_COMMAND(0x0120,0x7f,(char*)data_0120) == 0x79)
102de2a0:	e3a00e12 	mov	r0, #288	; 0x120
102de2a4:	e3a0107f 	mov	r1, #127	; 0x7f
102de2a8:	e59f2180 	ldr	r2, [pc, #384]	; 102de430 <FirmwareUpgrade+0x3e8>
102de2ac:	ebfffda4 	bl	102dd944 <WRITE_COMMAND>
102de2b0:	e3500079 	cmp	r0, #121	; 0x79
102de2b4:	1affff98 	bne	102de11c <FirmwareUpgrade+0xd4>
													{
														READ_COMMAND(0x01A0,0x2f);
102de2b8:	e3a00e1a 	mov	r0, #416	; 0x1a0
102de2bc:	e3a0102f 	mov	r1, #47	; 0x2f
102de2c0:	ebfffdf1 	bl	102dda8c <READ_COMMAND>
														if(WRITE_COMMAND(0x01A0,0x2f,(char*)data_01A0) == 0x79)
102de2c4:	e3a00e1a 	mov	r0, #416	; 0x1a0
102de2c8:	e3a0102f 	mov	r1, #47	; 0x2f
102de2cc:	e59f2160 	ldr	r2, [pc, #352]	; 102de434 <FirmwareUpgrade+0x3ec>
102de2d0:	ebfffd9b 	bl	102dd944 <WRITE_COMMAND>
102de2d4:	e3500079 	cmp	r0, #121	; 0x79
102de2d8:	1affff8f 	bne	102de11c <FirmwareUpgrade+0xd4>
														{
															READ_COMMAND(0x00A0,0x7f);
102de2dc:	e3a000a0 	mov	r0, #160	; 0xa0
102de2e0:	e3a0107f 	mov	r1, #127	; 0x7f
102de2e4:	ebfffde8 	bl	102dda8c <READ_COMMAND>
															READ_COMMAND(0x0120,0x7f);
102de2e8:	e3a00e12 	mov	r0, #288	; 0x120
102de2ec:	e3a0107f 	mov	r1, #127	; 0x7f
102de2f0:	ebfffde5 	bl	102dda8c <READ_COMMAND>
															READ_COMMAND(0x01A0,0x2f);
102de2f4:	e3a00e1a 	mov	r0, #416	; 0x1a0
102de2f8:	e3a0102f 	mov	r1, #47	; 0x2f
102de2fc:	ebfffde2 	bl	102dda8c <READ_COMMAND>
															READ_COMMAND(0x8000,0x01);
102de300:	e3a00902 	mov	r0, #32768	; 0x8000
102de304:	e3a01001 	mov	r1, #1
102de308:	ebfffddf 	bl	102dda8c <READ_COMMAND>
102de30c:	e59f3124 	ldr	r3, [pc, #292]	; 102de438 <FirmwareUpgrade+0x3f0>

															for(i=0;i<(MCU_FW_SIZE);i=i+128)
102de310:	e3a04000 	mov	r4, #0
															{
																if(WRITE_COMMAND(0x8000+i,0x7f,(char*)&updated_code[i]) != 0x79)
102de314:	e0832004 	add	r2, r3, r4
102de318:	e2840902 	add	r0, r4, #32768	; 0x8000
102de31c:	e3a0107f 	mov	r1, #127	; 0x7f
102de320:	e58d3004 	str	r3, [sp, #4]
102de324:	ebfffd86 	bl	102dd944 <WRITE_COMMAND>
102de328:	e59d3004 	ldr	r3, [sp, #4]
102de32c:	e3500079 	cmp	r0, #121	; 0x79
102de330:	1a00001b 	bne	102de3a4 <FirmwareUpgrade+0x35c>
#ifdef IPC_DEBUG_MSG
																	APP_DEBUG("<-- Firmware upgrade Attempt[%d] Failed, -->\r\n", FW_Upgrade_Attempt);
#endif
																	break;
																}
																if(i==MCU_FW_SIZE-128) //This is the last page to be written
102de334:	e3540d9e 	cmp	r4, #10112	; 0x2780
															READ_COMMAND(0x00A0,0x7f);
															READ_COMMAND(0x0120,0x7f);
															READ_COMMAND(0x01A0,0x2f);
															READ_COMMAND(0x8000,0x01);

															for(i=0;i<(MCU_FW_SIZE);i=i+128)
102de338:	e2844080 	add	r4, r4, #128	; 0x80
#ifdef IPC_DEBUG_MSG
																	APP_DEBUG("<-- Firmware upgrade Attempt[%d] Failed, -->\r\n", FW_Upgrade_Attempt);
#endif
																	break;
																}
																if(i==MCU_FW_SIZE-128) //This is the last page to be written
102de33c:	1afffff4 	bne	102de314 <FirmwareUpgrade+0x2cc>
																{
#ifdef DEBUG_MSG
																	APP_DEBUG("<-- Firmware upgraded, Device restarting  -->\r\n");
102de340:	e3a02c02 	mov	r2, #512	; 0x200
102de344:	e3a01000 	mov	r1, #0
102de348:	e59f00b0 	ldr	r0, [pc, #176]	; 102de400 <FirmwareUpgrade+0x3b8>
102de34c:	e12fff39 	blx	r9
102de350:	e59f10e4 	ldr	r1, [pc, #228]	; 102de43c <FirmwareUpgrade+0x3f4>
102de354:	e59a3000 	ldr	r3, [sl]
102de358:	e59f00a0 	ldr	r0, [pc, #160]	; 102de400 <FirmwareUpgrade+0x3b8>
102de35c:	e12fff33 	blx	r3
102de360:	e59f30a0 	ldr	r3, [pc, #160]	; 102de408 <FirmwareUpgrade+0x3c0>
102de364:	e59f0094 	ldr	r0, [pc, #148]	; 102de400 <FirmwareUpgrade+0x3b8>
102de368:	e12fff33 	blx	r3
102de36c:	e59f108c 	ldr	r1, [pc, #140]	; 102de400 <FirmwareUpgrade+0x3b8>
102de370:	e59f3094 	ldr	r3, [pc, #148]	; 102de40c <FirmwareUpgrade+0x3c4>
																	//Go command to execute STM8S code
																	GO_COMMAND(0x8000);
																	Ql_Sleep(1000);
																	SET_RESET_BOOTLOADER_BTYE(PID_RESET_BOOTLOADER_BTYE);
																	//READ_BOOTLOADER_BTYE(0x00,0xFF);
																	FLAG.CON_STARTED_SUCCESS = TRUE;
102de374:	e3a04001 	mov	r4, #1
																	break;
																}
																if(i==MCU_FW_SIZE-128) //This is the last page to be written
																{
#ifdef DEBUG_MSG
																	APP_DEBUG("<-- Firmware upgraded, Device restarting  -->\r\n");
102de378:	e1a02000 	mov	r2, r0
102de37c:	e3a0000a 	mov	r0, #10
102de380:	e12fff33 	blx	r3
#endif
																	//Go command to execute STM8S code
																	GO_COMMAND(0x8000);
102de384:	e3a00902 	mov	r0, #32768	; 0x8000
102de388:	ebfffe48 	bl	102ddcb0 <GO_COMMAND>
																	Ql_Sleep(1000);
102de38c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
102de390:	e12fff37 	blx	r7
																	SET_RESET_BOOTLOADER_BTYE(PID_RESET_BOOTLOADER_BTYE);
102de394:	e3a00006 	mov	r0, #6
102de398:	ebfffcda 	bl	102dd708 <SET_RESET_BOOTLOADER_BTYE>
																	//READ_BOOTLOADER_BTYE(0x00,0xFF);
																	FLAG.CON_STARTED_SUCCESS = TRUE;
102de39c:	e5c64020 	strb	r4, [r6, #32]
102de3a0:	eaffff60 	b	102de128 <FirmwareUpgrade+0xe0>
															for(i=0;i<(MCU_FW_SIZE);i=i+128)
															{
																if(WRITE_COMMAND(0x8000+i,0x7f,(char*)&updated_code[i]) != 0x79)
																{
#ifdef IPC_DEBUG_MSG
																	APP_DEBUG("<-- Firmware upgrade Attempt[%d] Failed, -->\r\n", FW_Upgrade_Attempt);
102de3a4:	e3a01000 	mov	r1, #0
102de3a8:	e3a02c02 	mov	r2, #512	; 0x200
102de3ac:	e59f004c 	ldr	r0, [pc, #76]	; 102de400 <FirmwareUpgrade+0x3b8>
102de3b0:	e12fff39 	blx	r9
102de3b4:	e1a02005 	mov	r2, r5
102de3b8:	e59f1080 	ldr	r1, [pc, #128]	; 102de440 <FirmwareUpgrade+0x3f8>
102de3bc:	e59a3000 	ldr	r3, [sl]
102de3c0:	e59f0038 	ldr	r0, [pc, #56]	; 102de400 <FirmwareUpgrade+0x3b8>
102de3c4:	e12fff33 	blx	r3
102de3c8:	e59f3038 	ldr	r3, [pc, #56]	; 102de408 <FirmwareUpgrade+0x3c0>
102de3cc:	e59f002c 	ldr	r0, [pc, #44]	; 102de400 <FirmwareUpgrade+0x3b8>
102de3d0:	e12fff33 	blx	r3
102de3d4:	e59f1024 	ldr	r1, [pc, #36]	; 102de400 <FirmwareUpgrade+0x3b8>
102de3d8:	e59f302c 	ldr	r3, [pc, #44]	; 102de40c <FirmwareUpgrade+0x3c4>
102de3dc:	e1a02000 	mov	r2, r0
102de3e0:	e3a0000a 	mov	r0, #10
102de3e4:	e12fff33 	blx	r3
102de3e8:	eaffff4b 	b	102de11c <FirmwareUpgrade+0xd4>
102de3ec:	f03da5f0 	.word	0xf03da5f0
102de3f0:	102e47d8 	.word	0x102e47d8
102de3f4:	102e5b10 	.word	0x102e5b10
102de3f8:	102e58f4 	.word	0x102e58f4
102de3fc:	f03de540 	.word	0xf03de540
102de400:	f03da2f8 	.word	0xf03da2f8
102de404:	102f0070 	.word	0x102f0070
102de408:	102e57a4 	.word	0x102e57a4
102de40c:	102e6230 	.word	0x102e6230
102de410:	102f00a8 	.word	0x102f00a8
102de414:	f03d4684 	.word	0xf03d4684
102de418:	000010c8 	.word	0x000010c8
102de41c:	102e5cb4 	.word	0x102e5cb4
102de420:	102f00ac 	.word	0x102f00ac
102de424:	f03da2f4 	.word	0xf03da2f4
102de428:	102da070 	.word	0x102da070
102de42c:	102ed970 	.word	0x102ed970
102de430:	102ed9f0 	.word	0x102ed9f0
102de434:	102eda70 	.word	0x102eda70
102de438:	102eb170 	.word	0x102eb170
102de43c:	102f0040 	.word	0x102f0040
102de440:	102f0010 	.word	0x102f0010

102de444 <READ_WATER_BALANCE>:
 *
 * Return: None
 *
 *****************************************************************/
s32 READ_WATER_BALANCE(void)
{
102de444:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
102de448:	e24dd018 	sub	sp, sp, #24
	u8 command[5] = {0xFF, 0x01, 0x4E, 0x09, 0xA8};//Hard coded Read identity command sequnce.
102de44c:	e59f3164 	ldr	r3, [pc, #356]	; 102de5b8 <READ_WATER_BALANCE+0x174>
102de450:	e1a0000d 	mov	r0, sp
102de454:	e59f1160 	ldr	r1, [pc, #352]	; 102de5bc <READ_WATER_BALANCE+0x178>
102de458:	e3a02005 	mov	r2, #5
	u16 UART_IPC_Read_Buffer[7] = {0x00};

	do
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
	}while(UART_IPC_Read_Buffer[i] != 60000); //Flush the input buffer
102de45c:	e59f415c 	ldr	r4, [pc, #348]	; 102de5c0 <READ_WATER_BALANCE+0x17c>
 * Return: None
 *
 *****************************************************************/
s32 READ_WATER_BALANCE(void)
{
	u8 command[5] = {0xFF, 0x01, 0x4E, 0x09, 0xA8};//Hard coded Read identity command sequnce.
102de460:	e12fff33 	blx	r3
	u16 i=0;
	u8 *p = &command[0];
	u16 UART_IPC_Read_Buffer[7] = {0x00};
102de464:	e3a03000 	mov	r3, #0
102de468:	e58d300c 	str	r3, [sp, #12]
102de46c:	e58d3010 	str	r3, [sp, #16]

	do
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
102de470:	ebfffc88 	bl	102dd698 <READ_ACK>
	}while(UART_IPC_Read_Buffer[i] != 60000); //Flush the input buffer
102de474:	e1500004 	cmp	r0, r4
102de478:	1afffffc 	bne	102de470 <READ_WATER_BALANCE+0x2c>

	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
102de47c:	e3a0000c 	mov	r0, #12
102de480:	e1a0100d 	mov	r1, sp
102de484:	e3a02005 	mov	r2, #5
102de488:	e59f7134 	ldr	r7, [pc, #308]	; 102de5c4 <READ_WATER_BALANCE+0x180>
102de48c:	e12fff37 	blx	r7
102de490:	e3a06001 	mov	r6, #1
102de494:	e3a05000 	mov	r5, #0
			{
				if(i == 4)
					water_balance = (UART_IPC_Read_Buffer[4]);
				if(i == 5)
				{
					water_balance |= (UART_IPC_Read_Buffer[5] << 8);
102de498:	e59f8128 	ldr	r8, [pc, #296]	; 102de5c8 <READ_WATER_BALANCE+0x184>
					format_water_balance_buffer(water_balance, water_balance_buffer); // format the latest water balance to display
#ifdef IPC_DEBUG_MSG
					APP_DEBUG("\n\r<--  Water balance is %s -->\r\n",water_balance_buffer);
102de49c:	e59f9128 	ldr	r9, [pc, #296]	; 102de5cc <READ_WATER_BALANCE+0x188>
102de4a0:	e59fa128 	ldr	sl, [pc, #296]	; 102de5d0 <READ_WATER_BALANCE+0x18c>
102de4a4:	ea000003 	b	102de4b8 <READ_WATER_BALANCE+0x74>
102de4a8:	e2866001 	add	r6, r6, #1
102de4ac:	e1a06806 	lsl	r6, r6, #16
102de4b0:	e2855001 	add	r5, r5, #1
102de4b4:	e1a06826 	lsr	r6, r6, #16
	}while(UART_IPC_Read_Buffer[i] != 60000); //Flush the input buffer

	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
	for(i=0;i<7;i++)
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
102de4b8:	ebfffc76 	bl	102dd698 <READ_ACK>
102de4bc:	e1a04805 	lsl	r4, r5, #16
102de4c0:	e28d2018 	add	r2, sp, #24
102de4c4:	e1a04824 	lsr	r4, r4, #16
102de4c8:	e0823084 	add	r3, r2, r4, lsl #1
		if(UART_IPC_Read_Buffer[i] == 60000)
102de4cc:	e59f20ec 	ldr	r2, [pc, #236]	; 102de5c0 <READ_WATER_BALANCE+0x17c>
102de4d0:	e1500002 	cmp	r0, r2
	}while(UART_IPC_Read_Buffer[i] != 60000); //Flush the input buffer

	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
	for(i=0;i<7;i++)
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
102de4d4:	e14301b0 	strh	r0, [r3, #-16]
		if(UART_IPC_Read_Buffer[i] == 60000)
102de4d8:	0a000031 	beq	102de5a4 <READ_WATER_BALANCE+0x160>
		{
			return -1;
		}
		if(i>2)
102de4dc:	e3540002 	cmp	r4, #2
102de4e0:	9a000002 	bls	102de4f0 <READ_WATER_BALANCE+0xac>
		{
			if((UART_IPC_Read_Buffer[2] == 'n') &&( UART_IPC_Read_Buffer[3] == 0x09))
102de4e4:	e1dd30bc 	ldrh	r3, [sp, #12]
102de4e8:	e353006e 	cmp	r3, #110	; 0x6e
102de4ec:	0a000004 	beq	102de504 <READ_WATER_BALANCE+0xc0>
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
	}while(UART_IPC_Read_Buffer[i] != 60000); //Flush the input buffer

	Ql_UART_Write(UART_PORT_IPC, p, 5); // Send the Read Identity command over IPC UART
	for(i=0;i<7;i++)
102de4f0:	e3560007 	cmp	r6, #7
102de4f4:	1affffeb 	bne	102de4a8 <READ_WATER_BALANCE+0x64>
					}
				}
			}
		}
	}
	return 0;
102de4f8:	e3a00000 	mov	r0, #0
}
102de4fc:	e28dd018 	add	sp, sp, #24
102de500:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
		{
			return -1;
		}
		if(i>2)
		{
			if((UART_IPC_Read_Buffer[2] == 'n') &&( UART_IPC_Read_Buffer[3] == 0x09))
102de504:	e1dd30be 	ldrh	r3, [sp, #14]
102de508:	e3530009 	cmp	r3, #9
102de50c:	1afffff7 	bne	102de4f0 <READ_WATER_BALANCE+0xac>
			{
				if(i == 4)
102de510:	e3540004 	cmp	r4, #4
102de514:	0a000024 	beq	102de5ac <READ_WATER_BALANCE+0x168>
					water_balance = (UART_IPC_Read_Buffer[4]);
				if(i == 5)
102de518:	e3540005 	cmp	r4, #5
102de51c:	1afffff3 	bne	102de4f0 <READ_WATER_BALANCE+0xac>
				{
					water_balance |= (UART_IPC_Read_Buffer[5] << 8);
102de520:	e5983000 	ldr	r3, [r8]
102de524:	e1dd21b2 	ldrh	r2, [sp, #18]
					format_water_balance_buffer(water_balance, water_balance_buffer); // format the latest water balance to display
102de528:	e59f10a4 	ldr	r1, [pc, #164]	; 102de5d4 <READ_WATER_BALANCE+0x190>
			{
				if(i == 4)
					water_balance = (UART_IPC_Read_Buffer[4]);
				if(i == 5)
				{
					water_balance |= (UART_IPC_Read_Buffer[5] << 8);
102de52c:	e1833402 	orr	r3, r3, r2, lsl #8
					format_water_balance_buffer(water_balance, water_balance_buffer); // format the latest water balance to display
102de530:	e1a00003 	mov	r0, r3
			{
				if(i == 4)
					water_balance = (UART_IPC_Read_Buffer[4]);
				if(i == 5)
				{
					water_balance |= (UART_IPC_Read_Buffer[5] << 8);
102de534:	e5883000 	str	r3, [r8]
					format_water_balance_buffer(water_balance, water_balance_buffer); // format the latest water balance to display
102de538:	ebfffade 	bl	102dd0b8 <format_water_balance_buffer>
#ifdef IPC_DEBUG_MSG
					APP_DEBUG("\n\r<--  Water balance is %s -->\r\n",water_balance_buffer);
102de53c:	e3a01000 	mov	r1, #0
102de540:	e3a02c02 	mov	r2, #512	; 0x200
102de544:	e59f008c 	ldr	r0, [pc, #140]	; 102de5d8 <READ_WATER_BALANCE+0x194>
102de548:	e12fff39 	blx	r9
102de54c:	e59f0084 	ldr	r0, [pc, #132]	; 102de5d8 <READ_WATER_BALANCE+0x194>
102de550:	e59f1084 	ldr	r1, [pc, #132]	; 102de5dc <READ_WATER_BALANCE+0x198>
102de554:	e2802e22 	add	r2, r0, #544	; 0x220
102de558:	e59a3000 	ldr	r3, [sl]
102de55c:	e12fff33 	blx	r3
102de560:	e59f3078 	ldr	r3, [pc, #120]	; 102de5e0 <READ_WATER_BALANCE+0x19c>
102de564:	e59f006c 	ldr	r0, [pc, #108]	; 102de5d8 <READ_WATER_BALANCE+0x194>
102de568:	e12fff33 	blx	r3
102de56c:	e59f1064 	ldr	r1, [pc, #100]	; 102de5d8 <READ_WATER_BALANCE+0x194>
102de570:	e1a02000 	mov	r2, r0
102de574:	e3a0000a 	mov	r0, #10
102de578:	e12fff37 	blx	r7
#endif
					if(water_balance >= 0 && water_balance <= MAX_ALLOWED_WATER_BALANCE)
102de57c:	e5982000 	ldr	r2, [r8]
102de580:	e59f305c 	ldr	r3, [pc, #92]	; 102de5e4 <READ_WATER_BALANCE+0x1a0>
102de584:	e1520003 	cmp	r2, r3
102de588:	8affffc6 	bhi	102de4a8 <READ_WATER_BALANCE+0x64>
					{
						Init_Water_Balance_Screen();
102de58c:	e59f3054 	ldr	r3, [pc, #84]	; 102de5e8 <READ_WATER_BALANCE+0x1a4>
102de590:	e12fff33 	blx	r3
						FLAG.CON_STARTED_SUCCESS = TRUE; // Set the flag at this place
102de594:	e59f3050 	ldr	r3, [pc, #80]	; 102de5ec <READ_WATER_BALANCE+0x1a8>
102de598:	e3a02001 	mov	r2, #1
102de59c:	e5c32020 	strb	r2, [r3, #32]
102de5a0:	eaffffc0 	b	102de4a8 <READ_WATER_BALANCE+0x64>
	for(i=0;i<7;i++)
	{
		UART_IPC_Read_Buffer[i] = READ_ACK();
		if(UART_IPC_Read_Buffer[i] == 60000)
		{
			return -1;
102de5a4:	e3e00000 	mvn	r0, #0
102de5a8:	eaffffd3 	b	102de4fc <READ_WATER_BALANCE+0xb8>
		if(i>2)
		{
			if((UART_IPC_Read_Buffer[2] == 'n') &&( UART_IPC_Read_Buffer[3] == 0x09))
			{
				if(i == 4)
					water_balance = (UART_IPC_Read_Buffer[4]);
102de5ac:	e1dd31b0 	ldrh	r3, [sp, #16]
102de5b0:	e5883000 	str	r3, [r8]
102de5b4:	eaffffbb 	b	102de4a8 <READ_WATER_BALANCE+0x64>
102de5b8:	102df8c9 	.word	0x102df8c9
102de5bc:	102edaa0 	.word	0x102edaa0
102de5c0:	0000ea60 	.word	0x0000ea60
102de5c4:	102e6230 	.word	0x102e6230
102de5c8:	f03d5bf4 	.word	0xf03d5bf4
102de5cc:	102e58f4 	.word	0x102e58f4
102de5d0:	f03de540 	.word	0xf03de540
102de5d4:	f03da518 	.word	0xf03da518
102de5d8:	f03da2f8 	.word	0xf03da2f8
102de5dc:	102f00b0 	.word	0x102f00b0
102de5e0:	102e57a4 	.word	0x102e57a4
102de5e4:	0000270f 	.word	0x0000270f
102de5e8:	102d9fa8 	.word	0x102d9fa8
102de5ec:	f03da5f0 	.word	0xf03da5f0

102de5f0 <Callback_External_Interrupt_Hdlr>:
 *
 * Return:
 *
 *****************************************************************/
static void Callback_External_Interrupt_Hdlr(Enum_PinName eintPinName, Enum_PinLevel pinLevel, void* customParam)
{
102de5f0:	e12fff1e 	bx	lr

102de5f4 <CallBack_UART_MAIN_Hdlr>:
 *
 * Return:
 *
 *****************************************************************/
static void CallBack_UART_MAIN_Hdlr(Enum_SerialPort port, Enum_UARTEventType msg, bool level, void* customizedPara)
{
102de5f4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102de5f8:	e24ddd5e 	sub	sp, sp, #6016	; 0x1780
102de5fc:	e24dd004 	sub	sp, sp, #4
102de600:	e1a05001 	mov	r5, r1
	char c[4];
	char UART_MAIN_Read_Buffer[2000] = {0x00};
102de604:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102de608:	e3a01000 	mov	r1, #0
102de60c:	e59f38f8 	ldr	r3, [pc, #2296]	; 102def0c <CallBack_UART_MAIN_Hdlr+0x918>
102de610:	e28d0010 	add	r0, sp, #16
102de614:	e12fff33 	blx	r3
	s32 ret = -1;

	u16 Read_Uart_Buffer_Temp_len;
	/*------------------------------------------------------------------------------*/
	float RCbalance_now =0;
	Ql_memset(Read_Uart_buffer_one, 0x0, sizeof(Read_Uart_buffer_one)); // Clear the MAIN READ buffer by filling it with all 0x00
102de618:	e59f48f0 	ldr	r4, [pc, #2288]	; 102def10 <CallBack_UART_MAIN_Hdlr+0x91c>
102de61c:	e28d0e7e 	add	r0, sp, #2016	; 0x7e0
102de620:	e3a01000 	mov	r1, #0
102de624:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102de628:	e12fff34 	blx	r4
	switch(msg)
102de62c:	e3550000 	cmp	r5, #0
102de630:	1a00002d 	bne	102de6ec <CallBack_UART_MAIN_Hdlr+0xf8>
	{
	case EVENT_UART_READY_TO_READ :
		Ql_memset(UART_MAIN_Read_Buffer, 0x0, sizeof(UART_MAIN_Read_Buffer)); // Clear the MAIN READ buffer by filling it with all 0x00
102de634:	e1a01005 	mov	r1, r5
102de638:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102de63c:	e28d0010 	add	r0, sp, #16
102de640:	e12fff34 	blx	r4

		Ql_UART_Read(UART_PORT_MAIN, UART_MAIN_Read_Buffer, sizeof(UART_MAIN_Read_Buffer));// Reat the UART receive buffer in MAIN READ buffer
102de644:	e59f78c8 	ldr	r7, [pc, #2248]	; 102def14 <CallBack_UART_MAIN_Hdlr+0x920>
102de648:	e3a0000a 	mov	r0, #10
102de64c:	e28d1010 	add	r1, sp, #16
102de650:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102de654:	e12fff37 	blx	r7

		//Send command CK0<file size> for ex."CK01706".This command is used for to store Client Private Key Liscence file.
		/*******************************************************/
		/*********Check command to write the CERTIFICATE******************/
		/*******************************************************/
		if((UART_MAIN_Read_Buffer[0] == 'C') && ((UART_MAIN_Read_Buffer[1] == 'K') || (UART_MAIN_Read_Buffer[1] == 'C') || (UART_MAIN_Read_Buffer[1] == 'A')) && (UART_MAIN_Read_Buffer[2] == '0'))
102de658:	e59f38b8 	ldr	r3, [pc, #2232]	; 102def18 <CallBack_UART_MAIN_Hdlr+0x924>
102de65c:	e28d0d5e 	add	r0, sp, #6016	; 0x1780
102de660:	e7d03003 	ldrb	r3, [r0, r3]
102de664:	e3530043 	cmp	r3, #67	; 0x43
102de668:	0a000022 	beq	102de6f8 <CallBack_UART_MAIN_Hdlr+0x104>
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
				break;
			}
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'I') && (UART_MAIN_Read_Buffer[2] == 'D') ))
102de66c:	e3530044 	cmp	r3, #68	; 0x44
102de670:	0a00005e 	beq	102de7f0 <CallBack_UART_MAIN_Hdlr+0x1fc>
102de674:	e59f68a0 	ldr	r6, [pc, #2208]	; 102def1c <CallBack_UART_MAIN_Hdlr+0x928>
102de678:	e5d65000 	ldrb	r5, [r6]
		}
		/*******************************************************/
		/*********WRITE CLIENT KEY CERTIFICATE******************/
		/*******************************************************/
		//Send command CA0<file size> for ex."CA01206". This command is used for to store RootCA Liscence file.
		if(Certificate_File_Download_state == CERTIFICATE_CK0)// State machine is in Receive CK0 file and we received data on UART
102de67c:	e3550001 	cmp	r5, #1
102de680:	0a0000e8 	beq	102dea28 <CallBack_UART_MAIN_Hdlr+0x434>

		//Send command CK0<file size> for ex."CK01270". This command is used for to store Public Liscence file.
		/*******************************************************/
		/*********WRITE CLIENT PUBLIC CERTIFICATE******************/
		/*******************************************************/
		if(Certificate_File_Download_state == CERTIFICATE_CC0)// State machine is in Receive CK0 file and we received data on UART
102de684:	e3550002 	cmp	r5, #2
102de688:	0a000136 	beq	102deb68 <CallBack_UART_MAIN_Hdlr+0x574>

		//Send command CA0<file size> for ex."CA01206". This command is used for to store RootCA Liscence file.
		/*******************************************************/
		/*********WRITE ROOT CA CERTIFICATE******************/
		/*******************************************************/
		if(Certificate_File_Download_state == CERTIFICATE_CA0)// State machine is in Receive CK0 file and we received data on UART
102de68c:	e3550003 	cmp	r5, #3
102de690:	0a00010d 	beq	102deacc <CallBack_UART_MAIN_Hdlr+0x4d8>

		//Send command "DID" to store device ID
		/*******************************************************/
		/*****************STORE DEVICE ID***********************/
		/*******************************************************/
		if(Certificate_File_Download_state == DID)
102de694:	e3550004 	cmp	r5, #4
102de698:	0a000078 	beq	102de880 <CallBack_UART_MAIN_Hdlr+0x28c>

		//Send command "DPS" to store DPS_ID
		/*******************************************************/
		/*****************STORE DPS ID***********************/
		/*******************************************************/
		if(Certificate_File_Download_state == DPS)
102de69c:	e3550005 	cmp	r5, #5
102de6a0:	0a0000b5 	beq	102de97c <CallBack_UART_MAIN_Hdlr+0x388>

#ifdef DEBUG_MSG
		//!!! ATTENTION --> Used only in development / debug.. need tobe commented out in RELEASE
		//--------------------------------------------------
		// // GET_IDENTITY
		if(UART_MAIN_Read_Buffer[0] == 'I')
102de6a4:	e59f586c 	ldr	r5, [pc, #2156]	; 102def18 <CallBack_UART_MAIN_Hdlr+0x924>
102de6a8:	e28dcd5e 	add	ip, sp, #6016	; 0x1780
102de6ac:	e7dc3005 	ldrb	r3, [ip, r5]
102de6b0:	e3530049 	cmp	r3, #73	; 0x49
102de6b4:	0a000098 	beq	102de91c <CallBack_UART_MAIN_Hdlr+0x328>

			IPC_CMD_REQ_source |= SCHEDULE_IPC_GET_IDENTITY_CMD; // Get identification commmand
		}
		//---------------------------------------------------
		// Water Balance recharge
		if(UART_MAIN_Read_Buffer[0] == 'w')
102de6b8:	e3530077 	cmp	r3, #119	; 0x77
102de6bc:	0a000076 	beq	102de89c <CallBack_UART_MAIN_Hdlr+0x2a8>
			else
				rechargebalance =0;
		}
		//---------------------------------------------------
		// // Lock
		if(UART_MAIN_Read_Buffer[0] == 'l')
102de6c0:	e353006c 	cmp	r3, #108	; 0x6c
102de6c4:	0a000190 	beq	102ded0c <CallBack_UART_MAIN_Hdlr+0x718>

			IPC_CMD_REQ_source |= SCHEDULE_IPC_LOCK_CMD; // Set water balance data command is scheduled
		}
		//---------------------------------------------------
		// // UnLock
		if(UART_MAIN_Read_Buffer[0] == 'u')
102de6c8:	e3530075 	cmp	r3, #117	; 0x75
102de6cc:	0a000175 	beq	102deca8 <CallBack_UART_MAIN_Hdlr+0x6b4>
			IPC_CMD_REQ_source |= SCHEDULE_IPC_UNLOCK_CMD; // Set water balance data command is scheduled
		}
		//---------------------------------------------------
		// Reset Device to factory mode configuration

		if(UART_MAIN_Read_Buffer[0] == 'r')
102de6d0:	e3530072 	cmp	r3, #114	; 0x72
102de6d4:	0a000155 	beq	102dec30 <CallBack_UART_MAIN_Hdlr+0x63c>
			IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
			FLAG.DEVICE_RESET_SCHEDULED = TRUE;
		}
		//---------------------------------------------------
		// Force FOTA
		if(UART_MAIN_Read_Buffer[0] == 'x')
102de6d8:	e3530078 	cmp	r3, #120	; 0x78
102de6dc:	0a00014c 	beq	102dec14 <CallBack_UART_MAIN_Hdlr+0x620>
			Ql_strcpy(FOTA_URL, " https://s3.amazonaws.com/harmanfota/HUL/APPGS3MDM32A01_Upgrade_Package.bin");
			FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD = TRUE;
		}
		//---------------------------------------------------
#endif
		Ql_UART_ClrRxBuffer(UART_PORT_MAIN);
102de6e0:	e3a0000a 	mov	r0, #10
102de6e4:	e59f3834 	ldr	r3, [pc, #2100]	; 102def20 <CallBack_UART_MAIN_Hdlr+0x92c>
102de6e8:	e12fff33 	blx	r3
		break;

	default	:
		break;
	}
}
102de6ec:	e28ddfe1 	add	sp, sp, #900	; 0x384
102de6f0:	e28ddb05 	add	sp, sp, #5120	; 0x1400
102de6f4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

		//Send command CK0<file size> for ex."CK01706".This command is used for to store Client Private Key Liscence file.
		/*******************************************************/
		/*********Check command to write the CERTIFICATE******************/
		/*******************************************************/
		if((UART_MAIN_Read_Buffer[0] == 'C') && ((UART_MAIN_Read_Buffer[1] == 'K') || (UART_MAIN_Read_Buffer[1] == 'C') || (UART_MAIN_Read_Buffer[1] == 'A')) && (UART_MAIN_Read_Buffer[2] == '0'))
102de6f8:	e5dd3011 	ldrb	r3, [sp, #17]
102de6fc:	e20320f7 	and	r2, r3, #247	; 0xf7
102de700:	e3520043 	cmp	r2, #67	; 0x43
102de704:	0a000001 	beq	102de710 <CallBack_UART_MAIN_Hdlr+0x11c>
102de708:	e3530041 	cmp	r3, #65	; 0x41
102de70c:	1affffd8 	bne	102de674 <CallBack_UART_MAIN_Hdlr+0x80>
102de710:	e5dd3012 	ldrb	r3, [sp, #18]
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102de714:	e59f6800 	ldr	r6, [pc, #2048]	; 102def1c <CallBack_UART_MAIN_Hdlr+0x928>

		//Send command CK0<file size> for ex."CK01706".This command is used for to store Client Private Key Liscence file.
		/*******************************************************/
		/*********Check command to write the CERTIFICATE******************/
		/*******************************************************/
		if((UART_MAIN_Read_Buffer[0] == 'C') && ((UART_MAIN_Read_Buffer[1] == 'K') || (UART_MAIN_Read_Buffer[1] == 'C') || (UART_MAIN_Read_Buffer[1] == 'A')) && (UART_MAIN_Read_Buffer[2] == '0'))
102de718:	e3530030 	cmp	r3, #48	; 0x30
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102de71c:	e5d65000 	ldrb	r5, [r6]

		//Send command CK0<file size> for ex."CK01706".This command is used for to store Client Private Key Liscence file.
		/*******************************************************/
		/*********Check command to write the CERTIFICATE******************/
		/*******************************************************/
		if((UART_MAIN_Read_Buffer[0] == 'C') && ((UART_MAIN_Read_Buffer[1] == 'K') || (UART_MAIN_Read_Buffer[1] == 'C') || (UART_MAIN_Read_Buffer[1] == 'A')) && (UART_MAIN_Read_Buffer[2] == '0'))
102de720:	1affffd5 	bne	102de67c <CallBack_UART_MAIN_Hdlr+0x88>
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102de724:	e3550000 	cmp	r5, #0
102de728:	1affffd3 	bne	102de67c <CallBack_UART_MAIN_Hdlr+0x88>
			{
				FLAG.SUSPEND_IPC_COMMUNICATION = TRUE;
				int j=3;
				for(int i =0; i<4;i++)
				{
					c[i]=UART_MAIN_Read_Buffer [j++];
102de72c:	e5dd3016 	ldrb	r3, [sp, #22]
102de730:	e59fc7ec 	ldr	ip, [pc, #2028]	; 102def24 <CallBack_UART_MAIN_Hdlr+0x930>
102de734:	e5dde013 	ldrb	lr, [sp, #19]
102de738:	e5dd1014 	ldrb	r1, [sp, #20]
102de73c:	e5dd2015 	ldrb	r2, [sp, #21]
		/*******************************************************/
		if((UART_MAIN_Read_Buffer[0] == 'C') && ((UART_MAIN_Read_Buffer[1] == 'K') || (UART_MAIN_Read_Buffer[1] == 'C') || (UART_MAIN_Read_Buffer[1] == 'A')) && (UART_MAIN_Read_Buffer[2] == '0'))
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
			{
				FLAG.SUSPEND_IPC_COMMUNICATION = TRUE;
102de740:	e3a05001 	mov	r5, #1
				int j=3;
				for(int i =0; i<4;i++)
				{
					c[i]=UART_MAIN_Read_Buffer [j++];
102de744:	e5cd3007 	strb	r3, [sp, #7]
				}
				Cx0_File_Size = Ql_atoi(c);
102de748:	e28d0004 	add	r0, sp, #4
102de74c:	e59f37d4 	ldr	r3, [pc, #2004]	; 102def28 <CallBack_UART_MAIN_Hdlr+0x934>
			{
				FLAG.SUSPEND_IPC_COMMUNICATION = TRUE;
				int j=3;
				for(int i =0; i<4;i++)
				{
					c[i]=UART_MAIN_Read_Buffer [j++];
102de750:	e28d7d5e 	add	r7, sp, #6016	; 0x1780
		/*******************************************************/
		if((UART_MAIN_Read_Buffer[0] == 'C') && ((UART_MAIN_Read_Buffer[1] == 'K') || (UART_MAIN_Read_Buffer[1] == 'C') || (UART_MAIN_Read_Buffer[1] == 'A')) && (UART_MAIN_Read_Buffer[2] == '0'))
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
			{
				FLAG.SUSPEND_IPC_COMMUNICATION = TRUE;
102de754:	e5c65021 	strb	r5, [r6, #33]	; 0x21
				int j=3;
				for(int i =0; i<4;i++)
				{
					c[i]=UART_MAIN_Read_Buffer [j++];
102de758:	e7c7e00c 	strb	lr, [r7, ip]
102de75c:	e5cd1005 	strb	r1, [sp, #5]
102de760:	e5cd2006 	strb	r2, [sp, #6]
				}
				Cx0_File_Size = Ql_atoi(c);
102de764:	e12fff33 	blx	r3
				if(UART_MAIN_Read_Buffer[1] == 'K')
102de768:	e5dd3011 	ldrb	r3, [sp, #17]
102de76c:	e353004b 	cmp	r3, #75	; 0x4b
					Certificate_File_Download_state = CERTIFICATE_CK0;
102de770:	05c65000 	strbeq	r5, [r6]
				int j=3;
				for(int i =0; i<4;i++)
				{
					c[i]=UART_MAIN_Read_Buffer [j++];
				}
				Cx0_File_Size = Ql_atoi(c);
102de774:	e1c602bc 	strh	r0, [r6, #44]	; 0x2c
				if(UART_MAIN_Read_Buffer[1] == 'K')
102de778:	0a000006 	beq	102de798 <CallBack_UART_MAIN_Hdlr+0x1a4>
					Certificate_File_Download_state = CERTIFICATE_CK0;
				else if(UART_MAIN_Read_Buffer[1] == 'C')
102de77c:	e3530043 	cmp	r3, #67	; 0x43
					Certificate_File_Download_state = CERTIFICATE_CC0;
102de780:	03a03002 	moveq	r3, #2
102de784:	05c63000 	strbeq	r3, [r6]
					c[i]=UART_MAIN_Read_Buffer [j++];
				}
				Cx0_File_Size = Ql_atoi(c);
				if(UART_MAIN_Read_Buffer[1] == 'K')
					Certificate_File_Download_state = CERTIFICATE_CK0;
				else if(UART_MAIN_Read_Buffer[1] == 'C')
102de788:	0a000002 	beq	102de798 <CallBack_UART_MAIN_Hdlr+0x1a4>
					Certificate_File_Download_state = CERTIFICATE_CC0;
				else if(UART_MAIN_Read_Buffer[1] == 'A')
102de78c:	e3530041 	cmp	r3, #65	; 0x41
					Certificate_File_Download_state = CERTIFICATE_CA0;
102de790:	03a03003 	moveq	r3, #3
102de794:	05c63000 	strbeq	r3, [r6]
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
102de798:	e3a02c02 	mov	r2, #512	; 0x200
102de79c:	e3a01000 	mov	r1, #0
102de7a0:	e59f0784 	ldr	r0, [pc, #1924]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de7a4:	e12fff34 	blx	r4
102de7a8:	e59f3780 	ldr	r3, [pc, #1920]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102de7ac:	e59f1780 	ldr	r1, [pc, #1920]	; 102def34 <CallBack_UART_MAIN_Hdlr+0x940>
102de7b0:	e5933000 	ldr	r3, [r3]
102de7b4:	e59f0770 	ldr	r0, [pc, #1904]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de7b8:	e12fff33 	blx	r3
102de7bc:	e59f3774 	ldr	r3, [pc, #1908]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102de7c0:	e59f0764 	ldr	r0, [pc, #1892]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de7c4:	e12fff33 	blx	r3
102de7c8:	e59f175c 	ldr	r1, [pc, #1884]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de7cc:	e59f3768 	ldr	r3, [pc, #1896]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102de7d0:	e1a02000 	mov	r2, r0
102de7d4:	e3a0000a 	mov	r0, #10
102de7d8:	e12fff33 	blx	r3
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
102de7dc:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102de7e0:	e3a01000 	mov	r1, #0
102de7e4:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102de7e8:	e12fff34 	blx	r4
				break;
102de7ec:	eaffffbe 	b	102de6ec <CallBack_UART_MAIN_Hdlr+0xf8>
			}
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'I') && (UART_MAIN_Read_Buffer[2] == 'D') ))
102de7f0:	e5dd3011 	ldrb	r3, [sp, #17]
102de7f4:	e3530049 	cmp	r3, #73	; 0x49
102de7f8:	0a0001b2 	beq	102deec8 <CallBack_UART_MAIN_Hdlr+0x8d4>
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
				break;
			}
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'P') && (UART_MAIN_Read_Buffer[2] == 'S') ))
102de7fc:	e3530050 	cmp	r3, #80	; 0x50
102de800:	1affff9b 	bne	102de674 <CallBack_UART_MAIN_Hdlr+0x80>
102de804:	e5dd3012 	ldrb	r3, [sp, #18]
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102de808:	e59f670c 	ldr	r6, [pc, #1804]	; 102def1c <CallBack_UART_MAIN_Hdlr+0x928>
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
				break;
			}
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'P') && (UART_MAIN_Read_Buffer[2] == 'S') ))
102de80c:	e3530053 	cmp	r3, #83	; 0x53
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102de810:	e5d65000 	ldrb	r5, [r6]
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
				break;
			}
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'P') && (UART_MAIN_Read_Buffer[2] == 'S') ))
102de814:	1affff98 	bne	102de67c <CallBack_UART_MAIN_Hdlr+0x88>
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102de818:	e3550000 	cmp	r5, #0
102de81c:	1affff96 	bne	102de67c <CallBack_UART_MAIN_Hdlr+0x88>
			{
				Certificate_File_Download_state = DPS;
102de820:	e1a00006 	mov	r0, r6
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
102de824:	e3a02c02 	mov	r2, #512	; 0x200
102de828:	e1a01005 	mov	r1, r5
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'P') && (UART_MAIN_Read_Buffer[2] == 'S') ))
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
			{
				Certificate_File_Download_state = DPS;
102de82c:	e3a03005 	mov	r3, #5
102de830:	e4c03030 	strb	r3, [r0], #48	; 0x30
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
102de834:	e12fff34 	blx	r4
102de838:	e59f36f0 	ldr	r3, [pc, #1776]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102de83c:	e59f16f0 	ldr	r1, [pc, #1776]	; 102def34 <CallBack_UART_MAIN_Hdlr+0x940>
102de840:	e5933000 	ldr	r3, [r3]
102de844:	e2860030 	add	r0, r6, #48	; 0x30
102de848:	e12fff33 	blx	r3
102de84c:	e2860030 	add	r0, r6, #48	; 0x30
102de850:	e59f36e0 	ldr	r3, [pc, #1760]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102de854:	e12fff33 	blx	r3
102de858:	e2861030 	add	r1, r6, #48	; 0x30
102de85c:	e59f36d8 	ldr	r3, [pc, #1752]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102de860:	e1a02000 	mov	r2, r0
102de864:	e3a0000a 	mov	r0, #10
102de868:	e12fff33 	blx	r3
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
102de86c:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102de870:	e1a01005 	mov	r1, r5
102de874:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102de878:	e12fff34 	blx	r4
				break;
102de87c:	eaffff9a 	b	102de6ec <CallBack_UART_MAIN_Hdlr+0xf8>
		/*******************************************************/
		/*****************STORE DEVICE ID***********************/
		/*******************************************************/
		if(Certificate_File_Download_state == DID)
		{
			if(Ql_strlen(UART_MAIN_Read_Buffer) == 15)
102de880:	e28d0010 	add	r0, sp, #16
102de884:	e59f56ac 	ldr	r5, [pc, #1708]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102de888:	e12fff35 	blx	r5
102de88c:	e350000f 	cmp	r0, #15
102de890:	0a000165 	beq	102dee2c <CallBack_UART_MAIN_Hdlr+0x838>
102de894:	e5d65000 	ldrb	r5, [r6]
102de898:	eaffff7f 	b	102de69c <CallBack_UART_MAIN_Hdlr+0xa8>
		}
		//---------------------------------------------------
		// Water Balance recharge
		if(UART_MAIN_Read_Buffer[0] == 'w')
		{
			char hrcbal[10] = "1.0";
102de89c:	e59f2680 	ldr	r2, [pc, #1664]	; 102def24 <CallBack_UART_MAIN_Hdlr+0x930>
102de8a0:	e3a05000 	mov	r5, #0
102de8a4:	e28d1004 	add	r1, sp, #4
102de8a8:	e28d3008 	add	r3, sp, #8
			RCbalance_now = Ql_atof((const char *)hrcbal);
102de8ac:	e1a00001 	mov	r0, r1
		}
		//---------------------------------------------------
		// Water Balance recharge
		if(UART_MAIN_Read_Buffer[0] == 'w')
		{
			char hrcbal[10] = "1.0";
102de8b0:	e1c350b4 	strh	r5, [r3, #4]
102de8b4:	e59f1684 	ldr	r1, [pc, #1668]	; 102def40 <CallBack_UART_MAIN_Hdlr+0x94c>
			RCbalance_now = Ql_atof((const char *)hrcbal);
102de8b8:	e59f3684 	ldr	r3, [pc, #1668]	; 102def44 <CallBack_UART_MAIN_Hdlr+0x950>
		}
		//---------------------------------------------------
		// Water Balance recharge
		if(UART_MAIN_Read_Buffer[0] == 'w')
		{
			char hrcbal[10] = "1.0";
102de8bc:	e28d7d5e 	add	r7, sp, #6016	; 0x1780
102de8c0:	e7871002 	str	r1, [r7, r2]
102de8c4:	e58d5008 	str	r5, [sp, #8]
			RCbalance_now = Ql_atof((const char *)hrcbal);
102de8c8:	e12fff33 	blx	r3
102de8cc:	e59f3674 	ldr	r3, [pc, #1652]	; 102def48 <CallBack_UART_MAIN_Hdlr+0x954>
102de8d0:	e12fff33 	blx	r3
			rechargebalance = RCbalance_now * 10;
102de8d4:	e59f1670 	ldr	r1, [pc, #1648]	; 102def4c <CallBack_UART_MAIN_Hdlr+0x958>
102de8d8:	e59f3670 	ldr	r3, [pc, #1648]	; 102def50 <CallBack_UART_MAIN_Hdlr+0x95c>
102de8dc:	e12fff33 	blx	r3
102de8e0:	e59f366c 	ldr	r3, [pc, #1644]	; 102def54 <CallBack_UART_MAIN_Hdlr+0x960>
102de8e4:	e12fff33 	blx	r3
			if(((water_balance) + (rechargebalance)) <= MAX_ALLOWED_WATER_BALANCE)
102de8e8:	e59f3668 	ldr	r3, [pc, #1640]	; 102def58 <CallBack_UART_MAIN_Hdlr+0x964>
102de8ec:	e59f2668 	ldr	r2, [pc, #1640]	; 102def5c <CallBack_UART_MAIN_Hdlr+0x968>
102de8f0:	e5931000 	ldr	r1, [r3]
		// Water Balance recharge
		if(UART_MAIN_Read_Buffer[0] == 'w')
		{
			char hrcbal[10] = "1.0";
			RCbalance_now = Ql_atof((const char *)hrcbal);
			rechargebalance = RCbalance_now * 10;
102de8f4:	e59f3664 	ldr	r3, [pc, #1636]	; 102def60 <CallBack_UART_MAIN_Hdlr+0x96c>
			if(((water_balance) + (rechargebalance)) <= MAX_ALLOWED_WATER_BALANCE)
102de8f8:	e0801001 	add	r1, r0, r1
102de8fc:	e1510002 	cmp	r1, r2
		// Water Balance recharge
		if(UART_MAIN_Read_Buffer[0] == 'w')
		{
			char hrcbal[10] = "1.0";
			RCbalance_now = Ql_atof((const char *)hrcbal);
			rechargebalance = RCbalance_now * 10;
102de900:	e5830000 	str	r0, [r3]
				APP_DEBUG("\r\n--> TopUp Recharge for %s gallons.-->\r\n",cmdrcbal);

				IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
			}
			else
				rechargebalance =0;
102de904:	85835000 	strhi	r5, [r3]
		if(UART_MAIN_Read_Buffer[0] == 'w')
		{
			char hrcbal[10] = "1.0";
			RCbalance_now = Ql_atof((const char *)hrcbal);
			rechargebalance = RCbalance_now * 10;
			if(((water_balance) + (rechargebalance)) <= MAX_ALLOWED_WATER_BALANCE)
102de908:	9a00012c 	bls	102dedc0 <CallBack_UART_MAIN_Hdlr+0x7cc>
102de90c:	e59f3604 	ldr	r3, [pc, #1540]	; 102def18 <CallBack_UART_MAIN_Hdlr+0x924>
102de910:	e28dcd5e 	add	ip, sp, #6016	; 0x1780
102de914:	e7dc3003 	ldrb	r3, [ip, r3]
102de918:	eaffff68 	b	102de6c0 <CallBack_UART_MAIN_Hdlr+0xcc>
		//--------------------------------------------------
		// // GET_IDENTITY
		if(UART_MAIN_Read_Buffer[0] == 'I')
		{

			APP_DEBUG("\r\n--> Identity command received.\r\n\n");
102de91c:	e3a02c02 	mov	r2, #512	; 0x200
102de920:	e3a01000 	mov	r1, #0
102de924:	e59f0600 	ldr	r0, [pc, #1536]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de928:	e12fff34 	blx	r4
102de92c:	e59f35fc 	ldr	r3, [pc, #1532]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102de930:	e59f162c 	ldr	r1, [pc, #1580]	; 102def64 <CallBack_UART_MAIN_Hdlr+0x970>
102de934:	e5933000 	ldr	r3, [r3]
102de938:	e59f05ec 	ldr	r0, [pc, #1516]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de93c:	e12fff33 	blx	r3
102de940:	e59f35f0 	ldr	r3, [pc, #1520]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102de944:	e59f05e0 	ldr	r0, [pc, #1504]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de948:	e12fff33 	blx	r3
102de94c:	e59f15d8 	ldr	r1, [pc, #1496]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de950:	e59f35e4 	ldr	r3, [pc, #1508]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102de954:	e1a02000 	mov	r2, r0
102de958:	e3a0000a 	mov	r0, #10
102de95c:	e12fff33 	blx	r3

			IPC_CMD_REQ_source |= SCHEDULE_IPC_GET_IDENTITY_CMD; // Get identification commmand
102de960:	e59f2600 	ldr	r2, [pc, #1536]	; 102def68 <CallBack_UART_MAIN_Hdlr+0x974>
102de964:	e28d0d5e 	add	r0, sp, #6016	; 0x1780
102de968:	e5921000 	ldr	r1, [r2]
102de96c:	e7d03005 	ldrb	r3, [r0, r5]
102de970:	e3811040 	orr	r1, r1, #64	; 0x40
102de974:	e5821000 	str	r1, [r2]
102de978:	eaffff4e 	b	102de6b8 <CallBack_UART_MAIN_Hdlr+0xc4>
		/*******************************************************/
		/*****************STORE DPS ID***********************/
		/*******************************************************/
		if(Certificate_File_Download_state == DPS)
		{
			Ql_strcpy(Read_Uart_Certificate_file_Buffer,UART_MAIN_Read_Buffer);
102de97c:	e28d1010 	add	r1, sp, #16
102de980:	e59f55e4 	ldr	r5, [pc, #1508]	; 102def6c <CallBack_UART_MAIN_Hdlr+0x978>
102de984:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102de988:	e12fff35 	blx	r5
			Ql_strcpy(AZURE_IoT_DPS_ID,Read_Uart_Certificate_file_Buffer);
102de98c:	e28d1efb 	add	r1, sp, #4016	; 0xfb0
102de990:	e59f05d8 	ldr	r0, [pc, #1496]	; 102def70 <CallBack_UART_MAIN_Hdlr+0x97c>
102de994:	e12fff35 	blx	r5
			Ql_memset(AZURE_assigned_IoT_Hub, 0x0, sizeof(AZURE_assigned_IoT_Hub));//Remove assigned IoT Hub information
102de998:	e3a02032 	mov	r2, #50	; 0x32
102de99c:	e3a01000 	mov	r1, #0
102de9a0:	e59f05cc 	ldr	r0, [pc, #1484]	; 102def74 <CallBack_UART_MAIN_Hdlr+0x980>
102de9a4:	e12fff34 	blx	r4
			Store_IoT_Persistent_Data();
102de9a8:	e59f35c8 	ldr	r3, [pc, #1480]	; 102def78 <CallBack_UART_MAIN_Hdlr+0x984>
102de9ac:	e12fff33 	blx	r3
			Read_IoT_Persistent_Data();
102de9b0:	e59f35c4 	ldr	r3, [pc, #1476]	; 102def7c <CallBack_UART_MAIN_Hdlr+0x988>
102de9b4:	e12fff33 	blx	r3
			if(Ql_strcmp(AZURE_IoT_DPS_ID, Read_Uart_Certificate_file_Buffer) == 0)
102de9b8:	e28d1efb 	add	r1, sp, #4016	; 0xfb0
102de9bc:	e59f35bc 	ldr	r3, [pc, #1468]	; 102def80 <CallBack_UART_MAIN_Hdlr+0x98c>
102de9c0:	e59f05a8 	ldr	r0, [pc, #1448]	; 102def70 <CallBack_UART_MAIN_Hdlr+0x97c>
102de9c4:	e12fff33 	blx	r3
		/*******************************************************/
		if(Certificate_File_Download_state == DPS)
		{
			Ql_strcpy(Read_Uart_Certificate_file_Buffer,UART_MAIN_Read_Buffer);
			Ql_strcpy(AZURE_IoT_DPS_ID,Read_Uart_Certificate_file_Buffer);
			Ql_memset(AZURE_assigned_IoT_Hub, 0x0, sizeof(AZURE_assigned_IoT_Hub));//Remove assigned IoT Hub information
102de9c8:	e59f3540 	ldr	r3, [pc, #1344]	; 102def10 <CallBack_UART_MAIN_Hdlr+0x91c>
			Store_IoT_Persistent_Data();
			Read_IoT_Persistent_Data();
			if(Ql_strcmp(AZURE_IoT_DPS_ID, Read_Uart_Certificate_file_Buffer) == 0)
			{
				APP_DEBUG("<-- PASS -->\r\n");//Return PASS indicates success in file Read and upload
102de9cc:	e3a02c02 	mov	r2, #512	; 0x200
			Ql_strcpy(Read_Uart_Certificate_file_Buffer,UART_MAIN_Read_Buffer);
			Ql_strcpy(AZURE_IoT_DPS_ID,Read_Uart_Certificate_file_Buffer);
			Ql_memset(AZURE_assigned_IoT_Hub, 0x0, sizeof(AZURE_assigned_IoT_Hub));//Remove assigned IoT Hub information
			Store_IoT_Persistent_Data();
			Read_IoT_Persistent_Data();
			if(Ql_strcmp(AZURE_IoT_DPS_ID, Read_Uart_Certificate_file_Buffer) == 0)
102de9d0:	e2501000 	subs	r1, r0, #0
102de9d4:	0a0000e5 	beq	102ded70 <CallBack_UART_MAIN_Hdlr+0x77c>
				//Reset the HW.. to have these variables in effect..
				IPC_CMD_REQ_source|=SCHEDULE_POWER_DOWN_WITH_BACKUP;
			}
			else
			{
				APP_DEBUG("<-- FAIL -->\r\n");//Return PASS indicates error in file Read and upload
102de9d8:	e3a01000 	mov	r1, #0
102de9dc:	e59f0548 	ldr	r0, [pc, #1352]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de9e0:	e12fff33 	blx	r3
102de9e4:	e59f3544 	ldr	r3, [pc, #1348]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102de9e8:	e59f1594 	ldr	r1, [pc, #1428]	; 102def84 <CallBack_UART_MAIN_Hdlr+0x990>
102de9ec:	e5933000 	ldr	r3, [r3]
102de9f0:	e59f0534 	ldr	r0, [pc, #1332]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102de9f4:	e12fff33 	blx	r3
102de9f8:	e59f3538 	ldr	r3, [pc, #1336]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102de9fc:	e59f0528 	ldr	r0, [pc, #1320]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dea00:	e12fff33 	blx	r3
102dea04:	e59f1520 	ldr	r1, [pc, #1312]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dea08:	e59f352c 	ldr	r3, [pc, #1324]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102dea0c:	e1a02000 	mov	r2, r0
102dea10:	e3a0000a 	mov	r0, #10
102dea14:	e12fff33 	blx	r3
			}
			FLAG.SUSPEND_IPC_COMMUNICATION = FAIL; // Restore the IPC state machine
102dea18:	e3a03000 	mov	r3, #0
102dea1c:	e5c63021 	strb	r3, [r6, #33]	; 0x21
			Certificate_File_Download_state = CERTIFICATE_COMMAND;
102dea20:	e5c63000 	strb	r3, [r6]
102dea24:	eaffff1e 	b	102de6a4 <CallBack_UART_MAIN_Hdlr+0xb0>
		/*********WRITE CLIENT KEY CERTIFICATE******************/
		/*******************************************************/
		//Send command CA0<file size> for ex."CA01206". This command is used for to store RootCA Liscence file.
		if(Certificate_File_Download_state == CERTIFICATE_CK0)// State machine is in Receive CK0 file and we received data on UART
		{
			Ql_strcpy(Read_Uart_Certificate_file_Buffer,UART_MAIN_Read_Buffer);  //copy received file to Read_Uart_Certificate_file_Buffer
102dea28:	e28d1010 	add	r1, sp, #16
102dea2c:	e59f3538 	ldr	r3, [pc, #1336]	; 102def6c <CallBack_UART_MAIN_Hdlr+0x978>
102dea30:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102dea34:	e12fff33 	blx	r3
			Ql_Sleep(1000);
102dea38:	e59f3548 	ldr	r3, [pc, #1352]	; 102def88 <CallBack_UART_MAIN_Hdlr+0x994>
102dea3c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
102dea40:	e12fff33 	blx	r3
			//The Use of Read_Uart_Certificate_file_Buffer and after that Read_Uart_buffer_one is due to, when data sending from UART at first time in Read_Uart_Certificate_file_Buffer
			//It takes only upto 370 Bytes. So, we are using "Read_Uart_buffer_one" to copy all bytes and then we merge both strings.
			Ql_UART_Read(UART_PORT_MAIN, Read_Uart_buffer_one, sizeof(Read_Uart_buffer_one)); // again read the uart buffer for remaining data to received in Read_Uart_buffer_one
102dea44:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102dea48:	e28d1e7e 	add	r1, sp, #2016	; 0x7e0
102dea4c:	e3a0000a 	mov	r0, #10
102dea50:	e12fff37 	blx	r7
			Ql_strcat(Read_Uart_Certificate_file_Buffer,Read_Uart_buffer_one);    //Merge two strings and store into Read_Uart_Certificate_file_Buffer
102dea54:	e28d1e7e 	add	r1, sp, #2016	; 0x7e0
102dea58:	e59f352c 	ldr	r3, [pc, #1324]	; 102def8c <CallBack_UART_MAIN_Hdlr+0x998>
102dea5c:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102dea60:	e12fff33 	blx	r3
			Read_Uart_Buffer_Temp_len = Ql_strlen(Read_Uart_Certificate_file_Buffer); // Find out the buffer length
102dea64:	e59f54cc 	ldr	r5, [pc, #1228]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102dea68:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102dea6c:	e12fff35 	blx	r5
			if(Cx0_File_Size == Read_Uart_Buffer_Temp_len)   //if file copied successfully then store file
102dea70:	e1d672bc 	ldrh	r7, [r6, #44]	; 0x2c
102dea74:	e1a00800 	lsl	r0, r0, #16
102dea78:	e1570820 	cmp	r7, r0, lsr #16
102dea7c:	0a000100 	beq	102dee84 <CallBack_UART_MAIN_Hdlr+0x890>
			{
				APP_DEBUG("<-- PASS -->\r\n");//Return PASS indicates success in file Read and upload
			}
			else
			{
				APP_DEBUG("<-- FAIL -->\r\n");//Return PASS indicates error in file Read and upload
102dea80:	e3a01000 	mov	r1, #0
102dea84:	e3a02c02 	mov	r2, #512	; 0x200
102dea88:	e59f049c 	ldr	r0, [pc, #1180]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dea8c:	e12fff34 	blx	r4
102dea90:	e59f14ec 	ldr	r1, [pc, #1260]	; 102def84 <CallBack_UART_MAIN_Hdlr+0x990>
				{
					APP_DEBUG("<-- PASS -->\r\n");//Return PASS indicates success in file Read and upload
				}
				else
				{
					APP_DEBUG("<-- FAIL -->\r\n");//Return PASS indicates error in file Read and upload
102dea94:	e59f3494 	ldr	r3, [pc, #1172]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102dea98:	e59f048c 	ldr	r0, [pc, #1164]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dea9c:	e5933000 	ldr	r3, [r3]
102deaa0:	e12fff33 	blx	r3
102deaa4:	e59f0480 	ldr	r0, [pc, #1152]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102deaa8:	e12fff35 	blx	r5
102deaac:	e59f3488 	ldr	r3, [pc, #1160]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102deab0:	e59f1474 	ldr	r1, [pc, #1140]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102deab4:	e1a02000 	mov	r2, r0
102deab8:	e3a0000a 	mov	r0, #10
102deabc:	e12fff33 	blx	r3
				}
				Certificate_File_Download_state = CERTIFICATE_COMMAND;
102deac0:	e3a03000 	mov	r3, #0
102deac4:	e5c63000 	strb	r3, [r6]
102deac8:	eafffef5 	b	102de6a4 <CallBack_UART_MAIN_Hdlr+0xb0>
		/*******************************************************/
		/*********WRITE ROOT CA CERTIFICATE******************/
		/*******************************************************/
		if(Certificate_File_Download_state == CERTIFICATE_CA0)// State machine is in Receive CK0 file and we received data on UART
		{
			Ql_strcpy(Read_Uart_Certificate_file_Buffer,UART_MAIN_Read_Buffer);  //copy received file to Read_Uart_Certificate_file_Buffer
102deacc:	e28d1010 	add	r1, sp, #16
102dead0:	e59f3494 	ldr	r3, [pc, #1172]	; 102def6c <CallBack_UART_MAIN_Hdlr+0x978>
102dead4:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102dead8:	e12fff33 	blx	r3
			Ql_Sleep(1000);
102deadc:	e59f34a4 	ldr	r3, [pc, #1188]	; 102def88 <CallBack_UART_MAIN_Hdlr+0x994>
102deae0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
102deae4:	e12fff33 	blx	r3
			//The Use of Read_Uart_Certificate_file_Buffer and after that Read_Uart_buffer_one is due to, when data sending from UART at first time in Read_Uart_Certificate_file_Buffer
			//It takes only upto 370 Bytes. So, we are using "Read_Uart_buffer_one" to copy all bytes and then we merge both strings.
			Ql_UART_Read(UART_PORT_MAIN, Read_Uart_buffer_one, sizeof(Read_Uart_buffer_one)); // again read the uart buffer for remaining data to received in Read_Uart_buffer_one
102deae8:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102deaec:	e28d1e7e 	add	r1, sp, #2016	; 0x7e0
102deaf0:	e3a0000a 	mov	r0, #10
102deaf4:	e12fff37 	blx	r7
			Ql_strcat(Read_Uart_Certificate_file_Buffer,Read_Uart_buffer_one);    //Merge two strings and store into Read_Uart_Certificate_file_Buffer
102deaf8:	e28d1e7e 	add	r1, sp, #2016	; 0x7e0
102deafc:	e59f3488 	ldr	r3, [pc, #1160]	; 102def8c <CallBack_UART_MAIN_Hdlr+0x998>
102deb00:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102deb04:	e12fff33 	blx	r3

			Read_Uart_Buffer_Temp_len = Ql_strlen(Read_Uart_Certificate_file_Buffer); // Find out the buffer length
102deb08:	e59f5428 	ldr	r5, [pc, #1064]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102deb0c:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102deb10:	e12fff35 	blx	r5
			if(Cx0_File_Size == Read_Uart_Buffer_Temp_len)   //if file copied successfully then store file
102deb14:	e1d672bc 	ldrh	r7, [r6, #44]	; 0x2c
102deb18:	e1a00800 	lsl	r0, r0, #16
102deb1c:	e1570820 	cmp	r7, r0, lsr #16
102deb20:	1affffd6 	bne	102dea80 <CallBack_UART_MAIN_Hdlr+0x48c>
			{
				ret = RIL_SSL_QSSLCERTIFICATE_DEL("CA0");//First Delete file if available.
102deb24:	e59f3464 	ldr	r3, [pc, #1124]	; 102def90 <CallBack_UART_MAIN_Hdlr+0x99c>
102deb28:	e59f0464 	ldr	r0, [pc, #1124]	; 102def94 <CallBack_UART_MAIN_Hdlr+0x9a0>
102deb2c:	e12fff33 	blx	r3
				ret = RIL_SSL_QSSLCERTIFICATE_WRITE("CA0",Read_Uart_Certificate_file_Buffer,Read_Uart_Buffer_Temp_len,100);//Write Licence file in NVRAM
102deb30:	e59f045c 	ldr	r0, [pc, #1116]	; 102def94 <CallBack_UART_MAIN_Hdlr+0x9a0>
102deb34:	e28d1efb 	add	r1, sp, #4016	; 0xfb0
102deb38:	e1a02007 	mov	r2, r7
102deb3c:	e3a03064 	mov	r3, #100	; 0x64
102deb40:	e59fc450 	ldr	ip, [pc, #1104]	; 102def98 <CallBack_UART_MAIN_Hdlr+0x9a4>
102deb44:	e12fff3c 	blx	ip

				if(ret == RIL_AT_SUCCESS)
102deb48:	e3500000 	cmp	r0, #0
102deb4c:	1affffcb 	bne	102dea80 <CallBack_UART_MAIN_Hdlr+0x48c>
				{
					ret = RIL_SSL_QSSLCERTIFICATE_READ("CA0");//Read file from NVRAM
102deb50:	e59f043c 	ldr	r0, [pc, #1084]	; 102def94 <CallBack_UART_MAIN_Hdlr+0x9a0>
102deb54:	e59f3440 	ldr	r3, [pc, #1088]	; 102def9c <CallBack_UART_MAIN_Hdlr+0x9a8>
102deb58:	e12fff33 	blx	r3
				}
			}

			if(ret == RIL_AT_SUCCESS)
102deb5c:	e2501000 	subs	r1, r0, #0
102deb60:	0a000026 	beq	102dec00 <CallBack_UART_MAIN_Hdlr+0x60c>
102deb64:	eaffffc5 	b	102dea80 <CallBack_UART_MAIN_Hdlr+0x48c>
		/*******************************************************/
		/*********WRITE CLIENT PUBLIC CERTIFICATE******************/
		/*******************************************************/
		if(Certificate_File_Download_state == CERTIFICATE_CC0)// State machine is in Receive CK0 file and we received data on UART
		{
			Ql_strcpy(Read_Uart_Certificate_file_Buffer,UART_MAIN_Read_Buffer);  //copy received file to Read_Uart_Certificate_file_Buffer
102deb68:	e28d1010 	add	r1, sp, #16
102deb6c:	e59f33f8 	ldr	r3, [pc, #1016]	; 102def6c <CallBack_UART_MAIN_Hdlr+0x978>
102deb70:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102deb74:	e12fff33 	blx	r3
			Ql_Sleep(1000);
102deb78:	e59f3408 	ldr	r3, [pc, #1032]	; 102def88 <CallBack_UART_MAIN_Hdlr+0x994>
102deb7c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
102deb80:	e12fff33 	blx	r3
			//The Use of Read_Uart_Certificate_file_Buffer and after that Read_Uart_buffer_one is due to, when data sending from UART at first time in Read_Uart_Certificate_file_Buffer
			//It takes only upto 370 Bytes. So, we are using "Read_Uart_buffer_one" to copy all bytes and then we merge both strings.
			Ql_UART_Read(UART_PORT_MAIN, Read_Uart_buffer_one, sizeof(Read_Uart_buffer_one)); // again read the uart buffer for remaining data to received in Read_Uart_buffer_one
102deb84:	e3a02e7d 	mov	r2, #2000	; 0x7d0
102deb88:	e28d1e7e 	add	r1, sp, #2016	; 0x7e0
102deb8c:	e3a0000a 	mov	r0, #10
102deb90:	e12fff37 	blx	r7
			Ql_strcat(Read_Uart_Certificate_file_Buffer,Read_Uart_buffer_one);    //Merge two strings and store into Read_Uart_Certificate_file_Buffer
102deb94:	e28d1e7e 	add	r1, sp, #2016	; 0x7e0
102deb98:	e59f33ec 	ldr	r3, [pc, #1004]	; 102def8c <CallBack_UART_MAIN_Hdlr+0x998>
102deb9c:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102deba0:	e12fff33 	blx	r3
			Read_Uart_Buffer_Temp_len = Ql_strlen(Read_Uart_Certificate_file_Buffer); // Find out the buffer length
102deba4:	e59f538c 	ldr	r5, [pc, #908]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102deba8:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102debac:	e12fff35 	blx	r5
			if(Cx0_File_Size == Read_Uart_Buffer_Temp_len)   //if file copied successfully then store file
102debb0:	e1d672bc 	ldrh	r7, [r6, #44]	; 0x2c
102debb4:	e1a00800 	lsl	r0, r0, #16
102debb8:	e1570820 	cmp	r7, r0, lsr #16
102debbc:	1affffaf 	bne	102dea80 <CallBack_UART_MAIN_Hdlr+0x48c>
			{
				ret = RIL_SSL_QSSLCERTIFICATE_DEL("CC0");	//First Delete file if available.
102debc0:	e59f33c8 	ldr	r3, [pc, #968]	; 102def90 <CallBack_UART_MAIN_Hdlr+0x99c>
102debc4:	e59f03d4 	ldr	r0, [pc, #980]	; 102defa0 <CallBack_UART_MAIN_Hdlr+0x9ac>
102debc8:	e12fff33 	blx	r3
				ret = RIL_SSL_QSSLCERTIFICATE_WRITE("CC0",Read_Uart_Certificate_file_Buffer,Read_Uart_Buffer_Temp_len,100);//Write Licence file in NVRAM
102debcc:	e59f03cc 	ldr	r0, [pc, #972]	; 102defa0 <CallBack_UART_MAIN_Hdlr+0x9ac>
102debd0:	e28d1efb 	add	r1, sp, #4016	; 0xfb0
102debd4:	e1a02007 	mov	r2, r7
102debd8:	e3a03064 	mov	r3, #100	; 0x64
102debdc:	e59fc3b4 	ldr	ip, [pc, #948]	; 102def98 <CallBack_UART_MAIN_Hdlr+0x9a4>
102debe0:	e12fff3c 	blx	ip

				if(ret == RIL_AT_SUCCESS)
102debe4:	e3500000 	cmp	r0, #0
102debe8:	1affffa4 	bne	102dea80 <CallBack_UART_MAIN_Hdlr+0x48c>
				{
					ret = RIL_SSL_QSSLCERTIFICATE_READ("CC0");//Read file from NVRAM
102debec:	e59f03ac 	ldr	r0, [pc, #940]	; 102defa0 <CallBack_UART_MAIN_Hdlr+0x9ac>
102debf0:	e59f33a4 	ldr	r3, [pc, #932]	; 102def9c <CallBack_UART_MAIN_Hdlr+0x9a8>
102debf4:	e12fff33 	blx	r3
				}
			}
			if(ret == RIL_AT_SUCCESS)
102debf8:	e2501000 	subs	r1, r0, #0
102debfc:	1affff9f 	bne	102dea80 <CallBack_UART_MAIN_Hdlr+0x48c>
				}
			}

			if(ret == RIL_AT_SUCCESS)
			{
				APP_DEBUG("<-- PASS -->\r\n");//Return PASS indicates success in file Read and upload
102dec00:	e3a02c02 	mov	r2, #512	; 0x200
102dec04:	e59f0320 	ldr	r0, [pc, #800]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dec08:	e12fff34 	blx	r4
102dec0c:	e59f1390 	ldr	r1, [pc, #912]	; 102defa4 <CallBack_UART_MAIN_Hdlr+0x9b0>
102dec10:	eaffff9f 	b	102dea94 <CallBack_UART_MAIN_Hdlr+0x4a0>
		}
		//---------------------------------------------------
		// Force FOTA
		if(UART_MAIN_Read_Buffer[0] == 'x')
		{
			Ql_strcpy(FOTA_URL, " https://s3.amazonaws.com/harmanfota/HUL/APPGS3MDM32A01_Upgrade_Package.bin");
102dec14:	e59f3350 	ldr	r3, [pc, #848]	; 102def6c <CallBack_UART_MAIN_Hdlr+0x978>
102dec18:	e59f0388 	ldr	r0, [pc, #904]	; 102defa8 <CallBack_UART_MAIN_Hdlr+0x9b4>
102dec1c:	e59f1388 	ldr	r1, [pc, #904]	; 102defac <CallBack_UART_MAIN_Hdlr+0x9b8>
102dec20:	e12fff33 	blx	r3
			FLAG.READY_TO_INITIATE_FOTA_DOWNLOAD = TRUE;
102dec24:	e3a03001 	mov	r3, #1
102dec28:	e5c63028 	strb	r3, [r6, #40]	; 0x28
102dec2c:	eafffeab 	b	102de6e0 <CallBack_UART_MAIN_Hdlr+0xec>
		// Reset Device to factory mode configuration

		if(UART_MAIN_Read_Buffer[0] == 'r')
		{

			APP_DEBUG("\r\n--> Reset Device...\r\n\n");
102dec30:	e3a02c02 	mov	r2, #512	; 0x200
102dec34:	e3a01000 	mov	r1, #0
102dec38:	e59f02ec 	ldr	r0, [pc, #748]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dec3c:	e12fff34 	blx	r4
102dec40:	e59f32e8 	ldr	r3, [pc, #744]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102dec44:	e59f1364 	ldr	r1, [pc, #868]	; 102defb0 <CallBack_UART_MAIN_Hdlr+0x9bc>
102dec48:	e5933000 	ldr	r3, [r3]
102dec4c:	e59f02d8 	ldr	r0, [pc, #728]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dec50:	e12fff33 	blx	r3
102dec54:	e59f32dc 	ldr	r3, [pc, #732]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102dec58:	e59f02cc 	ldr	r0, [pc, #716]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dec5c:	e12fff33 	blx	r3
102dec60:	e59f12c4 	ldr	r1, [pc, #708]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dec64:	e59f32d0 	ldr	r3, [pc, #720]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102dec68:	e1a02000 	mov	r2, r0
102dec6c:	e3a0000a 	mov	r0, #10
102dec70:	e12fff33 	blx	r3

			rechargebalance = 0;
			IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102dec74:	e59f22ec 	ldr	r2, [pc, #748]	; 102def68 <CallBack_UART_MAIN_Hdlr+0x974>
102dec78:	e59f3298 	ldr	r3, [pc, #664]	; 102def18 <CallBack_UART_MAIN_Hdlr+0x924>
102dec7c:	e5921000 	ldr	r1, [r2]
102dec80:	e28dcd5e 	add	ip, sp, #6016	; 0x1780
102dec84:	e3811020 	orr	r1, r1, #32
		if(UART_MAIN_Read_Buffer[0] == 'r')
		{

			APP_DEBUG("\r\n--> Reset Device...\r\n\n");

			rechargebalance = 0;
102dec88:	e59f02d0 	ldr	r0, [pc, #720]	; 102def60 <CallBack_UART_MAIN_Hdlr+0x96c>
102dec8c:	e7dc3003 	ldrb	r3, [ip, r3]
			IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102dec90:	e5821000 	str	r1, [r2]
		if(UART_MAIN_Read_Buffer[0] == 'r')
		{

			APP_DEBUG("\r\n--> Reset Device...\r\n\n");

			rechargebalance = 0;
102dec94:	e3a0c000 	mov	ip, #0
			IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
			FLAG.DEVICE_RESET_SCHEDULED = TRUE;
102dec98:	e3a02001 	mov	r2, #1
		if(UART_MAIN_Read_Buffer[0] == 'r')
		{

			APP_DEBUG("\r\n--> Reset Device...\r\n\n");

			rechargebalance = 0;
102dec9c:	e580c000 	str	ip, [r0]
			IPC_CMD_REQ_source |= SCHEDULE_IPC_RESET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
			FLAG.DEVICE_RESET_SCHEDULED = TRUE;
102deca0:	e5c62015 	strb	r2, [r6, #21]
102deca4:	eafffe8b 	b	102de6d8 <CallBack_UART_MAIN_Hdlr+0xe4>
		//---------------------------------------------------
		// // UnLock
		if(UART_MAIN_Read_Buffer[0] == 'u')
		{

			APP_DEBUG("\r\n--> UnLock command received.\r\n\n");
102deca8:	e3a02c02 	mov	r2, #512	; 0x200
102decac:	e3a01000 	mov	r1, #0
102decb0:	e59f0274 	ldr	r0, [pc, #628]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102decb4:	e12fff34 	blx	r4
102decb8:	e59f3270 	ldr	r3, [pc, #624]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102decbc:	e59f12f0 	ldr	r1, [pc, #752]	; 102defb4 <CallBack_UART_MAIN_Hdlr+0x9c0>
102decc0:	e5933000 	ldr	r3, [r3]
102decc4:	e59f0260 	ldr	r0, [pc, #608]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102decc8:	e12fff33 	blx	r3
102deccc:	e59f3264 	ldr	r3, [pc, #612]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102decd0:	e59f0254 	ldr	r0, [pc, #596]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102decd4:	e12fff33 	blx	r3
102decd8:	e59f124c 	ldr	r1, [pc, #588]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102decdc:	e59f3258 	ldr	r3, [pc, #600]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102dece0:	e28d7d5e 	add	r7, sp, #6016	; 0x1780
102dece4:	e1a02000 	mov	r2, r0
102dece8:	e3a0000a 	mov	r0, #10
102decec:	e12fff33 	blx	r3

			IPC_CMD_REQ_source |= SCHEDULE_IPC_UNLOCK_CMD; // Set water balance data command is scheduled
102decf0:	e59f2270 	ldr	r2, [pc, #624]	; 102def68 <CallBack_UART_MAIN_Hdlr+0x974>
102decf4:	e59f321c 	ldr	r3, [pc, #540]	; 102def18 <CallBack_UART_MAIN_Hdlr+0x924>
102decf8:	e5921000 	ldr	r1, [r2]
102decfc:	e7d73003 	ldrb	r3, [r7, r3]
102ded00:	e3811004 	orr	r1, r1, #4
102ded04:	e5821000 	str	r1, [r2]
102ded08:	eafffe70 	b	102de6d0 <CallBack_UART_MAIN_Hdlr+0xdc>
		//---------------------------------------------------
		// // Lock
		if(UART_MAIN_Read_Buffer[0] == 'l')
		{

			APP_DEBUG("\r\n--> Lock command received.\r\n\n");
102ded0c:	e3a02c02 	mov	r2, #512	; 0x200
102ded10:	e3a01000 	mov	r1, #0
102ded14:	e59f0210 	ldr	r0, [pc, #528]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102ded18:	e12fff34 	blx	r4
102ded1c:	e59f320c 	ldr	r3, [pc, #524]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102ded20:	e59f1290 	ldr	r1, [pc, #656]	; 102defb8 <CallBack_UART_MAIN_Hdlr+0x9c4>
102ded24:	e5933000 	ldr	r3, [r3]
102ded28:	e59f01fc 	ldr	r0, [pc, #508]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102ded2c:	e12fff33 	blx	r3
102ded30:	e59f3200 	ldr	r3, [pc, #512]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102ded34:	e59f01f0 	ldr	r0, [pc, #496]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102ded38:	e12fff33 	blx	r3
102ded3c:	e59f11e8 	ldr	r1, [pc, #488]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102ded40:	e59f31f4 	ldr	r3, [pc, #500]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102ded44:	e1a02000 	mov	r2, r0
102ded48:	e3a0000a 	mov	r0, #10
102ded4c:	e12fff33 	blx	r3

			IPC_CMD_REQ_source |= SCHEDULE_IPC_LOCK_CMD; // Set water balance data command is scheduled
102ded50:	e59f2210 	ldr	r2, [pc, #528]	; 102def68 <CallBack_UART_MAIN_Hdlr+0x974>
102ded54:	e59f31bc 	ldr	r3, [pc, #444]	; 102def18 <CallBack_UART_MAIN_Hdlr+0x924>
102ded58:	e5921000 	ldr	r1, [r2]
102ded5c:	e28d0d5e 	add	r0, sp, #6016	; 0x1780
102ded60:	e3811008 	orr	r1, r1, #8
102ded64:	e7d03003 	ldrb	r3, [r0, r3]
102ded68:	e5821000 	str	r1, [r2]
102ded6c:	eafffe55 	b	102de6c8 <CallBack_UART_MAIN_Hdlr+0xd4>
			Ql_memset(AZURE_assigned_IoT_Hub, 0x0, sizeof(AZURE_assigned_IoT_Hub));//Remove assigned IoT Hub information
			Store_IoT_Persistent_Data();
			Read_IoT_Persistent_Data();
			if(Ql_strcmp(AZURE_IoT_DPS_ID, Read_Uart_Certificate_file_Buffer) == 0)
			{
				APP_DEBUG("<-- PASS -->\r\n");//Return PASS indicates success in file Read and upload
102ded70:	e59f01b4 	ldr	r0, [pc, #436]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102ded74:	e12fff33 	blx	r3
102ded78:	e59f31b0 	ldr	r3, [pc, #432]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102ded7c:	e59f1220 	ldr	r1, [pc, #544]	; 102defa4 <CallBack_UART_MAIN_Hdlr+0x9b0>
102ded80:	e5933000 	ldr	r3, [r3]
102ded84:	e59f01a0 	ldr	r0, [pc, #416]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102ded88:	e12fff33 	blx	r3
102ded8c:	e59f31a4 	ldr	r3, [pc, #420]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102ded90:	e59f0194 	ldr	r0, [pc, #404]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102ded94:	e12fff33 	blx	r3
102ded98:	e59f319c 	ldr	r3, [pc, #412]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102ded9c:	e59f1188 	ldr	r1, [pc, #392]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102deda0:	e1a02000 	mov	r2, r0
102deda4:	e3a0000a 	mov	r0, #10
102deda8:	e12fff33 	blx	r3
				//Reset the HW.. to have these variables in effect..
				IPC_CMD_REQ_source|=SCHEDULE_POWER_DOWN_WITH_BACKUP;
102dedac:	e59f31b4 	ldr	r3, [pc, #436]	; 102def68 <CallBack_UART_MAIN_Hdlr+0x974>
102dedb0:	e5932000 	ldr	r2, [r3]
102dedb4:	e3822a01 	orr	r2, r2, #4096	; 0x1000
102dedb8:	e5832000 	str	r2, [r3]
102dedbc:	eaffff15 	b	102dea18 <CallBack_UART_MAIN_Hdlr+0x424>
			char hrcbal[10] = "1.0";
			RCbalance_now = Ql_atof((const char *)hrcbal);
			rechargebalance = RCbalance_now * 10;
			if(((water_balance) + (rechargebalance)) <= MAX_ALLOWED_WATER_BALANCE)
			{
				Ql_strcpy(cmdrcbal,hrcbal);
102dedc0:	e59f31a4 	ldr	r3, [pc, #420]	; 102def6c <CallBack_UART_MAIN_Hdlr+0x978>
102dedc4:	e28d1004 	add	r1, sp, #4
102dedc8:	e59f01ec 	ldr	r0, [pc, #492]	; 102defbc <CallBack_UART_MAIN_Hdlr+0x9c8>
102dedcc:	e12fff33 	blx	r3

				APP_DEBUG("\r\n--> TopUp Recharge for %s gallons.-->\r\n",cmdrcbal);
102dedd0:	e1a01005 	mov	r1, r5
102dedd4:	e3a02c02 	mov	r2, #512	; 0x200
102dedd8:	e59f014c 	ldr	r0, [pc, #332]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102deddc:	e12fff34 	blx	r4
102dede0:	e59f3148 	ldr	r3, [pc, #328]	; 102def30 <CallBack_UART_MAIN_Hdlr+0x93c>
102dede4:	e59f11d4 	ldr	r1, [pc, #468]	; 102defc0 <CallBack_UART_MAIN_Hdlr+0x9cc>
102dede8:	e59f21cc 	ldr	r2, [pc, #460]	; 102defbc <CallBack_UART_MAIN_Hdlr+0x9c8>
102dedec:	e5933000 	ldr	r3, [r3]
102dedf0:	e59f0134 	ldr	r0, [pc, #308]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dedf4:	e12fff33 	blx	r3
102dedf8:	e59f3138 	ldr	r3, [pc, #312]	; 102def38 <CallBack_UART_MAIN_Hdlr+0x944>
102dedfc:	e59f0128 	ldr	r0, [pc, #296]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dee00:	e12fff33 	blx	r3
102dee04:	e59f3130 	ldr	r3, [pc, #304]	; 102def3c <CallBack_UART_MAIN_Hdlr+0x948>
102dee08:	e59f111c 	ldr	r1, [pc, #284]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dee0c:	e1a02000 	mov	r2, r0
102dee10:	e3a0000a 	mov	r0, #10
102dee14:	e12fff33 	blx	r3

				IPC_CMD_REQ_source |= SCHEDULE_IPC_SET_WATER_DATA_CMD; // Schedule IPC command towards Control Module
102dee18:	e59f3148 	ldr	r3, [pc, #328]	; 102def68 <CallBack_UART_MAIN_Hdlr+0x974>
102dee1c:	e5932000 	ldr	r2, [r3]
102dee20:	e3822002 	orr	r2, r2, #2
102dee24:	e5832000 	str	r2, [r3]
102dee28:	eafffeb7 	b	102de90c <CallBack_UART_MAIN_Hdlr+0x318>
		/*******************************************************/
		if(Certificate_File_Download_state == DID)
		{
			if(Ql_strlen(UART_MAIN_Read_Buffer) == 15)
			{
				Ql_strcpy(Read_Uart_Certificate_file_Buffer,UART_MAIN_Read_Buffer);
102dee2c:	e28d1010 	add	r1, sp, #16
102dee30:	e59f7134 	ldr	r7, [pc, #308]	; 102def6c <CallBack_UART_MAIN_Hdlr+0x978>
102dee34:	e28d0efb 	add	r0, sp, #4016	; 0xfb0
102dee38:	e12fff37 	blx	r7
				Ql_strcpy(AZURE_IoT_device_ID,Read_Uart_Certificate_file_Buffer);
102dee3c:	e28d1efb 	add	r1, sp, #4016	; 0xfb0
102dee40:	e59f017c 	ldr	r0, [pc, #380]	; 102defc4 <CallBack_UART_MAIN_Hdlr+0x9d0>
102dee44:	e12fff37 	blx	r7
				Store_IoT_Persistent_Data();
102dee48:	e59f3128 	ldr	r3, [pc, #296]	; 102def78 <CallBack_UART_MAIN_Hdlr+0x984>
102dee4c:	e12fff33 	blx	r3
				Read_IoT_Persistent_Data();
102dee50:	e59f3124 	ldr	r3, [pc, #292]	; 102def7c <CallBack_UART_MAIN_Hdlr+0x988>
102dee54:	e12fff33 	blx	r3
				if(Ql_strcmp(AZURE_IoT_device_ID, Read_Uart_Certificate_file_Buffer) == 0)
102dee58:	e28d1efb 	add	r1, sp, #4016	; 0xfb0
102dee5c:	e59f0160 	ldr	r0, [pc, #352]	; 102defc4 <CallBack_UART_MAIN_Hdlr+0x9d0>
102dee60:	e59f3118 	ldr	r3, [pc, #280]	; 102def80 <CallBack_UART_MAIN_Hdlr+0x98c>
102dee64:	e12fff33 	blx	r3
				{
					APP_DEBUG("<-- PASS -->\r\n");//Return PASS indicates success in file Read and upload
102dee68:	e3a02c02 	mov	r2, #512	; 0x200
			{
				Ql_strcpy(Read_Uart_Certificate_file_Buffer,UART_MAIN_Read_Buffer);
				Ql_strcpy(AZURE_IoT_device_ID,Read_Uart_Certificate_file_Buffer);
				Store_IoT_Persistent_Data();
				Read_IoT_Persistent_Data();
				if(Ql_strcmp(AZURE_IoT_device_ID, Read_Uart_Certificate_file_Buffer) == 0)
102dee6c:	e2501000 	subs	r1, r0, #0
102dee70:	1a000020 	bne	102deef8 <CallBack_UART_MAIN_Hdlr+0x904>
				{
					APP_DEBUG("<-- PASS -->\r\n");//Return PASS indicates success in file Read and upload
102dee74:	e59f00b0 	ldr	r0, [pc, #176]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102dee78:	e12fff34 	blx	r4
102dee7c:	e59f1120 	ldr	r1, [pc, #288]	; 102defa4 <CallBack_UART_MAIN_Hdlr+0x9b0>
102dee80:	eaffff03 	b	102dea94 <CallBack_UART_MAIN_Hdlr+0x4a0>
			Ql_UART_Read(UART_PORT_MAIN, Read_Uart_buffer_one, sizeof(Read_Uart_buffer_one)); // again read the uart buffer for remaining data to received in Read_Uart_buffer_one
			Ql_strcat(Read_Uart_Certificate_file_Buffer,Read_Uart_buffer_one);    //Merge two strings and store into Read_Uart_Certificate_file_Buffer
			Read_Uart_Buffer_Temp_len = Ql_strlen(Read_Uart_Certificate_file_Buffer); // Find out the buffer length
			if(Cx0_File_Size == Read_Uart_Buffer_Temp_len)   //if file copied successfully then store file
			{
				ret = RIL_SSL_QSSLCERTIFICATE_DEL("CK0");	//First Delete file if available.
102dee84:	e59f3104 	ldr	r3, [pc, #260]	; 102def90 <CallBack_UART_MAIN_Hdlr+0x99c>
102dee88:	e59f0138 	ldr	r0, [pc, #312]	; 102defc8 <CallBack_UART_MAIN_Hdlr+0x9d4>
102dee8c:	e12fff33 	blx	r3
				ret= RIL_SSL_QSSLCERTIFICATE_WRITE("CK0",Read_Uart_Certificate_file_Buffer,Read_Uart_Buffer_Temp_len,100); //Write Licence file in NVRAM
102dee90:	e59f0130 	ldr	r0, [pc, #304]	; 102defc8 <CallBack_UART_MAIN_Hdlr+0x9d4>
102dee94:	e28d1efb 	add	r1, sp, #4016	; 0xfb0
102dee98:	e1a02007 	mov	r2, r7
102dee9c:	e3a03064 	mov	r3, #100	; 0x64
102deea0:	e59fc0f0 	ldr	ip, [pc, #240]	; 102def98 <CallBack_UART_MAIN_Hdlr+0x9a4>
102deea4:	e12fff3c 	blx	ip

				if(ret == RIL_AT_SUCCESS)
102deea8:	e3500000 	cmp	r0, #0
102deeac:	1afffef3 	bne	102dea80 <CallBack_UART_MAIN_Hdlr+0x48c>
				{
					ret = RIL_SSL_QSSLCERTIFICATE_READ("CK0");//Read file from NVRAM
102deeb0:	e59f0110 	ldr	r0, [pc, #272]	; 102defc8 <CallBack_UART_MAIN_Hdlr+0x9d4>
102deeb4:	e59f30e0 	ldr	r3, [pc, #224]	; 102def9c <CallBack_UART_MAIN_Hdlr+0x9a8>
102deeb8:	e12fff33 	blx	r3
				}
			}
			if(ret == RIL_AT_SUCCESS)
102deebc:	e2501000 	subs	r1, r0, #0
102deec0:	0affff4e 	beq	102dec00 <CallBack_UART_MAIN_Hdlr+0x60c>
102deec4:	eafffeed 	b	102dea80 <CallBack_UART_MAIN_Hdlr+0x48c>
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
				break;
			}
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'I') && (UART_MAIN_Read_Buffer[2] == 'D') ))
102deec8:	e5dd3012 	ldrb	r3, [sp, #18]
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102deecc:	e59f6048 	ldr	r6, [pc, #72]	; 102def1c <CallBack_UART_MAIN_Hdlr+0x928>
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
				break;
			}
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'I') && (UART_MAIN_Read_Buffer[2] == 'D') ))
102deed0:	e3530044 	cmp	r3, #68	; 0x44
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102deed4:	e5d65000 	ldrb	r5, [r6]
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
				Ql_memset(Read_Uart_Certificate_file_Buffer, 0, sizeof(Read_Uart_Certificate_file_Buffer));
				break;
			}
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'I') && (UART_MAIN_Read_Buffer[2] == 'D') ))
102deed8:	1afffde7 	bne	102de67c <CallBack_UART_MAIN_Hdlr+0x88>
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
102deedc:	e3550000 	cmp	r5, #0
102deee0:	1afffde5 	bne	102de67c <CallBack_UART_MAIN_Hdlr+0x88>
			{
				Certificate_File_Download_state = DID;
102deee4:	e1a00006 	mov	r0, r6
				APP_DEBUG("\r\n--> OK \r\n");// To infortm the external script about readiness to receive the file
102deee8:	e3a02c02 	mov	r2, #512	; 0x200
102deeec:	e1a01005 	mov	r1, r5
		}
		if(((UART_MAIN_Read_Buffer[0] == 'D') && (UART_MAIN_Read_Buffer[1] == 'I') && (UART_MAIN_Read_Buffer[2] == 'D') ))
		{
			if(Certificate_File_Download_state == CERTIFICATE_COMMAND)
			{
				Certificate_File_Download_state = DID;
102deef0:	e3a03004 	mov	r3, #4
102deef4:	eafffe4d 	b	102de830 <CallBack_UART_MAIN_Hdlr+0x23c>
				{
					APP_DEBUG("<-- PASS -->\r\n");//Return PASS indicates success in file Read and upload
				}
				else
				{
					APP_DEBUG("<-- FAIL -->\r\n");//Return PASS indicates error in file Read and upload
102deef8:	e3a01000 	mov	r1, #0
102deefc:	e59f0028 	ldr	r0, [pc, #40]	; 102def2c <CallBack_UART_MAIN_Hdlr+0x938>
102def00:	e12fff34 	blx	r4
102def04:	e59f1078 	ldr	r1, [pc, #120]	; 102def84 <CallBack_UART_MAIN_Hdlr+0x990>
102def08:	eafffee1 	b	102dea94 <CallBack_UART_MAIN_Hdlr+0x4a0>
102def0c:	102df9d5 	.word	0x102df9d5
102def10:	102e58f4 	.word	0x102e58f4
102def14:	102e62a0 	.word	0x102e62a0
102def18:	ffffe890 	.word	0xffffe890
102def1c:	f03da5ec 	.word	0xf03da5ec
102def20:	102e6310 	.word	0x102e6310
102def24:	ffffe884 	.word	0xffffe884
102def28:	102e5a8c 	.word	0x102e5a8c
102def2c:	f03da61c 	.word	0xf03da61c
102def30:	f03de540 	.word	0xf03de540
102def34:	102f00d4 	.word	0x102f00d4
102def38:	102e57a4 	.word	0x102e57a4
102def3c:	102e6230 	.word	0x102e6230
102def40:	00302e31 	.word	0x00302e31
102def44:	102e5564 	.word	0x102e5564
102def48:	102e39b0 	.word	0x102e39b0
102def4c:	41200000 	.word	0x41200000
102def50:	102e3a50 	.word	0x102e3a50
102def54:	102e3e5c 	.word	0x102e3e5c
102def58:	f03d5bf4 	.word	0xf03d5bf4
102def5c:	0000270f 	.word	0x0000270f
102def60:	f03d5bd8 	.word	0xf03d5bd8
102def64:	102f0100 	.word	0x102f0100
102def68:	f03da514 	.word	0xf03da514
102def6c:	102e55fc 	.word	0x102e55fc
102def70:	f03d5e18 	.word	0xf03d5e18
102def74:	f03d5e34 	.word	0xf03d5e34
102def78:	102d3988 	.word	0x102d3988
102def7c:	102d3c1c 	.word	0x102d3c1c
102def80:	102e581c 	.word	0x102e581c
102def84:	102f00f0 	.word	0x102f00f0
102def88:	102e5b10 	.word	0x102e5b10
102def8c:	102e5724 	.word	0x102e5724
102def90:	102dbec8 	.word	0x102dbec8
102def94:	102ef468 	.word	0x102ef468
102def98:	102dbf64 	.word	0x102dbf64
102def9c:	102dc014 	.word	0x102dc014
102defa0:	102ef464 	.word	0x102ef464
102defa4:	102f00e0 	.word	0x102f00e0
102defa8:	f03d6168 	.word	0xf03d6168
102defac:	102f01b0 	.word	0x102f01b0
102defb0:	102f0194 	.word	0x102f0194
102defb4:	102f0170 	.word	0x102f0170
102defb8:	102f0150 	.word	0x102f0150
102defbc:	f03d5be8 	.word	0xf03d5be8
102defc0:	102f0124 	.word	0x102f0124
102defc4:	f03d5dfc 	.word	0xf03d5dfc
102defc8:	102ef460 	.word	0x102ef460

102defcc <Get_Signal_RSSI>:
/***************************************************************************
 * Function: Get_Signal_RSSI
 * Description: Process the rssi data for the signal strength.
 ****************************************************************************/
void Get_Signal_RSSI(void)
{
102defcc:	e92d4030 	push	{r4, r5, lr}
	u32 nw_signal_bit_err_code =0;
	if(FLAG.SIMCARD_REGISTERED == TRUE)//Read RSSI only if SIM Card is Present and detected
102defd0:	e59f40e0 	ldr	r4, [pc, #224]	; 102df0b8 <Get_Signal_RSSI+0xec>
/***************************************************************************
 * Function: Get_Signal_RSSI
 * Description: Process the rssi data for the signal strength.
 ****************************************************************************/
void Get_Signal_RSSI(void)
{
102defd4:	e24dd00c 	sub	sp, sp, #12
	u32 nw_signal_bit_err_code =0;
	if(FLAG.SIMCARD_REGISTERED == TRUE)//Read RSSI only if SIM Card is Present and detected
102defd8:	e5d43006 	ldrb	r3, [r4, #6]
 * Function: Get_Signal_RSSI
 * Description: Process the rssi data for the signal strength.
 ****************************************************************************/
void Get_Signal_RSSI(void)
{
	u32 nw_signal_bit_err_code =0;
102defdc:	e3a05000 	mov	r5, #0
	if(FLAG.SIMCARD_REGISTERED == TRUE)//Read RSSI only if SIM Card is Present and detected
102defe0:	e3530001 	cmp	r3, #1
 * Function: Get_Signal_RSSI
 * Description: Process the rssi data for the signal strength.
 ****************************************************************************/
void Get_Signal_RSSI(void)
{
	u32 nw_signal_bit_err_code =0;
102defe4:	e58d5004 	str	r5, [sp, #4]
	if(FLAG.SIMCARD_REGISTERED == TRUE)//Read RSSI only if SIM Card is Present and detected
102defe8:	0a000001 	beq	102deff4 <Get_Signal_RSSI+0x28>
						PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_CONNECTIVITY_ON;
				}
			}
		}
	}
}
102defec:	e28dd00c 	add	sp, sp, #12
102deff0:	e8bd8030 	pop	{r4, r5, pc}
void Get_Signal_RSSI(void)
{
	u32 nw_signal_bit_err_code =0;
	if(FLAG.SIMCARD_REGISTERED == TRUE)//Read RSSI only if SIM Card is Present and detected
	{
		RIL_NW_GetSignalQuality(&rssi, &nw_signal_bit_err_code);
102deff4:	e59f30c0 	ldr	r3, [pc, #192]	; 102df0bc <Get_Signal_RSSI+0xf0>
102deff8:	e2840e23 	add	r0, r4, #560	; 0x230
102deffc:	e28d1004 	add	r1, sp, #4
102df000:	e12fff33 	blx	r3

		if(!(rssi>0 && rssi <32))
102df004:	e5943230 	ldr	r3, [r4, #560]	; 0x230
102df008:	e2432001 	sub	r2, r3, #1
102df00c:	e352001e 	cmp	r2, #30
			rssi = 0;
102df010:	81a02005 	movhi	r2, r5
102df014:	85845230 	strhi	r5, [r4, #560]	; 0x230
		RssiLevel = (s8)rssi;
102df018:	e59f5098 	ldr	r5, [pc, #152]	; 102df0b8 <Get_Signal_RSSI+0xec>
102df01c:	920320ff 	andls	r2, r3, #255	; 0xff
	if(FLAG.SIMCARD_REGISTERED == TRUE)//Read RSSI only if SIM Card is Present and detected
	{
		RIL_NW_GetSignalQuality(&rssi, &nw_signal_bit_err_code);

		if(!(rssi>0 && rssi <32))
			rssi = 0;
102df020:	81a03002 	movhi	r3, r2
		RssiLevel = (s8)rssi;
102df024:	e5c42234 	strb	r2, [r4, #564]	; 0x234
		//compare with previous with current rssi level if same do not update on lcd
		if(previous_rssival != rssi)
102df028:	e2852f8d 	add	r2, r5, #564	; 0x234
102df02c:	e1d220d1 	ldrsb	r2, [r2, #1]
102df030:	e1520003 	cmp	r2, r3
102df034:	0affffec 	beq	102defec <Get_Signal_RSSI+0x20>
		{
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_ANTENNA_SYMBOL);
102df038:	e3a03000 	mov	r3, #0
102df03c:	e3a00003 	mov	r0, #3
102df040:	e59f1078 	ldr	r1, [pc, #120]	; 102df0c0 <Get_Signal_RSSI+0xf4>
102df044:	e3a02002 	mov	r2, #2
102df048:	e59fc074 	ldr	ip, [pc, #116]	; 102df0c4 <Get_Signal_RSSI+0xf8>
102df04c:	e12fff3c 	blx	ip
			if(rssi<10 && (FLAG.RSSI_LOW_DETECT == FALSE)) // RSSI fall below 10 so need to publish this event
102df050:	e5953230 	ldr	r3, [r5, #560]	; 0x230
102df054:	e3530009 	cmp	r3, #9
102df058:	e5d53007 	ldrb	r3, [r5, #7]
102df05c:	8a00000a 	bhi	102df08c <Get_Signal_RSSI+0xc0>
102df060:	e3530000 	cmp	r3, #0
102df064:	1a000008 	bne	102df08c <Get_Signal_RSSI+0xc0>
			{
				FLAG.RSSI_LOW_DETECT = TRUE;
				if(FLAG.CON_MSG_PUBLISH_PENDING == FALSE)//If already connected to cloud and connectivity status is already published then do this for new RSSI level
102df068:	e5d53008 	ldrb	r3, [r5, #8]
102df06c:	e3530000 	cmp	r3, #0
		if(previous_rssival != rssi)
		{
			Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_ANTENNA_SYMBOL);
			if(rssi<10 && (FLAG.RSSI_LOW_DETECT == FALSE)) // RSSI fall below 10 so need to publish this event
			{
				FLAG.RSSI_LOW_DETECT = TRUE;
102df070:	e3a03001 	mov	r3, #1
102df074:	e5c53007 	strb	r3, [r5, #7]
				if(FLAG.CON_MSG_PUBLISH_PENDING == FALSE)//If already connected to cloud and connectivity status is already published then do this for new RSSI level
					PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_CONNECTIVITY_LOW;
102df078:	059f3048 	ldreq	r3, [pc, #72]	; 102df0c8 <Get_Signal_RSSI+0xfc>
102df07c:	05932000 	ldreq	r2, [r3]
102df080:	03822c02 	orreq	r2, r2, #512	; 0x200
102df084:	05832000 	streq	r2, [r3]
102df088:	eaffffd7 	b	102defec <Get_Signal_RSSI+0x20>
			}
			else // RSSI is above 10
			{
				if(FLAG.RSSI_LOW_DETECT == TRUE) // Reset the RSSI Low flag in case it is already set to true
102df08c:	e3530001 	cmp	r3, #1
102df090:	1affffd5 	bne	102defec <Get_Signal_RSSI+0x20>
				{
					FLAG.RSSI_LOW_DETECT = FALSE;
					if(FLAG.CON_MSG_PUBLISH_PENDING == FALSE)//If already connected to cloud and connectivity status is already published then do this for new RSSI level
102df094:	e5d43008 	ldrb	r3, [r4, #8]
102df098:	e3530000 	cmp	r3, #0
			}
			else // RSSI is above 10
			{
				if(FLAG.RSSI_LOW_DETECT == TRUE) // Reset the RSSI Low flag in case it is already set to true
				{
					FLAG.RSSI_LOW_DETECT = FALSE;
102df09c:	e3a03000 	mov	r3, #0
102df0a0:	e5c43007 	strb	r3, [r4, #7]
					if(FLAG.CON_MSG_PUBLISH_PENDING == FALSE)//If already connected to cloud and connectivity status is already published then do this for new RSSI level
						PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_CONNECTIVITY_ON;
102df0a4:	059f301c 	ldreq	r3, [pc, #28]	; 102df0c8 <Get_Signal_RSSI+0xfc>
102df0a8:	05932000 	ldreq	r2, [r3]
102df0ac:	03822020 	orreq	r2, r2, #32
102df0b0:	05832000 	streq	r2, [r3]
102df0b4:	eaffffcc 	b	102defec <Get_Signal_RSSI+0x20>
102df0b8:	f03da5ec 	.word	0xf03da5ec
102df0bc:	102cb1fc 	.word	0x102cb1fc
102df0c0:	000010c8 	.word	0x000010c8
102df0c4:	102e5cb4 	.word	0x102e5cb4
102df0c8:	f03da598 	.word	0xf03da598

102df0cc <Callback_Location>:
 *		 s32 result,  ST_LocInfo* loc_info structure containing Lat and Long
 * Return:
 *		void
 *****************************************************************/
void Callback_Location(s32 result, ST_LocInfo* loc_info)
{
102df0cc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Module Latitude :%f , Module Longitude :%f -->\r\n", loc_info->latitude,loc_info->longitude);
102df0d0:	e59fa104 	ldr	sl, [pc, #260]	; 102df1dc <Callback_Location+0x110>
 *		 s32 result,  ST_LocInfo* loc_info structure containing Lat and Long
 * Return:
 *		void
 *****************************************************************/
void Callback_Location(s32 result, ST_LocInfo* loc_info)
{
102df0d4:	e24dd00c 	sub	sp, sp, #12
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Module Latitude :%f , Module Longitude :%f -->\r\n", loc_info->latitude,loc_info->longitude);
102df0d8:	e28a8030 	add	r8, sl, #48	; 0x30
 *		 s32 result,  ST_LocInfo* loc_info structure containing Lat and Long
 * Return:
 *		void
 *****************************************************************/
void Callback_Location(s32 result, ST_LocInfo* loc_info)
{
102df0dc:	e1a07001 	mov	r7, r1
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Module Latitude :%f , Module Longitude :%f -->\r\n", loc_info->latitude,loc_info->longitude);
102df0e0:	e3a02c02 	mov	r2, #512	; 0x200
102df0e4:	e59f30f4 	ldr	r3, [pc, #244]	; 102df1e0 <Callback_Location+0x114>
102df0e8:	e3a01000 	mov	r1, #0
102df0ec:	e1a00008 	mov	r0, r8
102df0f0:	e12fff33 	blx	r3
102df0f4:	e59f60e8 	ldr	r6, [pc, #232]	; 102df1e4 <Callback_Location+0x118>
102df0f8:	e5970004 	ldr	r0, [r7, #4]
102df0fc:	e12fff36 	blx	r6
102df100:	e59f90e0 	ldr	r9, [pc, #224]	; 102df1e8 <Callback_Location+0x11c>
#endif
	Ql_sprintf(latitude_, "%f",loc_info->latitude);
102df104:	e28abf8e 	add	fp, sl, #568	; 0x238
 *		void
 *****************************************************************/
void Callback_Location(s32 result, ST_LocInfo* loc_info)
{
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Module Latitude :%f , Module Longitude :%f -->\r\n", loc_info->latitude,loc_info->longitude);
102df108:	e1a04000 	mov	r4, r0
102df10c:	e5970000 	ldr	r0, [r7]
102df110:	e1a05001 	mov	r5, r1
102df114:	e12fff36 	blx	r6
102df118:	e599c000 	ldr	ip, [r9]
102df11c:	e1a02004 	mov	r2, r4
102df120:	e1a03005 	mov	r3, r5
#endif
	Ql_sprintf(latitude_, "%f",loc_info->latitude);
102df124:	e59f40c0 	ldr	r4, [pc, #192]	; 102df1ec <Callback_Location+0x120>
	Ql_sprintf(longitude_,"%f",loc_info->longitude);
102df128:	e28a5f91 	add	r5, sl, #580	; 0x244
 *		void
 *****************************************************************/
void Callback_Location(s32 result, ST_LocInfo* loc_info)
{
#ifdef DEBUG_MSG
	APP_DEBUG("\r\n<-- Module Latitude :%f , Module Longitude :%f -->\r\n", loc_info->latitude,loc_info->longitude);
102df12c:	e1cd00f0 	strd	r0, [sp]
102df130:	e59f10b8 	ldr	r1, [pc, #184]	; 102df1f0 <Callback_Location+0x124>
102df134:	e1a00008 	mov	r0, r8
102df138:	e12fff3c 	blx	ip
102df13c:	e59f30b0 	ldr	r3, [pc, #176]	; 102df1f4 <Callback_Location+0x128>
102df140:	e1a00008 	mov	r0, r8
102df144:	e12fff33 	blx	r3
102df148:	e59f30a8 	ldr	r3, [pc, #168]	; 102df1f8 <Callback_Location+0x12c>
102df14c:	e1a01008 	mov	r1, r8
102df150:	e1a02000 	mov	r2, r0
102df154:	e3a0000a 	mov	r0, #10
102df158:	e12fff33 	blx	r3
#endif
	Ql_sprintf(latitude_, "%f",loc_info->latitude);
102df15c:	e5970004 	ldr	r0, [r7, #4]
102df160:	e12fff36 	blx	r6
102df164:	e599c000 	ldr	ip, [r9]
102df168:	e1a02000 	mov	r2, r0
102df16c:	e1a03001 	mov	r3, r1
102df170:	e1a0000b 	mov	r0, fp
102df174:	e1a01004 	mov	r1, r4
102df178:	e12fff3c 	blx	ip
	Ql_sprintf(longitude_,"%f",loc_info->longitude);
102df17c:	e5970000 	ldr	r0, [r7]
102df180:	e12fff36 	blx	r6
102df184:	e599c000 	ldr	ip, [r9]
102df188:	e1a02000 	mov	r2, r0
102df18c:	e1a03001 	mov	r3, r1
102df190:	e1a00005 	mov	r0, r5
102df194:	e1a01004 	mov	r1, r4
102df198:	e12fff3c 	blx	ip

	Ql_OS_SendMessage(3, MSG_ID_GW_STATE,GW_STATE_LCD_DISPLAY,TFT_STATE_DRAW_DIAG_INIT);// Refresh LatLog info on Diag Screen
102df19c:	e3a02002 	mov	r2, #2
102df1a0:	e59f1054 	ldr	r1, [pc, #84]	; 102df1fc <Callback_Location+0x130>
102df1a4:	e3a0301b 	mov	r3, #27
102df1a8:	e59fc050 	ldr	ip, [pc, #80]	; 102df200 <Callback_Location+0x134>
102df1ac:	e3a00003 	mov	r0, #3
102df1b0:	e12fff3c 	blx	ip
	FLAG.LOCATION_DATA_GATHERED = TRUE;
102df1b4:	e3a03001 	mov	r3, #1
102df1b8:	e5ca300a 	strb	r3, [sl, #10]

	Store_Persistent_Data();   //Write permanent data to flash file for Latitude and Longitude data
102df1bc:	e59f3040 	ldr	r3, [pc, #64]	; 102df204 <Callback_Location+0x138>
102df1c0:	e12fff33 	blx	r3
	PUBLISH_RESPONSE_REQ_source |= SCHEDULE_PUBLISH_LAT_LONG ; // Schedule a MQTT publish event for Latitude and Longitude data
102df1c4:	e59f303c 	ldr	r3, [pc, #60]	; 102df208 <Callback_Location+0x13c>
102df1c8:	e5932000 	ldr	r2, [r3]
102df1cc:	e3822b01 	orr	r2, r2, #1024	; 0x400
102df1d0:	e5832000 	str	r2, [r3]
}
102df1d4:	e28dd00c 	add	sp, sp, #12
102df1d8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
102df1dc:	f03da5ec 	.word	0xf03da5ec
102df1e0:	102e58f4 	.word	0x102e58f4
102df1e4:	102e326c 	.word	0x102e326c
102df1e8:	f03de540 	.word	0xf03de540
102df1ec:	102ef930 	.word	0x102ef930
102df1f0:	102f01fc 	.word	0x102f01fc
102df1f4:	102e57a4 	.word	0x102e57a4
102df1f8:	102e6230 	.word	0x102e6230
102df1fc:	000010c8 	.word	0x000010c8
102df200:	102e5cb4 	.word	0x102e5cb4
102df204:	102d3078 	.word	0x102d3078
102df208:	f03da598 	.word	0xf03da598

102df20c <publish_data>:
 * Return:
 *
 *****************************************************************/
void publish_data(u32 param2)
{
	MQTT_Send_Publish(SSID_HOST_AZURE,param2);
102df20c:	e1a01800 	lsl	r1, r0, #16
 *
 * Return:
 *
 *****************************************************************/
void publish_data(u32 param2)
{
102df210:	e92d4008 	push	{r3, lr}
	MQTT_Send_Publish(SSID_HOST_AZURE,param2);
102df214:	e1a01821 	lsr	r1, r1, #16
102df218:	e59f3008 	ldr	r3, [pc, #8]	; 102df228 <publish_data+0x1c>
102df21c:	e3a00000 	mov	r0, #0
102df220:	e12fff33 	blx	r3
102df224:	e8bd8008 	pop	{r3, pc}
102df228:	102ce838 	.word	0x102ce838

102df22c <proc_main_task>:
{
	// Initialize the GPIO pin (output / input, level, pullup / pulldn)
	//Ql_GPIO_Init(PINNAME_NETLIGHT, PINDIRECTION_OUT, PINLEVEL_HIGH, PINPULLSEL_PULLUP); // Not used in this design

	//----------------- OUTPUT PINS --------------------------------------------------
	Ql_GPIO_Init(PINNAME_DCD, PINDIRECTION_OUT, PINLEVEL_HIGH,  PINPULLSEL_PULLUP); //used to control Backlight of LCD
102df22c:	e3a01001 	mov	r1, #1
 *
 * Return:
 *
 *****************************************************************/
void proc_main_task(s32 taskId)
{
102df230:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	// Initialize the GPIO pin (output / input, level, pullup / pulldn)
	//Ql_GPIO_Init(PINNAME_NETLIGHT, PINDIRECTION_OUT, PINLEVEL_HIGH, PINPULLSEL_PULLUP); // Not used in this design

	//----------------- OUTPUT PINS --------------------------------------------------
	Ql_GPIO_Init(PINNAME_DCD, PINDIRECTION_OUT, PINLEVEL_HIGH,  PINPULLSEL_PULLUP); //used to control Backlight of LCD
102df234:	e1a02001 	mov	r2, r1
 *
 * Return:
 *
 *****************************************************************/
void proc_main_task(s32 taskId)
{
102df238:	e24dd014 	sub	sp, sp, #20
{
	// Initialize the GPIO pin (output / input, level, pullup / pulldn)
	//Ql_GPIO_Init(PINNAME_NETLIGHT, PINDIRECTION_OUT, PINLEVEL_HIGH, PINPULLSEL_PULLUP); // Not used in this design

	//----------------- OUTPUT PINS --------------------------------------------------
	Ql_GPIO_Init(PINNAME_DCD, PINDIRECTION_OUT, PINLEVEL_HIGH,  PINPULLSEL_PULLUP); //used to control Backlight of LCD
102df23c:	e59f440c 	ldr	r4, [pc, #1036]	; 102df650 <proc_main_task+0x424>
102df240:	e3a03002 	mov	r3, #2
102df244:	e3a00003 	mov	r0, #3
102df248:	e12fff34 	blx	r4
	Ql_GPIO_Init(PINNAME_CTS, PINDIRECTION_OUT, PINLEVEL_HIGH, PINPULLSEL_PULLUP); //used to control DATA/COMMAND pin of LCD
102df24c:	e3a01001 	mov	r1, #1
102df250:	e1a02001 	mov	r2, r1
102df254:	e3a03002 	mov	r3, #2
102df258:	e3a00004 	mov	r0, #4
102df25c:	e12fff34 	blx	r4
	Ql_GPIO_Init(PINNAME_RTS, PINDIRECTION_OUT, PINLEVEL_HIGH, PINPULLSEL_PULLUP); //used to control RESET pin of LCD
102df260:	e3a01001 	mov	r1, #1
102df264:	e1a02001 	mov	r2, r1
102df268:	e3a03002 	mov	r3, #2
102df26c:	e3a00005 	mov	r0, #5
102df270:	e12fff34 	blx	r4
	Ql_GPIO_Init(PINNAME_RI,  PINDIRECTION_OUT, PINLEVEL_HIGH, PINPULLSEL_PULLUP); //used to control NRESET pin control module
102df274:	e3a01001 	mov	r1, #1
102df278:	e3a00002 	mov	r0, #2
102df27c:	e1a02001 	mov	r2, r1
102df280:	e1a03000 	mov	r3, r0
102df284:	e12fff34 	blx	r4
	//----------------- INPUT PINS --------------------------------------------------
	//Turn ON LCD backlight
	Ql_GPIO_SetLevel(PINNAME_DCD, PINLEVEL_HIGH); // LCD Backlight ON
102df288:	e59f83c4 	ldr	r8, [pc, #964]	; 102df654 <proc_main_task+0x428>
102df28c:	e3a01001 	mov	r1, #1
102df290:	e3a00003 	mov	r0, #3
102df294:	e12fff38 	blx	r8
	//----------------- External Interrupt INPUT PINS --------------------------------------------------
	Ql_EINT_Register(PINNAME_DTR,Callback_External_Interrupt_Hdlr,NULL); // This function registers an EINT I/O, and specifies the interrupt handler.
102df298:	e3a02000 	mov	r2, #0
102df29c:	e59f13b4 	ldr	r1, [pc, #948]	; 102df658 <proc_main_task+0x42c>
102df2a0:	e59f33b4 	ldr	r3, [pc, #948]	; 102df65c <proc_main_task+0x430>
102df2a4:	e3a00001 	mov	r0, #1
	Ql_EINT_Init(PINNAME_DTR, EINT_LEVEL_TRIGGERED,0,5,0);
102df2a8:	e1a0a002 	mov	sl, r2
	Ql_GPIO_Init(PINNAME_RI,  PINDIRECTION_OUT, PINLEVEL_HIGH, PINPULLSEL_PULLUP); //used to control NRESET pin control module
	//----------------- INPUT PINS --------------------------------------------------
	//Turn ON LCD backlight
	Ql_GPIO_SetLevel(PINNAME_DCD, PINLEVEL_HIGH); // LCD Backlight ON
	//----------------- External Interrupt INPUT PINS --------------------------------------------------
	Ql_EINT_Register(PINNAME_DTR,Callback_External_Interrupt_Hdlr,NULL); // This function registers an EINT I/O, and specifies the interrupt handler.
102df2ac:	e12fff33 	blx	r3
	Ql_EINT_Init(PINNAME_DTR, EINT_LEVEL_TRIGGERED,0,5,0);
102df2b0:	e3a00001 	mov	r0, #1
102df2b4:	e59fc3a4 	ldr	ip, [pc, #932]	; 102df660 <proc_main_task+0x434>
102df2b8:	e3a03005 	mov	r3, #5
102df2bc:	e1a01000 	mov	r1, r0
102df2c0:	e1a0200a 	mov	r2, sl
102df2c4:	e58da000 	str	sl, [sp]
102df2c8:	e12fff3c 	blx	ip
static void SerialPort_Init(void)
{
	s32 iResult = 0;

	//Register UART_PORT_MAIN
	iResult = Ql_UART_Register(UART_PORT_MAIN, CallBack_UART_MAIN_Hdlr, NULL);
102df2cc:	e59f3390 	ldr	r3, [pc, #912]	; 102df664 <proc_main_task+0x438>
102df2d0:	e59f1390 	ldr	r1, [pc, #912]	; 102df668 <proc_main_task+0x43c>
102df2d4:	e1a0200a 	mov	r2, sl
102df2d8:	e3a0000a 	mov	r0, #10
102df2dc:	e12fff33 	blx	r3
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] UART_PORT_MAIN register -->\r\n", (iResult ==  0) ? "SUCCESS" : "FAIL");
102df2e0:	e59f4384 	ldr	r4, [pc, #900]	; 102df66c <proc_main_task+0x440>
102df2e4:	e59f7384 	ldr	r7, [pc, #900]	; 102df670 <proc_main_task+0x444>
102df2e8:	e3a02c02 	mov	r2, #512	; 0x200
102df2ec:	e59f9380 	ldr	r9, [pc, #896]	; 102df674 <proc_main_task+0x448>
102df2f0:	e59fb380 	ldr	fp, [pc, #896]	; 102df678 <proc_main_task+0x44c>
102df2f4:	e1a0100a 	mov	r1, sl
102df2f8:	e59f637c 	ldr	r6, [pc, #892]	; 102df67c <proc_main_task+0x450>
static void SerialPort_Init(void)
{
	s32 iResult = 0;

	//Register UART_PORT_MAIN
	iResult = Ql_UART_Register(UART_PORT_MAIN, CallBack_UART_MAIN_Hdlr, NULL);
102df2fc:	e1a05000 	mov	r5, r0
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] UART_PORT_MAIN register -->\r\n", (iResult ==  0) ? "SUCCESS" : "FAIL");
102df300:	e59f0378 	ldr	r0, [pc, #888]	; 102df680 <proc_main_task+0x454>
102df304:	e12fff34 	blx	r4
102df308:	e155000a 	cmp	r5, sl
102df30c:	11a02009 	movne	r2, r9
102df310:	01a0200b 	moveq	r2, fp
102df314:	e5973000 	ldr	r3, [r7]
102df318:	e59f1364 	ldr	r1, [pc, #868]	; 102df684 <proc_main_task+0x458>
102df31c:	e59f035c 	ldr	r0, [pc, #860]	; 102df680 <proc_main_task+0x454>
102df320:	e12fff33 	blx	r3
102df324:	e59f0354 	ldr	r0, [pc, #852]	; 102df680 <proc_main_task+0x454>
102df328:	e12fff36 	blx	r6
102df32c:	e59f5354 	ldr	r5, [pc, #852]	; 102df688 <proc_main_task+0x45c>
102df330:	e59f1348 	ldr	r1, [pc, #840]	; 102df680 <proc_main_task+0x454>
102df334:	e1a02000 	mov	r2, r0
102df338:	e3a0000a 	mov	r0, #10
102df33c:	e12fff35 	blx	r5
#endif

	//Open UART_PORT_MAIN
	iResult = Ql_UART_Open(UART_PORT_MAIN, BAUDRATE_PORT_MAIN, FC_NONE);
102df340:	e59f1344 	ldr	r1, [pc, #836]	; 102df68c <proc_main_task+0x460>
102df344:	e3a02001 	mov	r2, #1
102df348:	e59f3340 	ldr	r3, [pc, #832]	; 102df690 <proc_main_task+0x464>
102df34c:	e3a0000a 	mov	r0, #10
102df350:	e12fff33 	blx	r3
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] UART_PORT_MAIN Open -->\r\n", (iResult ==  0) ? "SUCCESS" : "FAIL");
102df354:	e3a02c02 	mov	r2, #512	; 0x200
102df358:	e1a0100a 	mov	r1, sl
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] UART_PORT_MAIN register -->\r\n", (iResult ==  0) ? "SUCCESS" : "FAIL");
#endif

	//Open UART_PORT_MAIN
	iResult = Ql_UART_Open(UART_PORT_MAIN, BAUDRATE_PORT_MAIN, FC_NONE);
102df35c:	e1a03000 	mov	r3, r0
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] UART_PORT_MAIN Open -->\r\n", (iResult ==  0) ? "SUCCESS" : "FAIL");
102df360:	e58d300c 	str	r3, [sp, #12]
102df364:	e59f0314 	ldr	r0, [pc, #788]	; 102df680 <proc_main_task+0x454>
102df368:	e12fff34 	blx	r4
102df36c:	e59d300c 	ldr	r3, [sp, #12]
102df370:	e59f131c 	ldr	r1, [pc, #796]	; 102df694 <proc_main_task+0x468>
102df374:	e153000a 	cmp	r3, sl
102df378:	11a02009 	movne	r2, r9
102df37c:	01a0200b 	moveq	r2, fp
102df380:	e5973000 	ldr	r3, [r7]
102df384:	e59f02f4 	ldr	r0, [pc, #756]	; 102df680 <proc_main_task+0x454>
102df388:	e12fff33 	blx	r3
102df38c:	e59f02ec 	ldr	r0, [pc, #748]	; 102df680 <proc_main_task+0x454>
102df390:	e12fff36 	blx	r6
102df394:	e59f12e4 	ldr	r1, [pc, #740]	; 102df680 <proc_main_task+0x454>
102df398:	e1a02000 	mov	r2, r0
102df39c:	e3a0000a 	mov	r0, #10
102df3a0:	e12fff35 	blx	r5
 *****************************************************************/
static void Init(void)
{
	GPIO_Init();	// Init the GPIO pins and configure them
	SerialPort_Init();//Register the UART_Main Port and open the main port
	InitIPComm();	//Init UART for IPC communication
102df3a4:	e59f32ec 	ldr	r3, [pc, #748]	; 102df698 <proc_main_task+0x46c>
102df3a8:	e12fff33 	blx	r3
static void SPI_Init(void)
{
	s32 ret = 0;

	//Init SPI PORT
	ret = Ql_SPI_Init(USR_SPI_CHANNAL,PINNAME_PCM_IN,PINNAME_PCM_SYNC,PINNAME_PCM_OUT,PINNAME_PCM_CLK,SPI_HARDWARE);
102df3ac:	e3a00008 	mov	r0, #8
102df3b0:	e58d0000 	str	r0, [sp]
102df3b4:	e3a00001 	mov	r0, #1
102df3b8:	e59fc2dc 	ldr	ip, [pc, #732]	; 102df69c <proc_main_task+0x470>
102df3bc:	e3a0300b 	mov	r3, #11
102df3c0:	e3a0100a 	mov	r1, #10
102df3c4:	e3a02009 	mov	r2, #9
102df3c8:	e58d0004 	str	r0, [sp, #4]
102df3cc:	e12fff3c 	blx	ip
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] SPI Init -->\r\n", (ret < 0)?"FAIL" : "SUCCESS");
102df3d0:	e3a02c02 	mov	r2, #512	; 0x200
102df3d4:	e1a0100a 	mov	r1, sl
static void SPI_Init(void)
{
	s32 ret = 0;

	//Init SPI PORT
	ret = Ql_SPI_Init(USR_SPI_CHANNAL,PINNAME_PCM_IN,PINNAME_PCM_SYNC,PINNAME_PCM_OUT,PINNAME_PCM_CLK,SPI_HARDWARE);
102df3d8:	e1a03000 	mov	r3, r0
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] SPI Init -->\r\n", (ret < 0)?"FAIL" : "SUCCESS");
102df3dc:	e58d300c 	str	r3, [sp, #12]
102df3e0:	e59f0298 	ldr	r0, [pc, #664]	; 102df680 <proc_main_task+0x454>
102df3e4:	e12fff34 	blx	r4
102df3e8:	e59d300c 	ldr	r3, [sp, #12]
102df3ec:	e59f12ac 	ldr	r1, [pc, #684]	; 102df6a0 <proc_main_task+0x474>
102df3f0:	e153000a 	cmp	r3, sl
102df3f4:	b1a02009 	movlt	r2, r9
102df3f8:	a1a0200b 	movge	r2, fp
102df3fc:	e5973000 	ldr	r3, [r7]
102df400:	e59f0278 	ldr	r0, [pc, #632]	; 102df680 <proc_main_task+0x454>
102df404:	e12fff33 	blx	r3
102df408:	e59f0270 	ldr	r0, [pc, #624]	; 102df680 <proc_main_task+0x454>
102df40c:	e12fff36 	blx	r6
102df410:	e59f1268 	ldr	r1, [pc, #616]	; 102df680 <proc_main_task+0x454>
102df414:	e1a02000 	mov	r2, r0
102df418:	e3a0000a 	mov	r0, #10
102df41c:	e12fff35 	blx	r5
#endif

	//Config SPI PORT
	ret = Ql_SPI_Config(USR_SPI_CHANNAL,1,0,0,10000); //config sclk about 10MHz;
102df420:	e3a00001 	mov	r0, #1
102df424:	e59fc278 	ldr	ip, [pc, #632]	; 102df6a4 <proc_main_task+0x478>
102df428:	e1a0300a 	mov	r3, sl
102df42c:	e1a01000 	mov	r1, r0
102df430:	e1a0200a 	mov	r2, sl
102df434:	e58dc000 	str	ip, [sp]
102df438:	e59fc268 	ldr	ip, [pc, #616]	; 102df6a8 <proc_main_task+0x47c>
102df43c:	e12fff3c 	blx	ip
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] SPI Config -->\r\n", (ret < 0)?"FAIL" : "SUCCESS");
102df440:	e3a02c02 	mov	r2, #512	; 0x200
102df444:	e1a0100a 	mov	r1, sl
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] SPI Init -->\r\n", (ret < 0)?"FAIL" : "SUCCESS");
#endif

	//Config SPI PORT
	ret = Ql_SPI_Config(USR_SPI_CHANNAL,1,0,0,10000); //config sclk about 10MHz;
102df448:	e1a03000 	mov	r3, r0
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] SPI Config -->\r\n", (ret < 0)?"FAIL" : "SUCCESS");
102df44c:	e58d300c 	str	r3, [sp, #12]
102df450:	e59f0228 	ldr	r0, [pc, #552]	; 102df680 <proc_main_task+0x454>
102df454:	e12fff34 	blx	r4
102df458:	e59d300c 	ldr	r3, [sp, #12]
102df45c:	e59f1248 	ldr	r1, [pc, #584]	; 102df6ac <proc_main_task+0x480>
102df460:	e153000a 	cmp	r3, sl
102df464:	b1a02009 	movlt	r2, r9
102df468:	a1a0200b 	movge	r2, fp
102df46c:	e5973000 	ldr	r3, [r7]
102df470:	e59f0208 	ldr	r0, [pc, #520]	; 102df680 <proc_main_task+0x454>
102df474:	e12fff33 	blx	r3
102df478:	e59f0200 	ldr	r0, [pc, #512]	; 102df680 <proc_main_task+0x454>
102df47c:	e12fff36 	blx	r6
102df480:	e59f11f8 	ldr	r1, [pc, #504]	; 102df680 <proc_main_task+0x454>

	//----- Initialize & open HW peripherals -----
	Init();

	// Do not remove the delay
	Ql_Sleep(1000);
102df484:	e59f9224 	ldr	r9, [pc, #548]	; 102df6b0 <proc_main_task+0x484>
#endif

	//Config SPI PORT
	ret = Ql_SPI_Config(USR_SPI_CHANNAL,1,0,0,10000); //config sclk about 10MHz;
#ifdef INOUT
	APP_DEBUG("\n\r<-- [%s] SPI Config -->\r\n", (ret < 0)?"FAIL" : "SUCCESS");
102df488:	e1a02000 	mov	r2, r0
102df48c:	e3a0000a 	mov	r0, #10
102df490:	e12fff35 	blx	r5
{
	GPIO_Init();	// Init the GPIO pins and configure them
	SerialPort_Init();//Register the UART_Main Port and open the main port
	InitIPComm();	//Init UART for IPC communication
	SPI_Init();	//Init the SPI Port and Config the port
	Timer_register();
102df494:	e59f3218 	ldr	r3, [pc, #536]	; 102df6b4 <proc_main_task+0x488>
102df498:	e12fff33 	blx	r3
	Ql_memset(coresdkpbuf, 0, sizeof(coresdkpbuf));
102df49c:	e3a02064 	mov	r2, #100	; 0x64
102df4a0:	e1a0100a 	mov	r1, sl
102df4a4:	e59f020c 	ldr	r0, [pc, #524]	; 102df6b8 <proc_main_task+0x48c>
102df4a8:	e12fff34 	blx	r4
	Ql_GetSDKVer((u8*)coresdkpbuf, sizeof(coresdkpbuf));
102df4ac:	e59f3208 	ldr	r3, [pc, #520]	; 102df6bc <proc_main_task+0x490>
102df4b0:	e3a01064 	mov	r1, #100	; 0x64
102df4b4:	e59f01fc 	ldr	r0, [pc, #508]	; 102df6b8 <proc_main_task+0x48c>
102df4b8:	e12fff33 	blx	r3
#ifdef DEBUG_MSG
	APP_DEBUG("<-- SDK vesrion  :%s -->\r\n", coresdkpbuf);
102df4bc:	e1a0100a 	mov	r1, sl
102df4c0:	e3a02c02 	mov	r2, #512	; 0x200
102df4c4:	e59f01b4 	ldr	r0, [pc, #436]	; 102df680 <proc_main_task+0x454>
102df4c8:	e12fff34 	blx	r4
102df4cc:	e59f01ac 	ldr	r0, [pc, #428]	; 102df680 <proc_main_task+0x454>
102df4d0:	e5973000 	ldr	r3, [r7]
102df4d4:	e59f11e4 	ldr	r1, [pc, #484]	; 102df6c0 <proc_main_task+0x494>
102df4d8:	e2802e22 	add	r2, r0, #544	; 0x220
102df4dc:	e12fff33 	blx	r3
102df4e0:	e59f0198 	ldr	r0, [pc, #408]	; 102df680 <proc_main_task+0x454>
102df4e4:	e12fff36 	blx	r6
102df4e8:	e59f1190 	ldr	r1, [pc, #400]	; 102df680 <proc_main_task+0x454>
102df4ec:	e1a02000 	mov	r2, r0
102df4f0:	e3a0000a 	mov	r0, #10
102df4f4:	e12fff35 	blx	r5
#endif
	APP_DEBUG("WELCOME TO QUECTEL M66\n");
102df4f8:	e3a02c02 	mov	r2, #512	; 0x200
102df4fc:	e1a0100a 	mov	r1, sl
102df500:	e59f0178 	ldr	r0, [pc, #376]	; 102df680 <proc_main_task+0x454>
102df504:	e12fff34 	blx	r4
102df508:	e5973000 	ldr	r3, [r7]
102df50c:	e59f11b0 	ldr	r1, [pc, #432]	; 102df6c4 <proc_main_task+0x498>
102df510:	e59f0168 	ldr	r0, [pc, #360]	; 102df680 <proc_main_task+0x454>
102df514:	e12fff33 	blx	r3
102df518:	e59f0160 	ldr	r0, [pc, #352]	; 102df680 <proc_main_task+0x454>
102df51c:	e12fff36 	blx	r6
102df520:	e59f1158 	ldr	r1, [pc, #344]	; 102df680 <proc_main_task+0x454>
102df524:	e1a02000 	mov	r2, r0
102df528:	e3a0000a 	mov	r0, #10
102df52c:	e12fff35 	blx	r5
	Ql_memset(coresdkpbuf, 0, sizeof(coresdkpbuf));
102df530:	e3a02064 	mov	r2, #100	; 0x64
102df534:	e1a0100a 	mov	r1, sl
102df538:	e59f0178 	ldr	r0, [pc, #376]	; 102df6b8 <proc_main_task+0x48c>
102df53c:	e12fff34 	blx	r4
	Ql_GetCoreVer((u8*)coresdkpbuf, sizeof(coresdkpbuf));
102df540:	e59f3180 	ldr	r3, [pc, #384]	; 102df6c8 <proc_main_task+0x49c>
102df544:	e3a01064 	mov	r1, #100	; 0x64
102df548:	e59f0168 	ldr	r0, [pc, #360]	; 102df6b8 <proc_main_task+0x48c>
102df54c:	e12fff33 	blx	r3
#ifdef DEBUG_MSG
	APP_DEBUG("<-- M66 Core     :%s -->\r\n", coresdkpbuf);
102df550:	e1a0100a 	mov	r1, sl
102df554:	e3a02c02 	mov	r2, #512	; 0x200
102df558:	e59f0120 	ldr	r0, [pc, #288]	; 102df680 <proc_main_task+0x454>
102df55c:	e12fff34 	blx	r4
102df560:	e59f0118 	ldr	r0, [pc, #280]	; 102df680 <proc_main_task+0x454>
102df564:	e5973000 	ldr	r3, [r7]
102df568:	e59f115c 	ldr	r1, [pc, #348]	; 102df6cc <proc_main_task+0x4a0>
102df56c:	e2802e22 	add	r2, r0, #544	; 0x220
102df570:	e12fff33 	blx	r3
102df574:	e59f0104 	ldr	r0, [pc, #260]	; 102df680 <proc_main_task+0x454>
102df578:	e12fff36 	blx	r6
102df57c:	e59f10fc 	ldr	r1, [pc, #252]	; 102df680 <proc_main_task+0x454>
102df580:	e1a02000 	mov	r2, r0
102df584:	e3a0000a 	mov	r0, #10
102df588:	e12fff35 	blx	r5
#endif

	fileSys_SetFileSystem(FALSE); // False -> No filesystem Format
102df58c:	e59f313c 	ldr	r3, [pc, #316]	; 102df6d0 <proc_main_task+0x4a4>
102df590:	e1a0000a 	mov	r0, sl
102df594:	e12fff33 	blx	r3

	//----- Initialize & open HW peripherals -----
	Init();

	// Do not remove the delay
	Ql_Sleep(1000);
102df598:	e3a00ffa 	mov	r0, #1000	; 0x3e8
102df59c:	e12fff39 	blx	r9
	APP_DEBUG("\r<-- WELCOM -->\r\n");
102df5a0:	e1a0100a 	mov	r1, sl
102df5a4:	e3a02c02 	mov	r2, #512	; 0x200
102df5a8:	e59f00d0 	ldr	r0, [pc, #208]	; 102df680 <proc_main_task+0x454>
102df5ac:	e12fff34 	blx	r4
102df5b0:	e59f111c 	ldr	r1, [pc, #284]	; 102df6d4 <proc_main_task+0x4a8>
102df5b4:	e5973000 	ldr	r3, [r7]
102df5b8:	e59f00c0 	ldr	r0, [pc, #192]	; 102df680 <proc_main_task+0x454>
102df5bc:	e12fff33 	blx	r3
102df5c0:	e59f00b8 	ldr	r0, [pc, #184]	; 102df680 <proc_main_task+0x454>
102df5c4:	e12fff36 	blx	r6
102df5c8:	e59f10b0 	ldr	r1, [pc, #176]	; 102df680 <proc_main_task+0x454>
102df5cc:	e1a02000 	mov	r2, r0
102df5d0:	e3a0000a 	mov	r0, #10
102df5d4:	e12fff35 	blx	r5

	//----- START MESSAGE LOOP OF THIS TASK -----
	while(TRUE)
	{
		Ql_GPIO_SetLevel(PINNAME_RI, PINLEVEL_LOW); // Set RESET pin LOW
102df5d8:	e3a01000 	mov	r1, #0
102df5dc:	e3a00002 	mov	r0, #2
102df5e0:	e12fff38 	blx	r8
		Ql_Sleep(1000);
102df5e4:	e3a00ffa 	mov	r0, #1000	; 0x3e8
102df5e8:	e12fff39 	blx	r9
		APP_DEBUG("\nLED OFF\r\n");
102df5ec:	e3a02c02 	mov	r2, #512	; 0x200
102df5f0:	e3a01000 	mov	r1, #0
102df5f4:	e59f0084 	ldr	r0, [pc, #132]	; 102df680 <proc_main_task+0x454>
102df5f8:	e12fff34 	blx	r4
102df5fc:	e5973000 	ldr	r3, [r7]
102df600:	e59f10d0 	ldr	r1, [pc, #208]	; 102df6d8 <proc_main_task+0x4ac>
102df604:	e59f0074 	ldr	r0, [pc, #116]	; 102df680 <proc_main_task+0x454>
102df608:	e12fff33 	blx	r3
102df60c:	e59f006c 	ldr	r0, [pc, #108]	; 102df680 <proc_main_task+0x454>
102df610:	e12fff36 	blx	r6
102df614:	e59f1064 	ldr	r1, [pc, #100]	; 102df680 <proc_main_task+0x454>
102df618:	e1a02000 	mov	r2, r0
102df61c:	e3a0000a 	mov	r0, #10
102df620:	e12fff35 	blx	r5
		Ql_GPIO_SetLevel(PINNAME_RI, PINLEVEL_HIGH); // Set RESET pin HIGH
102df624:	e3a01001 	mov	r1, #1
102df628:	e3a00002 	mov	r0, #2
102df62c:	e12fff38 	blx	r8
		Ql_Sleep(1000);
102df630:	e3a00ffa 	mov	r0, #1000	; 0x3e8
102df634:	e12fff39 	blx	r9
		APP_DEBUG("\nLED ON\r\n");
102df638:	e3a01000 	mov	r1, #0
102df63c:	e3a02c02 	mov	r2, #512	; 0x200
102df640:	e59f0038 	ldr	r0, [pc, #56]	; 102df680 <proc_main_task+0x454>
102df644:	e12fff34 	blx	r4
102df648:	e59f108c 	ldr	r1, [pc, #140]	; 102df6dc <proc_main_task+0x4b0>
102df64c:	eaffffd8 	b	102df5b4 <proc_main_task+0x388>
102df650:	102e4760 	.word	0x102e4760
102df654:	102e47d8 	.word	0x102e47d8
102df658:	102de5f0 	.word	0x102de5f0
102df65c:	102e3f60 	.word	0x102e3f60
102df660:	102e3fd0 	.word	0x102e3fd0
102df664:	102e6150 	.word	0x102e6150
102df668:	102de5f4 	.word	0x102de5f4
102df66c:	102e58f4 	.word	0x102e58f4
102df670:	f03de540 	.word	0xf03de540
102df674:	102efb50 	.word	0x102efb50
102df678:	102ef9dc 	.word	0x102ef9dc
102df67c:	102e57a4 	.word	0x102e57a4
102df680:	f03da61c 	.word	0xf03da61c
102df684:	102f0234 	.word	0x102f0234
102df688:	102e6230 	.word	0x102e6230
102df68c:	0001c200 	.word	0x0001c200
102df690:	102e61c0 	.word	0x102e61c0
102df694:	102f0260 	.word	0x102f0260
102df698:	102dd2ac 	.word	0x102dd2ac
102df69c:	102e53ec 	.word	0x102e53ec
102df6a0:	102f0288 	.word	0x102f0288
102df6a4:	00002710 	.word	0x00002710
102df6a8:	102e5474 	.word	0x102e5474
102df6ac:	102f02a4 	.word	0x102f02a4
102df6b0:	102e5b10 	.word	0x102e5b10
102df6b4:	102cd280 	.word	0x102cd280
102df6b8:	f03da83c 	.word	0xf03da83c
102df6bc:	102e5bf0 	.word	0x102e5bf0
102df6c0:	102f02c0 	.word	0x102f02c0
102df6c4:	102f02dc 	.word	0x102f02dc
102df6c8:	102e5b84 	.word	0x102e5b84
102df6cc:	102f02f4 	.word	0x102f02f4
102df6d0:	102d2cb0 	.word	0x102d2cb0
102df6d4:	102f0310 	.word	0x102f0310
102df6d8:	102f0324 	.word	0x102f0324
102df6dc:	102f0330 	.word	0x102f0330

102df6e0 <proc_subtask1>:

/**************************************************************
 * the 1st sub task
 ***************************************************************/
void proc_subtask1(s32 TaskId)
{
102df6e0:	e92d4070 	push	{r4, r5, r6, lr}
102df6e4:	e59f5024 	ldr	r5, [pc, #36]	; 102df710 <proc_subtask1+0x30>
102df6e8:	e59f6024 	ldr	r6, [pc, #36]	; 102df714 <proc_subtask1+0x34>
	ST_MSG subtask1_msg;

	while(1)
	{
		Ql_OS_GetMessage(&subtask1_msg);
		switch(subtask1_msg.message)
102df6ec:	e59f4024 	ldr	r4, [pc, #36]	; 102df718 <proc_subtask1+0x38>

/**************************************************************
 * the 1st sub task
 ***************************************************************/
void proc_subtask1(s32 TaskId)
{
102df6f0:	e24dd010 	sub	sp, sp, #16
	ST_MSG subtask1_msg;

	while(1)
	{
		Ql_OS_GetMessage(&subtask1_msg);
102df6f4:	e1a0000d 	mov	r0, sp
102df6f8:	e12fff35 	blx	r5
		switch(subtask1_msg.message)
102df6fc:	e59d3000 	ldr	r3, [sp]
102df700:	e1530004 	cmp	r3, r4
		{
		case MSG_ID_GW_STATE:
		{
			GW_sf_state = subtask1_msg.param1;
102df704:	059d3004 	ldreq	r3, [sp, #4]
102df708:	05c63000 	strbeq	r3, [r6]
			switch (GW_sf_state)
			{
			default:
				break;
102df70c:	eafffff8 	b	102df6f4 <proc_subtask1+0x14>
102df710:	102e5c54 	.word	0x102e5c54
102df714:	f03db8ec 	.word	0xf03db8ec
102df718:	000010c8 	.word	0x000010c8

102df71c <_OCPU_InitUserMem>:
102df71c:	e59f0030 	ldr	r0, [pc, #48]	; 102df754 <_OCPU_InitUserMem+0x38>
102df720:	e59f1030 	ldr	r1, [pc, #48]	; 102df758 <_OCPU_InitUserMem+0x3c>
102df724:	e59f2030 	ldr	r2, [pc, #48]	; 102df75c <_OCPU_InitUserMem+0x40>
102df728:	e1510002 	cmp	r1, r2
102df72c:	b8b00008 	ldmlt	r0!, {r3}
102df730:	b8a10008 	stmialt	r1!, {r3}
102df734:	bafffffb 	blt	102df728 <_OCPU_InitUserMem+0xc>
102df738:	e59f1020 	ldr	r1, [pc, #32]	; 102df760 <_OCPU_InitUserMem+0x44>
102df73c:	e59f2020 	ldr	r2, [pc, #32]	; 102df764 <_OCPU_InitUserMem+0x48>
102df740:	e3a03000 	mov	r3, #0
102df744:	e1510002 	cmp	r1, r2
102df748:	b8a10008 	stmialt	r1!, {r3}
102df74c:	bafffffc 	blt	102df744 <_OCPU_InitUserMem+0x28>
102df750:	e12fff1e 	bx	lr
102df754:	102f0ab8 	.word	0x102f0ab8
102df758:	f03d2000 	.word	0xf03d2000
102df75c:	f03d5050 	.word	0xf03d5050
102df760:	f03d5050 	.word	0xf03d5050
102df764:	f03db7c8 	.word	0xf03db7c8

102df768 <floor>:
102df768:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
102df76a:	4646      	mov	r6, r8
102df76c:	464f      	mov	r7, r9
102df76e:	b4c0      	push	{r6, r7}
102df770:	1c0b      	adds	r3, r1, #0
102df772:	1c0d      	adds	r5, r1, #0
102df774:	1c0f      	adds	r7, r1, #0
102df776:	0049      	lsls	r1, r1, #1
102df778:	0d49      	lsrs	r1, r1, #21
102df77a:	4c45      	ldr	r4, [pc, #276]	; (102df890 <floor+0x128>)
102df77c:	4688      	mov	r8, r1
102df77e:	4444      	add	r4, r8
102df780:	1c02      	adds	r2, r0, #0
102df782:	1c06      	adds	r6, r0, #0
102df784:	2c13      	cmp	r4, #19
102df786:	dc23      	bgt.n	102df7d0 <floor+0x68>
102df788:	2c00      	cmp	r4, #0
102df78a:	db4a      	blt.n	102df822 <floor+0xba>
102df78c:	4941      	ldr	r1, [pc, #260]	; (102df894 <floor+0x12c>)
102df78e:	4121      	asrs	r1, r4
102df790:	4688      	mov	r8, r1
102df792:	4029      	ands	r1, r5
102df794:	4301      	orrs	r1, r0
102df796:	d013      	beq.n	102df7c0 <floor+0x58>
102df798:	1c10      	adds	r0, r2, #0
102df79a:	1c19      	adds	r1, r3, #0
102df79c:	4b39      	ldr	r3, [pc, #228]	; (102df884 <floor+0x11c>)
102df79e:	4a38      	ldr	r2, [pc, #224]	; (102df880 <floor+0x118>)
102df7a0:	f004 fbc8 	bl	102e3f34 <____aeabi_dadd_from_thumb>
102df7a4:	4a38      	ldr	r2, [pc, #224]	; (102df888 <floor+0x120>)
102df7a6:	4b39      	ldr	r3, [pc, #228]	; (102df88c <floor+0x124>)
102df7a8:	f004 fb90 	bl	102e3ecc <____aeabi_dcmpgt_from_thumb>
102df7ac:	2800      	cmp	r0, #0
102df7ae:	d005      	beq.n	102df7bc <floor+0x54>
102df7b0:	2d00      	cmp	r5, #0
102df7b2:	db47      	blt.n	102df844 <floor+0xdc>
102df7b4:	1c3d      	adds	r5, r7, #0
102df7b6:	4641      	mov	r1, r8
102df7b8:	438d      	bics	r5, r1
102df7ba:	2600      	movs	r6, #0
102df7bc:	1c2b      	adds	r3, r5, #0
102df7be:	1c32      	adds	r2, r6, #0
102df7c0:	1c10      	adds	r0, r2, #0
102df7c2:	1c19      	adds	r1, r3, #0
102df7c4:	bc0c      	pop	{r2, r3}
102df7c6:	4690      	mov	r8, r2
102df7c8:	4699      	mov	r9, r3
102df7ca:	bcf8      	pop	{r3, r4, r5, r6, r7}
102df7cc:	bc04      	pop	{r2}
102df7ce:	4710      	bx	r2
102df7d0:	2c33      	cmp	r4, #51	; 0x33
102df7d2:	dd0a      	ble.n	102df7ea <floor+0x82>
102df7d4:	2180      	movs	r1, #128	; 0x80
102df7d6:	00c9      	lsls	r1, r1, #3
102df7d8:	428c      	cmp	r4, r1
102df7da:	d1f1      	bne.n	102df7c0 <floor+0x58>
102df7dc:	1c10      	adds	r0, r2, #0
102df7de:	1c19      	adds	r1, r3, #0
102df7e0:	f004 fba8 	bl	102e3f34 <____aeabi_dadd_from_thumb>
102df7e4:	1c02      	adds	r2, r0, #0
102df7e6:	1c0b      	adds	r3, r1, #0
102df7e8:	e7ea      	b.n	102df7c0 <floor+0x58>
102df7ea:	492b      	ldr	r1, [pc, #172]	; (102df898 <floor+0x130>)
102df7ec:	2001      	movs	r0, #1
102df7ee:	4240      	negs	r0, r0
102df7f0:	4441      	add	r1, r8
102df7f2:	40c8      	lsrs	r0, r1
102df7f4:	4681      	mov	r9, r0
102df7f6:	4206      	tst	r6, r0
102df7f8:	d0e2      	beq.n	102df7c0 <floor+0x58>
102df7fa:	1c10      	adds	r0, r2, #0
102df7fc:	1c19      	adds	r1, r3, #0
102df7fe:	4b21      	ldr	r3, [pc, #132]	; (102df884 <floor+0x11c>)
102df800:	4a1f      	ldr	r2, [pc, #124]	; (102df880 <floor+0x118>)
102df802:	f004 fb97 	bl	102e3f34 <____aeabi_dadd_from_thumb>
102df806:	4a20      	ldr	r2, [pc, #128]	; (102df888 <floor+0x120>)
102df808:	4b20      	ldr	r3, [pc, #128]	; (102df88c <floor+0x124>)
102df80a:	f004 fb5f 	bl	102e3ecc <____aeabi_dcmpgt_from_thumb>
102df80e:	2800      	cmp	r0, #0
102df810:	d0d4      	beq.n	102df7bc <floor+0x54>
102df812:	2d00      	cmp	r5, #0
102df814:	db1b      	blt.n	102df84e <floor+0xe6>
102df816:	464b      	mov	r3, r9
102df818:	439e      	bics	r6, r3
102df81a:	1c3d      	adds	r5, r7, #0
102df81c:	1c2b      	adds	r3, r5, #0
102df81e:	1c32      	adds	r2, r6, #0
102df820:	e7ce      	b.n	102df7c0 <floor+0x58>
102df822:	1c10      	adds	r0, r2, #0
102df824:	1c19      	adds	r1, r3, #0
102df826:	4b17      	ldr	r3, [pc, #92]	; (102df884 <floor+0x11c>)
102df828:	4a15      	ldr	r2, [pc, #84]	; (102df880 <floor+0x118>)
102df82a:	f004 fb83 	bl	102e3f34 <____aeabi_dadd_from_thumb>
102df82e:	4a16      	ldr	r2, [pc, #88]	; (102df888 <floor+0x120>)
102df830:	4b16      	ldr	r3, [pc, #88]	; (102df88c <floor+0x124>)
102df832:	f004 fb4b 	bl	102e3ecc <____aeabi_dcmpgt_from_thumb>
102df836:	2800      	cmp	r0, #0
102df838:	d0c0      	beq.n	102df7bc <floor+0x54>
102df83a:	2d00      	cmp	r5, #0
102df83c:	db14      	blt.n	102df868 <floor+0x100>
102df83e:	2600      	movs	r6, #0
102df840:	2500      	movs	r5, #0
102df842:	e7bb      	b.n	102df7bc <floor+0x54>
102df844:	2380      	movs	r3, #128	; 0x80
102df846:	035b      	lsls	r3, r3, #13
102df848:	4123      	asrs	r3, r4
102df84a:	18ef      	adds	r7, r5, r3
102df84c:	e7b2      	b.n	102df7b4 <floor+0x4c>
102df84e:	2c14      	cmp	r4, #20
102df850:	d013      	beq.n	102df87a <floor+0x112>
102df852:	4b12      	ldr	r3, [pc, #72]	; (102df89c <floor+0x134>)
102df854:	4642      	mov	r2, r8
102df856:	1a9b      	subs	r3, r3, r2
102df858:	2201      	movs	r2, #1
102df85a:	409a      	lsls	r2, r3
102df85c:	1993      	adds	r3, r2, r6
102df85e:	429e      	cmp	r6, r3
102df860:	d909      	bls.n	102df876 <floor+0x10e>
102df862:	3701      	adds	r7, #1
102df864:	1c1e      	adds	r6, r3, #0
102df866:	e7d6      	b.n	102df816 <floor+0xae>
102df868:	006b      	lsls	r3, r5, #1
102df86a:	085b      	lsrs	r3, r3, #1
102df86c:	4333      	orrs	r3, r6
102df86e:	d0a5      	beq.n	102df7bc <floor+0x54>
102df870:	2600      	movs	r6, #0
102df872:	4d0b      	ldr	r5, [pc, #44]	; (102df8a0 <floor+0x138>)
102df874:	e7a2      	b.n	102df7bc <floor+0x54>
102df876:	1c1e      	adds	r6, r3, #0
102df878:	e7cd      	b.n	102df816 <floor+0xae>
102df87a:	3701      	adds	r7, #1
102df87c:	e7cb      	b.n	102df816 <floor+0xae>
102df87e:	46c0      	nop			; (mov r8, r8)
102df880:	8800759c 	.word	0x8800759c
102df884:	7e37e43c 	.word	0x7e37e43c
	...
102df890:	fffffc01 	.word	0xfffffc01
102df894:	000fffff 	.word	0x000fffff
102df898:	fffffbed 	.word	0xfffffbed
102df89c:	00000433 	.word	0x00000433
102df8a0:	bff00000 	.word	0xbff00000
102df8a4:	46c0      	nop			; (mov r8, r8)
102df8a6:	46c0      	nop			; (mov r8, r8)

102df8a8 <atoi>:
102df8a8:	b508      	push	{r3, lr}
102df8aa:	2100      	movs	r1, #0
102df8ac:	220a      	movs	r2, #10
102df8ae:	f001 fc65 	bl	102e117c <strtol>
102df8b2:	bc08      	pop	{r3}
102df8b4:	bc02      	pop	{r1}
102df8b6:	4708      	bx	r1

102df8b8 <_atoi_r>:
102df8b8:	b508      	push	{r3, lr}
102df8ba:	2200      	movs	r2, #0
102df8bc:	230a      	movs	r3, #10
102df8be:	f001 fba5 	bl	102e100c <_strtol_r>
102df8c2:	bc08      	pop	{r3}
102df8c4:	bc02      	pop	{r1}
102df8c6:	4708      	bx	r1

102df8c8 <memcpy>:
102df8c8:	b5f0      	push	{r4, r5, r6, r7, lr}
102df8ca:	4657      	mov	r7, sl
102df8cc:	464e      	mov	r6, r9
102df8ce:	4645      	mov	r5, r8
102df8d0:	b4e0      	push	{r5, r6, r7}
102df8d2:	2a03      	cmp	r2, #3
102df8d4:	d80e      	bhi.n	102df8f4 <memcpy+0x2c>
102df8d6:	2300      	movs	r3, #0
102df8d8:	2a00      	cmp	r2, #0
102df8da:	d004      	beq.n	102df8e6 <memcpy+0x1e>
102df8dc:	5ccc      	ldrb	r4, [r1, r3]
102df8de:	54c4      	strb	r4, [r0, r3]
102df8e0:	3301      	adds	r3, #1
102df8e2:	4293      	cmp	r3, r2
102df8e4:	d1fa      	bne.n	102df8dc <memcpy+0x14>
102df8e6:	bc1c      	pop	{r2, r3, r4}
102df8e8:	4690      	mov	r8, r2
102df8ea:	4699      	mov	r9, r3
102df8ec:	46a2      	mov	sl, r4
102df8ee:	bcf0      	pop	{r4, r5, r6, r7}
102df8f0:	bc02      	pop	{r1}
102df8f2:	4708      	bx	r1
102df8f4:	1882      	adds	r2, r0, r2
102df8f6:	0783      	lsls	r3, r0, #30
102df8f8:	d008      	beq.n	102df90c <memcpy+0x44>
102df8fa:	1c03      	adds	r3, r0, #0
102df8fc:	2403      	movs	r4, #3
102df8fe:	780d      	ldrb	r5, [r1, #0]
102df900:	701d      	strb	r5, [r3, #0]
102df902:	3301      	adds	r3, #1
102df904:	3101      	adds	r1, #1
102df906:	4223      	tst	r3, r4
102df908:	d1f9      	bne.n	102df8fe <memcpy+0x36>
102df90a:	e000      	b.n	102df90e <memcpy+0x46>
102df90c:	1c03      	adds	r3, r0, #0
102df90e:	2403      	movs	r4, #3
102df910:	400c      	ands	r4, r1
102df912:	d046      	beq.n	102df9a2 <memcpy+0xda>
102df914:	4267      	negs	r7, r4
102df916:	46ba      	mov	sl, r7
102df918:	59ce      	ldr	r6, [r1, r7]
102df91a:	1ad7      	subs	r7, r2, r3
102df91c:	2f03      	cmp	r7, #3
102df91e:	dd15      	ble.n	102df94c <memcpy+0x84>
102df920:	2704      	movs	r7, #4
102df922:	00e5      	lsls	r5, r4, #3
102df924:	1b3c      	subs	r4, r7, r4
102df926:	00e4      	lsls	r4, r4, #3
102df928:	46ac      	mov	ip, r5
102df92a:	46a1      	mov	r9, r4
102df92c:	4654      	mov	r4, sl
102df92e:	3104      	adds	r1, #4
102df930:	590f      	ldr	r7, [r1, r4]
102df932:	464c      	mov	r4, r9
102df934:	1c3d      	adds	r5, r7, #0
102df936:	40a5      	lsls	r5, r4
102df938:	46a8      	mov	r8, r5
102df93a:	4665      	mov	r5, ip
102df93c:	40ee      	lsrs	r6, r5
102df93e:	4644      	mov	r4, r8
102df940:	4326      	orrs	r6, r4
102df942:	c340      	stmia	r3!, {r6}
102df944:	1c3e      	adds	r6, r7, #0
102df946:	1ad7      	subs	r7, r2, r3
102df948:	2f03      	cmp	r7, #3
102df94a:	dcef      	bgt.n	102df92c <memcpy+0x64>
102df94c:	429a      	cmp	r2, r3
102df94e:	d9ca      	bls.n	102df8e6 <memcpy+0x1e>
102df950:	780c      	ldrb	r4, [r1, #0]
102df952:	701c      	strb	r4, [r3, #0]
102df954:	3301      	adds	r3, #1
102df956:	3101      	adds	r1, #1
102df958:	4293      	cmp	r3, r2
102df95a:	d1f9      	bne.n	102df950 <memcpy+0x88>
102df95c:	e7c3      	b.n	102df8e6 <memcpy+0x1e>
102df95e:	680c      	ldr	r4, [r1, #0]
102df960:	601c      	str	r4, [r3, #0]
102df962:	684d      	ldr	r5, [r1, #4]
102df964:	605d      	str	r5, [r3, #4]
102df966:	688f      	ldr	r7, [r1, #8]
102df968:	609f      	str	r7, [r3, #8]
102df96a:	68cc      	ldr	r4, [r1, #12]
102df96c:	60dc      	str	r4, [r3, #12]
102df96e:	690d      	ldr	r5, [r1, #16]
102df970:	611d      	str	r5, [r3, #16]
102df972:	694f      	ldr	r7, [r1, #20]
102df974:	615f      	str	r7, [r3, #20]
102df976:	698c      	ldr	r4, [r1, #24]
102df978:	619c      	str	r4, [r3, #24]
102df97a:	69cd      	ldr	r5, [r1, #28]
102df97c:	61dd      	str	r5, [r3, #28]
102df97e:	6a0f      	ldr	r7, [r1, #32]
102df980:	621f      	str	r7, [r3, #32]
102df982:	6a4c      	ldr	r4, [r1, #36]	; 0x24
102df984:	625c      	str	r4, [r3, #36]	; 0x24
102df986:	6a8d      	ldr	r5, [r1, #40]	; 0x28
102df988:	629d      	str	r5, [r3, #40]	; 0x28
102df98a:	6acf      	ldr	r7, [r1, #44]	; 0x2c
102df98c:	62df      	str	r7, [r3, #44]	; 0x2c
102df98e:	6b0c      	ldr	r4, [r1, #48]	; 0x30
102df990:	631c      	str	r4, [r3, #48]	; 0x30
102df992:	6b4d      	ldr	r5, [r1, #52]	; 0x34
102df994:	635d      	str	r5, [r3, #52]	; 0x34
102df996:	6b8f      	ldr	r7, [r1, #56]	; 0x38
102df998:	639f      	str	r7, [r3, #56]	; 0x38
102df99a:	6bcc      	ldr	r4, [r1, #60]	; 0x3c
102df99c:	3140      	adds	r1, #64	; 0x40
102df99e:	63dc      	str	r4, [r3, #60]	; 0x3c
102df9a0:	3340      	adds	r3, #64	; 0x40
102df9a2:	1ad4      	subs	r4, r2, r3
102df9a4:	2c3f      	cmp	r4, #63	; 0x3f
102df9a6:	dcda      	bgt.n	102df95e <memcpy+0x96>
102df9a8:	e00a      	b.n	102df9c0 <memcpy+0xf8>
102df9aa:	680d      	ldr	r5, [r1, #0]
102df9ac:	601d      	str	r5, [r3, #0]
102df9ae:	684f      	ldr	r7, [r1, #4]
102df9b0:	605f      	str	r7, [r3, #4]
102df9b2:	688c      	ldr	r4, [r1, #8]
102df9b4:	609c      	str	r4, [r3, #8]
102df9b6:	68cd      	ldr	r5, [r1, #12]
102df9b8:	60dd      	str	r5, [r3, #12]
102df9ba:	3310      	adds	r3, #16
102df9bc:	3110      	adds	r1, #16
102df9be:	1ad4      	subs	r4, r2, r3
102df9c0:	2c0f      	cmp	r4, #15
102df9c2:	dcf2      	bgt.n	102df9aa <memcpy+0xe2>
102df9c4:	e002      	b.n	102df9cc <memcpy+0x104>
102df9c6:	c910      	ldmia	r1!, {r4}
102df9c8:	c310      	stmia	r3!, {r4}
102df9ca:	1ad4      	subs	r4, r2, r3
102df9cc:	2c03      	cmp	r4, #3
102df9ce:	dcfa      	bgt.n	102df9c6 <memcpy+0xfe>
102df9d0:	e7bc      	b.n	102df94c <memcpy+0x84>
102df9d2:	46c0      	nop			; (mov r8, r8)

102df9d4 <memset>:
102df9d4:	b530      	push	{r4, r5, lr}
102df9d6:	060c      	lsls	r4, r1, #24
102df9d8:	0e24      	lsrs	r4, r4, #24
102df9da:	2a03      	cmp	r2, #3
102df9dc:	d80a      	bhi.n	102df9f4 <memset+0x20>
102df9de:	1c03      	adds	r3, r0, #0
102df9e0:	1811      	adds	r1, r2, r0
102df9e2:	2a00      	cmp	r2, #0
102df9e4:	d003      	beq.n	102df9ee <memset+0x1a>
102df9e6:	701c      	strb	r4, [r3, #0]
102df9e8:	3301      	adds	r3, #1
102df9ea:	428b      	cmp	r3, r1
102df9ec:	d1fb      	bne.n	102df9e6 <memset+0x12>
102df9ee:	bc30      	pop	{r4, r5}
102df9f0:	bc02      	pop	{r1}
102df9f2:	4708      	bx	r1
102df9f4:	1882      	adds	r2, r0, r2
102df9f6:	0783      	lsls	r3, r0, #30
102df9f8:	d006      	beq.n	102dfa08 <memset+0x34>
102df9fa:	1c03      	adds	r3, r0, #0
102df9fc:	2503      	movs	r5, #3
102df9fe:	701c      	strb	r4, [r3, #0]
102dfa00:	3301      	adds	r3, #1
102dfa02:	422b      	tst	r3, r5
102dfa04:	d1fb      	bne.n	102df9fe <memset+0x2a>
102dfa06:	e000      	b.n	102dfa0a <memset+0x36>
102dfa08:	1c03      	adds	r3, r0, #0
102dfa0a:	25ff      	movs	r5, #255	; 0xff
102dfa0c:	4029      	ands	r1, r5
102dfa0e:	020d      	lsls	r5, r1, #8
102dfa10:	1869      	adds	r1, r5, r1
102dfa12:	040d      	lsls	r5, r1, #16
102dfa14:	1949      	adds	r1, r1, r5
102dfa16:	1ad5      	subs	r5, r2, r3
102dfa18:	2d3f      	cmp	r5, #63	; 0x3f
102dfa1a:	dd1a      	ble.n	102dfa52 <memset+0x7e>
102dfa1c:	6019      	str	r1, [r3, #0]
102dfa1e:	6059      	str	r1, [r3, #4]
102dfa20:	6099      	str	r1, [r3, #8]
102dfa22:	60d9      	str	r1, [r3, #12]
102dfa24:	6119      	str	r1, [r3, #16]
102dfa26:	6159      	str	r1, [r3, #20]
102dfa28:	6199      	str	r1, [r3, #24]
102dfa2a:	61d9      	str	r1, [r3, #28]
102dfa2c:	6219      	str	r1, [r3, #32]
102dfa2e:	6259      	str	r1, [r3, #36]	; 0x24
102dfa30:	6299      	str	r1, [r3, #40]	; 0x28
102dfa32:	62d9      	str	r1, [r3, #44]	; 0x2c
102dfa34:	6319      	str	r1, [r3, #48]	; 0x30
102dfa36:	6359      	str	r1, [r3, #52]	; 0x34
102dfa38:	6399      	str	r1, [r3, #56]	; 0x38
102dfa3a:	63d9      	str	r1, [r3, #60]	; 0x3c
102dfa3c:	3340      	adds	r3, #64	; 0x40
102dfa3e:	1ad5      	subs	r5, r2, r3
102dfa40:	2d3f      	cmp	r5, #63	; 0x3f
102dfa42:	dceb      	bgt.n	102dfa1c <memset+0x48>
102dfa44:	e005      	b.n	102dfa52 <memset+0x7e>
102dfa46:	6019      	str	r1, [r3, #0]
102dfa48:	6059      	str	r1, [r3, #4]
102dfa4a:	6099      	str	r1, [r3, #8]
102dfa4c:	60d9      	str	r1, [r3, #12]
102dfa4e:	3310      	adds	r3, #16
102dfa50:	1ad5      	subs	r5, r2, r3
102dfa52:	2d0f      	cmp	r5, #15
102dfa54:	dcf7      	bgt.n	102dfa46 <memset+0x72>
102dfa56:	e001      	b.n	102dfa5c <memset+0x88>
102dfa58:	c302      	stmia	r3!, {r1}
102dfa5a:	1ad5      	subs	r5, r2, r3
102dfa5c:	2d03      	cmp	r5, #3
102dfa5e:	dcfb      	bgt.n	102dfa58 <memset+0x84>
102dfa60:	429a      	cmp	r2, r3
102dfa62:	d9c4      	bls.n	102df9ee <memset+0x1a>
102dfa64:	701c      	strb	r4, [r3, #0]
102dfa66:	3301      	adds	r3, #1
102dfa68:	4293      	cmp	r3, r2
102dfa6a:	d1fb      	bne.n	102dfa64 <memset+0x90>
102dfa6c:	e7bf      	b.n	102df9ee <memset+0x1a>
102dfa6e:	46c0      	nop			; (mov r8, r8)

102dfa70 <realloc>:
102dfa70:	b508      	push	{r3, lr}
102dfa72:	1c0a      	adds	r2, r1, #0
102dfa74:	4904      	ldr	r1, [pc, #16]	; (102dfa88 <realloc+0x18>)
102dfa76:	1c03      	adds	r3, r0, #0
102dfa78:	6808      	ldr	r0, [r1, #0]
102dfa7a:	1c19      	adds	r1, r3, #0
102dfa7c:	f000 f806 	bl	102dfa8c <_realloc_r>
102dfa80:	bc08      	pop	{r3}
102dfa82:	bc02      	pop	{r1}
102dfa84:	4708      	bx	r1
102dfa86:	46c0      	nop			; (mov r8, r8)
102dfa88:	f03d4790 	.word	0xf03d4790

102dfa8c <_realloc_r>:
102dfa8c:	b5f0      	push	{r4, r5, r6, r7, lr}
102dfa8e:	465f      	mov	r7, fp
102dfa90:	4644      	mov	r4, r8
102dfa92:	4656      	mov	r6, sl
102dfa94:	464d      	mov	r5, r9
102dfa96:	b4f0      	push	{r4, r5, r6, r7}
102dfa98:	4693      	mov	fp, r2
102dfa9a:	b085      	sub	sp, #20
102dfa9c:	1c07      	adds	r7, r0, #0
102dfa9e:	1e0c      	subs	r4, r1, #0
102dfaa0:	d100      	bne.n	102dfaa4 <_realloc_r+0x18>
102dfaa2:	e104      	b.n	102dfcae <_realloc_r+0x222>
102dfaa4:	1c26      	adds	r6, r4, #0
102dfaa6:	3e08      	subs	r6, #8
102dfaa8:	f002 fbf2 	bl	102e2290 <__malloc_lock>
102dfaac:	6873      	ldr	r3, [r6, #4]
102dfaae:	2203      	movs	r2, #3
102dfab0:	1c18      	adds	r0, r3, #0
102dfab2:	465d      	mov	r5, fp
102dfab4:	4390      	bics	r0, r2
102dfab6:	350b      	adds	r5, #11
102dfab8:	4680      	mov	r8, r0
102dfaba:	2d16      	cmp	r5, #22
102dfabc:	d864      	bhi.n	102dfb88 <_realloc_r+0xfc>
102dfabe:	2110      	movs	r1, #16
102dfac0:	9101      	str	r1, [sp, #4]
102dfac2:	2200      	movs	r2, #0
102dfac4:	2510      	movs	r5, #16
102dfac6:	455d      	cmp	r5, fp
102dfac8:	d200      	bcs.n	102dfacc <_realloc_r+0x40>
102dfaca:	e0f5      	b.n	102dfcb8 <_realloc_r+0x22c>
102dfacc:	2a00      	cmp	r2, #0
102dface:	d000      	beq.n	102dfad2 <_realloc_r+0x46>
102dfad0:	e0f2      	b.n	102dfcb8 <_realloc_r+0x22c>
102dfad2:	9801      	ldr	r0, [sp, #4]
102dfad4:	4580      	cmp	r8, r0
102dfad6:	da5c      	bge.n	102dfb92 <_realloc_r+0x106>
102dfad8:	48d3      	ldr	r0, [pc, #844]	; (102dfe28 <_realloc_r+0x39c>)
102dfada:	4641      	mov	r1, r8
102dfadc:	6880      	ldr	r0, [r0, #8]
102dfade:	1872      	adds	r2, r6, r1
102dfae0:	9002      	str	r0, [sp, #8]
102dfae2:	4290      	cmp	r0, r2
102dfae4:	d100      	bne.n	102dfae8 <_realloc_r+0x5c>
102dfae6:	e0ec      	b.n	102dfcc2 <_realloc_r+0x236>
102dfae8:	6851      	ldr	r1, [r2, #4]
102dfaea:	2001      	movs	r0, #1
102dfaec:	468a      	mov	sl, r1
102dfaee:	4381      	bics	r1, r0
102dfaf0:	4689      	mov	r9, r1
102dfaf2:	4491      	add	r9, r2
102dfaf4:	4684      	mov	ip, r0
102dfaf6:	4648      	mov	r0, r9
102dfaf8:	6840      	ldr	r0, [r0, #4]
102dfafa:	4661      	mov	r1, ip
102dfafc:	4208      	tst	r0, r1
102dfafe:	d064      	beq.n	102dfbca <_realloc_r+0x13e>
102dfb00:	2200      	movs	r2, #0
102dfb02:	4694      	mov	ip, r2
102dfb04:	07d9      	lsls	r1, r3, #31
102dfb06:	d500      	bpl.n	102dfb0a <_realloc_r+0x7e>
102dfb08:	e07e      	b.n	102dfc08 <_realloc_r+0x17c>
102dfb0a:	6833      	ldr	r3, [r6, #0]
102dfb0c:	1af3      	subs	r3, r6, r3
102dfb0e:	469a      	mov	sl, r3
102dfb10:	4651      	mov	r1, sl
102dfb12:	6848      	ldr	r0, [r1, #4]
102dfb14:	2303      	movs	r3, #3
102dfb16:	4398      	bics	r0, r3
102dfb18:	1c03      	adds	r3, r0, #0
102dfb1a:	2a00      	cmp	r2, #0
102dfb1c:	d100      	bne.n	102dfb20 <_realloc_r+0x94>
102dfb1e:	e09a      	b.n	102dfc56 <_realloc_r+0x1ca>
102dfb20:	9802      	ldr	r0, [sp, #8]
102dfb22:	4443      	add	r3, r8
102dfb24:	9302      	str	r3, [sp, #8]
102dfb26:	4463      	add	r3, ip
102dfb28:	4282      	cmp	r2, r0
102dfb2a:	d100      	bne.n	102dfb2e <_realloc_r+0xa2>
102dfb2c:	e101      	b.n	102dfd32 <_realloc_r+0x2a6>
102dfb2e:	4699      	mov	r9, r3
102dfb30:	9b01      	ldr	r3, [sp, #4]
102dfb32:	4599      	cmp	r9, r3
102dfb34:	da00      	bge.n	102dfb38 <_realloc_r+0xac>
102dfb36:	e090      	b.n	102dfc5a <_realloc_r+0x1ce>
102dfb38:	6893      	ldr	r3, [r2, #8]
102dfb3a:	68d1      	ldr	r1, [r2, #12]
102dfb3c:	60d9      	str	r1, [r3, #12]
102dfb3e:	608b      	str	r3, [r1, #8]
102dfb40:	4650      	mov	r0, sl
102dfb42:	68c2      	ldr	r2, [r0, #12]
102dfb44:	6883      	ldr	r3, [r0, #8]
102dfb46:	60da      	str	r2, [r3, #12]
102dfb48:	6093      	str	r3, [r2, #8]
102dfb4a:	4642      	mov	r2, r8
102dfb4c:	4656      	mov	r6, sl
102dfb4e:	3a04      	subs	r2, #4
102dfb50:	3608      	adds	r6, #8
102dfb52:	2a24      	cmp	r2, #36	; 0x24
102dfb54:	d900      	bls.n	102dfb58 <_realloc_r+0xcc>
102dfb56:	e134      	b.n	102dfdc2 <_realloc_r+0x336>
102dfb58:	1c33      	adds	r3, r6, #0
102dfb5a:	2a13      	cmp	r2, #19
102dfb5c:	d909      	bls.n	102dfb72 <_realloc_r+0xe6>
102dfb5e:	6821      	ldr	r1, [r4, #0]
102dfb60:	6081      	str	r1, [r0, #8]
102dfb62:	6863      	ldr	r3, [r4, #4]
102dfb64:	60c3      	str	r3, [r0, #12]
102dfb66:	2a1b      	cmp	r2, #27
102dfb68:	d900      	bls.n	102dfb6c <_realloc_r+0xe0>
102dfb6a:	e133      	b.n	102dfdd4 <_realloc_r+0x348>
102dfb6c:	4653      	mov	r3, sl
102dfb6e:	3310      	adds	r3, #16
102dfb70:	3408      	adds	r4, #8
102dfb72:	6820      	ldr	r0, [r4, #0]
102dfb74:	6018      	str	r0, [r3, #0]
102dfb76:	6861      	ldr	r1, [r4, #4]
102dfb78:	6059      	str	r1, [r3, #4]
102dfb7a:	68a4      	ldr	r4, [r4, #8]
102dfb7c:	609c      	str	r4, [r3, #8]
102dfb7e:	4652      	mov	r2, sl
102dfb80:	1c34      	adds	r4, r6, #0
102dfb82:	6853      	ldr	r3, [r2, #4]
102dfb84:	4656      	mov	r6, sl
102dfb86:	e005      	b.n	102dfb94 <_realloc_r+0x108>
102dfb88:	2207      	movs	r2, #7
102dfb8a:	4395      	bics	r5, r2
102dfb8c:	9501      	str	r5, [sp, #4]
102dfb8e:	0fea      	lsrs	r2, r5, #31
102dfb90:	e799      	b.n	102dfac6 <_realloc_r+0x3a>
102dfb92:	46c1      	mov	r9, r8
102dfb94:	4648      	mov	r0, r9
102dfb96:	1b42      	subs	r2, r0, r5
102dfb98:	2a0f      	cmp	r2, #15
102dfb9a:	d824      	bhi.n	102dfbe6 <_realloc_r+0x15a>
102dfb9c:	2201      	movs	r2, #1
102dfb9e:	4013      	ands	r3, r2
102dfba0:	4648      	mov	r0, r9
102dfba2:	4303      	orrs	r3, r0
102dfba4:	6073      	str	r3, [r6, #4]
102dfba6:	444e      	add	r6, r9
102dfba8:	6871      	ldr	r1, [r6, #4]
102dfbaa:	430a      	orrs	r2, r1
102dfbac:	6072      	str	r2, [r6, #4]
102dfbae:	1c38      	adds	r0, r7, #0
102dfbb0:	f002 fb70 	bl	102e2294 <__malloc_unlock>
102dfbb4:	46a1      	mov	r9, r4
102dfbb6:	4648      	mov	r0, r9
102dfbb8:	b005      	add	sp, #20
102dfbba:	bc3c      	pop	{r2, r3, r4, r5}
102dfbbc:	4690      	mov	r8, r2
102dfbbe:	4699      	mov	r9, r3
102dfbc0:	46a2      	mov	sl, r4
102dfbc2:	46ab      	mov	fp, r5
102dfbc4:	bcf0      	pop	{r4, r5, r6, r7}
102dfbc6:	bc02      	pop	{r1}
102dfbc8:	4708      	bx	r1
102dfbca:	2003      	movs	r0, #3
102dfbcc:	4651      	mov	r1, sl
102dfbce:	4381      	bics	r1, r0
102dfbd0:	9801      	ldr	r0, [sp, #4]
102dfbd2:	468c      	mov	ip, r1
102dfbd4:	4441      	add	r1, r8
102dfbd6:	4689      	mov	r9, r1
102dfbd8:	4281      	cmp	r1, r0
102dfbda:	db93      	blt.n	102dfb04 <_realloc_r+0x78>
102dfbdc:	68d1      	ldr	r1, [r2, #12]
102dfbde:	6892      	ldr	r2, [r2, #8]
102dfbe0:	60d1      	str	r1, [r2, #12]
102dfbe2:	608a      	str	r2, [r1, #8]
102dfbe4:	e7d6      	b.n	102dfb94 <_realloc_r+0x108>
102dfbe6:	2001      	movs	r0, #1
102dfbe8:	4003      	ands	r3, r0
102dfbea:	1971      	adds	r1, r6, r5
102dfbec:	431d      	orrs	r5, r3
102dfbee:	1c13      	adds	r3, r2, #0
102dfbf0:	4303      	orrs	r3, r0
102dfbf2:	6075      	str	r5, [r6, #4]
102dfbf4:	604b      	str	r3, [r1, #4]
102dfbf6:	188a      	adds	r2, r1, r2
102dfbf8:	6853      	ldr	r3, [r2, #4]
102dfbfa:	4318      	orrs	r0, r3
102dfbfc:	6050      	str	r0, [r2, #4]
102dfbfe:	3108      	adds	r1, #8
102dfc00:	1c38      	adds	r0, r7, #0
102dfc02:	f001 fb1d 	bl	102e1240 <_free_r>
102dfc06:	e7d2      	b.n	102dfbae <_realloc_r+0x122>
102dfc08:	1c38      	adds	r0, r7, #0
102dfc0a:	4659      	mov	r1, fp
102dfc0c:	f002 f85c 	bl	102e1cc8 <_malloc_r>
102dfc10:	4681      	mov	r9, r0
102dfc12:	2800      	cmp	r0, #0
102dfc14:	d01b      	beq.n	102dfc4e <_realloc_r+0x1c2>
102dfc16:	6873      	ldr	r3, [r6, #4]
102dfc18:	1c02      	adds	r2, r0, #0
102dfc1a:	2101      	movs	r1, #1
102dfc1c:	1c18      	adds	r0, r3, #0
102dfc1e:	4388      	bics	r0, r1
102dfc20:	3a08      	subs	r2, #8
102dfc22:	1831      	adds	r1, r6, r0
102dfc24:	428a      	cmp	r2, r1
102dfc26:	d100      	bne.n	102dfc2a <_realloc_r+0x19e>
102dfc28:	e0c5      	b.n	102dfdb6 <_realloc_r+0x32a>
102dfc2a:	4642      	mov	r2, r8
102dfc2c:	3a04      	subs	r2, #4
102dfc2e:	2a24      	cmp	r2, #36	; 0x24
102dfc30:	d87a      	bhi.n	102dfd28 <_realloc_r+0x29c>
102dfc32:	2a13      	cmp	r2, #19
102dfc34:	d852      	bhi.n	102dfcdc <_realloc_r+0x250>
102dfc36:	464b      	mov	r3, r9
102dfc38:	1c22      	adds	r2, r4, #0
102dfc3a:	6810      	ldr	r0, [r2, #0]
102dfc3c:	6018      	str	r0, [r3, #0]
102dfc3e:	6851      	ldr	r1, [r2, #4]
102dfc40:	6059      	str	r1, [r3, #4]
102dfc42:	6892      	ldr	r2, [r2, #8]
102dfc44:	609a      	str	r2, [r3, #8]
102dfc46:	1c38      	adds	r0, r7, #0
102dfc48:	1c21      	adds	r1, r4, #0
102dfc4a:	f001 faf9 	bl	102e1240 <_free_r>
102dfc4e:	1c38      	adds	r0, r7, #0
102dfc50:	f002 fb20 	bl	102e2294 <__malloc_unlock>
102dfc54:	e7af      	b.n	102dfbb6 <_realloc_r+0x12a>
102dfc56:	4443      	add	r3, r8
102dfc58:	9302      	str	r3, [sp, #8]
102dfc5a:	9902      	ldr	r1, [sp, #8]
102dfc5c:	9a01      	ldr	r2, [sp, #4]
102dfc5e:	4291      	cmp	r1, r2
102dfc60:	dbd2      	blt.n	102dfc08 <_realloc_r+0x17c>
102dfc62:	4653      	mov	r3, sl
102dfc64:	68da      	ldr	r2, [r3, #12]
102dfc66:	689b      	ldr	r3, [r3, #8]
102dfc68:	60da      	str	r2, [r3, #12]
102dfc6a:	6093      	str	r3, [r2, #8]
102dfc6c:	4642      	mov	r2, r8
102dfc6e:	4656      	mov	r6, sl
102dfc70:	3a04      	subs	r2, #4
102dfc72:	3608      	adds	r6, #8
102dfc74:	2a24      	cmp	r2, #36	; 0x24
102dfc76:	d83c      	bhi.n	102dfcf2 <_realloc_r+0x266>
102dfc78:	1c33      	adds	r3, r6, #0
102dfc7a:	2a13      	cmp	r2, #19
102dfc7c:	d90a      	bls.n	102dfc94 <_realloc_r+0x208>
102dfc7e:	6820      	ldr	r0, [r4, #0]
102dfc80:	4651      	mov	r1, sl
102dfc82:	6088      	str	r0, [r1, #8]
102dfc84:	6863      	ldr	r3, [r4, #4]
102dfc86:	60cb      	str	r3, [r1, #12]
102dfc88:	2a1b      	cmp	r2, #27
102dfc8a:	d900      	bls.n	102dfc8e <_realloc_r+0x202>
102dfc8c:	e0b7      	b.n	102dfdfe <_realloc_r+0x372>
102dfc8e:	4653      	mov	r3, sl
102dfc90:	3310      	adds	r3, #16
102dfc92:	3408      	adds	r4, #8
102dfc94:	6820      	ldr	r0, [r4, #0]
102dfc96:	6018      	str	r0, [r3, #0]
102dfc98:	6861      	ldr	r1, [r4, #4]
102dfc9a:	6059      	str	r1, [r3, #4]
102dfc9c:	68a4      	ldr	r4, [r4, #8]
102dfc9e:	9802      	ldr	r0, [sp, #8]
102dfca0:	609c      	str	r4, [r3, #8]
102dfca2:	4652      	mov	r2, sl
102dfca4:	1c34      	adds	r4, r6, #0
102dfca6:	6853      	ldr	r3, [r2, #4]
102dfca8:	4681      	mov	r9, r0
102dfcaa:	4656      	mov	r6, sl
102dfcac:	e772      	b.n	102dfb94 <_realloc_r+0x108>
102dfcae:	1c11      	adds	r1, r2, #0
102dfcb0:	f002 f80a 	bl	102e1cc8 <_malloc_r>
102dfcb4:	4681      	mov	r9, r0
102dfcb6:	e77e      	b.n	102dfbb6 <_realloc_r+0x12a>
102dfcb8:	230c      	movs	r3, #12
102dfcba:	2200      	movs	r2, #0
102dfcbc:	603b      	str	r3, [r7, #0]
102dfcbe:	4691      	mov	r9, r2
102dfcc0:	e779      	b.n	102dfbb6 <_realloc_r+0x12a>
102dfcc2:	9902      	ldr	r1, [sp, #8]
102dfcc4:	6849      	ldr	r1, [r1, #4]
102dfcc6:	2203      	movs	r2, #3
102dfcc8:	4391      	bics	r1, r2
102dfcca:	1c0a      	adds	r2, r1, #0
102dfccc:	2010      	movs	r0, #16
102dfcce:	4442      	add	r2, r8
102dfcd0:	1940      	adds	r0, r0, r5
102dfcd2:	468c      	mov	ip, r1
102dfcd4:	4282      	cmp	r2, r0
102dfcd6:	da17      	bge.n	102dfd08 <_realloc_r+0x27c>
102dfcd8:	9a02      	ldr	r2, [sp, #8]
102dfcda:	e713      	b.n	102dfb04 <_realloc_r+0x78>
102dfcdc:	6821      	ldr	r1, [r4, #0]
102dfcde:	464b      	mov	r3, r9
102dfce0:	6019      	str	r1, [r3, #0]
102dfce2:	6860      	ldr	r0, [r4, #4]
102dfce4:	6058      	str	r0, [r3, #4]
102dfce6:	2a1b      	cmp	r2, #27
102dfce8:	d85a      	bhi.n	102dfda0 <_realloc_r+0x314>
102dfcea:	1c22      	adds	r2, r4, #0
102dfcec:	3308      	adds	r3, #8
102dfcee:	3208      	adds	r2, #8
102dfcf0:	e7a3      	b.n	102dfc3a <_realloc_r+0x1ae>
102dfcf2:	1c21      	adds	r1, r4, #0
102dfcf4:	1c30      	adds	r0, r6, #0
102dfcf6:	f002 fa73 	bl	102e21e0 <memmove>
102dfcfa:	9a02      	ldr	r2, [sp, #8]
102dfcfc:	4651      	mov	r1, sl
102dfcfe:	1c34      	adds	r4, r6, #0
102dfd00:	684b      	ldr	r3, [r1, #4]
102dfd02:	4691      	mov	r9, r2
102dfd04:	4656      	mov	r6, sl
102dfd06:	e745      	b.n	102dfb94 <_realloc_r+0x108>
102dfd08:	4b47      	ldr	r3, [pc, #284]	; (102dfe28 <_realloc_r+0x39c>)
102dfd0a:	1971      	adds	r1, r6, r5
102dfd0c:	6099      	str	r1, [r3, #8]
102dfd0e:	1b52      	subs	r2, r2, r5
102dfd10:	2301      	movs	r3, #1
102dfd12:	431a      	orrs	r2, r3
102dfd14:	604a      	str	r2, [r1, #4]
102dfd16:	6870      	ldr	r0, [r6, #4]
102dfd18:	4003      	ands	r3, r0
102dfd1a:	431d      	orrs	r5, r3
102dfd1c:	6075      	str	r5, [r6, #4]
102dfd1e:	1c38      	adds	r0, r7, #0
102dfd20:	f002 fab8 	bl	102e2294 <__malloc_unlock>
102dfd24:	46a1      	mov	r9, r4
102dfd26:	e746      	b.n	102dfbb6 <_realloc_r+0x12a>
102dfd28:	4648      	mov	r0, r9
102dfd2a:	1c21      	adds	r1, r4, #0
102dfd2c:	f002 fa58 	bl	102e21e0 <memmove>
102dfd30:	e789      	b.n	102dfc46 <_realloc_r+0x1ba>
102dfd32:	9303      	str	r3, [sp, #12]
102dfd34:	9903      	ldr	r1, [sp, #12]
102dfd36:	1c2b      	adds	r3, r5, #0
102dfd38:	3310      	adds	r3, #16
102dfd3a:	4299      	cmp	r1, r3
102dfd3c:	db8d      	blt.n	102dfc5a <_realloc_r+0x1ce>
102dfd3e:	4653      	mov	r3, sl
102dfd40:	68da      	ldr	r2, [r3, #12]
102dfd42:	689b      	ldr	r3, [r3, #8]
102dfd44:	2008      	movs	r0, #8
102dfd46:	60da      	str	r2, [r3, #12]
102dfd48:	6093      	str	r3, [r2, #8]
102dfd4a:	4642      	mov	r2, r8
102dfd4c:	4450      	add	r0, sl
102dfd4e:	3a04      	subs	r2, #4
102dfd50:	4681      	mov	r9, r0
102dfd52:	2a24      	cmp	r2, #36	; 0x24
102dfd54:	d873      	bhi.n	102dfe3e <_realloc_r+0x3b2>
102dfd56:	1c03      	adds	r3, r0, #0
102dfd58:	2a13      	cmp	r2, #19
102dfd5a:	d908      	bls.n	102dfd6e <_realloc_r+0x2e2>
102dfd5c:	6821      	ldr	r1, [r4, #0]
102dfd5e:	4653      	mov	r3, sl
102dfd60:	6099      	str	r1, [r3, #8]
102dfd62:	6860      	ldr	r0, [r4, #4]
102dfd64:	60d8      	str	r0, [r3, #12]
102dfd66:	2a1b      	cmp	r2, #27
102dfd68:	d86d      	bhi.n	102dfe46 <_realloc_r+0x3ba>
102dfd6a:	3310      	adds	r3, #16
102dfd6c:	3408      	adds	r4, #8
102dfd6e:	6820      	ldr	r0, [r4, #0]
102dfd70:	6018      	str	r0, [r3, #0]
102dfd72:	6861      	ldr	r1, [r4, #4]
102dfd74:	6059      	str	r1, [r3, #4]
102dfd76:	68a4      	ldr	r4, [r4, #8]
102dfd78:	609c      	str	r4, [r3, #8]
102dfd7a:	4653      	mov	r3, sl
102dfd7c:	195a      	adds	r2, r3, r5
102dfd7e:	9b03      	ldr	r3, [sp, #12]
102dfd80:	1b59      	subs	r1, r3, r5
102dfd82:	2301      	movs	r3, #1
102dfd84:	4319      	orrs	r1, r3
102dfd86:	4828      	ldr	r0, [pc, #160]	; (102dfe28 <_realloc_r+0x39c>)
102dfd88:	6051      	str	r1, [r2, #4]
102dfd8a:	6082      	str	r2, [r0, #8]
102dfd8c:	4650      	mov	r0, sl
102dfd8e:	6840      	ldr	r0, [r0, #4]
102dfd90:	4003      	ands	r3, r0
102dfd92:	431d      	orrs	r5, r3
102dfd94:	4651      	mov	r1, sl
102dfd96:	604d      	str	r5, [r1, #4]
102dfd98:	1c38      	adds	r0, r7, #0
102dfd9a:	f002 fa7b 	bl	102e2294 <__malloc_unlock>
102dfd9e:	e70a      	b.n	102dfbb6 <_realloc_r+0x12a>
102dfda0:	68a1      	ldr	r1, [r4, #8]
102dfda2:	464b      	mov	r3, r9
102dfda4:	6099      	str	r1, [r3, #8]
102dfda6:	68e0      	ldr	r0, [r4, #12]
102dfda8:	60d8      	str	r0, [r3, #12]
102dfdaa:	2a24      	cmp	r2, #36	; 0x24
102dfdac:	d01d      	beq.n	102dfdea <_realloc_r+0x35e>
102dfdae:	1c22      	adds	r2, r4, #0
102dfdb0:	3310      	adds	r3, #16
102dfdb2:	3210      	adds	r2, #16
102dfdb4:	e741      	b.n	102dfc3a <_realloc_r+0x1ae>
102dfdb6:	6852      	ldr	r2, [r2, #4]
102dfdb8:	2103      	movs	r1, #3
102dfdba:	438a      	bics	r2, r1
102dfdbc:	4442      	add	r2, r8
102dfdbe:	4691      	mov	r9, r2
102dfdc0:	e6e8      	b.n	102dfb94 <_realloc_r+0x108>
102dfdc2:	1c30      	adds	r0, r6, #0
102dfdc4:	1c21      	adds	r1, r4, #0
102dfdc6:	f002 fa0b 	bl	102e21e0 <memmove>
102dfdca:	4650      	mov	r0, sl
102dfdcc:	1c34      	adds	r4, r6, #0
102dfdce:	6843      	ldr	r3, [r0, #4]
102dfdd0:	4656      	mov	r6, sl
102dfdd2:	e6df      	b.n	102dfb94 <_realloc_r+0x108>
102dfdd4:	68a0      	ldr	r0, [r4, #8]
102dfdd6:	4651      	mov	r1, sl
102dfdd8:	6108      	str	r0, [r1, #16]
102dfdda:	68e3      	ldr	r3, [r4, #12]
102dfddc:	614b      	str	r3, [r1, #20]
102dfdde:	2a24      	cmp	r2, #36	; 0x24
102dfde0:	d018      	beq.n	102dfe14 <_realloc_r+0x388>
102dfde2:	4653      	mov	r3, sl
102dfde4:	3318      	adds	r3, #24
102dfde6:	3410      	adds	r4, #16
102dfde8:	e6c3      	b.n	102dfb72 <_realloc_r+0xe6>
102dfdea:	6921      	ldr	r1, [r4, #16]
102dfdec:	6119      	str	r1, [r3, #16]
102dfdee:	6963      	ldr	r3, [r4, #20]
102dfdf0:	464a      	mov	r2, r9
102dfdf2:	6153      	str	r3, [r2, #20]
102dfdf4:	464b      	mov	r3, r9
102dfdf6:	1c22      	adds	r2, r4, #0
102dfdf8:	3318      	adds	r3, #24
102dfdfa:	3218      	adds	r2, #24
102dfdfc:	e71d      	b.n	102dfc3a <_realloc_r+0x1ae>
102dfdfe:	68a0      	ldr	r0, [r4, #8]
102dfe00:	4651      	mov	r1, sl
102dfe02:	6108      	str	r0, [r1, #16]
102dfe04:	68e3      	ldr	r3, [r4, #12]
102dfe06:	614b      	str	r3, [r1, #20]
102dfe08:	2a24      	cmp	r2, #36	; 0x24
102dfe0a:	d00f      	beq.n	102dfe2c <_realloc_r+0x3a0>
102dfe0c:	4653      	mov	r3, sl
102dfe0e:	3318      	adds	r3, #24
102dfe10:	3410      	adds	r4, #16
102dfe12:	e73f      	b.n	102dfc94 <_realloc_r+0x208>
102dfe14:	6920      	ldr	r0, [r4, #16]
102dfe16:	4651      	mov	r1, sl
102dfe18:	6188      	str	r0, [r1, #24]
102dfe1a:	6962      	ldr	r2, [r4, #20]
102dfe1c:	4653      	mov	r3, sl
102dfe1e:	61ca      	str	r2, [r1, #28]
102dfe20:	3320      	adds	r3, #32
102dfe22:	3418      	adds	r4, #24
102dfe24:	e6a5      	b.n	102dfb72 <_realloc_r+0xe6>
102dfe26:	46c0      	nop			; (mov r8, r8)
102dfe28:	f03d4c3c 	.word	0xf03d4c3c
102dfe2c:	6920      	ldr	r0, [r4, #16]
102dfe2e:	4651      	mov	r1, sl
102dfe30:	6188      	str	r0, [r1, #24]
102dfe32:	6962      	ldr	r2, [r4, #20]
102dfe34:	4653      	mov	r3, sl
102dfe36:	61ca      	str	r2, [r1, #28]
102dfe38:	3320      	adds	r3, #32
102dfe3a:	3418      	adds	r4, #24
102dfe3c:	e72a      	b.n	102dfc94 <_realloc_r+0x208>
102dfe3e:	1c21      	adds	r1, r4, #0
102dfe40:	f002 f9ce 	bl	102e21e0 <memmove>
102dfe44:	e799      	b.n	102dfd7a <_realloc_r+0x2ee>
102dfe46:	68a1      	ldr	r1, [r4, #8]
102dfe48:	4653      	mov	r3, sl
102dfe4a:	6119      	str	r1, [r3, #16]
102dfe4c:	68e0      	ldr	r0, [r4, #12]
102dfe4e:	6158      	str	r0, [r3, #20]
102dfe50:	2a24      	cmp	r2, #36	; 0x24
102dfe52:	d002      	beq.n	102dfe5a <_realloc_r+0x3ce>
102dfe54:	3318      	adds	r3, #24
102dfe56:	3410      	adds	r4, #16
102dfe58:	e789      	b.n	102dfd6e <_realloc_r+0x2e2>
102dfe5a:	6921      	ldr	r1, [r4, #16]
102dfe5c:	6199      	str	r1, [r3, #24]
102dfe5e:	6963      	ldr	r3, [r4, #20]
102dfe60:	4652      	mov	r2, sl
102dfe62:	61d3      	str	r3, [r2, #28]
102dfe64:	4653      	mov	r3, sl
102dfe66:	3320      	adds	r3, #32
102dfe68:	3418      	adds	r4, #24
102dfe6a:	e780      	b.n	102dfd6e <_realloc_r+0x2e2>

102dfe6c <strchr>:
102dfe6c:	060a      	lsls	r2, r1, #24
102dfe6e:	b5f0      	push	{r4, r5, r6, r7, lr}
102dfe70:	0e12      	lsrs	r2, r2, #24
102dfe72:	d033      	beq.n	102dfedc <strchr+0x70>
102dfe74:	0783      	lsls	r3, r0, #30
102dfe76:	d00e      	beq.n	102dfe96 <strchr+0x2a>
102dfe78:	7803      	ldrb	r3, [r0, #0]
102dfe7a:	2b00      	cmp	r3, #0
102dfe7c:	d05a      	beq.n	102dff34 <strchr+0xc8>
102dfe7e:	429a      	cmp	r2, r3
102dfe80:	d04f      	beq.n	102dff22 <strchr+0xb6>
102dfe82:	2403      	movs	r4, #3
102dfe84:	e004      	b.n	102dfe90 <strchr+0x24>
102dfe86:	7803      	ldrb	r3, [r0, #0]
102dfe88:	2b00      	cmp	r3, #0
102dfe8a:	d053      	beq.n	102dff34 <strchr+0xc8>
102dfe8c:	429a      	cmp	r2, r3
102dfe8e:	d048      	beq.n	102dff22 <strchr+0xb6>
102dfe90:	3001      	adds	r0, #1
102dfe92:	4220      	tst	r0, r4
102dfe94:	d1f7      	bne.n	102dfe86 <strchr+0x1a>
102dfe96:	23ff      	movs	r3, #255	; 0xff
102dfe98:	4019      	ands	r1, r3
102dfe9a:	020b      	lsls	r3, r1, #8
102dfe9c:	4319      	orrs	r1, r3
102dfe9e:	040b      	lsls	r3, r1, #16
102dfea0:	4d25      	ldr	r5, [pc, #148]	; (102dff38 <strchr+0xcc>)
102dfea2:	4319      	orrs	r1, r3
102dfea4:	6803      	ldr	r3, [r0, #0]
102dfea6:	195c      	adds	r4, r3, r5
102dfea8:	4d24      	ldr	r5, [pc, #144]	; (102dff3c <strchr+0xd0>)
102dfeaa:	439c      	bics	r4, r3
102dfeac:	422c      	tst	r4, r5
102dfeae:	d13e      	bne.n	102dff2e <strchr+0xc2>
102dfeb0:	4e21      	ldr	r6, [pc, #132]	; (102dff38 <strchr+0xcc>)
102dfeb2:	404b      	eors	r3, r1
102dfeb4:	199c      	adds	r4, r3, r6
102dfeb6:	439c      	bics	r4, r3
102dfeb8:	422c      	tst	r4, r5
102dfeba:	d138      	bne.n	102dff2e <strchr+0xc2>
102dfebc:	1d04      	adds	r4, r0, #4
102dfebe:	e005      	b.n	102dfecc <strchr+0x60>
102dfec0:	4f1d      	ldr	r7, [pc, #116]	; (102dff38 <strchr+0xcc>)
102dfec2:	404b      	eors	r3, r1
102dfec4:	19de      	adds	r6, r3, r7
102dfec6:	439e      	bics	r6, r3
102dfec8:	422e      	tst	r6, r5
102dfeca:	d130      	bne.n	102dff2e <strchr+0xc2>
102dfecc:	1c20      	adds	r0, r4, #0
102dfece:	4f1a      	ldr	r7, [pc, #104]	; (102dff38 <strchr+0xcc>)
102dfed0:	cc08      	ldmia	r4!, {r3}
102dfed2:	19de      	adds	r6, r3, r7
102dfed4:	439e      	bics	r6, r3
102dfed6:	422e      	tst	r6, r5
102dfed8:	d0f2      	beq.n	102dfec0 <strchr+0x54>
102dfeda:	e028      	b.n	102dff2e <strchr+0xc2>
102dfedc:	0785      	lsls	r5, r0, #30
102dfede:	d00a      	beq.n	102dfef6 <strchr+0x8a>
102dfee0:	7803      	ldrb	r3, [r0, #0]
102dfee2:	2b00      	cmp	r3, #0
102dfee4:	d01d      	beq.n	102dff22 <strchr+0xb6>
102dfee6:	2203      	movs	r2, #3
102dfee8:	e002      	b.n	102dfef0 <strchr+0x84>
102dfeea:	7803      	ldrb	r3, [r0, #0]
102dfeec:	2b00      	cmp	r3, #0
102dfeee:	d018      	beq.n	102dff22 <strchr+0xb6>
102dfef0:	3001      	adds	r0, #1
102dfef2:	4210      	tst	r0, r2
102dfef4:	d1f9      	bne.n	102dfeea <strchr+0x7e>
102dfef6:	6803      	ldr	r3, [r0, #0]
102dfef8:	4e0f      	ldr	r6, [pc, #60]	; (102dff38 <strchr+0xcc>)
102dfefa:	4c10      	ldr	r4, [pc, #64]	; (102dff3c <strchr+0xd0>)
102dfefc:	199a      	adds	r2, r3, r6
102dfefe:	439a      	bics	r2, r3
102dff00:	4222      	tst	r2, r4
102dff02:	d107      	bne.n	102dff14 <strchr+0xa8>
102dff04:	1d03      	adds	r3, r0, #4
102dff06:	1c18      	adds	r0, r3, #0
102dff08:	4f0b      	ldr	r7, [pc, #44]	; (102dff38 <strchr+0xcc>)
102dff0a:	cb04      	ldmia	r3!, {r2}
102dff0c:	19d1      	adds	r1, r2, r7
102dff0e:	4391      	bics	r1, r2
102dff10:	4221      	tst	r1, r4
102dff12:	d0f8      	beq.n	102dff06 <strchr+0x9a>
102dff14:	7803      	ldrb	r3, [r0, #0]
102dff16:	2b00      	cmp	r3, #0
102dff18:	d003      	beq.n	102dff22 <strchr+0xb6>
102dff1a:	3001      	adds	r0, #1
102dff1c:	7803      	ldrb	r3, [r0, #0]
102dff1e:	2b00      	cmp	r3, #0
102dff20:	d1fb      	bne.n	102dff1a <strchr+0xae>
102dff22:	bcf0      	pop	{r4, r5, r6, r7}
102dff24:	bc02      	pop	{r1}
102dff26:	4708      	bx	r1
102dff28:	429a      	cmp	r2, r3
102dff2a:	d0fa      	beq.n	102dff22 <strchr+0xb6>
102dff2c:	3001      	adds	r0, #1
102dff2e:	7803      	ldrb	r3, [r0, #0]
102dff30:	2b00      	cmp	r3, #0
102dff32:	d1f9      	bne.n	102dff28 <strchr+0xbc>
102dff34:	2000      	movs	r0, #0
102dff36:	e7f4      	b.n	102dff22 <strchr+0xb6>
102dff38:	fefefeff 	.word	0xfefefeff
102dff3c:	80808080 	.word	0x80808080

102dff40 <strcmp>:
102dff40:	7802      	ldrb	r2, [r0, #0]
102dff42:	780b      	ldrb	r3, [r1, #0]
102dff44:	3001      	adds	r0, #1
102dff46:	3101      	adds	r1, #1
102dff48:	2a00      	cmp	r2, #0
102dff4a:	d001      	beq.n	102dff50 <strcmp+0x10>
102dff4c:	429a      	cmp	r2, r3
102dff4e:	d0f7      	beq.n	102dff40 <strcmp>
102dff50:	1ad0      	subs	r0, r2, r3
102dff52:	4770      	bx	lr

102dff54 <strcpy>:
102dff54:	1c03      	adds	r3, r0, #0
102dff56:	780a      	ldrb	r2, [r1, #0]
102dff58:	3101      	adds	r1, #1
102dff5a:	701a      	strb	r2, [r3, #0]
102dff5c:	3301      	adds	r3, #1
102dff5e:	2a00      	cmp	r2, #0
102dff60:	d1f9      	bne.n	102dff56 <strcpy+0x2>
102dff62:	4770      	bx	lr

102dff64 <strlen>:
102dff64:	2300      	movs	r3, #0
102dff66:	5cc2      	ldrb	r2, [r0, r3]
102dff68:	3301      	adds	r3, #1
102dff6a:	2a00      	cmp	r2, #0
102dff6c:	d1fb      	bne.n	102dff66 <strlen+0x2>
102dff6e:	1e58      	subs	r0, r3, #1
102dff70:	4770      	bx	lr
102dff72:	46c0      	nop			; (mov r8, r8)

102dff74 <strncmp>:
102dff74:	b570      	push	{r4, r5, r6, lr}
102dff76:	1c06      	adds	r6, r0, #0
102dff78:	2000      	movs	r0, #0
102dff7a:	2a00      	cmp	r2, #0
102dff7c:	d02f      	beq.n	102dffde <strncmp+0x6a>
102dff7e:	1c0b      	adds	r3, r1, #0
102dff80:	4333      	orrs	r3, r6
102dff82:	079c      	lsls	r4, r3, #30
102dff84:	d12e      	bne.n	102dffe4 <strncmp+0x70>
102dff86:	2a03      	cmp	r2, #3
102dff88:	d92c      	bls.n	102dffe4 <strncmp+0x70>
102dff8a:	6834      	ldr	r4, [r6, #0]
102dff8c:	680d      	ldr	r5, [r1, #0]
102dff8e:	42ac      	cmp	r4, r5
102dff90:	d128      	bne.n	102dffe4 <strncmp+0x70>
102dff92:	1f13      	subs	r3, r2, #4
102dff94:	2b00      	cmp	r3, #0
102dff96:	d022      	beq.n	102dffde <strncmp+0x6a>
102dff98:	4d23      	ldr	r5, [pc, #140]	; (102e0028 <strncmp+0xb4>)
102dff9a:	1962      	adds	r2, r4, r5
102dff9c:	43a2      	bics	r2, r4
102dff9e:	1c14      	adds	r4, r2, #0
102dffa0:	4a22      	ldr	r2, [pc, #136]	; (102e002c <strncmp+0xb8>)
102dffa2:	4214      	tst	r4, r2
102dffa4:	d11b      	bne.n	102dffde <strncmp+0x6a>
102dffa6:	1c30      	adds	r0, r6, #0
102dffa8:	1c16      	adds	r6, r2, #0
102dffaa:	e00d      	b.n	102dffc8 <strncmp+0x54>
102dffac:	6842      	ldr	r2, [r0, #4]
102dffae:	6849      	ldr	r1, [r1, #4]
102dffb0:	428a      	cmp	r2, r1
102dffb2:	d130      	bne.n	102e0016 <strncmp+0xa2>
102dffb4:	3b04      	subs	r3, #4
102dffb6:	2b00      	cmp	r3, #0
102dffb8:	d010      	beq.n	102dffdc <strncmp+0x68>
102dffba:	1c29      	adds	r1, r5, #0
102dffbc:	4d1a      	ldr	r5, [pc, #104]	; (102e0028 <strncmp+0xb4>)
102dffbe:	1c20      	adds	r0, r4, #0
102dffc0:	1954      	adds	r4, r2, r5
102dffc2:	4394      	bics	r4, r2
102dffc4:	4234      	tst	r4, r6
102dffc6:	d109      	bne.n	102dffdc <strncmp+0x68>
102dffc8:	1d04      	adds	r4, r0, #4
102dffca:	1d0d      	adds	r5, r1, #4
102dffcc:	2b03      	cmp	r3, #3
102dffce:	d8ed      	bhi.n	102dffac <strncmp+0x38>
102dffd0:	1e5a      	subs	r2, r3, #1
102dffd2:	2b00      	cmp	r3, #0
102dffd4:	d023      	beq.n	102e001e <strncmp+0xaa>
102dffd6:	1c29      	adds	r1, r5, #0
102dffd8:	1c26      	adds	r6, r4, #0
102dffda:	e004      	b.n	102dffe6 <strncmp+0x72>
102dffdc:	2000      	movs	r0, #0
102dffde:	bc70      	pop	{r4, r5, r6}
102dffe0:	bc02      	pop	{r1}
102dffe2:	4708      	bx	r1
102dffe4:	3a01      	subs	r2, #1
102dffe6:	7834      	ldrb	r4, [r6, #0]
102dffe8:	780d      	ldrb	r5, [r1, #0]
102dffea:	42ac      	cmp	r4, r5
102dffec:	d111      	bne.n	102e0012 <strncmp+0x9e>
102dffee:	2a00      	cmp	r2, #0
102dfff0:	d0f4      	beq.n	102dffdc <strncmp+0x68>
102dfff2:	2c00      	cmp	r4, #0
102dfff4:	d0f2      	beq.n	102dffdc <strncmp+0x68>
102dfff6:	1c73      	adds	r3, r6, #1
102dfff8:	3101      	adds	r1, #1
102dfffa:	18b0      	adds	r0, r6, r2
102dfffc:	e005      	b.n	102e000a <strncmp+0x96>
102dfffe:	4283      	cmp	r3, r0
102e0000:	d0ec      	beq.n	102dffdc <strncmp+0x68>
102e0002:	2c00      	cmp	r4, #0
102e0004:	d0ea      	beq.n	102dffdc <strncmp+0x68>
102e0006:	3301      	adds	r3, #1
102e0008:	3101      	adds	r1, #1
102e000a:	781c      	ldrb	r4, [r3, #0]
102e000c:	780d      	ldrb	r5, [r1, #0]
102e000e:	42ac      	cmp	r4, r5
102e0010:	d0f5      	beq.n	102dfffe <strncmp+0x8a>
102e0012:	1b60      	subs	r0, r4, r5
102e0014:	e7e3      	b.n	102dffde <strncmp+0x6a>
102e0016:	1e5a      	subs	r2, r3, #1
102e0018:	1c29      	adds	r1, r5, #0
102e001a:	1c26      	adds	r6, r4, #0
102e001c:	e7e3      	b.n	102dffe6 <strncmp+0x72>
102e001e:	7904      	ldrb	r4, [r0, #4]
102e0020:	790d      	ldrb	r5, [r1, #4]
102e0022:	1b60      	subs	r0, r4, r5
102e0024:	e7db      	b.n	102dffde <strncmp+0x6a>
102e0026:	46c0      	nop			; (mov r8, r8)
102e0028:	fefefeff 	.word	0xfefefeff
102e002c:	80808080 	.word	0x80808080

102e0030 <_strtod_r>:
102e0030:	b5f0      	push	{r4, r5, r6, r7, lr}
102e0032:	4656      	mov	r6, sl
102e0034:	4644      	mov	r4, r8
102e0036:	465f      	mov	r7, fp
102e0038:	464d      	mov	r5, r9
102e003a:	b4f0      	push	{r4, r5, r6, r7}
102e003c:	4688      	mov	r8, r1
102e003e:	4682      	mov	sl, r0
102e0040:	49c0      	ldr	r1, [pc, #768]	; (102e0344 <_strtod_r+0x314>)
102e0042:	48bf      	ldr	r0, [pc, #764]	; (102e0340 <_strtod_r+0x310>)
102e0044:	b09b      	sub	sp, #108	; 0x6c
102e0046:	9006      	str	r0, [sp, #24]
102e0048:	9107      	str	r1, [sp, #28]
102e004a:	4641      	mov	r1, r8
102e004c:	9115      	str	r1, [sp, #84]	; 0x54
102e004e:	49be      	ldr	r1, [pc, #760]	; (102e0348 <_strtod_r+0x318>)
102e0050:	920d      	str	r2, [sp, #52]	; 0x34
102e0052:	4642      	mov	r2, r8
102e0054:	7813      	ldrb	r3, [r2, #0]
102e0056:	2b2d      	cmp	r3, #45	; 0x2d
102e0058:	d97d      	bls.n	102e0156 <_strtod_r+0x126>
102e005a:	2400      	movs	r4, #0
102e005c:	940f      	str	r4, [sp, #60]	; 0x3c
102e005e:	1c17      	adds	r7, r2, #0
102e0060:	2400      	movs	r4, #0
102e0062:	9404      	str	r4, [sp, #16]
102e0064:	2b30      	cmp	r3, #48	; 0x30
102e0066:	d100      	bne.n	102e006a <_strtod_r+0x3a>
102e0068:	e100      	b.n	102e026c <_strtod_r+0x23c>
102e006a:	1c1d      	adds	r5, r3, #0
102e006c:	2b2f      	cmp	r3, #47	; 0x2f
102e006e:	dc01      	bgt.n	102e0074 <_strtod_r+0x44>
102e0070:	f000 fe0e 	bl	102e0c90 <_strtod_r+0xc60>
102e0074:	2b39      	cmp	r3, #57	; 0x39
102e0076:	dd01      	ble.n	102e007c <_strtod_r+0x4c>
102e0078:	f000 fe11 	bl	102e0c9e <_strtod_r+0xc6e>
102e007c:	1c7a      	adds	r2, r7, #1
102e007e:	2000      	movs	r0, #0
102e0080:	2600      	movs	r6, #0
102e0082:	2400      	movs	r4, #0
102e0084:	e00e      	b.n	102e00a4 <_strtod_r+0x74>
102e0086:	00b1      	lsls	r1, r6, #2
102e0088:	198e      	adds	r6, r1, r6
102e008a:	0076      	lsls	r6, r6, #1
102e008c:	18f6      	adds	r6, r6, r3
102e008e:	3e30      	subs	r6, #48	; 0x30
102e0090:	9215      	str	r2, [sp, #84]	; 0x54
102e0092:	7813      	ldrb	r3, [r2, #0]
102e0094:	3401      	adds	r4, #1
102e0096:	1c11      	adds	r1, r2, #0
102e0098:	1c1d      	adds	r5, r3, #0
102e009a:	2b2f      	cmp	r3, #47	; 0x2f
102e009c:	dd13      	ble.n	102e00c6 <_strtod_r+0x96>
102e009e:	3201      	adds	r2, #1
102e00a0:	2b39      	cmp	r3, #57	; 0x39
102e00a2:	dc10      	bgt.n	102e00c6 <_strtod_r+0x96>
102e00a4:	2c08      	cmp	r4, #8
102e00a6:	ddee      	ble.n	102e0086 <_strtod_r+0x56>
102e00a8:	2c0f      	cmp	r4, #15
102e00aa:	dcf1      	bgt.n	102e0090 <_strtod_r+0x60>
102e00ac:	0081      	lsls	r1, r0, #2
102e00ae:	1808      	adds	r0, r1, r0
102e00b0:	0040      	lsls	r0, r0, #1
102e00b2:	9215      	str	r2, [sp, #84]	; 0x54
102e00b4:	18c3      	adds	r3, r0, r3
102e00b6:	1c18      	adds	r0, r3, #0
102e00b8:	7813      	ldrb	r3, [r2, #0]
102e00ba:	3830      	subs	r0, #48	; 0x30
102e00bc:	3401      	adds	r4, #1
102e00be:	1c11      	adds	r1, r2, #0
102e00c0:	1c1d      	adds	r5, r3, #0
102e00c2:	2b2f      	cmp	r3, #47	; 0x2f
102e00c4:	dceb      	bgt.n	102e009e <_strtod_r+0x6e>
102e00c6:	4683      	mov	fp, r0
102e00c8:	4689      	mov	r9, r1
102e00ca:	4650      	mov	r0, sl
102e00cc:	f001 fde2 	bl	102e1c94 <_localeconv_r>
102e00d0:	6800      	ldr	r0, [r0, #0]
102e00d2:	9008      	str	r0, [sp, #32]
102e00d4:	4650      	mov	r0, sl
102e00d6:	f001 fddd 	bl	102e1c94 <_localeconv_r>
102e00da:	6800      	ldr	r0, [r0, #0]
102e00dc:	f7ff ff42 	bl	102dff64 <strlen>
102e00e0:	9908      	ldr	r1, [sp, #32]
102e00e2:	1c02      	adds	r2, r0, #0
102e00e4:	4648      	mov	r0, r9
102e00e6:	f7ff ff45 	bl	102dff74 <strncmp>
102e00ea:	2800      	cmp	r0, #0
102e00ec:	d100      	bne.n	102e00f0 <_strtod_r+0xc0>
102e00ee:	e135      	b.n	102e035c <_strtod_r+0x32c>
102e00f0:	2300      	movs	r3, #0
102e00f2:	9708      	str	r7, [sp, #32]
102e00f4:	4699      	mov	r9, r3
102e00f6:	1c27      	adds	r7, r4, #0
102e00f8:	2000      	movs	r0, #0
102e00fa:	2220      	movs	r2, #32
102e00fc:	1c29      	adds	r1, r5, #0
102e00fe:	4391      	bics	r1, r2
102e0100:	2945      	cmp	r1, #69	; 0x45
102e0102:	d056      	beq.n	102e01b2 <_strtod_r+0x182>
102e0104:	2100      	movs	r1, #0
102e0106:	2f00      	cmp	r7, #0
102e0108:	d000      	beq.n	102e010c <_strtod_r+0xdc>
102e010a:	e0c3      	b.n	102e0294 <_strtod_r+0x264>
102e010c:	9c04      	ldr	r4, [sp, #16]
102e010e:	4323      	orrs	r3, r4
102e0110:	d000      	beq.n	102e0114 <_strtod_r+0xe4>
102e0112:	e10e      	b.n	102e0332 <_strtod_r+0x302>
102e0114:	2800      	cmp	r0, #0
102e0116:	d119      	bne.n	102e014c <_strtod_r+0x11c>
102e0118:	2d4e      	cmp	r5, #78	; 0x4e
102e011a:	d101      	bne.n	102e0120 <_strtod_r+0xf0>
102e011c:	f000 fdd5 	bl	102e0cca <_strtod_r+0xc9a>
102e0120:	dd01      	ble.n	102e0126 <_strtod_r+0xf6>
102e0122:	f000 fdca 	bl	102e0cba <_strtod_r+0xc8a>
102e0126:	2d49      	cmp	r5, #73	; 0x49
102e0128:	d110      	bne.n	102e014c <_strtod_r+0x11c>
102e012a:	9b15      	ldr	r3, [sp, #84]	; 0x54
102e012c:	4987      	ldr	r1, [pc, #540]	; (102e034c <_strtod_r+0x31c>)
102e012e:	7808      	ldrb	r0, [r1, #0]
102e0130:	3101      	adds	r1, #1
102e0132:	2800      	cmp	r0, #0
102e0134:	d101      	bne.n	102e013a <_strtod_r+0x10a>
102e0136:	f000 fe48 	bl	102e0dca <_strtod_r+0xd9a>
102e013a:	3301      	adds	r3, #1
102e013c:	781a      	ldrb	r2, [r3, #0]
102e013e:	2a40      	cmp	r2, #64	; 0x40
102e0140:	dd02      	ble.n	102e0148 <_strtod_r+0x118>
102e0142:	2a5a      	cmp	r2, #90	; 0x5a
102e0144:	dc00      	bgt.n	102e0148 <_strtod_r+0x118>
102e0146:	3220      	adds	r2, #32
102e0148:	4282      	cmp	r2, r0
102e014a:	d0f0      	beq.n	102e012e <_strtod_r+0xfe>
102e014c:	9c06      	ldr	r4, [sp, #24]
102e014e:	9807      	ldr	r0, [sp, #28]
102e0150:	9404      	str	r4, [sp, #16]
102e0152:	4681      	mov	r9, r0
102e0154:	e00d      	b.n	102e0172 <_strtod_r+0x142>
102e0156:	0098      	lsls	r0, r3, #2
102e0158:	5808      	ldr	r0, [r1, r0]
102e015a:	4687      	mov	pc, r0
102e015c:	2401      	movs	r4, #1
102e015e:	940f      	str	r4, [sp, #60]	; 0x3c
102e0160:	1c57      	adds	r7, r2, #1
102e0162:	9715      	str	r7, [sp, #84]	; 0x54
102e0164:	7853      	ldrb	r3, [r2, #1]
102e0166:	2b00      	cmp	r3, #0
102e0168:	d000      	beq.n	102e016c <_strtod_r+0x13c>
102e016a:	e779      	b.n	102e0060 <_strtod_r+0x30>
102e016c:	2400      	movs	r4, #0
102e016e:	9404      	str	r4, [sp, #16]
102e0170:	46a1      	mov	r9, r4
102e0172:	4640      	mov	r0, r8
102e0174:	2400      	movs	r4, #0
102e0176:	9015      	str	r0, [sp, #84]	; 0x54
102e0178:	940f      	str	r4, [sp, #60]	; 0x3c
102e017a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
102e017c:	2c00      	cmp	r4, #0
102e017e:	d001      	beq.n	102e0184 <_strtod_r+0x154>
102e0180:	9815      	ldr	r0, [sp, #84]	; 0x54
102e0182:	6020      	str	r0, [r4, #0]
102e0184:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
102e0186:	2c00      	cmp	r4, #0
102e0188:	d002      	beq.n	102e0190 <_strtod_r+0x160>
102e018a:	2080      	movs	r0, #128	; 0x80
102e018c:	0600      	lsls	r0, r0, #24
102e018e:	4481      	add	r9, r0
102e0190:	9804      	ldr	r0, [sp, #16]
102e0192:	4649      	mov	r1, r9
102e0194:	b01b      	add	sp, #108	; 0x6c
102e0196:	bc3c      	pop	{r2, r3, r4, r5}
102e0198:	4690      	mov	r8, r2
102e019a:	4699      	mov	r9, r3
102e019c:	46a2      	mov	sl, r4
102e019e:	46ab      	mov	fp, r5
102e01a0:	bcf0      	pop	{r4, r5, r6, r7}
102e01a2:	bc04      	pop	{r2}
102e01a4:	4710      	bx	r2
102e01a6:	2400      	movs	r4, #0
102e01a8:	940f      	str	r4, [sp, #60]	; 0x3c
102e01aa:	e7d9      	b.n	102e0160 <_strtod_r+0x130>
102e01ac:	3201      	adds	r2, #1
102e01ae:	9215      	str	r2, [sp, #84]	; 0x54
102e01b0:	e750      	b.n	102e0054 <_strtod_r+0x24>
102e01b2:	1c3a      	adds	r2, r7, #0
102e01b4:	9904      	ldr	r1, [sp, #16]
102e01b6:	431a      	orrs	r2, r3
102e01b8:	430a      	orrs	r2, r1
102e01ba:	d0c7      	beq.n	102e014c <_strtod_r+0x11c>
102e01bc:	9915      	ldr	r1, [sp, #84]	; 0x54
102e01be:	1c0a      	adds	r2, r1, #0
102e01c0:	3201      	adds	r2, #1
102e01c2:	9215      	str	r2, [sp, #84]	; 0x54
102e01c4:	784d      	ldrb	r5, [r1, #1]
102e01c6:	4688      	mov	r8, r1
102e01c8:	2d2b      	cmp	r5, #43	; 0x2b
102e01ca:	d101      	bne.n	102e01d0 <_strtod_r+0x1a0>
102e01cc:	f000 fc01 	bl	102e09d2 <_strtod_r+0x9a2>
102e01d0:	2d2d      	cmp	r5, #45	; 0x2d
102e01d2:	d100      	bne.n	102e01d6 <_strtod_r+0x1a6>
102e01d4:	e2be      	b.n	102e0754 <_strtod_r+0x724>
102e01d6:	2200      	movs	r2, #0
102e01d8:	9209      	str	r2, [sp, #36]	; 0x24
102e01da:	1c2a      	adds	r2, r5, #0
102e01dc:	3a30      	subs	r2, #48	; 0x30
102e01de:	2a09      	cmp	r2, #9
102e01e0:	d900      	bls.n	102e01e4 <_strtod_r+0x1b4>
102e01e2:	e3a8      	b.n	102e0936 <_strtod_r+0x906>
102e01e4:	2d30      	cmp	r5, #48	; 0x30
102e01e6:	d106      	bne.n	102e01f6 <_strtod_r+0x1c6>
102e01e8:	9a15      	ldr	r2, [sp, #84]	; 0x54
102e01ea:	3201      	adds	r2, #1
102e01ec:	9215      	str	r2, [sp, #84]	; 0x54
102e01ee:	7815      	ldrb	r5, [r2, #0]
102e01f0:	3201      	adds	r2, #1
102e01f2:	2d30      	cmp	r5, #48	; 0x30
102e01f4:	d0fa      	beq.n	102e01ec <_strtod_r+0x1bc>
102e01f6:	1c2a      	adds	r2, r5, #0
102e01f8:	3a31      	subs	r2, #49	; 0x31
102e01fa:	2100      	movs	r1, #0
102e01fc:	2a08      	cmp	r2, #8
102e01fe:	d900      	bls.n	102e0202 <_strtod_r+0x1d2>
102e0200:	e781      	b.n	102e0106 <_strtod_r+0xd6>
102e0202:	9915      	ldr	r1, [sp, #84]	; 0x54
102e0204:	9102      	str	r1, [sp, #8]
102e0206:	3101      	adds	r1, #1
102e0208:	9115      	str	r1, [sp, #84]	; 0x54
102e020a:	9a02      	ldr	r2, [sp, #8]
102e020c:	3d30      	subs	r5, #48	; 0x30
102e020e:	950a      	str	r5, [sp, #40]	; 0x28
102e0210:	7855      	ldrb	r5, [r2, #1]
102e0212:	468c      	mov	ip, r1
102e0214:	2d2f      	cmp	r5, #47	; 0x2f
102e0216:	dd17      	ble.n	102e0248 <_strtod_r+0x218>
102e0218:	2d39      	cmp	r5, #57	; 0x39
102e021a:	dc15      	bgt.n	102e0248 <_strtod_r+0x218>
102e021c:	3202      	adds	r2, #2
102e021e:	469c      	mov	ip, r3
102e0220:	990a      	ldr	r1, [sp, #40]	; 0x28
102e0222:	e002      	b.n	102e022a <_strtod_r+0x1fa>
102e0224:	3201      	adds	r2, #1
102e0226:	2d39      	cmp	r5, #57	; 0x39
102e0228:	dc0a      	bgt.n	102e0240 <_strtod_r+0x210>
102e022a:	008b      	lsls	r3, r1, #2
102e022c:	1859      	adds	r1, r3, r1
102e022e:	0049      	lsls	r1, r1, #1
102e0230:	9215      	str	r2, [sp, #84]	; 0x54
102e0232:	194d      	adds	r5, r1, r5
102e0234:	1c29      	adds	r1, r5, #0
102e0236:	7815      	ldrb	r5, [r2, #0]
102e0238:	3930      	subs	r1, #48	; 0x30
102e023a:	1c13      	adds	r3, r2, #0
102e023c:	2d2f      	cmp	r5, #47	; 0x2f
102e023e:	dcf1      	bgt.n	102e0224 <_strtod_r+0x1f4>
102e0240:	1c1a      	adds	r2, r3, #0
102e0242:	910a      	str	r1, [sp, #40]	; 0x28
102e0244:	4663      	mov	r3, ip
102e0246:	4694      	mov	ip, r2
102e0248:	9a02      	ldr	r2, [sp, #8]
102e024a:	4661      	mov	r1, ip
102e024c:	1a89      	subs	r1, r1, r2
102e024e:	2908      	cmp	r1, #8
102e0250:	dd01      	ble.n	102e0256 <_strtod_r+0x226>
102e0252:	f000 fd89 	bl	102e0d68 <_strtod_r+0xd38>
102e0256:	990a      	ldr	r1, [sp, #40]	; 0x28
102e0258:	4a3d      	ldr	r2, [pc, #244]	; (102e0350 <_strtod_r+0x320>)
102e025a:	4291      	cmp	r1, r2
102e025c:	dd00      	ble.n	102e0260 <_strtod_r+0x230>
102e025e:	1c11      	adds	r1, r2, #0
102e0260:	9a09      	ldr	r2, [sp, #36]	; 0x24
102e0262:	2a00      	cmp	r2, #0
102e0264:	d100      	bne.n	102e0268 <_strtod_r+0x238>
102e0266:	e74e      	b.n	102e0106 <_strtod_r+0xd6>
102e0268:	4249      	negs	r1, r1
102e026a:	e74c      	b.n	102e0106 <_strtod_r+0xd6>
102e026c:	787b      	ldrb	r3, [r7, #1]
102e026e:	2b58      	cmp	r3, #88	; 0x58
102e0270:	d100      	bne.n	102e0274 <_strtod_r+0x244>
102e0272:	e365      	b.n	102e0940 <_strtod_r+0x910>
102e0274:	1c7a      	adds	r2, r7, #1
102e0276:	2b78      	cmp	r3, #120	; 0x78
102e0278:	d100      	bne.n	102e027c <_strtod_r+0x24c>
102e027a:	e361      	b.n	102e0940 <_strtod_r+0x910>
102e027c:	9215      	str	r2, [sp, #84]	; 0x54
102e027e:	1c17      	adds	r7, r2, #0
102e0280:	783b      	ldrb	r3, [r7, #0]
102e0282:	3201      	adds	r2, #1
102e0284:	2b30      	cmp	r3, #48	; 0x30
102e0286:	d0f9      	beq.n	102e027c <_strtod_r+0x24c>
102e0288:	2b00      	cmp	r3, #0
102e028a:	d100      	bne.n	102e028e <_strtod_r+0x25e>
102e028c:	e1c2      	b.n	102e0614 <_strtod_r+0x5e4>
102e028e:	2401      	movs	r4, #1
102e0290:	9404      	str	r4, [sp, #16]
102e0292:	e6ea      	b.n	102e006a <_strtod_r+0x3a>
102e0294:	464a      	mov	r2, r9
102e0296:	1a8a      	subs	r2, r1, r2
102e0298:	9210      	str	r2, [sp, #64]	; 0x40
102e029a:	9702      	str	r7, [sp, #8]
102e029c:	2c00      	cmp	r4, #0
102e029e:	d000      	beq.n	102e02a2 <_strtod_r+0x272>
102e02a0:	9402      	str	r4, [sp, #8]
102e02a2:	46b8      	mov	r8, r7
102e02a4:	2f10      	cmp	r7, #16
102e02a6:	dd01      	ble.n	102e02ac <_strtod_r+0x27c>
102e02a8:	2310      	movs	r3, #16
102e02aa:	4698      	mov	r8, r3
102e02ac:	1c30      	adds	r0, r6, #0
102e02ae:	f003 fe45 	bl	102e3f3c <____aeabi_ui2d_from_thumb>
102e02b2:	4644      	mov	r4, r8
102e02b4:	9006      	str	r0, [sp, #24]
102e02b6:	9107      	str	r1, [sp, #28]
102e02b8:	2c09      	cmp	r4, #9
102e02ba:	dd15      	ble.n	102e02e8 <_strtod_r+0x2b8>
102e02bc:	4643      	mov	r3, r8
102e02be:	4a25      	ldr	r2, [pc, #148]	; (102e0354 <_strtod_r+0x324>)
102e02c0:	3b09      	subs	r3, #9
102e02c2:	00db      	lsls	r3, r3, #3
102e02c4:	18d3      	adds	r3, r2, r3
102e02c6:	681a      	ldr	r2, [r3, #0]
102e02c8:	685b      	ldr	r3, [r3, #4]
102e02ca:	f003 fe3b 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e02ce:	1c04      	adds	r4, r0, #0
102e02d0:	4658      	mov	r0, fp
102e02d2:	1c0d      	adds	r5, r1, #0
102e02d4:	f003 fe32 	bl	102e3f3c <____aeabi_ui2d_from_thumb>
102e02d8:	1c02      	adds	r2, r0, #0
102e02da:	1c0b      	adds	r3, r1, #0
102e02dc:	1c20      	adds	r0, r4, #0
102e02de:	1c29      	adds	r1, r5, #0
102e02e0:	f003 fe28 	bl	102e3f34 <____aeabi_dadd_from_thumb>
102e02e4:	9006      	str	r0, [sp, #24]
102e02e6:	9107      	str	r1, [sp, #28]
102e02e8:	2f0f      	cmp	r7, #15
102e02ea:	dc5d      	bgt.n	102e03a8 <_strtod_r+0x378>
102e02ec:	9c10      	ldr	r4, [sp, #64]	; 0x40
102e02ee:	2c00      	cmp	r4, #0
102e02f0:	d01f      	beq.n	102e0332 <_strtod_r+0x302>
102e02f2:	9c10      	ldr	r4, [sp, #64]	; 0x40
102e02f4:	2c00      	cmp	r4, #0
102e02f6:	dc01      	bgt.n	102e02fc <_strtod_r+0x2cc>
102e02f8:	f000 fd39 	bl	102e0d6e <_strtod_r+0xd3e>
102e02fc:	2c16      	cmp	r4, #22
102e02fe:	dd01      	ble.n	102e0304 <_strtod_r+0x2d4>
102e0300:	f000 fcf6 	bl	102e0cf0 <_strtod_r+0xcc0>
102e0304:	4a13      	ldr	r2, [pc, #76]	; (102e0354 <_strtod_r+0x324>)
102e0306:	00e3      	lsls	r3, r4, #3
102e0308:	18d3      	adds	r3, r2, r3
102e030a:	6818      	ldr	r0, [r3, #0]
102e030c:	6859      	ldr	r1, [r3, #4]
102e030e:	9a06      	ldr	r2, [sp, #24]
102e0310:	9b07      	ldr	r3, [sp, #28]
102e0312:	f003 fe17 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e0316:	9004      	str	r0, [sp, #16]
102e0318:	4689      	mov	r9, r1
102e031a:	e72e      	b.n	102e017a <_strtod_r+0x14a>
102e031c:	1c53      	adds	r3, r2, #1
102e031e:	9315      	str	r3, [sp, #84]	; 0x54
102e0320:	7853      	ldrb	r3, [r2, #1]
102e0322:	2b28      	cmp	r3, #40	; 0x28
102e0324:	d101      	bne.n	102e032a <_strtod_r+0x2fa>
102e0326:	f000 fd86 	bl	102e0e36 <_strtod_r+0xe06>
102e032a:	4a0b      	ldr	r2, [pc, #44]	; (102e0358 <_strtod_r+0x328>)
102e032c:	2300      	movs	r3, #0
102e032e:	9207      	str	r2, [sp, #28]
102e0330:	9306      	str	r3, [sp, #24]
102e0332:	9c06      	ldr	r4, [sp, #24]
102e0334:	9807      	ldr	r0, [sp, #28]
102e0336:	9404      	str	r4, [sp, #16]
102e0338:	4681      	mov	r9, r0
102e033a:	e71e      	b.n	102e017a <_strtod_r+0x14a>
102e033c:	46c0      	nop			; (mov r8, r8)
102e033e:	46c0      	nop			; (mov r8, r8)
	...
102e0348:	102edbe0 	.word	0x102edbe0
102e034c:	102f033c 	.word	0x102f033c
102e0350:	00004e1f 	.word	0x00004e1f
102e0354:	102edce8 	.word	0x102edce8
102e0358:	fff80000 	.word	0xfff80000
102e035c:	4650      	mov	r0, sl
102e035e:	9d15      	ldr	r5, [sp, #84]	; 0x54
102e0360:	f001 fc98 	bl	102e1c94 <_localeconv_r>
102e0364:	6800      	ldr	r0, [r0, #0]
102e0366:	f7ff fdfd 	bl	102dff64 <strlen>
102e036a:	1828      	adds	r0, r5, r0
102e036c:	9015      	str	r0, [sp, #84]	; 0x54
102e036e:	7805      	ldrb	r5, [r0, #0]
102e0370:	2c00      	cmp	r4, #0
102e0372:	d000      	beq.n	102e0376 <_strtod_r+0x346>
102e0374:	e152      	b.n	102e061c <_strtod_r+0x5ec>
102e0376:	2d30      	cmp	r5, #48	; 0x30
102e0378:	d001      	beq.n	102e037e <_strtod_r+0x34e>
102e037a:	f000 fd18 	bl	102e0dae <_strtod_r+0xd7e>
102e037e:	1c42      	adds	r2, r0, #1
102e0380:	9215      	str	r2, [sp, #84]	; 0x54
102e0382:	7815      	ldrb	r5, [r2, #0]
102e0384:	1a13      	subs	r3, r2, r0
102e0386:	3201      	adds	r2, #1
102e0388:	2d30      	cmp	r5, #48	; 0x30
102e038a:	d0f9      	beq.n	102e0380 <_strtod_r+0x350>
102e038c:	1c2a      	adds	r2, r5, #0
102e038e:	3a31      	subs	r2, #49	; 0x31
102e0390:	2a08      	cmp	r2, #8
102e0392:	d900      	bls.n	102e0396 <_strtod_r+0x366>
102e0394:	e16f      	b.n	102e0676 <_strtod_r+0x646>
102e0396:	9815      	ldr	r0, [sp, #84]	; 0x54
102e0398:	3d30      	subs	r5, #48	; 0x30
102e039a:	4699      	mov	r9, r3
102e039c:	9008      	str	r0, [sp, #32]
102e039e:	9009      	str	r0, [sp, #36]	; 0x24
102e03a0:	2700      	movs	r7, #0
102e03a2:	2301      	movs	r3, #1
102e03a4:	46ac      	mov	ip, r5
102e03a6:	e148      	b.n	102e063a <_strtod_r+0x60a>
102e03a8:	4640      	mov	r0, r8
102e03aa:	9c10      	ldr	r4, [sp, #64]	; 0x40
102e03ac:	1a3d      	subs	r5, r7, r0
102e03ae:	1965      	adds	r5, r4, r5
102e03b0:	2d00      	cmp	r5, #0
102e03b2:	dc01      	bgt.n	102e03b8 <_strtod_r+0x388>
102e03b4:	f000 fc08 	bl	102e0bc8 <_strtod_r+0xb98>
102e03b8:	230f      	movs	r3, #15
102e03ba:	402b      	ands	r3, r5
102e03bc:	d00a      	beq.n	102e03d4 <_strtod_r+0x3a4>
102e03be:	4ada      	ldr	r2, [pc, #872]	; (102e0728 <_strtod_r+0x6f8>)
102e03c0:	00db      	lsls	r3, r3, #3
102e03c2:	18d3      	adds	r3, r2, r3
102e03c4:	6818      	ldr	r0, [r3, #0]
102e03c6:	6859      	ldr	r1, [r3, #4]
102e03c8:	9a06      	ldr	r2, [sp, #24]
102e03ca:	9b07      	ldr	r3, [sp, #28]
102e03cc:	f003 fdba 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e03d0:	9006      	str	r0, [sp, #24]
102e03d2:	9107      	str	r1, [sp, #28]
102e03d4:	230f      	movs	r3, #15
102e03d6:	439d      	bics	r5, r3
102e03d8:	d000      	beq.n	102e03dc <_strtod_r+0x3ac>
102e03da:	e151      	b.n	102e0680 <_strtod_r+0x650>
102e03dc:	9c06      	ldr	r4, [sp, #24]
102e03de:	9807      	ldr	r0, [sp, #28]
102e03e0:	9404      	str	r4, [sp, #16]
102e03e2:	2400      	movs	r4, #0
102e03e4:	9409      	str	r4, [sp, #36]	; 0x24
102e03e6:	4681      	mov	r9, r0
102e03e8:	9a02      	ldr	r2, [sp, #8]
102e03ea:	1c3b      	adds	r3, r7, #0
102e03ec:	9600      	str	r6, [sp, #0]
102e03ee:	4650      	mov	r0, sl
102e03f0:	9908      	ldr	r1, [sp, #32]
102e03f2:	f001 ffdd 	bl	102e23b0 <__s2b>
102e03f6:	9c10      	ldr	r4, [sp, #64]	; 0x40
102e03f8:	17e3      	asrs	r3, r4, #31
102e03fa:	4262      	negs	r2, r4
102e03fc:	1c04      	adds	r4, r0, #0
102e03fe:	340c      	adds	r4, #12
102e0400:	4013      	ands	r3, r2
102e0402:	9411      	str	r4, [sp, #68]	; 0x44
102e0404:	464c      	mov	r4, r9
102e0406:	930b      	str	r3, [sp, #44]	; 0x2c
102e0408:	4683      	mov	fp, r0
102e040a:	9408      	str	r4, [sp, #32]
102e040c:	e0ce      	b.n	102e05ac <_strtod_r+0x57c>
102e040e:	48c7      	ldr	r0, [pc, #796]	; (102e072c <_strtod_r+0x6fc>)
102e0410:	180a      	adds	r2, r1, r0
102e0412:	9909      	ldr	r1, [sp, #36]	; 0x24
102e0414:	189c      	adds	r4, r3, r2
102e0416:	18ba      	adds	r2, r7, r2
102e0418:	1855      	adds	r5, r2, r1
102e041a:	1c27      	adds	r7, r4, #0
102e041c:	429c      	cmp	r4, r3
102e041e:	dd00      	ble.n	102e0422 <_strtod_r+0x3f2>
102e0420:	1c1f      	adds	r7, r3, #0
102e0422:	42af      	cmp	r7, r5
102e0424:	dd00      	ble.n	102e0428 <_strtod_r+0x3f8>
102e0426:	1c2f      	adds	r7, r5, #0
102e0428:	2f00      	cmp	r7, #0
102e042a:	dc00      	bgt.n	102e042e <_strtod_r+0x3fe>
102e042c:	e1e7      	b.n	102e07fe <_strtod_r+0x7ce>
102e042e:	1be4      	subs	r4, r4, r7
102e0430:	1bed      	subs	r5, r5, r7
102e0432:	1bdf      	subs	r7, r3, r7
102e0434:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
102e0436:	2a00      	cmp	r2, #0
102e0438:	d010      	beq.n	102e045c <_strtod_r+0x42c>
102e043a:	4649      	mov	r1, r9
102e043c:	4650      	mov	r0, sl
102e043e:	f002 f90f 	bl	102e2660 <__pow5mult>
102e0442:	4681      	mov	r9, r0
102e0444:	4649      	mov	r1, r9
102e0446:	9a16      	ldr	r2, [sp, #88]	; 0x58
102e0448:	4650      	mov	r0, sl
102e044a:	f002 f857 	bl	102e24fc <__multiply>
102e044e:	9916      	ldr	r1, [sp, #88]	; 0x58
102e0450:	9002      	str	r0, [sp, #8]
102e0452:	4650      	mov	r0, sl
102e0454:	f001 ff4a 	bl	102e22ec <_Bfree>
102e0458:	9b02      	ldr	r3, [sp, #8]
102e045a:	9316      	str	r3, [sp, #88]	; 0x58
102e045c:	2c00      	cmp	r4, #0
102e045e:	dd05      	ble.n	102e046c <_strtod_r+0x43c>
102e0460:	4650      	mov	r0, sl
102e0462:	9916      	ldr	r1, [sp, #88]	; 0x58
102e0464:	1c22      	adds	r2, r4, #0
102e0466:	f002 f953 	bl	102e2710 <__lshift>
102e046a:	9016      	str	r0, [sp, #88]	; 0x58
102e046c:	2e00      	cmp	r6, #0
102e046e:	d005      	beq.n	102e047c <_strtod_r+0x44c>
102e0470:	4641      	mov	r1, r8
102e0472:	4650      	mov	r0, sl
102e0474:	1c32      	adds	r2, r6, #0
102e0476:	f002 f8f3 	bl	102e2660 <__pow5mult>
102e047a:	4680      	mov	r8, r0
102e047c:	2d00      	cmp	r5, #0
102e047e:	dd05      	ble.n	102e048c <_strtod_r+0x45c>
102e0480:	4641      	mov	r1, r8
102e0482:	4650      	mov	r0, sl
102e0484:	1c2a      	adds	r2, r5, #0
102e0486:	f002 f943 	bl	102e2710 <__lshift>
102e048a:	4680      	mov	r8, r0
102e048c:	2f00      	cmp	r7, #0
102e048e:	dd05      	ble.n	102e049c <_strtod_r+0x46c>
102e0490:	4649      	mov	r1, r9
102e0492:	4650      	mov	r0, sl
102e0494:	1c3a      	adds	r2, r7, #0
102e0496:	f002 f93b 	bl	102e2710 <__lshift>
102e049a:	4681      	mov	r9, r0
102e049c:	9916      	ldr	r1, [sp, #88]	; 0x58
102e049e:	4650      	mov	r0, sl
102e04a0:	4642      	mov	r2, r8
102e04a2:	f002 f9bb 	bl	102e281c <__mdiff>
102e04a6:	2300      	movs	r3, #0
102e04a8:	68c4      	ldr	r4, [r0, #12]
102e04aa:	4649      	mov	r1, r9
102e04ac:	60c3      	str	r3, [r0, #12]
102e04ae:	1c06      	adds	r6, r0, #0
102e04b0:	940c      	str	r4, [sp, #48]	; 0x30
102e04b2:	f002 f995 	bl	102e27e0 <__mcmp>
102e04b6:	2800      	cmp	r0, #0
102e04b8:	da00      	bge.n	102e04bc <_strtod_r+0x48c>
102e04ba:	e29f      	b.n	102e09fc <_strtod_r+0x9cc>
102e04bc:	d100      	bne.n	102e04c0 <_strtod_r+0x490>
102e04be:	e347      	b.n	102e0b50 <_strtod_r+0xb20>
102e04c0:	1c30      	adds	r0, r6, #0
102e04c2:	4649      	mov	r1, r9
102e04c4:	f002 faf4 	bl	102e2ab0 <__ratio>
102e04c8:	4b92      	ldr	r3, [pc, #584]	; (102e0714 <_strtod_r+0x6e4>)
102e04ca:	4a91      	ldr	r2, [pc, #580]	; (102e0710 <_strtod_r+0x6e0>)
102e04cc:	1c04      	adds	r4, r0, #0
102e04ce:	1c0d      	adds	r5, r1, #0
102e04d0:	f003 fd08 	bl	102e3ee4 <____aeabi_dcmple_from_thumb>
102e04d4:	2800      	cmp	r0, #0
102e04d6:	d100      	bne.n	102e04da <_strtod_r+0x4aa>
102e04d8:	e144      	b.n	102e0764 <_strtod_r+0x734>
102e04da:	9a0c      	ldr	r2, [sp, #48]	; 0x30
102e04dc:	2a00      	cmp	r2, #0
102e04de:	d100      	bne.n	102e04e2 <_strtod_r+0x4b2>
102e04e0:	e192      	b.n	102e0808 <_strtod_r+0x7d8>
102e04e2:	9b07      	ldr	r3, [sp, #28]
102e04e4:	4992      	ldr	r1, [pc, #584]	; (102e0730 <_strtod_r+0x700>)
102e04e6:	2000      	movs	r0, #0
102e04e8:	4c8b      	ldr	r4, [pc, #556]	; (102e0718 <_strtod_r+0x6e8>)
102e04ea:	4d8c      	ldr	r5, [pc, #560]	; (102e071c <_strtod_r+0x6ec>)
102e04ec:	930e      	str	r3, [sp, #56]	; 0x38
102e04ee:	900a      	str	r0, [sp, #40]	; 0x28
102e04f0:	9102      	str	r1, [sp, #8]
102e04f2:	9f0e      	ldr	r7, [sp, #56]	; 0x38
102e04f4:	4a8f      	ldr	r2, [pc, #572]	; (102e0734 <_strtod_r+0x704>)
102e04f6:	4b90      	ldr	r3, [pc, #576]	; (102e0738 <_strtod_r+0x708>)
102e04f8:	4017      	ands	r7, r2
102e04fa:	429f      	cmp	r7, r3
102e04fc:	d100      	bne.n	102e0500 <_strtod_r+0x4d0>
102e04fe:	e14b      	b.n	102e0798 <_strtod_r+0x768>
102e0500:	23d4      	movs	r3, #212	; 0xd4
102e0502:	04db      	lsls	r3, r3, #19
102e0504:	42bb      	cmp	r3, r7
102e0506:	d322      	bcc.n	102e054e <_strtod_r+0x51e>
102e0508:	9a09      	ldr	r2, [sp, #36]	; 0x24
102e050a:	2a00      	cmp	r2, #0
102e050c:	d01f      	beq.n	102e054e <_strtod_r+0x51e>
102e050e:	980a      	ldr	r0, [sp, #40]	; 0x28
102e0510:	9902      	ldr	r1, [sp, #8]
102e0512:	4a83      	ldr	r2, [pc, #524]	; (102e0720 <_strtod_r+0x6f0>)
102e0514:	4b83      	ldr	r3, [pc, #524]	; (102e0724 <_strtod_r+0x6f4>)
102e0516:	f003 fce5 	bl	102e3ee4 <____aeabi_dcmple_from_thumb>
102e051a:	2800      	cmp	r0, #0
102e051c:	d013      	beq.n	102e0546 <_strtod_r+0x516>
102e051e:	980a      	ldr	r0, [sp, #40]	; 0x28
102e0520:	9902      	ldr	r1, [sp, #8]
102e0522:	f003 fcfb 	bl	102e3f1c <____aeabi_d2uiz_from_thumb>
102e0526:	2800      	cmp	r0, #0
102e0528:	d100      	bne.n	102e052c <_strtod_r+0x4fc>
102e052a:	e1f7      	b.n	102e091c <_strtod_r+0x8ec>
102e052c:	f003 fd06 	bl	102e3f3c <____aeabi_ui2d_from_thumb>
102e0530:	900a      	str	r0, [sp, #40]	; 0x28
102e0532:	9102      	str	r1, [sp, #8]
102e0534:	9c0c      	ldr	r4, [sp, #48]	; 0x30
102e0536:	9b02      	ldr	r3, [sp, #8]
102e0538:	2c00      	cmp	r4, #0
102e053a:	d102      	bne.n	102e0542 <_strtod_r+0x512>
102e053c:	2080      	movs	r0, #128	; 0x80
102e053e:	0600      	lsls	r0, r0, #24
102e0540:	181b      	adds	r3, r3, r0
102e0542:	9c0a      	ldr	r4, [sp, #40]	; 0x28
102e0544:	1c1d      	adds	r5, r3, #0
102e0546:	21d6      	movs	r1, #214	; 0xd6
102e0548:	04c9      	lsls	r1, r1, #19
102e054a:	186b      	adds	r3, r5, r1
102e054c:	1bdd      	subs	r5, r3, r7
102e054e:	9804      	ldr	r0, [sp, #16]
102e0550:	9908      	ldr	r1, [sp, #32]
102e0552:	f002 f9db 	bl	102e290c <__ulp>
102e0556:	1c02      	adds	r2, r0, #0
102e0558:	1c0b      	adds	r3, r1, #0
102e055a:	1c20      	adds	r0, r4, #0
102e055c:	1c29      	adds	r1, r5, #0
102e055e:	f003 fcf1 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e0562:	1c02      	adds	r2, r0, #0
102e0564:	1c0b      	adds	r3, r1, #0
102e0566:	9804      	ldr	r0, [sp, #16]
102e0568:	9908      	ldr	r1, [sp, #32]
102e056a:	f003 fce3 	bl	102e3f34 <____aeabi_dadd_from_thumb>
102e056e:	1c02      	adds	r2, r0, #0
102e0570:	1c0b      	adds	r3, r1, #0
102e0572:	9206      	str	r2, [sp, #24]
102e0574:	9307      	str	r3, [sp, #28]
102e0576:	9004      	str	r0, [sp, #16]
102e0578:	9108      	str	r1, [sp, #32]
102e057a:	9c07      	ldr	r4, [sp, #28]
102e057c:	9a09      	ldr	r2, [sp, #36]	; 0x24
102e057e:	2a00      	cmp	r2, #0
102e0580:	d104      	bne.n	102e058c <_strtod_r+0x55c>
102e0582:	4b6c      	ldr	r3, [pc, #432]	; (102e0734 <_strtod_r+0x704>)
102e0584:	4023      	ands	r3, r4
102e0586:	429f      	cmp	r7, r3
102e0588:	d100      	bne.n	102e058c <_strtod_r+0x55c>
102e058a:	e163      	b.n	102e0854 <_strtod_r+0x824>
102e058c:	4650      	mov	r0, sl
102e058e:	9916      	ldr	r1, [sp, #88]	; 0x58
102e0590:	f001 feac 	bl	102e22ec <_Bfree>
102e0594:	4650      	mov	r0, sl
102e0596:	4641      	mov	r1, r8
102e0598:	f001 fea8 	bl	102e22ec <_Bfree>
102e059c:	4650      	mov	r0, sl
102e059e:	4649      	mov	r1, r9
102e05a0:	f001 fea4 	bl	102e22ec <_Bfree>
102e05a4:	4650      	mov	r0, sl
102e05a6:	1c31      	adds	r1, r6, #0
102e05a8:	f001 fea0 	bl	102e22ec <_Bfree>
102e05ac:	465a      	mov	r2, fp
102e05ae:	6851      	ldr	r1, [r2, #4]
102e05b0:	4650      	mov	r0, sl
102e05b2:	f001 fe71 	bl	102e2298 <_Balloc>
102e05b6:	465b      	mov	r3, fp
102e05b8:	691a      	ldr	r2, [r3, #16]
102e05ba:	3202      	adds	r2, #2
102e05bc:	9911      	ldr	r1, [sp, #68]	; 0x44
102e05be:	0092      	lsls	r2, r2, #2
102e05c0:	4680      	mov	r8, r0
102e05c2:	300c      	adds	r0, #12
102e05c4:	f7ff f980 	bl	102df8c8 <memcpy>
102e05c8:	ac14      	add	r4, sp, #80	; 0x50
102e05ca:	a817      	add	r0, sp, #92	; 0x5c
102e05cc:	9400      	str	r4, [sp, #0]
102e05ce:	9001      	str	r0, [sp, #4]
102e05d0:	9a04      	ldr	r2, [sp, #16]
102e05d2:	9b08      	ldr	r3, [sp, #32]
102e05d4:	4650      	mov	r0, sl
102e05d6:	f002 fa0f 	bl	102e29f8 <__d2b>
102e05da:	2101      	movs	r1, #1
102e05dc:	9016      	str	r0, [sp, #88]	; 0x58
102e05de:	4650      	mov	r0, sl
102e05e0:	f001 ff80 	bl	102e24e4 <__i2b>
102e05e4:	9c10      	ldr	r4, [sp, #64]	; 0x40
102e05e6:	2600      	movs	r6, #0
102e05e8:	4681      	mov	r9, r0
102e05ea:	42a6      	cmp	r6, r4
102e05ec:	da00      	bge.n	102e05f0 <_strtod_r+0x5c0>
102e05ee:	1c26      	adds	r6, r4, #0
102e05f0:	9914      	ldr	r1, [sp, #80]	; 0x50
102e05f2:	2900      	cmp	r1, #0
102e05f4:	da00      	bge.n	102e05f8 <_strtod_r+0x5c8>
102e05f6:	e104      	b.n	102e0802 <_strtod_r+0x7d2>
102e05f8:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
102e05fa:	1c37      	adds	r7, r6, #0
102e05fc:	1863      	adds	r3, r4, r1
102e05fe:	9c09      	ldr	r4, [sp, #36]	; 0x24
102e0600:	9a17      	ldr	r2, [sp, #92]	; 0x5c
102e0602:	1b09      	subs	r1, r1, r4
102e0604:	484d      	ldr	r0, [pc, #308]	; (102e073c <_strtod_r+0x70c>)
102e0606:	188c      	adds	r4, r1, r2
102e0608:	4284      	cmp	r4, r0
102e060a:	da00      	bge.n	102e060e <_strtod_r+0x5de>
102e060c:	e6ff      	b.n	102e040e <_strtod_r+0x3de>
102e060e:	2136      	movs	r1, #54	; 0x36
102e0610:	1a8a      	subs	r2, r1, r2
102e0612:	e6fe      	b.n	102e0412 <_strtod_r+0x3e2>
102e0614:	2400      	movs	r4, #0
102e0616:	9404      	str	r4, [sp, #16]
102e0618:	46a1      	mov	r9, r4
102e061a:	e5ae      	b.n	102e017a <_strtod_r+0x14a>
102e061c:	2300      	movs	r3, #0
102e061e:	9708      	str	r7, [sp, #32]
102e0620:	4699      	mov	r9, r3
102e0622:	1c27      	adds	r7, r4, #0
102e0624:	2230      	movs	r2, #48	; 0x30
102e0626:	4252      	negs	r2, r2
102e0628:	1952      	adds	r2, r2, r5
102e062a:	4694      	mov	ip, r2
102e062c:	2001      	movs	r0, #1
102e062e:	2a09      	cmp	r2, #9
102e0630:	d900      	bls.n	102e0634 <_strtod_r+0x604>
102e0632:	e562      	b.n	102e00fa <_strtod_r+0xca>
102e0634:	9815      	ldr	r0, [sp, #84]	; 0x54
102e0636:	9009      	str	r0, [sp, #36]	; 0x24
102e0638:	3301      	adds	r3, #1
102e063a:	4661      	mov	r1, ip
102e063c:	2900      	cmp	r1, #0
102e063e:	d100      	bne.n	102e0642 <_strtod_r+0x612>
102e0640:	e1d6      	b.n	102e09f0 <_strtod_r+0x9c0>
102e0642:	4499      	add	r9, r3
102e0644:	2b01      	cmp	r3, #1
102e0646:	d101      	bne.n	102e064c <_strtod_r+0x61c>
102e0648:	f000 fbf3 	bl	102e0e32 <_strtod_r+0xe02>
102e064c:	18f8      	adds	r0, r7, r3
102e064e:	3801      	subs	r0, #1
102e0650:	1c3a      	adds	r2, r7, #0
102e0652:	465d      	mov	r5, fp
102e0654:	e005      	b.n	102e0662 <_strtod_r+0x632>
102e0656:	00b1      	lsls	r1, r6, #2
102e0658:	198e      	adds	r6, r1, r6
102e065a:	0076      	lsls	r6, r6, #1
102e065c:	4282      	cmp	r2, r0
102e065e:	d100      	bne.n	102e0662 <_strtod_r+0x632>
102e0660:	e1ba      	b.n	102e09d8 <_strtod_r+0x9a8>
102e0662:	3201      	adds	r2, #1
102e0664:	1e51      	subs	r1, r2, #1
102e0666:	2908      	cmp	r1, #8
102e0668:	ddf5      	ble.n	102e0656 <_strtod_r+0x626>
102e066a:	2a10      	cmp	r2, #16
102e066c:	dcf6      	bgt.n	102e065c <_strtod_r+0x62c>
102e066e:	00a9      	lsls	r1, r5, #2
102e0670:	194d      	adds	r5, r1, r5
102e0672:	006d      	lsls	r5, r5, #1
102e0674:	e7f2      	b.n	102e065c <_strtod_r+0x62c>
102e0676:	9708      	str	r7, [sp, #32]
102e0678:	2700      	movs	r7, #0
102e067a:	46b9      	mov	r9, r7
102e067c:	2001      	movs	r0, #1
102e067e:	e53c      	b.n	102e00fa <_strtod_r+0xca>
102e0680:	239a      	movs	r3, #154	; 0x9a
102e0682:	005b      	lsls	r3, r3, #1
102e0684:	429d      	cmp	r5, r3
102e0686:	dd00      	ble.n	102e068a <_strtod_r+0x65a>
102e0688:	e294      	b.n	102e0bb4 <_strtod_r+0xb84>
102e068a:	112d      	asrs	r5, r5, #4
102e068c:	2d01      	cmp	r5, #1
102e068e:	dc00      	bgt.n	102e0692 <_strtod_r+0x662>
102e0690:	e3c9      	b.n	102e0e26 <_strtod_r+0xdf6>
102e0692:	4a2b      	ldr	r2, [pc, #172]	; (102e0740 <_strtod_r+0x710>)
102e0694:	2400      	movs	r4, #0
102e0696:	2301      	movs	r3, #1
102e0698:	4693      	mov	fp, r2
102e069a:	4699      	mov	r9, r3
102e069c:	9806      	ldr	r0, [sp, #24]
102e069e:	9907      	ldr	r1, [sp, #28]
102e06a0:	1c23      	adds	r3, r4, #0
102e06a2:	46b0      	mov	r8, r6
102e06a4:	465c      	mov	r4, fp
102e06a6:	1c1e      	adds	r6, r3, #0
102e06a8:	464a      	mov	r2, r9
102e06aa:	422a      	tst	r2, r5
102e06ac:	d003      	beq.n	102e06b6 <_strtod_r+0x686>
102e06ae:	6822      	ldr	r2, [r4, #0]
102e06b0:	6863      	ldr	r3, [r4, #4]
102e06b2:	f003 fc47 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e06b6:	3601      	adds	r6, #1
102e06b8:	106d      	asrs	r5, r5, #1
102e06ba:	3408      	adds	r4, #8
102e06bc:	2d01      	cmp	r5, #1
102e06be:	dcf3      	bgt.n	102e06a8 <_strtod_r+0x678>
102e06c0:	9006      	str	r0, [sp, #24]
102e06c2:	9107      	str	r1, [sp, #28]
102e06c4:	1c34      	adds	r4, r6, #0
102e06c6:	4646      	mov	r6, r8
102e06c8:	9807      	ldr	r0, [sp, #28]
102e06ca:	491e      	ldr	r1, [pc, #120]	; (102e0744 <_strtod_r+0x714>)
102e06cc:	00e4      	lsls	r4, r4, #3
102e06ce:	1841      	adds	r1, r0, r1
102e06d0:	9107      	str	r1, [sp, #28]
102e06d2:	445c      	add	r4, fp
102e06d4:	9a06      	ldr	r2, [sp, #24]
102e06d6:	9b07      	ldr	r3, [sp, #28]
102e06d8:	6820      	ldr	r0, [r4, #0]
102e06da:	6861      	ldr	r1, [r4, #4]
102e06dc:	f003 fc32 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e06e0:	9006      	str	r0, [sp, #24]
102e06e2:	9107      	str	r1, [sp, #28]
102e06e4:	9b07      	ldr	r3, [sp, #28]
102e06e6:	4a13      	ldr	r2, [pc, #76]	; (102e0734 <_strtod_r+0x704>)
102e06e8:	4917      	ldr	r1, [pc, #92]	; (102e0748 <_strtod_r+0x718>)
102e06ea:	401a      	ands	r2, r3
102e06ec:	428a      	cmp	r2, r1
102e06ee:	d900      	bls.n	102e06f2 <_strtod_r+0x6c2>
102e06f0:	e260      	b.n	102e0bb4 <_strtod_r+0xb84>
102e06f2:	4916      	ldr	r1, [pc, #88]	; (102e074c <_strtod_r+0x71c>)
102e06f4:	428a      	cmp	r2, r1
102e06f6:	d800      	bhi.n	102e06fa <_strtod_r+0x6ca>
102e06f8:	e35c      	b.n	102e0db4 <_strtod_r+0xd84>
102e06fa:	4a15      	ldr	r2, [pc, #84]	; (102e0750 <_strtod_r+0x720>)
102e06fc:	2301      	movs	r3, #1
102e06fe:	425b      	negs	r3, r3
102e0700:	2400      	movs	r4, #0
102e0702:	9207      	str	r2, [sp, #28]
102e0704:	9306      	str	r3, [sp, #24]
102e0706:	9304      	str	r3, [sp, #16]
102e0708:	4691      	mov	r9, r2
102e070a:	9409      	str	r4, [sp, #36]	; 0x24
102e070c:	e66c      	b.n	102e03e8 <_strtod_r+0x3b8>
102e070e:	46c0      	nop			; (mov r8, r8)
102e0710:	00000000 	.word	0x00000000
102e0714:	40000000 	.word	0x40000000
102e0718:	00000000 	.word	0x00000000
102e071c:	3ff00000 	.word	0x3ff00000
102e0720:	ffc00000 	.word	0xffc00000
102e0724:	41dfffff 	.word	0x41dfffff
102e0728:	102edce8 	.word	0x102edce8
102e072c:	00000433 	.word	0x00000433
102e0730:	3ff00000 	.word	0x3ff00000
102e0734:	7ff00000 	.word	0x7ff00000
102e0738:	7fe00000 	.word	0x7fe00000
102e073c:	fffffc03 	.word	0xfffffc03
102e0740:	102eddd8 	.word	0x102eddd8
102e0744:	fcb00000 	.word	0xfcb00000
102e0748:	7ca00000 	.word	0x7ca00000
102e074c:	7c900000 	.word	0x7c900000
102e0750:	7fefffff 	.word	0x7fefffff
102e0754:	2101      	movs	r1, #1
102e0756:	9109      	str	r1, [sp, #36]	; 0x24
102e0758:	4642      	mov	r2, r8
102e075a:	3202      	adds	r2, #2
102e075c:	9215      	str	r2, [sp, #84]	; 0x54
102e075e:	4642      	mov	r2, r8
102e0760:	7895      	ldrb	r5, [r2, #2]
102e0762:	e53a      	b.n	102e01da <_strtod_r+0x1aa>
102e0764:	1c20      	adds	r0, r4, #0
102e0766:	4bd1      	ldr	r3, [pc, #836]	; (102e0aac <_strtod_r+0xa7c>)
102e0768:	4acf      	ldr	r2, [pc, #828]	; (102e0aa8 <_strtod_r+0xa78>)
102e076a:	1c29      	adds	r1, r5, #0
102e076c:	f003 fbea 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e0770:	9c0c      	ldr	r4, [sp, #48]	; 0x30
102e0772:	900a      	str	r0, [sp, #40]	; 0x28
102e0774:	9102      	str	r1, [sp, #8]
102e0776:	1c0b      	adds	r3, r1, #0
102e0778:	2c00      	cmp	r4, #0
102e077a:	d102      	bne.n	102e0782 <_strtod_r+0x752>
102e077c:	2080      	movs	r0, #128	; 0x80
102e077e:	0600      	lsls	r0, r0, #24
102e0780:	180b      	adds	r3, r1, r0
102e0782:	9907      	ldr	r1, [sp, #28]
102e0784:	910e      	str	r1, [sp, #56]	; 0x38
102e0786:	1c1d      	adds	r5, r3, #0
102e0788:	9f0e      	ldr	r7, [sp, #56]	; 0x38
102e078a:	4ad3      	ldr	r2, [pc, #844]	; (102e0ad8 <_strtod_r+0xaa8>)
102e078c:	4bd3      	ldr	r3, [pc, #844]	; (102e0adc <_strtod_r+0xaac>)
102e078e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
102e0790:	4017      	ands	r7, r2
102e0792:	429f      	cmp	r7, r3
102e0794:	d000      	beq.n	102e0798 <_strtod_r+0x768>
102e0796:	e6b3      	b.n	102e0500 <_strtod_r+0x4d0>
102e0798:	9a04      	ldr	r2, [sp, #16]
102e079a:	9b08      	ldr	r3, [sp, #32]
102e079c:	48d0      	ldr	r0, [pc, #832]	; (102e0ae0 <_strtod_r+0xab0>)
102e079e:	9212      	str	r2, [sp, #72]	; 0x48
102e07a0:	9313      	str	r3, [sp, #76]	; 0x4c
102e07a2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
102e07a4:	1818      	adds	r0, r3, r0
102e07a6:	9007      	str	r0, [sp, #28]
102e07a8:	9404      	str	r4, [sp, #16]
102e07aa:	9505      	str	r5, [sp, #20]
102e07ac:	9c06      	ldr	r4, [sp, #24]
102e07ae:	9d07      	ldr	r5, [sp, #28]
102e07b0:	1c20      	adds	r0, r4, #0
102e07b2:	1c29      	adds	r1, r5, #0
102e07b4:	f002 f8aa 	bl	102e290c <__ulp>
102e07b8:	1c02      	adds	r2, r0, #0
102e07ba:	1c0b      	adds	r3, r1, #0
102e07bc:	9804      	ldr	r0, [sp, #16]
102e07be:	9905      	ldr	r1, [sp, #20]
102e07c0:	f003 fbc0 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e07c4:	1c02      	adds	r2, r0, #0
102e07c6:	1c0b      	adds	r3, r1, #0
102e07c8:	1c20      	adds	r0, r4, #0
102e07ca:	1c29      	adds	r1, r5, #0
102e07cc:	f003 fbb2 	bl	102e3f34 <____aeabi_dadd_from_thumb>
102e07d0:	9006      	str	r0, [sp, #24]
102e07d2:	9107      	str	r1, [sp, #28]
102e07d4:	9c07      	ldr	r4, [sp, #28]
102e07d6:	4ac0      	ldr	r2, [pc, #768]	; (102e0ad8 <_strtod_r+0xaa8>)
102e07d8:	4bc2      	ldr	r3, [pc, #776]	; (102e0ae4 <_strtod_r+0xab4>)
102e07da:	4022      	ands	r2, r4
102e07dc:	429a      	cmp	r2, r3
102e07de:	d800      	bhi.n	102e07e2 <_strtod_r+0x7b2>
102e07e0:	e0a1      	b.n	102e0926 <_strtod_r+0x8f6>
102e07e2:	4bc1      	ldr	r3, [pc, #772]	; (102e0ae8 <_strtod_r+0xab8>)
102e07e4:	9913      	ldr	r1, [sp, #76]	; 0x4c
102e07e6:	4299      	cmp	r1, r3
102e07e8:	d100      	bne.n	102e07ec <_strtod_r+0x7bc>
102e07ea:	e1d1      	b.n	102e0b90 <_strtod_r+0xb60>
102e07ec:	4bbe      	ldr	r3, [pc, #760]	; (102e0ae8 <_strtod_r+0xab8>)
102e07ee:	9307      	str	r3, [sp, #28]
102e07f0:	9c07      	ldr	r4, [sp, #28]
102e07f2:	2301      	movs	r3, #1
102e07f4:	425b      	negs	r3, r3
102e07f6:	9306      	str	r3, [sp, #24]
102e07f8:	9304      	str	r3, [sp, #16]
102e07fa:	9408      	str	r4, [sp, #32]
102e07fc:	e6c6      	b.n	102e058c <_strtod_r+0x55c>
102e07fe:	1c1f      	adds	r7, r3, #0
102e0800:	e618      	b.n	102e0434 <_strtod_r+0x404>
102e0802:	1a77      	subs	r7, r6, r1
102e0804:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
102e0806:	e6fa      	b.n	102e05fe <_strtod_r+0x5ce>
102e0808:	9b06      	ldr	r3, [sp, #24]
102e080a:	2b00      	cmp	r3, #0
102e080c:	d15c      	bne.n	102e08c8 <_strtod_r+0x898>
102e080e:	9a07      	ldr	r2, [sp, #28]
102e0810:	920e      	str	r2, [sp, #56]	; 0x38
102e0812:	0313      	lsls	r3, r2, #12
102e0814:	d117      	bne.n	102e0846 <_strtod_r+0x816>
102e0816:	1c20      	adds	r0, r4, #0
102e0818:	1c29      	adds	r1, r5, #0
102e081a:	4aa5      	ldr	r2, [pc, #660]	; (102e0ab0 <_strtod_r+0xa80>)
102e081c:	4ba5      	ldr	r3, [pc, #660]	; (102e0ab4 <_strtod_r+0xa84>)
102e081e:	f003 fb69 	bl	102e3ef4 <____aeabi_dcmplt_from_thumb>
102e0822:	2800      	cmp	r0, #0
102e0824:	d000      	beq.n	102e0828 <_strtod_r+0x7f8>
102e0826:	e22c      	b.n	102e0c82 <_strtod_r+0xc52>
102e0828:	4ba0      	ldr	r3, [pc, #640]	; (102e0aac <_strtod_r+0xa7c>)
102e082a:	4a9f      	ldr	r2, [pc, #636]	; (102e0aa8 <_strtod_r+0xa78>)
102e082c:	1c20      	adds	r0, r4, #0
102e082e:	1c29      	adds	r1, r5, #0
102e0830:	f003 fb88 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e0834:	2480      	movs	r4, #128	; 0x80
102e0836:	0624      	lsls	r4, r4, #24
102e0838:	900a      	str	r0, [sp, #40]	; 0x28
102e083a:	9102      	str	r1, [sp, #8]
102e083c:	1c02      	adds	r2, r0, #0
102e083e:	190b      	adds	r3, r1, r4
102e0840:	1c14      	adds	r4, r2, #0
102e0842:	1c1d      	adds	r5, r3, #0
102e0844:	e655      	b.n	102e04f2 <_strtod_r+0x4c2>
102e0846:	49a9      	ldr	r1, [pc, #676]	; (102e0aec <_strtod_r+0xabc>)
102e0848:	2000      	movs	r0, #0
102e084a:	4c9b      	ldr	r4, [pc, #620]	; (102e0ab8 <_strtod_r+0xa88>)
102e084c:	4d9b      	ldr	r5, [pc, #620]	; (102e0abc <_strtod_r+0xa8c>)
102e084e:	900a      	str	r0, [sp, #40]	; 0x28
102e0850:	9102      	str	r1, [sp, #8]
102e0852:	e64e      	b.n	102e04f2 <_strtod_r+0x4c2>
102e0854:	9902      	ldr	r1, [sp, #8]
102e0856:	980a      	ldr	r0, [sp, #40]	; 0x28
102e0858:	f003 fb7c 	bl	102e3f54 <____aeabi_d2iz_from_thumb>
102e085c:	f003 fb66 	bl	102e3f2c <____aeabi_i2d_from_thumb>
102e0860:	1c0b      	adds	r3, r1, #0
102e0862:	1c02      	adds	r2, r0, #0
102e0864:	9902      	ldr	r1, [sp, #8]
102e0866:	980a      	ldr	r0, [sp, #40]	; 0x28
102e0868:	f003 fb38 	bl	102e3edc <____aeabi_dsub_from_thumb>
102e086c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
102e086e:	9002      	str	r0, [sp, #8]
102e0870:	9103      	str	r1, [sp, #12]
102e0872:	2b00      	cmp	r3, #0
102e0874:	d139      	bne.n	102e08ea <_strtod_r+0x8ba>
102e0876:	9806      	ldr	r0, [sp, #24]
102e0878:	2800      	cmp	r0, #0
102e087a:	d136      	bne.n	102e08ea <_strtod_r+0x8ba>
102e087c:	0324      	lsls	r4, r4, #12
102e087e:	d134      	bne.n	102e08ea <_strtod_r+0x8ba>
102e0880:	9802      	ldr	r0, [sp, #8]
102e0882:	9903      	ldr	r1, [sp, #12]
102e0884:	4a8e      	ldr	r2, [pc, #568]	; (102e0ac0 <_strtod_r+0xa90>)
102e0886:	4b8f      	ldr	r3, [pc, #572]	; (102e0ac4 <_strtod_r+0xa94>)
102e0888:	f003 fb34 	bl	102e3ef4 <____aeabi_dcmplt_from_thumb>
102e088c:	2800      	cmp	r0, #0
102e088e:	d100      	bne.n	102e0892 <_strtod_r+0x862>
102e0890:	e67c      	b.n	102e058c <_strtod_r+0x55c>
102e0892:	9b08      	ldr	r3, [sp, #32]
102e0894:	4645      	mov	r5, r8
102e0896:	464c      	mov	r4, r9
102e0898:	46d8      	mov	r8, fp
102e089a:	4699      	mov	r9, r3
102e089c:	46b3      	mov	fp, r6
102e089e:	4650      	mov	r0, sl
102e08a0:	9916      	ldr	r1, [sp, #88]	; 0x58
102e08a2:	f001 fd23 	bl	102e22ec <_Bfree>
102e08a6:	4650      	mov	r0, sl
102e08a8:	1c29      	adds	r1, r5, #0
102e08aa:	f001 fd1f 	bl	102e22ec <_Bfree>
102e08ae:	4650      	mov	r0, sl
102e08b0:	1c21      	adds	r1, r4, #0
102e08b2:	f001 fd1b 	bl	102e22ec <_Bfree>
102e08b6:	4650      	mov	r0, sl
102e08b8:	4641      	mov	r1, r8
102e08ba:	f001 fd17 	bl	102e22ec <_Bfree>
102e08be:	4650      	mov	r0, sl
102e08c0:	4659      	mov	r1, fp
102e08c2:	f001 fd13 	bl	102e22ec <_Bfree>
102e08c6:	e458      	b.n	102e017a <_strtod_r+0x14a>
102e08c8:	9c07      	ldr	r4, [sp, #28]
102e08ca:	940e      	str	r4, [sp, #56]	; 0x38
102e08cc:	2b01      	cmp	r3, #1
102e08ce:	d1ba      	bne.n	102e0846 <_strtod_r+0x816>
102e08d0:	2c00      	cmp	r4, #0
102e08d2:	d1b8      	bne.n	102e0846 <_strtod_r+0x816>
102e08d4:	4645      	mov	r5, r8
102e08d6:	464c      	mov	r4, r9
102e08d8:	46d8      	mov	r8, fp
102e08da:	46b3      	mov	fp, r6
102e08dc:	2200      	movs	r2, #0
102e08de:	2322      	movs	r3, #34	; 0x22
102e08e0:	4651      	mov	r1, sl
102e08e2:	600b      	str	r3, [r1, #0]
102e08e4:	9204      	str	r2, [sp, #16]
102e08e6:	4691      	mov	r9, r2
102e08e8:	e7d9      	b.n	102e089e <_strtod_r+0x86e>
102e08ea:	9802      	ldr	r0, [sp, #8]
102e08ec:	9903      	ldr	r1, [sp, #12]
102e08ee:	4a76      	ldr	r2, [pc, #472]	; (102e0ac8 <_strtod_r+0xa98>)
102e08f0:	4b76      	ldr	r3, [pc, #472]	; (102e0acc <_strtod_r+0xa9c>)
102e08f2:	f003 faff 	bl	102e3ef4 <____aeabi_dcmplt_from_thumb>
102e08f6:	2800      	cmp	r0, #0
102e08f8:	d000      	beq.n	102e08fc <_strtod_r+0x8cc>
102e08fa:	e27e      	b.n	102e0dfa <_strtod_r+0xdca>
102e08fc:	9802      	ldr	r0, [sp, #8]
102e08fe:	9903      	ldr	r1, [sp, #12]
102e0900:	4a73      	ldr	r2, [pc, #460]	; (102e0ad0 <_strtod_r+0xaa0>)
102e0902:	4b74      	ldr	r3, [pc, #464]	; (102e0ad4 <_strtod_r+0xaa4>)
102e0904:	f003 fae2 	bl	102e3ecc <____aeabi_dcmpgt_from_thumb>
102e0908:	2800      	cmp	r0, #0
102e090a:	d100      	bne.n	102e090e <_strtod_r+0x8de>
102e090c:	e63e      	b.n	102e058c <_strtod_r+0x55c>
102e090e:	9908      	ldr	r1, [sp, #32]
102e0910:	4645      	mov	r5, r8
102e0912:	464c      	mov	r4, r9
102e0914:	46d8      	mov	r8, fp
102e0916:	4689      	mov	r9, r1
102e0918:	46b3      	mov	fp, r6
102e091a:	e7c0      	b.n	102e089e <_strtod_r+0x86e>
102e091c:	2400      	movs	r4, #0
102e091e:	940a      	str	r4, [sp, #40]	; 0x28
102e0920:	4c72      	ldr	r4, [pc, #456]	; (102e0aec <_strtod_r+0xabc>)
102e0922:	9402      	str	r4, [sp, #8]
102e0924:	e606      	b.n	102e0534 <_strtod_r+0x504>
102e0926:	20d4      	movs	r0, #212	; 0xd4
102e0928:	0480      	lsls	r0, r0, #18
102e092a:	9906      	ldr	r1, [sp, #24]
102e092c:	1824      	adds	r4, r4, r0
102e092e:	9407      	str	r4, [sp, #28]
102e0930:	9104      	str	r1, [sp, #16]
102e0932:	9408      	str	r4, [sp, #32]
102e0934:	e622      	b.n	102e057c <_strtod_r+0x54c>
102e0936:	4641      	mov	r1, r8
102e0938:	9115      	str	r1, [sp, #84]	; 0x54
102e093a:	2100      	movs	r1, #0
102e093c:	f7ff fbe3 	bl	102e0106 <_strtod_r+0xd6>
102e0940:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
102e0942:	4e6b      	ldr	r6, [pc, #428]	; (102e0af0 <_strtod_r+0xac0>)
102e0944:	ab16      	add	r3, sp, #88	; 0x58
102e0946:	9300      	str	r3, [sp, #0]
102e0948:	9401      	str	r4, [sp, #4]
102e094a:	4650      	mov	r0, sl
102e094c:	a915      	add	r1, sp, #84	; 0x54
102e094e:	1c32      	adds	r2, r6, #0
102e0950:	ab17      	add	r3, sp, #92	; 0x5c
102e0952:	f000 fdcd 	bl	102e14f0 <__gethex>
102e0956:	2407      	movs	r4, #7
102e0958:	1c05      	adds	r5, r0, #0
102e095a:	4004      	ands	r4, r0
102e095c:	d100      	bne.n	102e0960 <_strtod_r+0x930>
102e095e:	e659      	b.n	102e0614 <_strtod_r+0x5e4>
102e0960:	2c06      	cmp	r4, #6
102e0962:	d100      	bne.n	102e0966 <_strtod_r+0x936>
102e0964:	e1a2      	b.n	102e0cac <_strtod_r+0xc7c>
102e0966:	9a16      	ldr	r2, [sp, #88]	; 0x58
102e0968:	2a00      	cmp	r2, #0
102e096a:	d007      	beq.n	102e097c <_strtod_r+0x94c>
102e096c:	6831      	ldr	r1, [r6, #0]
102e096e:	a818      	add	r0, sp, #96	; 0x60
102e0970:	f002 f8f8 	bl	102e2b64 <__copybits>
102e0974:	4650      	mov	r0, sl
102e0976:	9916      	ldr	r1, [sp, #88]	; 0x58
102e0978:	f001 fcb8 	bl	102e22ec <_Bfree>
102e097c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
102e097e:	2c05      	cmp	r4, #5
102e0980:	d808      	bhi.n	102e0994 <_strtod_r+0x964>
102e0982:	4a5c      	ldr	r2, [pc, #368]	; (102e0af4 <_strtod_r+0xac4>)
102e0984:	00a4      	lsls	r4, r4, #2
102e0986:	5912      	ldr	r2, [r2, r4]
102e0988:	4697      	mov	pc, r2
102e098a:	4a5b      	ldr	r2, [pc, #364]	; (102e0af8 <_strtod_r+0xac8>)
102e098c:	2301      	movs	r3, #1
102e098e:	425b      	negs	r3, r3
102e0990:	9207      	str	r2, [sp, #28]
102e0992:	9306      	str	r3, [sp, #24]
102e0994:	072b      	lsls	r3, r5, #28
102e0996:	d400      	bmi.n	102e099a <_strtod_r+0x96a>
102e0998:	e4cb      	b.n	102e0332 <_strtod_r+0x302>
102e099a:	2380      	movs	r3, #128	; 0x80
102e099c:	9907      	ldr	r1, [sp, #28]
102e099e:	061b      	lsls	r3, r3, #24
102e09a0:	9c06      	ldr	r4, [sp, #24]
102e09a2:	430b      	orrs	r3, r1
102e09a4:	9404      	str	r4, [sp, #16]
102e09a6:	4699      	mov	r9, r3
102e09a8:	f7ff fbe7 	bl	102e017a <_strtod_r+0x14a>
102e09ac:	494a      	ldr	r1, [pc, #296]	; (102e0ad8 <_strtod_r+0xaa8>)
102e09ae:	9107      	str	r1, [sp, #28]
102e09b0:	e7f0      	b.n	102e0994 <_strtod_r+0x964>
102e09b2:	9818      	ldr	r0, [sp, #96]	; 0x60
102e09b4:	9919      	ldr	r1, [sp, #100]	; 0x64
102e09b6:	9006      	str	r0, [sp, #24]
102e09b8:	9107      	str	r1, [sp, #28]
102e09ba:	e7eb      	b.n	102e0994 <_strtod_r+0x964>
102e09bc:	9a18      	ldr	r2, [sp, #96]	; 0x60
102e09be:	4c4f      	ldr	r4, [pc, #316]	; (102e0afc <_strtod_r+0xacc>)
102e09c0:	9206      	str	r2, [sp, #24]
102e09c2:	9819      	ldr	r0, [sp, #100]	; 0x64
102e09c4:	4a4e      	ldr	r2, [pc, #312]	; (102e0b00 <_strtod_r+0xad0>)
102e09c6:	191b      	adds	r3, r3, r4
102e09c8:	051b      	lsls	r3, r3, #20
102e09ca:	4002      	ands	r2, r0
102e09cc:	4313      	orrs	r3, r2
102e09ce:	9307      	str	r3, [sp, #28]
102e09d0:	e7e0      	b.n	102e0994 <_strtod_r+0x964>
102e09d2:	2100      	movs	r1, #0
102e09d4:	9109      	str	r1, [sp, #36]	; 0x24
102e09d6:	e6bf      	b.n	102e0758 <_strtod_r+0x728>
102e09d8:	18fb      	adds	r3, r7, r3
102e09da:	46ab      	mov	fp, r5
102e09dc:	3b01      	subs	r3, #1
102e09de:	1c5f      	adds	r7, r3, #1
102e09e0:	2b08      	cmp	r3, #8
102e09e2:	dd00      	ble.n	102e09e6 <_strtod_r+0x9b6>
102e09e4:	e1d6      	b.n	102e0d94 <_strtod_r+0xd64>
102e09e6:	00b3      	lsls	r3, r6, #2
102e09e8:	199e      	adds	r6, r3, r6
102e09ea:	0076      	lsls	r6, r6, #1
102e09ec:	4466      	add	r6, ip
102e09ee:	2300      	movs	r3, #0
102e09f0:	9a09      	ldr	r2, [sp, #36]	; 0x24
102e09f2:	3201      	adds	r2, #1
102e09f4:	9215      	str	r2, [sp, #84]	; 0x54
102e09f6:	9909      	ldr	r1, [sp, #36]	; 0x24
102e09f8:	784d      	ldrb	r5, [r1, #1]
102e09fa:	e613      	b.n	102e0624 <_strtod_r+0x5f4>
102e09fc:	980c      	ldr	r0, [sp, #48]	; 0x30
102e09fe:	4645      	mov	r5, r8
102e0a00:	464c      	mov	r4, r9
102e0a02:	46d8      	mov	r8, fp
102e0a04:	46b3      	mov	fp, r6
102e0a06:	2800      	cmp	r0, #0
102e0a08:	d000      	beq.n	102e0a0c <_strtod_r+0x9dc>
102e0a0a:	e099      	b.n	102e0b40 <_strtod_r+0xb10>
102e0a0c:	9906      	ldr	r1, [sp, #24]
102e0a0e:	2900      	cmp	r1, #0
102e0a10:	d000      	beq.n	102e0a14 <_strtod_r+0x9e4>
102e0a12:	e095      	b.n	102e0b40 <_strtod_r+0xb10>
102e0a14:	9b07      	ldr	r3, [sp, #28]
102e0a16:	031a      	lsls	r2, r3, #12
102e0a18:	d000      	beq.n	102e0a1c <_strtod_r+0x9ec>
102e0a1a:	e091      	b.n	102e0b40 <_strtod_r+0xb10>
102e0a1c:	4a2e      	ldr	r2, [pc, #184]	; (102e0ad8 <_strtod_r+0xaa8>)
102e0a1e:	4013      	ands	r3, r2
102e0a20:	22d6      	movs	r2, #214	; 0xd6
102e0a22:	04d2      	lsls	r2, r2, #19
102e0a24:	4293      	cmp	r3, r2
102e0a26:	d800      	bhi.n	102e0a2a <_strtod_r+0x9fa>
102e0a28:	e08a      	b.n	102e0b40 <_strtod_r+0xb10>
102e0a2a:	6972      	ldr	r2, [r6, #20]
102e0a2c:	2a00      	cmp	r2, #0
102e0a2e:	d103      	bne.n	102e0a38 <_strtod_r+0xa08>
102e0a30:	6933      	ldr	r3, [r6, #16]
102e0a32:	2b01      	cmp	r3, #1
102e0a34:	dc00      	bgt.n	102e0a38 <_strtod_r+0xa08>
102e0a36:	e083      	b.n	102e0b40 <_strtod_r+0xb10>
102e0a38:	4659      	mov	r1, fp
102e0a3a:	4650      	mov	r0, sl
102e0a3c:	2201      	movs	r2, #1
102e0a3e:	f001 fe67 	bl	102e2710 <__lshift>
102e0a42:	1c21      	adds	r1, r4, #0
102e0a44:	4683      	mov	fp, r0
102e0a46:	f001 fecb 	bl	102e27e0 <__mcmp>
102e0a4a:	2800      	cmp	r0, #0
102e0a4c:	dd78      	ble.n	102e0b40 <_strtod_r+0xb10>
102e0a4e:	9909      	ldr	r1, [sp, #36]	; 0x24
102e0a50:	2900      	cmp	r1, #0
102e0a52:	d100      	bne.n	102e0a56 <_strtod_r+0xa26>
102e0a54:	e1d8      	b.n	102e0e08 <_strtod_r+0xdd8>
102e0a56:	9a07      	ldr	r2, [sp, #28]
102e0a58:	4b1f      	ldr	r3, [pc, #124]	; (102e0ad8 <_strtod_r+0xaa8>)
102e0a5a:	4013      	ands	r3, r2
102e0a5c:	22d6      	movs	r2, #214	; 0xd6
102e0a5e:	04d2      	lsls	r2, r2, #19
102e0a60:	4293      	cmp	r3, r2
102e0a62:	d900      	bls.n	102e0a66 <_strtod_r+0xa36>
102e0a64:	e1d0      	b.n	102e0e08 <_strtod_r+0xdd8>
102e0a66:	22dc      	movs	r2, #220	; 0xdc
102e0a68:	0492      	lsls	r2, r2, #18
102e0a6a:	4293      	cmp	r3, r2
102e0a6c:	d800      	bhi.n	102e0a70 <_strtod_r+0xa40>
102e0a6e:	e735      	b.n	102e08dc <_strtod_r+0x8ac>
102e0a70:	4924      	ldr	r1, [pc, #144]	; (102e0b04 <_strtod_r+0xad4>)
102e0a72:	2200      	movs	r2, #0
102e0a74:	9113      	str	r1, [sp, #76]	; 0x4c
102e0a76:	9212      	str	r2, [sp, #72]	; 0x48
102e0a78:	9a12      	ldr	r2, [sp, #72]	; 0x48
102e0a7a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
102e0a7c:	9806      	ldr	r0, [sp, #24]
102e0a7e:	9907      	ldr	r1, [sp, #28]
102e0a80:	f003 fa60 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e0a84:	1c0b      	adds	r3, r1, #0
102e0a86:	1c02      	adds	r2, r0, #0
102e0a88:	9206      	str	r2, [sp, #24]
102e0a8a:	9307      	str	r3, [sp, #28]
102e0a8c:	9b07      	ldr	r3, [sp, #28]
102e0a8e:	9004      	str	r0, [sp, #16]
102e0a90:	4689      	mov	r9, r1
102e0a92:	2b00      	cmp	r3, #0
102e0a94:	d000      	beq.n	102e0a98 <_strtod_r+0xa68>
102e0a96:	e702      	b.n	102e089e <_strtod_r+0x86e>
102e0a98:	9806      	ldr	r0, [sp, #24]
102e0a9a:	2800      	cmp	r0, #0
102e0a9c:	d000      	beq.n	102e0aa0 <_strtod_r+0xa70>
102e0a9e:	e6fe      	b.n	102e089e <_strtod_r+0x86e>
102e0aa0:	2322      	movs	r3, #34	; 0x22
102e0aa2:	4651      	mov	r1, sl
102e0aa4:	600b      	str	r3, [r1, #0]
102e0aa6:	e6fa      	b.n	102e089e <_strtod_r+0x86e>
102e0aa8:	00000000 	.word	0x00000000
102e0aac:	3fe00000 	.word	0x3fe00000
102e0ab0:	00000000 	.word	0x00000000
102e0ab4:	3ff00000 	.word	0x3ff00000
102e0ab8:	00000000 	.word	0x00000000
102e0abc:	bff00000 	.word	0xbff00000
102e0ac0:	94a03595 	.word	0x94a03595
102e0ac4:	3fcfffff 	.word	0x3fcfffff
102e0ac8:	94a03595 	.word	0x94a03595
102e0acc:	3fdfffff 	.word	0x3fdfffff
102e0ad0:	35afe535 	.word	0x35afe535
102e0ad4:	3fe00000 	.word	0x3fe00000
102e0ad8:	7ff00000 	.word	0x7ff00000
102e0adc:	7fe00000 	.word	0x7fe00000
102e0ae0:	fcb00000 	.word	0xfcb00000
102e0ae4:	7c9fffff 	.word	0x7c9fffff
102e0ae8:	7fefffff 	.word	0x7fefffff
102e0aec:	3ff00000 	.word	0x3ff00000
102e0af0:	f03d4768 	.word	0xf03d4768
102e0af4:	102edc98 	.word	0x102edc98
102e0af8:	7fffffff 	.word	0x7fffffff
102e0afc:	00000433 	.word	0x00000433
102e0b00:	ffefffff 	.word	0xffefffff
102e0b04:	39500000 	.word	0x39500000
102e0b08:	9809      	ldr	r0, [sp, #36]	; 0x24
102e0b0a:	2800      	cmp	r0, #0
102e0b0c:	d100      	bne.n	102e0b10 <_strtod_r+0xae0>
102e0b0e:	e187      	b.n	102e0e20 <_strtod_r+0xdf0>
102e0b10:	49d7      	ldr	r1, [pc, #860]	; (102e0e70 <_strtod_r+0xe40>)
102e0b12:	20d4      	movs	r0, #212	; 0xd4
102e0b14:	4019      	ands	r1, r3
102e0b16:	04c0      	lsls	r0, r0, #19
102e0b18:	4281      	cmp	r1, r0
102e0b1a:	d900      	bls.n	102e0b1e <_strtod_r+0xaee>
102e0b1c:	e180      	b.n	102e0e20 <_strtod_r+0xdf0>
102e0b1e:	206b      	movs	r0, #107	; 0x6b
102e0b20:	0d09      	lsrs	r1, r1, #20
102e0b22:	1a41      	subs	r1, r0, r1
102e0b24:	2001      	movs	r0, #1
102e0b26:	4240      	negs	r0, r0
102e0b28:	4088      	lsls	r0, r1
102e0b2a:	1c01      	adds	r1, r0, #0
102e0b2c:	428a      	cmp	r2, r1
102e0b2e:	d120      	bne.n	102e0b72 <_strtod_r+0xb42>
102e0b30:	4acf      	ldr	r2, [pc, #828]	; (102e0e70 <_strtod_r+0xe40>)
102e0b32:	2180      	movs	r1, #128	; 0x80
102e0b34:	4013      	ands	r3, r2
102e0b36:	0349      	lsls	r1, r1, #13
102e0b38:	1859      	adds	r1, r3, r1
102e0b3a:	2200      	movs	r2, #0
102e0b3c:	9107      	str	r1, [sp, #28]
102e0b3e:	9206      	str	r2, [sp, #24]
102e0b40:	9a09      	ldr	r2, [sp, #36]	; 0x24
102e0b42:	2a00      	cmp	r2, #0
102e0b44:	d194      	bne.n	102e0a70 <_strtod_r+0xa40>
102e0b46:	9b06      	ldr	r3, [sp, #24]
102e0b48:	9807      	ldr	r0, [sp, #28]
102e0b4a:	9304      	str	r3, [sp, #16]
102e0b4c:	4681      	mov	r9, r0
102e0b4e:	e6a6      	b.n	102e089e <_strtod_r+0x86e>
102e0b50:	9808      	ldr	r0, [sp, #32]
102e0b52:	990c      	ldr	r1, [sp, #48]	; 0x30
102e0b54:	4645      	mov	r5, r8
102e0b56:	464c      	mov	r4, r9
102e0b58:	46d8      	mov	r8, fp
102e0b5a:	4681      	mov	r9, r0
102e0b5c:	46b3      	mov	fp, r6
102e0b5e:	2900      	cmp	r1, #0
102e0b60:	d100      	bne.n	102e0b64 <_strtod_r+0xb34>
102e0b62:	e0e3      	b.n	102e0d2c <_strtod_r+0xcfc>
102e0b64:	9b07      	ldr	r3, [sp, #28]
102e0b66:	49c3      	ldr	r1, [pc, #780]	; (102e0e74 <_strtod_r+0xe44>)
102e0b68:	0318      	lsls	r0, r3, #12
102e0b6a:	0b00      	lsrs	r0, r0, #12
102e0b6c:	9a06      	ldr	r2, [sp, #24]
102e0b6e:	4288      	cmp	r0, r1
102e0b70:	d0ca      	beq.n	102e0b08 <_strtod_r+0xad8>
102e0b72:	07d1      	lsls	r1, r2, #31
102e0b74:	d5e4      	bpl.n	102e0b40 <_strtod_r+0xb10>
102e0b76:	9804      	ldr	r0, [sp, #16]
102e0b78:	4649      	mov	r1, r9
102e0b7a:	f001 fec7 	bl	102e290c <__ulp>
102e0b7e:	1c02      	adds	r2, r0, #0
102e0b80:	1c0b      	adds	r3, r1, #0
102e0b82:	9804      	ldr	r0, [sp, #16]
102e0b84:	4649      	mov	r1, r9
102e0b86:	f003 f9d5 	bl	102e3f34 <____aeabi_dadd_from_thumb>
102e0b8a:	9006      	str	r0, [sp, #24]
102e0b8c:	9107      	str	r1, [sp, #28]
102e0b8e:	e7d7      	b.n	102e0b40 <_strtod_r+0xb10>
102e0b90:	9a12      	ldr	r2, [sp, #72]	; 0x48
102e0b92:	3201      	adds	r2, #1
102e0b94:	d000      	beq.n	102e0b98 <_strtod_r+0xb68>
102e0b96:	e629      	b.n	102e07ec <_strtod_r+0x7bc>
102e0b98:	2322      	movs	r3, #34	; 0x22
102e0b9a:	4ab5      	ldr	r2, [pc, #724]	; (102e0e70 <_strtod_r+0xe40>)
102e0b9c:	4651      	mov	r1, sl
102e0b9e:	600b      	str	r3, [r1, #0]
102e0ba0:	2300      	movs	r3, #0
102e0ba2:	4645      	mov	r5, r8
102e0ba4:	464c      	mov	r4, r9
102e0ba6:	46d8      	mov	r8, fp
102e0ba8:	9207      	str	r2, [sp, #28]
102e0baa:	46b3      	mov	fp, r6
102e0bac:	9306      	str	r3, [sp, #24]
102e0bae:	9304      	str	r3, [sp, #16]
102e0bb0:	4691      	mov	r9, r2
102e0bb2:	e674      	b.n	102e089e <_strtod_r+0x86e>
102e0bb4:	2322      	movs	r3, #34	; 0x22
102e0bb6:	4652      	mov	r2, sl
102e0bb8:	6013      	str	r3, [r2, #0]
102e0bba:	4bad      	ldr	r3, [pc, #692]	; (102e0e70 <_strtod_r+0xe40>)
102e0bbc:	2400      	movs	r4, #0
102e0bbe:	9307      	str	r3, [sp, #28]
102e0bc0:	9404      	str	r4, [sp, #16]
102e0bc2:	4699      	mov	r9, r3
102e0bc4:	f7ff fad9 	bl	102e017a <_strtod_r+0x14a>
102e0bc8:	2d00      	cmp	r5, #0
102e0bca:	d101      	bne.n	102e0bd0 <_strtod_r+0xba0>
102e0bcc:	f7ff fc06 	bl	102e03dc <_strtod_r+0x3ac>
102e0bd0:	426d      	negs	r5, r5
102e0bd2:	230f      	movs	r3, #15
102e0bd4:	402b      	ands	r3, r5
102e0bd6:	d00a      	beq.n	102e0bee <_strtod_r+0xbbe>
102e0bd8:	4aa7      	ldr	r2, [pc, #668]	; (102e0e78 <_strtod_r+0xe48>)
102e0bda:	00db      	lsls	r3, r3, #3
102e0bdc:	18d3      	adds	r3, r2, r3
102e0bde:	9806      	ldr	r0, [sp, #24]
102e0be0:	9907      	ldr	r1, [sp, #28]
102e0be2:	681a      	ldr	r2, [r3, #0]
102e0be4:	685b      	ldr	r3, [r3, #4]
102e0be6:	f003 f981 	bl	102e3eec <____aeabi_ddiv_from_thumb>
102e0bea:	9006      	str	r0, [sp, #24]
102e0bec:	9107      	str	r1, [sp, #28]
102e0bee:	112d      	asrs	r5, r5, #4
102e0bf0:	d101      	bne.n	102e0bf6 <_strtod_r+0xbc6>
102e0bf2:	f7ff fbf3 	bl	102e03dc <_strtod_r+0x3ac>
102e0bf6:	2d1f      	cmp	r5, #31
102e0bf8:	dc3b      	bgt.n	102e0c72 <_strtod_r+0xc42>
102e0bfa:	06eb      	lsls	r3, r5, #27
102e0bfc:	246a      	movs	r4, #106	; 0x6a
102e0bfe:	17db      	asrs	r3, r3, #31
102e0c00:	401c      	ands	r4, r3
102e0c02:	9409      	str	r4, [sp, #36]	; 0x24
102e0c04:	2d00      	cmp	r5, #0
102e0c06:	dd11      	ble.n	102e0c2c <_strtod_r+0xbfc>
102e0c08:	2201      	movs	r2, #1
102e0c0a:	9806      	ldr	r0, [sp, #24]
102e0c0c:	9907      	ldr	r1, [sp, #28]
102e0c0e:	4c9b      	ldr	r4, [pc, #620]	; (102e0e7c <_strtod_r+0xe4c>)
102e0c10:	4690      	mov	r8, r2
102e0c12:	4643      	mov	r3, r8
102e0c14:	422b      	tst	r3, r5
102e0c16:	d003      	beq.n	102e0c20 <_strtod_r+0xbf0>
102e0c18:	6822      	ldr	r2, [r4, #0]
102e0c1a:	6863      	ldr	r3, [r4, #4]
102e0c1c:	f003 f992 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e0c20:	106d      	asrs	r5, r5, #1
102e0c22:	3408      	adds	r4, #8
102e0c24:	2d00      	cmp	r5, #0
102e0c26:	d1f4      	bne.n	102e0c12 <_strtod_r+0xbe2>
102e0c28:	9006      	str	r0, [sp, #24]
102e0c2a:	9107      	str	r1, [sp, #28]
102e0c2c:	9c09      	ldr	r4, [sp, #36]	; 0x24
102e0c2e:	2c00      	cmp	r4, #0
102e0c30:	d011      	beq.n	102e0c56 <_strtod_r+0xc26>
102e0c32:	9a07      	ldr	r2, [sp, #28]
102e0c34:	0053      	lsls	r3, r2, #1
102e0c36:	0d5b      	lsrs	r3, r3, #21
102e0c38:	216b      	movs	r1, #107	; 0x6b
102e0c3a:	1acb      	subs	r3, r1, r3
102e0c3c:	2b00      	cmp	r3, #0
102e0c3e:	dd0a      	ble.n	102e0c56 <_strtod_r+0xc26>
102e0c40:	2b1f      	cmp	r3, #31
102e0c42:	dc00      	bgt.n	102e0c46 <_strtod_r+0xc16>
102e0c44:	e109      	b.n	102e0e5a <_strtod_r+0xe2a>
102e0c46:	2400      	movs	r4, #0
102e0c48:	9406      	str	r4, [sp, #24]
102e0c4a:	2b34      	cmp	r3, #52	; 0x34
102e0c4c:	dc00      	bgt.n	102e0c50 <_strtod_r+0xc20>
102e0c4e:	e127      	b.n	102e0ea0 <_strtod_r+0xe70>
102e0c50:	23dc      	movs	r3, #220	; 0xdc
102e0c52:	049b      	lsls	r3, r3, #18
102e0c54:	9307      	str	r3, [sp, #28]
102e0c56:	9807      	ldr	r0, [sp, #28]
102e0c58:	9c06      	ldr	r4, [sp, #24]
102e0c5a:	4681      	mov	r9, r0
102e0c5c:	4649      	mov	r1, r9
102e0c5e:	1c20      	adds	r0, r4, #0
102e0c60:	4b82      	ldr	r3, [pc, #520]	; (102e0e6c <_strtod_r+0xe3c>)
102e0c62:	4a81      	ldr	r2, [pc, #516]	; (102e0e68 <_strtod_r+0xe38>)
102e0c64:	9404      	str	r4, [sp, #16]
102e0c66:	f003 f971 	bl	102e3f4c <____aeabi_dcmpeq_from_thumb>
102e0c6a:	2800      	cmp	r0, #0
102e0c6c:	d101      	bne.n	102e0c72 <_strtod_r+0xc42>
102e0c6e:	f7ff fbbb 	bl	102e03e8 <_strtod_r+0x3b8>
102e0c72:	4654      	mov	r4, sl
102e0c74:	2322      	movs	r3, #34	; 0x22
102e0c76:	6023      	str	r3, [r4, #0]
102e0c78:	2400      	movs	r4, #0
102e0c7a:	9404      	str	r4, [sp, #16]
102e0c7c:	46a1      	mov	r9, r4
102e0c7e:	f7ff fa7c 	bl	102e017a <_strtod_r+0x14a>
102e0c82:	2400      	movs	r4, #0
102e0c84:	940a      	str	r4, [sp, #40]	; 0x28
102e0c86:	4c7e      	ldr	r4, [pc, #504]	; (102e0e80 <_strtod_r+0xe50>)
102e0c88:	2200      	movs	r2, #0
102e0c8a:	4b7e      	ldr	r3, [pc, #504]	; (102e0e84 <_strtod_r+0xe54>)
102e0c8c:	9402      	str	r4, [sp, #8]
102e0c8e:	e5d7      	b.n	102e0840 <_strtod_r+0x810>
102e0c90:	2100      	movs	r1, #0
102e0c92:	46b9      	mov	r9, r7
102e0c94:	468b      	mov	fp, r1
102e0c96:	2600      	movs	r6, #0
102e0c98:	2400      	movs	r4, #0
102e0c9a:	f7ff fa16 	bl	102e00ca <_strtod_r+0x9a>
102e0c9e:	2200      	movs	r2, #0
102e0ca0:	46b9      	mov	r9, r7
102e0ca2:	4693      	mov	fp, r2
102e0ca4:	2600      	movs	r6, #0
102e0ca6:	2400      	movs	r4, #0
102e0ca8:	f7ff fa0f 	bl	102e00ca <_strtod_r+0x9a>
102e0cac:	2400      	movs	r4, #0
102e0cae:	3701      	adds	r7, #1
102e0cb0:	9715      	str	r7, [sp, #84]	; 0x54
102e0cb2:	9404      	str	r4, [sp, #16]
102e0cb4:	46a1      	mov	r9, r4
102e0cb6:	f7ff fa60 	bl	102e017a <_strtod_r+0x14a>
102e0cba:	2d69      	cmp	r5, #105	; 0x69
102e0cbc:	d101      	bne.n	102e0cc2 <_strtod_r+0xc92>
102e0cbe:	f7ff fa34 	bl	102e012a <_strtod_r+0xfa>
102e0cc2:	2d6e      	cmp	r5, #110	; 0x6e
102e0cc4:	d001      	beq.n	102e0cca <_strtod_r+0xc9a>
102e0cc6:	f7ff fa41 	bl	102e014c <_strtod_r+0x11c>
102e0cca:	9a15      	ldr	r2, [sp, #84]	; 0x54
102e0ccc:	496e      	ldr	r1, [pc, #440]	; (102e0e88 <_strtod_r+0xe58>)
102e0cce:	7808      	ldrb	r0, [r1, #0]
102e0cd0:	3101      	adds	r1, #1
102e0cd2:	2800      	cmp	r0, #0
102e0cd4:	d101      	bne.n	102e0cda <_strtod_r+0xcaa>
102e0cd6:	f7ff fb21 	bl	102e031c <_strtod_r+0x2ec>
102e0cda:	3201      	adds	r2, #1
102e0cdc:	7813      	ldrb	r3, [r2, #0]
102e0cde:	2b40      	cmp	r3, #64	; 0x40
102e0ce0:	dd02      	ble.n	102e0ce8 <_strtod_r+0xcb8>
102e0ce2:	2b5a      	cmp	r3, #90	; 0x5a
102e0ce4:	dc00      	bgt.n	102e0ce8 <_strtod_r+0xcb8>
102e0ce6:	3320      	adds	r3, #32
102e0ce8:	4283      	cmp	r3, r0
102e0cea:	d0f0      	beq.n	102e0cce <_strtod_r+0xc9e>
102e0cec:	f7ff fa2e 	bl	102e014c <_strtod_r+0x11c>
102e0cf0:	9c10      	ldr	r4, [sp, #64]	; 0x40
102e0cf2:	2325      	movs	r3, #37	; 0x25
102e0cf4:	1bdb      	subs	r3, r3, r7
102e0cf6:	429c      	cmp	r4, r3
102e0cf8:	dd01      	ble.n	102e0cfe <_strtod_r+0xcce>
102e0cfa:	f7ff fb55 	bl	102e03a8 <_strtod_r+0x378>
102e0cfe:	230f      	movs	r3, #15
102e0d00:	1bdf      	subs	r7, r3, r7
102e0d02:	4c5d      	ldr	r4, [pc, #372]	; (102e0e78 <_strtod_r+0xe48>)
102e0d04:	00fb      	lsls	r3, r7, #3
102e0d06:	18e3      	adds	r3, r4, r3
102e0d08:	6818      	ldr	r0, [r3, #0]
102e0d0a:	6859      	ldr	r1, [r3, #4]
102e0d0c:	9a06      	ldr	r2, [sp, #24]
102e0d0e:	9b07      	ldr	r3, [sp, #28]
102e0d10:	f003 f918 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e0d14:	9a10      	ldr	r2, [sp, #64]	; 0x40
102e0d16:	1bd7      	subs	r7, r2, r7
102e0d18:	00ff      	lsls	r7, r7, #3
102e0d1a:	19e4      	adds	r4, r4, r7
102e0d1c:	6822      	ldr	r2, [r4, #0]
102e0d1e:	6863      	ldr	r3, [r4, #4]
102e0d20:	f003 f910 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e0d24:	9004      	str	r0, [sp, #16]
102e0d26:	4689      	mov	r9, r1
102e0d28:	f7ff fa27 	bl	102e017a <_strtod_r+0x14a>
102e0d2c:	9807      	ldr	r0, [sp, #28]
102e0d2e:	0303      	lsls	r3, r0, #12
102e0d30:	d13b      	bne.n	102e0daa <_strtod_r+0xd7a>
102e0d32:	9b06      	ldr	r3, [sp, #24]
102e0d34:	2b00      	cmp	r3, #0
102e0d36:	d100      	bne.n	102e0d3a <_strtod_r+0xd0a>
102e0d38:	e689      	b.n	102e0a4e <_strtod_r+0xa1e>
102e0d3a:	07d8      	lsls	r0, r3, #31
102e0d3c:	d400      	bmi.n	102e0d40 <_strtod_r+0xd10>
102e0d3e:	e6ff      	b.n	102e0b40 <_strtod_r+0xb10>
102e0d40:	9804      	ldr	r0, [sp, #16]
102e0d42:	4649      	mov	r1, r9
102e0d44:	f001 fde2 	bl	102e290c <__ulp>
102e0d48:	1c02      	adds	r2, r0, #0
102e0d4a:	1c0b      	adds	r3, r1, #0
102e0d4c:	9804      	ldr	r0, [sp, #16]
102e0d4e:	4649      	mov	r1, r9
102e0d50:	f003 f8c4 	bl	102e3edc <____aeabi_dsub_from_thumb>
102e0d54:	4b45      	ldr	r3, [pc, #276]	; (102e0e6c <_strtod_r+0xe3c>)
102e0d56:	4a44      	ldr	r2, [pc, #272]	; (102e0e68 <_strtod_r+0xe38>)
102e0d58:	9006      	str	r0, [sp, #24]
102e0d5a:	9107      	str	r1, [sp, #28]
102e0d5c:	f003 f8f6 	bl	102e3f4c <____aeabi_dcmpeq_from_thumb>
102e0d60:	2800      	cmp	r0, #0
102e0d62:	d000      	beq.n	102e0d66 <_strtod_r+0xd36>
102e0d64:	e5ba      	b.n	102e08dc <_strtod_r+0x8ac>
102e0d66:	e6eb      	b.n	102e0b40 <_strtod_r+0xb10>
102e0d68:	4948      	ldr	r1, [pc, #288]	; (102e0e8c <_strtod_r+0xe5c>)
102e0d6a:	f7ff fa79 	bl	102e0260 <_strtod_r+0x230>
102e0d6e:	9c10      	ldr	r4, [sp, #64]	; 0x40
102e0d70:	3416      	adds	r4, #22
102e0d72:	da01      	bge.n	102e0d78 <_strtod_r+0xd48>
102e0d74:	f7ff fb18 	bl	102e03a8 <_strtod_r+0x378>
102e0d78:	9c10      	ldr	r4, [sp, #64]	; 0x40
102e0d7a:	4a3f      	ldr	r2, [pc, #252]	; (102e0e78 <_strtod_r+0xe48>)
102e0d7c:	00e3      	lsls	r3, r4, #3
102e0d7e:	1ad3      	subs	r3, r2, r3
102e0d80:	9806      	ldr	r0, [sp, #24]
102e0d82:	9907      	ldr	r1, [sp, #28]
102e0d84:	681a      	ldr	r2, [r3, #0]
102e0d86:	685b      	ldr	r3, [r3, #4]
102e0d88:	f003 f8b0 	bl	102e3eec <____aeabi_ddiv_from_thumb>
102e0d8c:	9004      	str	r0, [sp, #16]
102e0d8e:	4689      	mov	r9, r1
102e0d90:	f7ff f9f3 	bl	102e017a <_strtod_r+0x14a>
102e0d94:	2300      	movs	r3, #0
102e0d96:	2f10      	cmp	r7, #16
102e0d98:	dd00      	ble.n	102e0d9c <_strtod_r+0xd6c>
102e0d9a:	e629      	b.n	102e09f0 <_strtod_r+0x9c0>
102e0d9c:	4658      	mov	r0, fp
102e0d9e:	0082      	lsls	r2, r0, #2
102e0da0:	445a      	add	r2, fp
102e0da2:	0052      	lsls	r2, r2, #1
102e0da4:	4462      	add	r2, ip
102e0da6:	4693      	mov	fp, r2
102e0da8:	e622      	b.n	102e09f0 <_strtod_r+0x9c0>
102e0daa:	9b06      	ldr	r3, [sp, #24]
102e0dac:	e7c5      	b.n	102e0d3a <_strtod_r+0xd0a>
102e0dae:	2300      	movs	r3, #0
102e0db0:	f7ff faec 	bl	102e038c <_strtod_r+0x35c>
102e0db4:	9c06      	ldr	r4, [sp, #24]
102e0db6:	20d4      	movs	r0, #212	; 0xd4
102e0db8:	0480      	lsls	r0, r0, #18
102e0dba:	181b      	adds	r3, r3, r0
102e0dbc:	9404      	str	r4, [sp, #16]
102e0dbe:	2400      	movs	r4, #0
102e0dc0:	9307      	str	r3, [sp, #28]
102e0dc2:	4699      	mov	r9, r3
102e0dc4:	9409      	str	r4, [sp, #36]	; 0x24
102e0dc6:	f7ff fb0f 	bl	102e03e8 <_strtod_r+0x3b8>
102e0dca:	9315      	str	r3, [sp, #84]	; 0x54
102e0dcc:	4930      	ldr	r1, [pc, #192]	; (102e0e90 <_strtod_r+0xe60>)
102e0dce:	1c1c      	adds	r4, r3, #0
102e0dd0:	7808      	ldrb	r0, [r1, #0]
102e0dd2:	3301      	adds	r3, #1
102e0dd4:	3101      	adds	r1, #1
102e0dd6:	2800      	cmp	r0, #0
102e0dd8:	d029      	beq.n	102e0e2e <_strtod_r+0xdfe>
102e0dda:	781a      	ldrb	r2, [r3, #0]
102e0ddc:	2a40      	cmp	r2, #64	; 0x40
102e0dde:	dd02      	ble.n	102e0de6 <_strtod_r+0xdb6>
102e0de0:	2a5a      	cmp	r2, #90	; 0x5a
102e0de2:	dc00      	bgt.n	102e0de6 <_strtod_r+0xdb6>
102e0de4:	3220      	adds	r2, #32
102e0de6:	4282      	cmp	r2, r0
102e0de8:	d0f2      	beq.n	102e0dd0 <_strtod_r+0xda0>
102e0dea:	1c63      	adds	r3, r4, #1
102e0dec:	9315      	str	r3, [sp, #84]	; 0x54
102e0dee:	4920      	ldr	r1, [pc, #128]	; (102e0e70 <_strtod_r+0xe40>)
102e0df0:	2200      	movs	r2, #0
102e0df2:	9107      	str	r1, [sp, #28]
102e0df4:	9206      	str	r2, [sp, #24]
102e0df6:	f7ff fa9c 	bl	102e0332 <_strtod_r+0x302>
102e0dfa:	9a08      	ldr	r2, [sp, #32]
102e0dfc:	4645      	mov	r5, r8
102e0dfe:	464c      	mov	r4, r9
102e0e00:	46d8      	mov	r8, fp
102e0e02:	4691      	mov	r9, r2
102e0e04:	46b3      	mov	fp, r6
102e0e06:	e54a      	b.n	102e089e <_strtod_r+0x86e>
102e0e08:	9807      	ldr	r0, [sp, #28]
102e0e0a:	4b19      	ldr	r3, [pc, #100]	; (102e0e70 <_strtod_r+0xe40>)
102e0e0c:	4921      	ldr	r1, [pc, #132]	; (102e0e94 <_strtod_r+0xe64>)
102e0e0e:	4003      	ands	r3, r0
102e0e10:	4a18      	ldr	r2, [pc, #96]	; (102e0e74 <_strtod_r+0xe44>)
102e0e12:	185b      	adds	r3, r3, r1
102e0e14:	431a      	orrs	r2, r3
102e0e16:	2301      	movs	r3, #1
102e0e18:	425b      	negs	r3, r3
102e0e1a:	9207      	str	r2, [sp, #28]
102e0e1c:	9306      	str	r3, [sp, #24]
102e0e1e:	e68f      	b.n	102e0b40 <_strtod_r+0xb10>
102e0e20:	2101      	movs	r1, #1
102e0e22:	4249      	negs	r1, r1
102e0e24:	e682      	b.n	102e0b2c <_strtod_r+0xafc>
102e0e26:	4b1c      	ldr	r3, [pc, #112]	; (102e0e98 <_strtod_r+0xe68>)
102e0e28:	2400      	movs	r4, #0
102e0e2a:	469b      	mov	fp, r3
102e0e2c:	e44c      	b.n	102e06c8 <_strtod_r+0x698>
102e0e2e:	9315      	str	r3, [sp, #84]	; 0x54
102e0e30:	e7dd      	b.n	102e0dee <_strtod_r+0xdbe>
102e0e32:	1c3b      	adds	r3, r7, #0
102e0e34:	e5d3      	b.n	102e09de <_strtod_r+0x9ae>
102e0e36:	4919      	ldr	r1, [pc, #100]	; (102e0e9c <_strtod_r+0xe6c>)
102e0e38:	a815      	add	r0, sp, #84	; 0x54
102e0e3a:	3114      	adds	r1, #20
102e0e3c:	aa18      	add	r2, sp, #96	; 0x60
102e0e3e:	f000 fe03 	bl	102e1a48 <__hexnan>
102e0e42:	2805      	cmp	r0, #5
102e0e44:	d001      	beq.n	102e0e4a <_strtod_r+0xe1a>
102e0e46:	f7ff fa70 	bl	102e032a <_strtod_r+0x2fa>
102e0e4a:	9b19      	ldr	r3, [sp, #100]	; 0x64
102e0e4c:	4a08      	ldr	r2, [pc, #32]	; (102e0e70 <_strtod_r+0xe40>)
102e0e4e:	9918      	ldr	r1, [sp, #96]	; 0x60
102e0e50:	431a      	orrs	r2, r3
102e0e52:	9207      	str	r2, [sp, #28]
102e0e54:	9106      	str	r1, [sp, #24]
102e0e56:	f7ff fa6c 	bl	102e0332 <_strtod_r+0x302>
102e0e5a:	2201      	movs	r2, #1
102e0e5c:	9806      	ldr	r0, [sp, #24]
102e0e5e:	4252      	negs	r2, r2
102e0e60:	409a      	lsls	r2, r3
102e0e62:	4010      	ands	r0, r2
102e0e64:	9006      	str	r0, [sp, #24]
102e0e66:	e6f6      	b.n	102e0c56 <_strtod_r+0xc26>
	...
102e0e70:	7ff00000 	.word	0x7ff00000
102e0e74:	000fffff 	.word	0x000fffff
102e0e78:	102edce8 	.word	0x102edce8
102e0e7c:	102edcb0 	.word	0x102edcb0
102e0e80:	3fe00000 	.word	0x3fe00000
102e0e84:	bfe00000 	.word	0xbfe00000
102e0e88:	102f0348 	.word	0x102f0348
102e0e8c:	00004e1f 	.word	0x00004e1f
102e0e90:	102f0340 	.word	0x102f0340
102e0e94:	fff00000 	.word	0xfff00000
102e0e98:	102eddd8 	.word	0x102eddd8
102e0e9c:	f03d4768 	.word	0xf03d4768
102e0ea0:	2101      	movs	r1, #1
102e0ea2:	3b20      	subs	r3, #32
102e0ea4:	4249      	negs	r1, r1
102e0ea6:	4099      	lsls	r1, r3
102e0ea8:	400a      	ands	r2, r1
102e0eaa:	9207      	str	r2, [sp, #28]
102e0eac:	e6d3      	b.n	102e0c56 <_strtod_r+0xc26>
102e0eae:	46c0      	nop			; (mov r8, r8)

102e0eb0 <strtod>:
102e0eb0:	b508      	push	{r3, lr}
102e0eb2:	1c0a      	adds	r2, r1, #0
102e0eb4:	4904      	ldr	r1, [pc, #16]	; (102e0ec8 <strtod+0x18>)
102e0eb6:	1c03      	adds	r3, r0, #0
102e0eb8:	6808      	ldr	r0, [r1, #0]
102e0eba:	1c19      	adds	r1, r3, #0
102e0ebc:	f7ff f8b8 	bl	102e0030 <_strtod_r>
102e0ec0:	bc08      	pop	{r3}
102e0ec2:	bc04      	pop	{r2}
102e0ec4:	4710      	bx	r2
102e0ec6:	46c0      	nop			; (mov r8, r8)
102e0ec8:	f03d4790 	.word	0xf03d4790

102e0ecc <strtof>:
102e0ecc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
102e0ece:	4f26      	ldr	r7, [pc, #152]	; (102e0f68 <strtof+0x9c>)
102e0ed0:	1c03      	adds	r3, r0, #0
102e0ed2:	1c0a      	adds	r2, r1, #0
102e0ed4:	6838      	ldr	r0, [r7, #0]
102e0ed6:	1c19      	adds	r1, r3, #0
102e0ed8:	f7ff f8aa 	bl	102e0030 <_strtod_r>
102e0edc:	1c0d      	adds	r5, r1, #0
102e0ede:	1c04      	adds	r4, r0, #0
102e0ee0:	f003 f810 	bl	102e3f04 <____aeabi_d2f_from_thumb>
102e0ee4:	2100      	movs	r1, #0
102e0ee6:	1c06      	adds	r6, r0, #0
102e0ee8:	f002 fff4 	bl	102e3ed4 <____aeabi_fcmpeq_from_thumb>
102e0eec:	2800      	cmp	r0, #0
102e0eee:	d00e      	beq.n	102e0f0e <strtof+0x42>
102e0ef0:	1c20      	adds	r0, r4, #0
102e0ef2:	1c29      	adds	r1, r5, #0
102e0ef4:	4b17      	ldr	r3, [pc, #92]	; (102e0f54 <strtof+0x88>)
102e0ef6:	4a16      	ldr	r2, [pc, #88]	; (102e0f50 <strtof+0x84>)
102e0ef8:	f003 f828 	bl	102e3f4c <____aeabi_dcmpeq_from_thumb>
102e0efc:	2800      	cmp	r0, #0
102e0efe:	d106      	bne.n	102e0f0e <strtof+0x42>
102e0f00:	683b      	ldr	r3, [r7, #0]
102e0f02:	2222      	movs	r2, #34	; 0x22
102e0f04:	601a      	str	r2, [r3, #0]
102e0f06:	1c30      	adds	r0, r6, #0
102e0f08:	bcf8      	pop	{r3, r4, r5, r6, r7}
102e0f0a:	bc02      	pop	{r1}
102e0f0c:	4708      	bx	r1
102e0f0e:	1c30      	adds	r0, r6, #0
102e0f10:	4916      	ldr	r1, [pc, #88]	; (102e0f6c <strtof+0xa0>)
102e0f12:	f002 ffd7 	bl	102e3ec4 <____aeabi_fcmpgt_from_thumb>
102e0f16:	2800      	cmp	r0, #0
102e0f18:	d10e      	bne.n	102e0f38 <strtof+0x6c>
102e0f1a:	1c30      	adds	r0, r6, #0
102e0f1c:	4914      	ldr	r1, [pc, #80]	; (102e0f70 <strtof+0xa4>)
102e0f1e:	f002 fff5 	bl	102e3f0c <____aeabi_fcmplt_from_thumb>
102e0f22:	2800      	cmp	r0, #0
102e0f24:	d0ef      	beq.n	102e0f06 <strtof+0x3a>
102e0f26:	1c20      	adds	r0, r4, #0
102e0f28:	1c29      	adds	r1, r5, #0
102e0f2a:	4a0b      	ldr	r2, [pc, #44]	; (102e0f58 <strtof+0x8c>)
102e0f2c:	4b0b      	ldr	r3, [pc, #44]	; (102e0f5c <strtof+0x90>)
102e0f2e:	f002 ffe1 	bl	102e3ef4 <____aeabi_dcmplt_from_thumb>
102e0f32:	2800      	cmp	r0, #0
102e0f34:	d0e4      	beq.n	102e0f00 <strtof+0x34>
102e0f36:	e7e6      	b.n	102e0f06 <strtof+0x3a>
102e0f38:	1c20      	adds	r0, r4, #0
102e0f3a:	1c29      	adds	r1, r5, #0
102e0f3c:	4a08      	ldr	r2, [pc, #32]	; (102e0f60 <strtof+0x94>)
102e0f3e:	4b09      	ldr	r3, [pc, #36]	; (102e0f64 <strtof+0x98>)
102e0f40:	f002 ffc4 	bl	102e3ecc <____aeabi_dcmpgt_from_thumb>
102e0f44:	2800      	cmp	r0, #0
102e0f46:	d0db      	beq.n	102e0f00 <strtof+0x34>
102e0f48:	e7e7      	b.n	102e0f1a <strtof+0x4e>
102e0f4a:	46c0      	nop			; (mov r8, r8)
102e0f4c:	46c0      	nop			; (mov r8, r8)
102e0f4e:	46c0      	nop			; (mov r8, r8)
	...
102e0f58:	ffffffff 	.word	0xffffffff
102e0f5c:	ffefffff 	.word	0xffefffff
102e0f60:	ffffffff 	.word	0xffffffff
102e0f64:	7fefffff 	.word	0x7fefffff
102e0f68:	f03d4790 	.word	0xf03d4790
102e0f6c:	7f7fffff 	.word	0x7f7fffff
102e0f70:	ff7fffff 	.word	0xff7fffff
102e0f74:	46c0      	nop			; (mov r8, r8)
102e0f76:	46c0      	nop			; (mov r8, r8)

102e0f78 <strtok>:
102e0f78:	b508      	push	{r3, lr}
102e0f7a:	4b04      	ldr	r3, [pc, #16]	; (102e0f8c <strtok+0x14>)
102e0f7c:	681a      	ldr	r2, [r3, #0]
102e0f7e:	2301      	movs	r3, #1
102e0f80:	325c      	adds	r2, #92	; 0x5c
102e0f82:	f000 f805 	bl	102e0f90 <__strtok_r>
102e0f86:	bc08      	pop	{r3}
102e0f88:	bc02      	pop	{r1}
102e0f8a:	4708      	bx	r1
102e0f8c:	f03d4790 	.word	0xf03d4790

102e0f90 <__strtok_r>:
102e0f90:	b5f0      	push	{r4, r5, r6, r7, lr}
102e0f92:	2800      	cmp	r0, #0
102e0f94:	d029      	beq.n	102e0fea <__strtok_r+0x5a>
102e0f96:	7807      	ldrb	r7, [r0, #0]
102e0f98:	1c46      	adds	r6, r0, #1
102e0f9a:	1c0c      	adds	r4, r1, #0
102e0f9c:	7825      	ldrb	r5, [r4, #0]
102e0f9e:	3401      	adds	r4, #1
102e0fa0:	2d00      	cmp	r5, #0
102e0fa2:	d005      	beq.n	102e0fb0 <__strtok_r+0x20>
102e0fa4:	42af      	cmp	r7, r5
102e0fa6:	d1f9      	bne.n	102e0f9c <__strtok_r+0xc>
102e0fa8:	2b00      	cmp	r3, #0
102e0faa:	d01a      	beq.n	102e0fe2 <__strtok_r+0x52>
102e0fac:	1c30      	adds	r0, r6, #0
102e0fae:	e7f2      	b.n	102e0f96 <__strtok_r+0x6>
102e0fb0:	1c30      	adds	r0, r6, #0
102e0fb2:	2f00      	cmp	r7, #0
102e0fb4:	d102      	bne.n	102e0fbc <__strtok_r+0x2c>
102e0fb6:	e01d      	b.n	102e0ff4 <__strtok_r+0x64>
102e0fb8:	2c00      	cmp	r4, #0
102e0fba:	d102      	bne.n	102e0fc2 <__strtok_r+0x32>
102e0fbc:	7835      	ldrb	r5, [r6, #0]
102e0fbe:	1c0b      	adds	r3, r1, #0
102e0fc0:	3601      	adds	r6, #1
102e0fc2:	781c      	ldrb	r4, [r3, #0]
102e0fc4:	3301      	adds	r3, #1
102e0fc6:	42a5      	cmp	r5, r4
102e0fc8:	d1f6      	bne.n	102e0fb8 <__strtok_r+0x28>
102e0fca:	2d00      	cmp	r5, #0
102e0fcc:	d007      	beq.n	102e0fde <__strtok_r+0x4e>
102e0fce:	1e73      	subs	r3, r6, #1
102e0fd0:	2100      	movs	r1, #0
102e0fd2:	7019      	strb	r1, [r3, #0]
102e0fd4:	6016      	str	r6, [r2, #0]
102e0fd6:	3801      	subs	r0, #1
102e0fd8:	bcf0      	pop	{r4, r5, r6, r7}
102e0fda:	bc02      	pop	{r1}
102e0fdc:	4708      	bx	r1
102e0fde:	2600      	movs	r6, #0
102e0fe0:	e7f8      	b.n	102e0fd4 <__strtok_r+0x44>
102e0fe2:	6016      	str	r6, [r2, #0]
102e0fe4:	3e01      	subs	r6, #1
102e0fe6:	7033      	strb	r3, [r6, #0]
102e0fe8:	e7f6      	b.n	102e0fd8 <__strtok_r+0x48>
102e0fea:	6810      	ldr	r0, [r2, #0]
102e0fec:	2800      	cmp	r0, #0
102e0fee:	d1d2      	bne.n	102e0f96 <__strtok_r+0x6>
102e0ff0:	2000      	movs	r0, #0
102e0ff2:	e7f1      	b.n	102e0fd8 <__strtok_r+0x48>
102e0ff4:	6017      	str	r7, [r2, #0]
102e0ff6:	2000      	movs	r0, #0
102e0ff8:	e7ee      	b.n	102e0fd8 <__strtok_r+0x48>
102e0ffa:	46c0      	nop			; (mov r8, r8)

102e0ffc <strtok_r>:
102e0ffc:	b508      	push	{r3, lr}
102e0ffe:	2301      	movs	r3, #1
102e1000:	f7ff ffc6 	bl	102e0f90 <__strtok_r>
102e1004:	bc08      	pop	{r3}
102e1006:	bc02      	pop	{r1}
102e1008:	4708      	bx	r1
102e100a:	46c0      	nop			; (mov r8, r8)

102e100c <_strtol_r>:
102e100c:	b5f0      	push	{r4, r5, r6, r7, lr}
102e100e:	4644      	mov	r4, r8
102e1010:	465f      	mov	r7, fp
102e1012:	4656      	mov	r6, sl
102e1014:	464d      	mov	r5, r9
102e1016:	b4f0      	push	{r4, r5, r6, r7}
102e1018:	4698      	mov	r8, r3
102e101a:	4b57      	ldr	r3, [pc, #348]	; (102e1178 <_strtol_r+0x16c>)
102e101c:	b087      	sub	sp, #28
102e101e:	9005      	str	r0, [sp, #20]
102e1020:	9102      	str	r1, [sp, #8]
102e1022:	681f      	ldr	r7, [r3, #0]
102e1024:	9203      	str	r2, [sp, #12]
102e1026:	1c0c      	adds	r4, r1, #0
102e1028:	2208      	movs	r2, #8
102e102a:	7825      	ldrb	r5, [r4, #0]
102e102c:	197b      	adds	r3, r7, r5
102e102e:	785b      	ldrb	r3, [r3, #1]
102e1030:	3401      	adds	r4, #1
102e1032:	421a      	tst	r2, r3
102e1034:	d1f9      	bne.n	102e102a <_strtol_r+0x1e>
102e1036:	2d2d      	cmp	r5, #45	; 0x2d
102e1038:	d100      	bne.n	102e103c <_strtol_r+0x30>
102e103a:	e082      	b.n	102e1142 <_strtol_r+0x136>
102e103c:	2200      	movs	r2, #0
102e103e:	9204      	str	r2, [sp, #16]
102e1040:	2d2b      	cmp	r5, #43	; 0x2b
102e1042:	d100      	bne.n	102e1046 <_strtol_r+0x3a>
102e1044:	e082      	b.n	102e114c <_strtol_r+0x140>
102e1046:	2310      	movs	r3, #16
102e1048:	4641      	mov	r1, r8
102e104a:	4399      	bics	r1, r3
102e104c:	46c2      	mov	sl, r8
102e104e:	d10b      	bne.n	102e1068 <_strtol_r+0x5c>
102e1050:	4641      	mov	r1, r8
102e1052:	424b      	negs	r3, r1
102e1054:	414b      	adcs	r3, r1
102e1056:	2d30      	cmp	r5, #48	; 0x30
102e1058:	d100      	bne.n	102e105c <_strtol_r+0x50>
102e105a:	e07a      	b.n	102e1152 <_strtol_r+0x146>
102e105c:	2b00      	cmp	r3, #0
102e105e:	d100      	bne.n	102e1062 <_strtol_r+0x56>
102e1060:	e088      	b.n	102e1174 <_strtol_r+0x168>
102e1062:	230a      	movs	r3, #10
102e1064:	469a      	mov	sl, r3
102e1066:	4698      	mov	r8, r3
102e1068:	9904      	ldr	r1, [sp, #16]
102e106a:	2680      	movs	r6, #128	; 0x80
102e106c:	424b      	negs	r3, r1
102e106e:	414b      	adcs	r3, r1
102e1070:	0636      	lsls	r6, r6, #24
102e1072:	1af6      	subs	r6, r6, r3
102e1074:	1c30      	adds	r0, r6, #0
102e1076:	4651      	mov	r1, sl
102e1078:	f002 ff40 	bl	102e3efc <____aeabi_uidivmod_from_thumb>
102e107c:	1c30      	adds	r0, r6, #0
102e107e:	4689      	mov	r9, r1
102e1080:	4651      	mov	r1, sl
102e1082:	f002 ff47 	bl	102e3f14 <____aeabi_uidiv_from_thumb>
102e1086:	2103      	movs	r1, #3
102e1088:	2304      	movs	r3, #4
102e108a:	468b      	mov	fp, r1
102e108c:	4641      	mov	r1, r8
102e108e:	2600      	movs	r6, #0
102e1090:	2200      	movs	r2, #0
102e1092:	469c      	mov	ip, r3
102e1094:	9101      	str	r1, [sp, #4]
102e1096:	e016      	b.n	102e10c6 <_strtol_r+0xba>
102e1098:	9b01      	ldr	r3, [sp, #4]
102e109a:	3d30      	subs	r5, #48	; 0x30
102e109c:	42ab      	cmp	r3, r5
102e109e:	dd23      	ble.n	102e10e8 <_strtol_r+0xdc>
102e10a0:	4290      	cmp	r0, r2
102e10a2:	d338      	bcc.n	102e1116 <_strtol_r+0x10a>
102e10a4:	2e00      	cmp	r6, #0
102e10a6:	db36      	blt.n	102e1116 <_strtol_r+0x10a>
102e10a8:	2301      	movs	r3, #1
102e10aa:	454d      	cmp	r5, r9
102e10ac:	dc00      	bgt.n	102e10b0 <_strtol_r+0xa4>
102e10ae:	2300      	movs	r3, #0
102e10b0:	061b      	lsls	r3, r3, #24
102e10b2:	d001      	beq.n	102e10b8 <_strtol_r+0xac>
102e10b4:	4282      	cmp	r2, r0
102e10b6:	d02e      	beq.n	102e1116 <_strtol_r+0x10a>
102e10b8:	1c11      	adds	r1, r2, #0
102e10ba:	4652      	mov	r2, sl
102e10bc:	434a      	muls	r2, r1
102e10be:	2601      	movs	r6, #1
102e10c0:	18aa      	adds	r2, r5, r2
102e10c2:	7825      	ldrb	r5, [r4, #0]
102e10c4:	3401      	adds	r4, #1
102e10c6:	197b      	adds	r3, r7, r5
102e10c8:	785b      	ldrb	r3, [r3, #1]
102e10ca:	4661      	mov	r1, ip
102e10cc:	4219      	tst	r1, r3
102e10ce:	d1e3      	bne.n	102e1098 <_strtol_r+0x8c>
102e10d0:	4659      	mov	r1, fp
102e10d2:	400b      	ands	r3, r1
102e10d4:	d008      	beq.n	102e10e8 <_strtol_r+0xdc>
102e10d6:	2157      	movs	r1, #87	; 0x57
102e10d8:	4688      	mov	r8, r1
102e10da:	2b01      	cmp	r3, #1
102e10dc:	d01e      	beq.n	102e111c <_strtol_r+0x110>
102e10de:	9b01      	ldr	r3, [sp, #4]
102e10e0:	4641      	mov	r1, r8
102e10e2:	1a6d      	subs	r5, r5, r1
102e10e4:	42ab      	cmp	r3, r5
102e10e6:	dcdb      	bgt.n	102e10a0 <_strtol_r+0x94>
102e10e8:	9904      	ldr	r1, [sp, #16]
102e10ea:	1c73      	adds	r3, r6, #1
102e10ec:	d019      	beq.n	102e1122 <_strtol_r+0x116>
102e10ee:	2900      	cmp	r1, #0
102e10f0:	d125      	bne.n	102e113e <_strtol_r+0x132>
102e10f2:	9b03      	ldr	r3, [sp, #12]
102e10f4:	1c10      	adds	r0, r2, #0
102e10f6:	2b00      	cmp	r3, #0
102e10f8:	d004      	beq.n	102e1104 <_strtol_r+0xf8>
102e10fa:	2e00      	cmp	r6, #0
102e10fc:	d11c      	bne.n	102e1138 <_strtol_r+0x12c>
102e10fe:	9902      	ldr	r1, [sp, #8]
102e1100:	9a03      	ldr	r2, [sp, #12]
102e1102:	6011      	str	r1, [r2, #0]
102e1104:	b007      	add	sp, #28
102e1106:	bc3c      	pop	{r2, r3, r4, r5}
102e1108:	4690      	mov	r8, r2
102e110a:	4699      	mov	r9, r3
102e110c:	46a2      	mov	sl, r4
102e110e:	46ab      	mov	fp, r5
102e1110:	bcf0      	pop	{r4, r5, r6, r7}
102e1112:	bc02      	pop	{r1}
102e1114:	4708      	bx	r1
102e1116:	2601      	movs	r6, #1
102e1118:	4276      	negs	r6, r6
102e111a:	e7d2      	b.n	102e10c2 <_strtol_r+0xb6>
102e111c:	2337      	movs	r3, #55	; 0x37
102e111e:	4698      	mov	r8, r3
102e1120:	e7dd      	b.n	102e10de <_strtol_r+0xd2>
102e1122:	2080      	movs	r0, #128	; 0x80
102e1124:	424b      	negs	r3, r1
102e1126:	414b      	adcs	r3, r1
102e1128:	0600      	lsls	r0, r0, #24
102e112a:	9a05      	ldr	r2, [sp, #20]
102e112c:	1ac0      	subs	r0, r0, r3
102e112e:	2322      	movs	r3, #34	; 0x22
102e1130:	6013      	str	r3, [r2, #0]
102e1132:	9b03      	ldr	r3, [sp, #12]
102e1134:	2b00      	cmp	r3, #0
102e1136:	d0e5      	beq.n	102e1104 <_strtol_r+0xf8>
102e1138:	3c01      	subs	r4, #1
102e113a:	9402      	str	r4, [sp, #8]
102e113c:	e7df      	b.n	102e10fe <_strtol_r+0xf2>
102e113e:	4252      	negs	r2, r2
102e1140:	e7d7      	b.n	102e10f2 <_strtol_r+0xe6>
102e1142:	2101      	movs	r1, #1
102e1144:	7825      	ldrb	r5, [r4, #0]
102e1146:	9104      	str	r1, [sp, #16]
102e1148:	3401      	adds	r4, #1
102e114a:	e77c      	b.n	102e1046 <_strtol_r+0x3a>
102e114c:	7825      	ldrb	r5, [r4, #0]
102e114e:	3401      	adds	r4, #1
102e1150:	e779      	b.n	102e1046 <_strtol_r+0x3a>
102e1152:	7822      	ldrb	r2, [r4, #0]
102e1154:	2120      	movs	r1, #32
102e1156:	438a      	bics	r2, r1
102e1158:	2a58      	cmp	r2, #88	; 0x58
102e115a:	d005      	beq.n	102e1168 <_strtol_r+0x15c>
102e115c:	2b00      	cmp	r3, #0
102e115e:	d009      	beq.n	102e1174 <_strtol_r+0x168>
102e1160:	2108      	movs	r1, #8
102e1162:	468a      	mov	sl, r1
102e1164:	4688      	mov	r8, r1
102e1166:	e77f      	b.n	102e1068 <_strtol_r+0x5c>
102e1168:	2210      	movs	r2, #16
102e116a:	7865      	ldrb	r5, [r4, #1]
102e116c:	4692      	mov	sl, r2
102e116e:	3402      	adds	r4, #2
102e1170:	4690      	mov	r8, r2
102e1172:	e779      	b.n	102e1068 <_strtol_r+0x5c>
102e1174:	46c2      	mov	sl, r8
102e1176:	e777      	b.n	102e1068 <_strtol_r+0x5c>
102e1178:	f03d4764 	.word	0xf03d4764

102e117c <strtol>:
102e117c:	b538      	push	{r3, r4, r5, lr}
102e117e:	1c13      	adds	r3, r2, #0
102e1180:	4a05      	ldr	r2, [pc, #20]	; (102e1198 <strtol+0x1c>)
102e1182:	1c05      	adds	r5, r0, #0
102e1184:	1c0c      	adds	r4, r1, #0
102e1186:	6810      	ldr	r0, [r2, #0]
102e1188:	1c29      	adds	r1, r5, #0
102e118a:	1c22      	adds	r2, r4, #0
102e118c:	f7ff ff3e 	bl	102e100c <_strtol_r>
102e1190:	bc38      	pop	{r3, r4, r5}
102e1192:	bc02      	pop	{r1}
102e1194:	4708      	bx	r1
102e1196:	46c0      	nop			; (mov r8, r8)
102e1198:	f03d4790 	.word	0xf03d4790

102e119c <_malloc_trim_r>:
102e119c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
102e119e:	1c0f      	adds	r7, r1, #0
102e11a0:	1c04      	adds	r4, r0, #0
102e11a2:	f001 f875 	bl	102e2290 <__malloc_lock>
102e11a6:	4d21      	ldr	r5, [pc, #132]	; (102e122c <_malloc_trim_r+0x90>)
102e11a8:	68ab      	ldr	r3, [r5, #8]
102e11aa:	685e      	ldr	r6, [r3, #4]
102e11ac:	4a20      	ldr	r2, [pc, #128]	; (102e1230 <_malloc_trim_r+0x94>)
102e11ae:	2303      	movs	r3, #3
102e11b0:	439e      	bics	r6, r3
102e11b2:	18b3      	adds	r3, r6, r2
102e11b4:	1bdf      	subs	r7, r3, r7
102e11b6:	0b3f      	lsrs	r7, r7, #12
102e11b8:	4b1e      	ldr	r3, [pc, #120]	; (102e1234 <_malloc_trim_r+0x98>)
102e11ba:	3f01      	subs	r7, #1
102e11bc:	033f      	lsls	r7, r7, #12
102e11be:	429f      	cmp	r7, r3
102e11c0:	dd07      	ble.n	102e11d2 <_malloc_trim_r+0x36>
102e11c2:	1c20      	adds	r0, r4, #0
102e11c4:	2100      	movs	r1, #0
102e11c6:	f001 fd1f 	bl	102e2c08 <_sbrk_r>
102e11ca:	68aa      	ldr	r2, [r5, #8]
102e11cc:	1993      	adds	r3, r2, r6
102e11ce:	4298      	cmp	r0, r3
102e11d0:	d006      	beq.n	102e11e0 <_malloc_trim_r+0x44>
102e11d2:	1c20      	adds	r0, r4, #0
102e11d4:	f001 f85e 	bl	102e2294 <__malloc_unlock>
102e11d8:	2000      	movs	r0, #0
102e11da:	bcf8      	pop	{r3, r4, r5, r6, r7}
102e11dc:	bc02      	pop	{r1}
102e11de:	4708      	bx	r1
102e11e0:	4279      	negs	r1, r7
102e11e2:	1c20      	adds	r0, r4, #0
102e11e4:	f001 fd10 	bl	102e2c08 <_sbrk_r>
102e11e8:	3001      	adds	r0, #1
102e11ea:	d00d      	beq.n	102e1208 <_malloc_trim_r+0x6c>
102e11ec:	68ab      	ldr	r3, [r5, #8]
102e11ee:	1bf6      	subs	r6, r6, r7
102e11f0:	2201      	movs	r2, #1
102e11f2:	4316      	orrs	r6, r2
102e11f4:	605e      	str	r6, [r3, #4]
102e11f6:	4b10      	ldr	r3, [pc, #64]	; (102e1238 <_malloc_trim_r+0x9c>)
102e11f8:	681a      	ldr	r2, [r3, #0]
102e11fa:	1c20      	adds	r0, r4, #0
102e11fc:	1bd7      	subs	r7, r2, r7
102e11fe:	601f      	str	r7, [r3, #0]
102e1200:	f001 f848 	bl	102e2294 <__malloc_unlock>
102e1204:	2001      	movs	r0, #1
102e1206:	e7e8      	b.n	102e11da <_malloc_trim_r+0x3e>
102e1208:	1c20      	adds	r0, r4, #0
102e120a:	2100      	movs	r1, #0
102e120c:	f001 fcfc 	bl	102e2c08 <_sbrk_r>
102e1210:	68ab      	ldr	r3, [r5, #8]
102e1212:	1ac2      	subs	r2, r0, r3
102e1214:	2a0f      	cmp	r2, #15
102e1216:	dddc      	ble.n	102e11d2 <_malloc_trim_r+0x36>
102e1218:	4908      	ldr	r1, [pc, #32]	; (102e123c <_malloc_trim_r+0xa0>)
102e121a:	6809      	ldr	r1, [r1, #0]
102e121c:	1a40      	subs	r0, r0, r1
102e121e:	4906      	ldr	r1, [pc, #24]	; (102e1238 <_malloc_trim_r+0x9c>)
102e1220:	6008      	str	r0, [r1, #0]
102e1222:	2101      	movs	r1, #1
102e1224:	430a      	orrs	r2, r1
102e1226:	605a      	str	r2, [r3, #4]
102e1228:	e7d3      	b.n	102e11d2 <_malloc_trim_r+0x36>
102e122a:	46c0      	nop			; (mov r8, r8)
102e122c:	f03d4c3c 	.word	0xf03d4c3c
102e1230:	00000fef 	.word	0x00000fef
102e1234:	00000fff 	.word	0x00000fff
102e1238:	f03db794 	.word	0xf03db794
102e123c:	f03d5044 	.word	0xf03d5044

102e1240 <_free_r>:
102e1240:	b5f0      	push	{r4, r5, r6, r7, lr}
102e1242:	4647      	mov	r7, r8
102e1244:	b480      	push	{r7}
102e1246:	1c05      	adds	r5, r0, #0
102e1248:	1e0c      	subs	r4, r1, #0
102e124a:	d055      	beq.n	102e12f8 <_free_r+0xb8>
102e124c:	f001 f820 	bl	102e2290 <__malloc_lock>
102e1250:	1c21      	adds	r1, r4, #0
102e1252:	3908      	subs	r1, #8
102e1254:	6848      	ldr	r0, [r1, #4]
102e1256:	2701      	movs	r7, #1
102e1258:	1c03      	adds	r3, r0, #0
102e125a:	43bb      	bics	r3, r7
102e125c:	18ca      	adds	r2, r1, r3
102e125e:	6854      	ldr	r4, [r2, #4]
102e1260:	4680      	mov	r8, r0
102e1262:	2003      	movs	r0, #3
102e1264:	4384      	bics	r4, r0
102e1266:	1c20      	adds	r0, r4, #0
102e1268:	4c54      	ldr	r4, [pc, #336]	; (102e13bc <_free_r+0x17c>)
102e126a:	68a6      	ldr	r6, [r4, #8]
102e126c:	4296      	cmp	r6, r2
102e126e:	d062      	beq.n	102e1336 <_free_r+0xf6>
102e1270:	2600      	movs	r6, #0
102e1272:	46b4      	mov	ip, r6
102e1274:	4646      	mov	r6, r8
102e1276:	6050      	str	r0, [r2, #4]
102e1278:	4237      	tst	r7, r6
102e127a:	d10a      	bne.n	102e1292 <_free_r+0x52>
102e127c:	680e      	ldr	r6, [r1, #0]
102e127e:	1b89      	subs	r1, r1, r6
102e1280:	199b      	adds	r3, r3, r6
102e1282:	1c27      	adds	r7, r4, #0
102e1284:	688e      	ldr	r6, [r1, #8]
102e1286:	3708      	adds	r7, #8
102e1288:	42be      	cmp	r6, r7
102e128a:	d06d      	beq.n	102e1368 <_free_r+0x128>
102e128c:	68cf      	ldr	r7, [r1, #12]
102e128e:	60f7      	str	r7, [r6, #12]
102e1290:	60be      	str	r6, [r7, #8]
102e1292:	1816      	adds	r6, r2, r0
102e1294:	6876      	ldr	r6, [r6, #4]
102e1296:	2701      	movs	r7, #1
102e1298:	423e      	tst	r6, r7
102e129a:	d107      	bne.n	102e12ac <_free_r+0x6c>
102e129c:	181b      	adds	r3, r3, r0
102e129e:	4660      	mov	r0, ip
102e12a0:	2800      	cmp	r0, #0
102e12a2:	d02e      	beq.n	102e1302 <_free_r+0xc2>
102e12a4:	6890      	ldr	r0, [r2, #8]
102e12a6:	68d2      	ldr	r2, [r2, #12]
102e12a8:	60c2      	str	r2, [r0, #12]
102e12aa:	6090      	str	r0, [r2, #8]
102e12ac:	2201      	movs	r2, #1
102e12ae:	1c18      	adds	r0, r3, #0
102e12b0:	4310      	orrs	r0, r2
102e12b2:	4666      	mov	r6, ip
102e12b4:	6048      	str	r0, [r1, #4]
102e12b6:	50cb      	str	r3, [r1, r3]
102e12b8:	2e00      	cmp	r6, #0
102e12ba:	d11a      	bne.n	102e12f2 <_free_r+0xb2>
102e12bc:	4840      	ldr	r0, [pc, #256]	; (102e13c0 <_free_r+0x180>)
102e12be:	4283      	cmp	r3, r0
102e12c0:	d92b      	bls.n	102e131a <_free_r+0xda>
102e12c2:	0a5a      	lsrs	r2, r3, #9
102e12c4:	2a04      	cmp	r2, #4
102e12c6:	d852      	bhi.n	102e136e <_free_r+0x12e>
102e12c8:	099f      	lsrs	r7, r3, #6
102e12ca:	3738      	adds	r7, #56	; 0x38
102e12cc:	0078      	lsls	r0, r7, #1
102e12ce:	0080      	lsls	r0, r0, #2
102e12d0:	1820      	adds	r0, r4, r0
102e12d2:	6882      	ldr	r2, [r0, #8]
102e12d4:	2603      	movs	r6, #3
102e12d6:	4282      	cmp	r2, r0
102e12d8:	d04f      	beq.n	102e137a <_free_r+0x13a>
102e12da:	6854      	ldr	r4, [r2, #4]
102e12dc:	43b4      	bics	r4, r6
102e12de:	42a3      	cmp	r3, r4
102e12e0:	d202      	bcs.n	102e12e8 <_free_r+0xa8>
102e12e2:	6892      	ldr	r2, [r2, #8]
102e12e4:	4290      	cmp	r0, r2
102e12e6:	d1f8      	bne.n	102e12da <_free_r+0x9a>
102e12e8:	68d3      	ldr	r3, [r2, #12]
102e12ea:	60cb      	str	r3, [r1, #12]
102e12ec:	608a      	str	r2, [r1, #8]
102e12ee:	60d1      	str	r1, [r2, #12]
102e12f0:	6099      	str	r1, [r3, #8]
102e12f2:	1c28      	adds	r0, r5, #0
102e12f4:	f000 ffce 	bl	102e2294 <__malloc_unlock>
102e12f8:	bc04      	pop	{r2}
102e12fa:	4690      	mov	r8, r2
102e12fc:	bcf0      	pop	{r4, r5, r6, r7}
102e12fe:	bc01      	pop	{r0}
102e1300:	4700      	bx	r0
102e1302:	6890      	ldr	r0, [r2, #8]
102e1304:	4e2f      	ldr	r6, [pc, #188]	; (102e13c4 <_free_r+0x184>)
102e1306:	42b0      	cmp	r0, r6
102e1308:	d1cd      	bne.n	102e12a6 <_free_r+0x66>
102e130a:	431f      	orrs	r7, r3
102e130c:	60c1      	str	r1, [r0, #12]
102e130e:	6081      	str	r1, [r0, #8]
102e1310:	60c8      	str	r0, [r1, #12]
102e1312:	6088      	str	r0, [r1, #8]
102e1314:	604f      	str	r7, [r1, #4]
102e1316:	50cb      	str	r3, [r1, r3]
102e1318:	e7eb      	b.n	102e12f2 <_free_r+0xb2>
102e131a:	08db      	lsrs	r3, r3, #3
102e131c:	1098      	asrs	r0, r3, #2
102e131e:	4082      	lsls	r2, r0
102e1320:	6860      	ldr	r0, [r4, #4]
102e1322:	00db      	lsls	r3, r3, #3
102e1324:	4302      	orrs	r2, r0
102e1326:	6062      	str	r2, [r4, #4]
102e1328:	18e4      	adds	r4, r4, r3
102e132a:	68a3      	ldr	r3, [r4, #8]
102e132c:	60cc      	str	r4, [r1, #12]
102e132e:	608b      	str	r3, [r1, #8]
102e1330:	60d9      	str	r1, [r3, #12]
102e1332:	60a1      	str	r1, [r4, #8]
102e1334:	e7dd      	b.n	102e12f2 <_free_r+0xb2>
102e1336:	18c3      	adds	r3, r0, r3
102e1338:	4640      	mov	r0, r8
102e133a:	4207      	tst	r7, r0
102e133c:	d106      	bne.n	102e134c <_free_r+0x10c>
102e133e:	680a      	ldr	r2, [r1, #0]
102e1340:	1a89      	subs	r1, r1, r2
102e1342:	68c8      	ldr	r0, [r1, #12]
102e1344:	189b      	adds	r3, r3, r2
102e1346:	688a      	ldr	r2, [r1, #8]
102e1348:	60d0      	str	r0, [r2, #12]
102e134a:	6082      	str	r2, [r0, #8]
102e134c:	2201      	movs	r2, #1
102e134e:	431a      	orrs	r2, r3
102e1350:	604a      	str	r2, [r1, #4]
102e1352:	4a1d      	ldr	r2, [pc, #116]	; (102e13c8 <_free_r+0x188>)
102e1354:	6812      	ldr	r2, [r2, #0]
102e1356:	60a1      	str	r1, [r4, #8]
102e1358:	4293      	cmp	r3, r2
102e135a:	d3ca      	bcc.n	102e12f2 <_free_r+0xb2>
102e135c:	4b1b      	ldr	r3, [pc, #108]	; (102e13cc <_free_r+0x18c>)
102e135e:	1c28      	adds	r0, r5, #0
102e1360:	6819      	ldr	r1, [r3, #0]
102e1362:	f7ff ff1b 	bl	102e119c <_malloc_trim_r>
102e1366:	e7c4      	b.n	102e12f2 <_free_r+0xb2>
102e1368:	2601      	movs	r6, #1
102e136a:	46b4      	mov	ip, r6
102e136c:	e791      	b.n	102e1292 <_free_r+0x52>
102e136e:	2a14      	cmp	r2, #20
102e1370:	d80c      	bhi.n	102e138c <_free_r+0x14c>
102e1372:	1c17      	adds	r7, r2, #0
102e1374:	375b      	adds	r7, #91	; 0x5b
102e1376:	0078      	lsls	r0, r7, #1
102e1378:	e7a9      	b.n	102e12ce <_free_r+0x8e>
102e137a:	10bf      	asrs	r7, r7, #2
102e137c:	2301      	movs	r3, #1
102e137e:	40bb      	lsls	r3, r7
102e1380:	1c1f      	adds	r7, r3, #0
102e1382:	6863      	ldr	r3, [r4, #4]
102e1384:	431f      	orrs	r7, r3
102e1386:	6067      	str	r7, [r4, #4]
102e1388:	1c13      	adds	r3, r2, #0
102e138a:	e7ae      	b.n	102e12ea <_free_r+0xaa>
102e138c:	2a54      	cmp	r2, #84	; 0x54
102e138e:	d803      	bhi.n	102e1398 <_free_r+0x158>
102e1390:	0b1f      	lsrs	r7, r3, #12
102e1392:	376e      	adds	r7, #110	; 0x6e
102e1394:	0078      	lsls	r0, r7, #1
102e1396:	e79a      	b.n	102e12ce <_free_r+0x8e>
102e1398:	20aa      	movs	r0, #170	; 0xaa
102e139a:	0040      	lsls	r0, r0, #1
102e139c:	4282      	cmp	r2, r0
102e139e:	d803      	bhi.n	102e13a8 <_free_r+0x168>
102e13a0:	0bdf      	lsrs	r7, r3, #15
102e13a2:	3777      	adds	r7, #119	; 0x77
102e13a4:	0078      	lsls	r0, r7, #1
102e13a6:	e792      	b.n	102e12ce <_free_r+0x8e>
102e13a8:	4809      	ldr	r0, [pc, #36]	; (102e13d0 <_free_r+0x190>)
102e13aa:	4282      	cmp	r2, r0
102e13ac:	d803      	bhi.n	102e13b6 <_free_r+0x176>
102e13ae:	0c9f      	lsrs	r7, r3, #18
102e13b0:	377c      	adds	r7, #124	; 0x7c
102e13b2:	0078      	lsls	r0, r7, #1
102e13b4:	e78b      	b.n	102e12ce <_free_r+0x8e>
102e13b6:	20fc      	movs	r0, #252	; 0xfc
102e13b8:	277e      	movs	r7, #126	; 0x7e
102e13ba:	e788      	b.n	102e12ce <_free_r+0x8e>
102e13bc:	f03d4c3c 	.word	0xf03d4c3c
102e13c0:	000001ff 	.word	0x000001ff
102e13c4:	f03d4c44 	.word	0xf03d4c44
102e13c8:	f03d5048 	.word	0xf03d5048
102e13cc:	f03db790 	.word	0xf03db790
102e13d0:	00000554 	.word	0x00000554

102e13d4 <rshift>:
102e13d4:	b5f0      	push	{r4, r5, r6, r7, lr}
102e13d6:	2214      	movs	r2, #20
102e13d8:	1812      	adds	r2, r2, r0
102e13da:	464f      	mov	r7, r9
102e13dc:	4691      	mov	r9, r2
102e13de:	6902      	ldr	r2, [r0, #16]
102e13e0:	4646      	mov	r6, r8
102e13e2:	b4c0      	push	{r6, r7}
102e13e4:	114b      	asrs	r3, r1, #5
102e13e6:	4293      	cmp	r3, r2
102e13e8:	da2e      	bge.n	102e1448 <rshift+0x74>
102e13ea:	3304      	adds	r3, #4
102e13ec:	009b      	lsls	r3, r3, #2
102e13ee:	3204      	adds	r2, #4
102e13f0:	18c3      	adds	r3, r0, r3
102e13f2:	1d1c      	adds	r4, r3, #4
102e13f4:	0092      	lsls	r2, r2, #2
102e13f6:	1882      	adds	r2, r0, r2
102e13f8:	46a4      	mov	ip, r4
102e13fa:	241f      	movs	r4, #31
102e13fc:	3204      	adds	r2, #4
102e13fe:	4021      	ands	r1, r4
102e1400:	d02c      	beq.n	102e145c <rshift+0x88>
102e1402:	2420      	movs	r4, #32
102e1404:	1a64      	subs	r4, r4, r1
102e1406:	46a0      	mov	r8, r4
102e1408:	685c      	ldr	r4, [r3, #4]
102e140a:	4663      	mov	r3, ip
102e140c:	3304      	adds	r3, #4
102e140e:	40cc      	lsrs	r4, r1
102e1410:	429a      	cmp	r2, r3
102e1412:	d93e      	bls.n	102e1492 <rshift+0xbe>
102e1414:	464d      	mov	r5, r9
102e1416:	681e      	ldr	r6, [r3, #0]
102e1418:	4647      	mov	r7, r8
102e141a:	40be      	lsls	r6, r7
102e141c:	4334      	orrs	r4, r6
102e141e:	c510      	stmia	r5!, {r4}
102e1420:	cb10      	ldmia	r3!, {r4}
102e1422:	40cc      	lsrs	r4, r1
102e1424:	429a      	cmp	r2, r3
102e1426:	d8f6      	bhi.n	102e1416 <rshift+0x42>
102e1428:	4661      	mov	r1, ip
102e142a:	1a53      	subs	r3, r2, r1
102e142c:	3b05      	subs	r3, #5
102e142e:	089b      	lsrs	r3, r3, #2
102e1430:	3305      	adds	r3, #5
102e1432:	009b      	lsls	r3, r3, #2
102e1434:	18c3      	adds	r3, r0, r3
102e1436:	3304      	adds	r3, #4
102e1438:	601c      	str	r4, [r3, #0]
102e143a:	2c00      	cmp	r4, #0
102e143c:	d025      	beq.n	102e148a <rshift+0xb6>
102e143e:	3304      	adds	r3, #4
102e1440:	464c      	mov	r4, r9
102e1442:	1b1f      	subs	r7, r3, r4
102e1444:	10bf      	asrs	r7, r7, #2
102e1446:	e01c      	b.n	102e1482 <rshift+0xae>
102e1448:	2300      	movs	r3, #0
102e144a:	6103      	str	r3, [r0, #16]
102e144c:	2300      	movs	r3, #0
102e144e:	6143      	str	r3, [r0, #20]
102e1450:	bc0c      	pop	{r2, r3}
102e1452:	4690      	mov	r8, r2
102e1454:	4699      	mov	r9, r3
102e1456:	bcf0      	pop	{r4, r5, r6, r7}
102e1458:	bc01      	pop	{r0}
102e145a:	4700      	bx	r0
102e145c:	4663      	mov	r3, ip
102e145e:	4649      	mov	r1, r9
102e1460:	4562      	cmp	r2, ip
102e1462:	d9f1      	bls.n	102e1448 <rshift+0x74>
102e1464:	cb10      	ldmia	r3!, {r4}
102e1466:	c110      	stmia	r1!, {r4}
102e1468:	429a      	cmp	r2, r3
102e146a:	d8fb      	bhi.n	102e1464 <rshift+0x90>
102e146c:	4666      	mov	r6, ip
102e146e:	43f3      	mvns	r3, r6
102e1470:	189b      	adds	r3, r3, r2
102e1472:	089b      	lsrs	r3, r3, #2
102e1474:	3305      	adds	r3, #5
102e1476:	009b      	lsls	r3, r3, #2
102e1478:	18c3      	adds	r3, r0, r3
102e147a:	3304      	adds	r3, #4
102e147c:	4649      	mov	r1, r9
102e147e:	1a5f      	subs	r7, r3, r1
102e1480:	10bf      	asrs	r7, r7, #2
102e1482:	6107      	str	r7, [r0, #16]
102e1484:	2f00      	cmp	r7, #0
102e1486:	d1e3      	bne.n	102e1450 <rshift+0x7c>
102e1488:	e7e0      	b.n	102e144c <rshift+0x78>
102e148a:	464a      	mov	r2, r9
102e148c:	1a9f      	subs	r7, r3, r2
102e148e:	10bf      	asrs	r7, r7, #2
102e1490:	e7f7      	b.n	102e1482 <rshift+0xae>
102e1492:	464b      	mov	r3, r9
102e1494:	e7d0      	b.n	102e1438 <rshift+0x64>
102e1496:	46c0      	nop			; (mov r8, r8)

102e1498 <__hexdig_init>:
102e1498:	b510      	push	{r4, lr}
102e149a:	4a11      	ldr	r2, [pc, #68]	; (102e14e0 <__hexdig_init+0x48>)
102e149c:	4c11      	ldr	r4, [pc, #68]	; (102e14e4 <__hexdig_init+0x4c>)
102e149e:	2300      	movs	r3, #0
102e14a0:	2130      	movs	r1, #48	; 0x30
102e14a2:	1c18      	adds	r0, r3, #0
102e14a4:	3010      	adds	r0, #16
102e14a6:	3301      	adds	r3, #1
102e14a8:	5450      	strb	r0, [r2, r1]
102e14aa:	5ce1      	ldrb	r1, [r4, r3]
102e14ac:	2900      	cmp	r1, #0
102e14ae:	d1f8      	bne.n	102e14a2 <__hexdig_init+0xa>
102e14b0:	4c0d      	ldr	r4, [pc, #52]	; (102e14e8 <__hexdig_init+0x50>)
102e14b2:	2300      	movs	r3, #0
102e14b4:	2161      	movs	r1, #97	; 0x61
102e14b6:	1c18      	adds	r0, r3, #0
102e14b8:	301a      	adds	r0, #26
102e14ba:	3301      	adds	r3, #1
102e14bc:	5450      	strb	r0, [r2, r1]
102e14be:	5ce1      	ldrb	r1, [r4, r3]
102e14c0:	2900      	cmp	r1, #0
102e14c2:	d1f8      	bne.n	102e14b6 <__hexdig_init+0x1e>
102e14c4:	4c09      	ldr	r4, [pc, #36]	; (102e14ec <__hexdig_init+0x54>)
102e14c6:	2300      	movs	r3, #0
102e14c8:	2141      	movs	r1, #65	; 0x41
102e14ca:	1c18      	adds	r0, r3, #0
102e14cc:	301a      	adds	r0, #26
102e14ce:	3301      	adds	r3, #1
102e14d0:	5450      	strb	r0, [r2, r1]
102e14d2:	5ce1      	ldrb	r1, [r4, r3]
102e14d4:	2900      	cmp	r1, #0
102e14d6:	d1f8      	bne.n	102e14ca <__hexdig_init+0x32>
102e14d8:	bc10      	pop	{r4}
102e14da:	bc01      	pop	{r0}
102e14dc:	4700      	bx	r0
102e14de:	46c0      	nop			; (mov r8, r8)
102e14e0:	f03de54c 	.word	0xf03de54c
102e14e4:	102f035c 	.word	0x102f035c
102e14e8:	102f0354 	.word	0x102f0354
102e14ec:	102f034c 	.word	0x102f034c

102e14f0 <__gethex>:
102e14f0:	b5f0      	push	{r4, r5, r6, r7, lr}
102e14f2:	465f      	mov	r7, fp
102e14f4:	4656      	mov	r6, sl
102e14f6:	4644      	mov	r4, r8
102e14f8:	464d      	mov	r5, r9
102e14fa:	b4f0      	push	{r4, r5, r6, r7}
102e14fc:	b091      	sub	sp, #68	; 0x44
102e14fe:	930f      	str	r3, [sp, #60]	; 0x3c
102e1500:	4688      	mov	r8, r1
102e1502:	4693      	mov	fp, r2
102e1504:	900c      	str	r0, [sp, #48]	; 0x30
102e1506:	f000 fbc5 	bl	102e1c94 <_localeconv_r>
102e150a:	6800      	ldr	r0, [r0, #0]
102e150c:	9007      	str	r0, [sp, #28]
102e150e:	f7fe fd29 	bl	102dff64 <strlen>
102e1512:	9f07      	ldr	r7, [sp, #28]
102e1514:	183b      	adds	r3, r7, r0
102e1516:	3b01      	subs	r3, #1
102e1518:	781b      	ldrb	r3, [r3, #0]
102e151a:	9008      	str	r0, [sp, #32]
102e151c:	9306      	str	r3, [sp, #24]
102e151e:	4ec7      	ldr	r6, [pc, #796]	; (102e183c <__gethex+0x34c>)
102e1520:	2330      	movs	r3, #48	; 0x30
102e1522:	5cf3      	ldrb	r3, [r6, r3]
102e1524:	2b00      	cmp	r3, #0
102e1526:	d100      	bne.n	102e152a <__gethex+0x3a>
102e1528:	e12a      	b.n	102e1780 <__gethex+0x290>
102e152a:	4641      	mov	r1, r8
102e152c:	6808      	ldr	r0, [r1, #0]
102e152e:	7882      	ldrb	r2, [r0, #2]
102e1530:	1c84      	adds	r4, r0, #2
102e1532:	2a30      	cmp	r2, #48	; 0x30
102e1534:	d000      	beq.n	102e1538 <__gethex+0x48>
102e1536:	e1d8      	b.n	102e18ea <__gethex+0x3fa>
102e1538:	2102      	movs	r1, #2
102e153a:	4249      	negs	r1, r1
102e153c:	1cc3      	adds	r3, r0, #3
102e153e:	1a09      	subs	r1, r1, r0
102e1540:	18cf      	adds	r7, r1, r3
102e1542:	1c1c      	adds	r4, r3, #0
102e1544:	3301      	adds	r3, #1
102e1546:	1e5a      	subs	r2, r3, #1
102e1548:	7812      	ldrb	r2, [r2, #0]
102e154a:	2a30      	cmp	r2, #48	; 0x30
102e154c:	d0f8      	beq.n	102e1540 <__gethex+0x50>
102e154e:	5cb3      	ldrb	r3, [r6, r2]
102e1550:	2b00      	cmp	r3, #0
102e1552:	d100      	bne.n	102e1556 <__gethex+0x66>
102e1554:	e0f3      	b.n	102e173e <__gethex+0x24e>
102e1556:	7823      	ldrb	r3, [r4, #0]
102e1558:	5cf3      	ldrb	r3, [r6, r3]
102e155a:	2000      	movs	r0, #0
102e155c:	1c22      	adds	r2, r4, #0
102e155e:	4681      	mov	r9, r0
102e1560:	2b00      	cmp	r3, #0
102e1562:	d100      	bne.n	102e1566 <__gethex+0x76>
102e1564:	e1fb      	b.n	102e195e <__gethex+0x46e>
102e1566:	1c15      	adds	r5, r2, #0
102e1568:	3501      	adds	r5, #1
102e156a:	782b      	ldrb	r3, [r5, #0]
102e156c:	5cf3      	ldrb	r3, [r6, r3]
102e156e:	2b00      	cmp	r3, #0
102e1570:	d1fa      	bne.n	102e1568 <__gethex+0x78>
102e1572:	2000      	movs	r0, #0
102e1574:	1c14      	adds	r4, r2, #0
102e1576:	4682      	mov	sl, r0
102e1578:	1c28      	adds	r0, r5, #0
102e157a:	9907      	ldr	r1, [sp, #28]
102e157c:	9a08      	ldr	r2, [sp, #32]
102e157e:	f7fe fcf9 	bl	102dff74 <strncmp>
102e1582:	2800      	cmp	r0, #0
102e1584:	d023      	beq.n	102e15ce <__gethex+0xde>
102e1586:	464a      	mov	r2, r9
102e1588:	782b      	ldrb	r3, [r5, #0]
102e158a:	2a00      	cmp	r2, #0
102e158c:	d100      	bne.n	102e1590 <__gethex+0xa0>
102e158e:	e19c      	b.n	102e18ca <__gethex+0x3da>
102e1590:	4648      	mov	r0, r9
102e1592:	1b42      	subs	r2, r0, r5
102e1594:	0092      	lsls	r2, r2, #2
102e1596:	920b      	str	r2, [sp, #44]	; 0x2c
102e1598:	2b50      	cmp	r3, #80	; 0x50
102e159a:	d100      	bne.n	102e159e <__gethex+0xae>
102e159c:	e0a1      	b.n	102e16e2 <__gethex+0x1f2>
102e159e:	2b70      	cmp	r3, #112	; 0x70
102e15a0:	d100      	bne.n	102e15a4 <__gethex+0xb4>
102e15a2:	e09e      	b.n	102e16e2 <__gethex+0x1f2>
102e15a4:	1c2b      	adds	r3, r5, #0
102e15a6:	4640      	mov	r0, r8
102e15a8:	4651      	mov	r1, sl
102e15aa:	6003      	str	r3, [r0, #0]
102e15ac:	2900      	cmp	r1, #0
102e15ae:	d014      	beq.n	102e15da <__gethex+0xea>
102e15b0:	427b      	negs	r3, r7
102e15b2:	415f      	adcs	r7, r3
102e15b4:	2406      	movs	r4, #6
102e15b6:	427f      	negs	r7, r7
102e15b8:	403c      	ands	r4, r7
102e15ba:	1c20      	adds	r0, r4, #0
102e15bc:	b011      	add	sp, #68	; 0x44
102e15be:	bc3c      	pop	{r2, r3, r4, r5}
102e15c0:	4690      	mov	r8, r2
102e15c2:	4699      	mov	r9, r3
102e15c4:	46a2      	mov	sl, r4
102e15c6:	46ab      	mov	fp, r5
102e15c8:	bcf0      	pop	{r4, r5, r6, r7}
102e15ca:	bc02      	pop	{r1}
102e15cc:	4708      	bx	r1
102e15ce:	4649      	mov	r1, r9
102e15d0:	2900      	cmp	r1, #0
102e15d2:	d100      	bne.n	102e15d6 <__gethex+0xe6>
102e15d4:	e1b3      	b.n	102e193e <__gethex+0x44e>
102e15d6:	782b      	ldrb	r3, [r5, #0]
102e15d8:	e7da      	b.n	102e1590 <__gethex+0xa0>
102e15da:	1b2b      	subs	r3, r5, r4
102e15dc:	3b01      	subs	r3, #1
102e15de:	2100      	movs	r1, #0
102e15e0:	2b07      	cmp	r3, #7
102e15e2:	dd03      	ble.n	102e15ec <__gethex+0xfc>
102e15e4:	3101      	adds	r1, #1
102e15e6:	105b      	asrs	r3, r3, #1
102e15e8:	2b07      	cmp	r3, #7
102e15ea:	dcfb      	bgt.n	102e15e4 <__gethex+0xf4>
102e15ec:	980c      	ldr	r0, [sp, #48]	; 0x30
102e15ee:	f000 fe53 	bl	102e2298 <_Balloc>
102e15f2:	900a      	str	r0, [sp, #40]	; 0x28
102e15f4:	3014      	adds	r0, #20
102e15f6:	900e      	str	r0, [sp, #56]	; 0x38
102e15f8:	42ac      	cmp	r4, r5
102e15fa:	d300      	bcc.n	102e15fe <__gethex+0x10e>
102e15fc:	e1cd      	b.n	102e199a <__gethex+0x4aa>
102e15fe:	2200      	movs	r2, #0
102e1600:	4682      	mov	sl, r0
102e1602:	9808      	ldr	r0, [sp, #32]
102e1604:	4690      	mov	r8, r2
102e1606:	2201      	movs	r2, #1
102e1608:	1a12      	subs	r2, r2, r0
102e160a:	920d      	str	r2, [sp, #52]	; 0x34
102e160c:	210f      	movs	r1, #15
102e160e:	4642      	mov	r2, r8
102e1610:	1c2b      	adds	r3, r5, #0
102e1612:	46a0      	mov	r8, r4
102e1614:	2700      	movs	r7, #0
102e1616:	4689      	mov	r9, r1
102e1618:	1c14      	adds	r4, r2, #0
102e161a:	e00c      	b.n	102e1636 <__gethex+0x146>
102e161c:	2f20      	cmp	r7, #32
102e161e:	d057      	beq.n	102e16d0 <__gethex+0x1e0>
102e1620:	1c3a      	adds	r2, r7, #0
102e1622:	3704      	adds	r7, #4
102e1624:	782b      	ldrb	r3, [r5, #0]
102e1626:	5cf3      	ldrb	r3, [r6, r3]
102e1628:	4648      	mov	r0, r9
102e162a:	4003      	ands	r3, r0
102e162c:	4093      	lsls	r3, r2
102e162e:	431c      	orrs	r4, r3
102e1630:	1c2b      	adds	r3, r5, #0
102e1632:	4598      	cmp	r8, r3
102e1634:	d213      	bcs.n	102e165e <__gethex+0x16e>
102e1636:	1e5d      	subs	r5, r3, #1
102e1638:	782b      	ldrb	r3, [r5, #0]
102e163a:	9a06      	ldr	r2, [sp, #24]
102e163c:	4293      	cmp	r3, r2
102e163e:	d1ed      	bne.n	102e161c <__gethex+0x12c>
102e1640:	9b0d      	ldr	r3, [sp, #52]	; 0x34
102e1642:	18eb      	adds	r3, r5, r3
102e1644:	9309      	str	r3, [sp, #36]	; 0x24
102e1646:	4598      	cmp	r8, r3
102e1648:	d8e8      	bhi.n	102e161c <__gethex+0x12c>
102e164a:	1c18      	adds	r0, r3, #0
102e164c:	9907      	ldr	r1, [sp, #28]
102e164e:	9a08      	ldr	r2, [sp, #32]
102e1650:	f7fe fc90 	bl	102dff74 <strncmp>
102e1654:	9b09      	ldr	r3, [sp, #36]	; 0x24
102e1656:	2800      	cmp	r0, #0
102e1658:	d1e0      	bne.n	102e161c <__gethex+0x12c>
102e165a:	4598      	cmp	r8, r3
102e165c:	d3eb      	bcc.n	102e1636 <__gethex+0x146>
102e165e:	46a0      	mov	r8, r4
102e1660:	4653      	mov	r3, sl
102e1662:	4641      	mov	r1, r8
102e1664:	c302      	stmia	r3!, {r1}
102e1666:	9f0e      	ldr	r7, [sp, #56]	; 0x38
102e1668:	1bdb      	subs	r3, r3, r7
102e166a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
102e166c:	109c      	asrs	r4, r3, #2
102e166e:	613c      	str	r4, [r7, #16]
102e1670:	4640      	mov	r0, r8
102e1672:	f000 feeb 	bl	102e244c <__hi0bits>
102e1676:	0164      	lsls	r4, r4, #5
102e1678:	1a24      	subs	r4, r4, r0
102e167a:	4658      	mov	r0, fp
102e167c:	6805      	ldr	r5, [r0, #0]
102e167e:	42ac      	cmp	r4, r5
102e1680:	dd00      	ble.n	102e1684 <__gethex+0x194>
102e1682:	e0fb      	b.n	102e187c <__gethex+0x38c>
102e1684:	2600      	movs	r6, #0
102e1686:	42ac      	cmp	r4, r5
102e1688:	da00      	bge.n	102e168c <__gethex+0x19c>
102e168a:	e121      	b.n	102e18d0 <__gethex+0x3e0>
102e168c:	4658      	mov	r0, fp
102e168e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
102e1690:	6880      	ldr	r0, [r0, #8]
102e1692:	4287      	cmp	r7, r0
102e1694:	dd00      	ble.n	102e1698 <__gethex+0x1a8>
102e1696:	e0c0      	b.n	102e181a <__gethex+0x32a>
102e1698:	465a      	mov	r2, fp
102e169a:	6853      	ldr	r3, [r2, #4]
102e169c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
102e169e:	429f      	cmp	r7, r3
102e16a0:	da00      	bge.n	102e16a4 <__gethex+0x1b4>
102e16a2:	e0cd      	b.n	102e1840 <__gethex+0x350>
102e16a4:	2401      	movs	r4, #1
102e16a6:	2e00      	cmp	r6, #0
102e16a8:	d00b      	beq.n	102e16c2 <__gethex+0x1d2>
102e16aa:	4658      	mov	r0, fp
102e16ac:	68c3      	ldr	r3, [r0, #12]
102e16ae:	2b02      	cmp	r3, #2
102e16b0:	d100      	bne.n	102e16b4 <__gethex+0x1c4>
102e16b2:	e17e      	b.n	102e19b2 <__gethex+0x4c2>
102e16b4:	2b03      	cmp	r3, #3
102e16b6:	d100      	bne.n	102e16ba <__gethex+0x1ca>
102e16b8:	e176      	b.n	102e19a8 <__gethex+0x4b8>
102e16ba:	2b01      	cmp	r3, #1
102e16bc:	d063      	beq.n	102e1786 <__gethex+0x296>
102e16be:	2310      	movs	r3, #16
102e16c0:	431c      	orrs	r4, r3
102e16c2:	9f0a      	ldr	r7, [sp, #40]	; 0x28
102e16c4:	981a      	ldr	r0, [sp, #104]	; 0x68
102e16c6:	6007      	str	r7, [r0, #0]
102e16c8:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
102e16ca:	980f      	ldr	r0, [sp, #60]	; 0x3c
102e16cc:	6007      	str	r7, [r0, #0]
102e16ce:	e774      	b.n	102e15ba <__gethex+0xca>
102e16d0:	4657      	mov	r7, sl
102e16d2:	3704      	adds	r7, #4
102e16d4:	46ba      	mov	sl, r7
102e16d6:	3f04      	subs	r7, #4
102e16d8:	c710      	stmia	r7!, {r4}
102e16da:	2200      	movs	r2, #0
102e16dc:	2704      	movs	r7, #4
102e16de:	2400      	movs	r4, #0
102e16e0:	e7a0      	b.n	102e1624 <__gethex+0x134>
102e16e2:	786b      	ldrb	r3, [r5, #1]
102e16e4:	2b2b      	cmp	r3, #43	; 0x2b
102e16e6:	d100      	bne.n	102e16ea <__gethex+0x1fa>
102e16e8:	e0c5      	b.n	102e1876 <__gethex+0x386>
102e16ea:	2b2d      	cmp	r3, #45	; 0x2d
102e16ec:	d100      	bne.n	102e16f0 <__gethex+0x200>
102e16ee:	e0bd      	b.n	102e186c <__gethex+0x37c>
102e16f0:	2000      	movs	r0, #0
102e16f2:	1c6a      	adds	r2, r5, #1
102e16f4:	4684      	mov	ip, r0
102e16f6:	5cf1      	ldrb	r1, [r6, r3]
102e16f8:	1c2b      	adds	r3, r5, #0
102e16fa:	2900      	cmp	r1, #0
102e16fc:	d100      	bne.n	102e1700 <__gethex+0x210>
102e16fe:	e752      	b.n	102e15a6 <__gethex+0xb6>
102e1700:	2919      	cmp	r1, #25
102e1702:	dd00      	ble.n	102e1706 <__gethex+0x216>
102e1704:	e74f      	b.n	102e15a6 <__gethex+0xb6>
102e1706:	1c53      	adds	r3, r2, #1
102e1708:	7852      	ldrb	r2, [r2, #1]
102e170a:	5cb2      	ldrb	r2, [r6, r2]
102e170c:	3910      	subs	r1, #16
102e170e:	2a00      	cmp	r2, #0
102e1710:	d10b      	bne.n	102e172a <__gethex+0x23a>
102e1712:	e00c      	b.n	102e172e <__gethex+0x23e>
102e1714:	0088      	lsls	r0, r1, #2
102e1716:	1841      	adds	r1, r0, r1
102e1718:	0049      	lsls	r1, r1, #1
102e171a:	188a      	adds	r2, r1, r2
102e171c:	3301      	adds	r3, #1
102e171e:	1c11      	adds	r1, r2, #0
102e1720:	781a      	ldrb	r2, [r3, #0]
102e1722:	5cb2      	ldrb	r2, [r6, r2]
102e1724:	3910      	subs	r1, #16
102e1726:	2a00      	cmp	r2, #0
102e1728:	d001      	beq.n	102e172e <__gethex+0x23e>
102e172a:	2a19      	cmp	r2, #25
102e172c:	ddf2      	ble.n	102e1714 <__gethex+0x224>
102e172e:	4660      	mov	r0, ip
102e1730:	2800      	cmp	r0, #0
102e1732:	d000      	beq.n	102e1736 <__gethex+0x246>
102e1734:	4249      	negs	r1, r1
102e1736:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
102e1738:	1852      	adds	r2, r2, r1
102e173a:	920b      	str	r2, [sp, #44]	; 0x2c
102e173c:	e733      	b.n	102e15a6 <__gethex+0xb6>
102e173e:	1c20      	adds	r0, r4, #0
102e1740:	9907      	ldr	r1, [sp, #28]
102e1742:	9a08      	ldr	r2, [sp, #32]
102e1744:	f7fe fc16 	bl	102dff74 <strncmp>
102e1748:	2800      	cmp	r0, #0
102e174a:	d16f      	bne.n	102e182c <__gethex+0x33c>
102e174c:	9b08      	ldr	r3, [sp, #32]
102e174e:	18e5      	adds	r5, r4, r3
102e1750:	782b      	ldrb	r3, [r5, #0]
102e1752:	5cf2      	ldrb	r2, [r6, r3]
102e1754:	2a00      	cmp	r2, #0
102e1756:	d100      	bne.n	102e175a <__gethex+0x26a>
102e1758:	e0c9      	b.n	102e18ee <__gethex+0x3fe>
102e175a:	1c2a      	adds	r2, r5, #0
102e175c:	2b30      	cmp	r3, #48	; 0x30
102e175e:	d000      	beq.n	102e1762 <__gethex+0x272>
102e1760:	e108      	b.n	102e1974 <__gethex+0x484>
102e1762:	3201      	adds	r2, #1
102e1764:	7813      	ldrb	r3, [r2, #0]
102e1766:	2b30      	cmp	r3, #48	; 0x30
102e1768:	d0fb      	beq.n	102e1762 <__gethex+0x272>
102e176a:	5cf3      	ldrb	r3, [r6, r3]
102e176c:	2b00      	cmp	r3, #0
102e176e:	d000      	beq.n	102e1772 <__gethex+0x282>
102e1770:	e100      	b.n	102e1974 <__gethex+0x484>
102e1772:	2101      	movs	r1, #1
102e1774:	46a9      	mov	r9, r5
102e1776:	1c14      	adds	r4, r2, #0
102e1778:	1c15      	adds	r5, r2, #0
102e177a:	468a      	mov	sl, r1
102e177c:	2701      	movs	r7, #1
102e177e:	e6fb      	b.n	102e1578 <__gethex+0x88>
102e1780:	f7ff fe8a 	bl	102e1498 <__hexdig_init>
102e1784:	e6d1      	b.n	102e152a <__gethex+0x3a>
102e1786:	07b1      	lsls	r1, r6, #30
102e1788:	d599      	bpl.n	102e16be <__gethex+0x1ce>
102e178a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
102e178c:	6812      	ldr	r2, [r2, #0]
102e178e:	4316      	orrs	r6, r2
102e1790:	4233      	tst	r3, r6
102e1792:	d094      	beq.n	102e16be <__gethex+0x1ce>
102e1794:	9f0a      	ldr	r7, [sp, #40]	; 0x28
102e1796:	693e      	ldr	r6, [r7, #16]
102e1798:	1d30      	adds	r0, r6, #4
102e179a:	0080      	lsls	r0, r0, #2
102e179c:	1838      	adds	r0, r7, r0
102e179e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
102e17a0:	3004      	adds	r0, #4
102e17a2:	2100      	movs	r1, #0
102e17a4:	681a      	ldr	r2, [r3, #0]
102e17a6:	1c57      	adds	r7, r2, #1
102e17a8:	d000      	beq.n	102e17ac <__gethex+0x2bc>
102e17aa:	e11a      	b.n	102e19e2 <__gethex+0x4f2>
102e17ac:	c302      	stmia	r3!, {r1}
102e17ae:	4298      	cmp	r0, r3
102e17b0:	d8f8      	bhi.n	102e17a4 <__gethex+0x2b4>
102e17b2:	980a      	ldr	r0, [sp, #40]	; 0x28
102e17b4:	6880      	ldr	r0, [r0, #8]
102e17b6:	1c33      	adds	r3, r6, #0
102e17b8:	4286      	cmp	r6, r0
102e17ba:	db00      	blt.n	102e17be <__gethex+0x2ce>
102e17bc:	e12b      	b.n	102e1a16 <__gethex+0x526>
102e17be:	1d1a      	adds	r2, r3, #4
102e17c0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
102e17c2:	0092      	lsls	r2, r2, #2
102e17c4:	18ba      	adds	r2, r7, r2
102e17c6:	2101      	movs	r1, #1
102e17c8:	3301      	adds	r3, #1
102e17ca:	6051      	str	r1, [r2, #4]
102e17cc:	613b      	str	r3, [r7, #16]
102e17ce:	2c02      	cmp	r4, #2
102e17d0:	d100      	bne.n	102e17d4 <__gethex+0x2e4>
102e17d2:	e109      	b.n	102e19e8 <__gethex+0x4f8>
102e17d4:	980a      	ldr	r0, [sp, #40]	; 0x28
102e17d6:	6900      	ldr	r0, [r0, #16]
102e17d8:	4286      	cmp	r6, r0
102e17da:	db11      	blt.n	102e1800 <__gethex+0x310>
102e17dc:	231f      	movs	r3, #31
102e17de:	401d      	ands	r5, r3
102e17e0:	2421      	movs	r4, #33	; 0x21
102e17e2:	2d00      	cmp	r5, #0
102e17e4:	d100      	bne.n	102e17e8 <__gethex+0x2f8>
102e17e6:	e76c      	b.n	102e16c2 <__gethex+0x1d2>
102e17e8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
102e17ea:	1cf3      	adds	r3, r6, #3
102e17ec:	009b      	lsls	r3, r3, #2
102e17ee:	18fb      	adds	r3, r7, r3
102e17f0:	6858      	ldr	r0, [r3, #4]
102e17f2:	f000 fe2b 	bl	102e244c <__hi0bits>
102e17f6:	2320      	movs	r3, #32
102e17f8:	1b5d      	subs	r5, r3, r5
102e17fa:	42a8      	cmp	r0, r5
102e17fc:	db00      	blt.n	102e1800 <__gethex+0x310>
102e17fe:	e760      	b.n	102e16c2 <__gethex+0x1d2>
102e1800:	980a      	ldr	r0, [sp, #40]	; 0x28
102e1802:	2101      	movs	r1, #1
102e1804:	f7ff fde6 	bl	102e13d4 <rshift>
102e1808:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
102e180a:	4658      	mov	r0, fp
102e180c:	6883      	ldr	r3, [r0, #8]
102e180e:	3701      	adds	r7, #1
102e1810:	970b      	str	r7, [sp, #44]	; 0x2c
102e1812:	2421      	movs	r4, #33	; 0x21
102e1814:	429f      	cmp	r7, r3
102e1816:	dc00      	bgt.n	102e181a <__gethex+0x32a>
102e1818:	e753      	b.n	102e16c2 <__gethex+0x1d2>
102e181a:	990a      	ldr	r1, [sp, #40]	; 0x28
102e181c:	980c      	ldr	r0, [sp, #48]	; 0x30
102e181e:	f000 fd65 	bl	102e22ec <_Bfree>
102e1822:	991a      	ldr	r1, [sp, #104]	; 0x68
102e1824:	2300      	movs	r3, #0
102e1826:	600b      	str	r3, [r1, #0]
102e1828:	24a3      	movs	r4, #163	; 0xa3
102e182a:	e6c6      	b.n	102e15ba <__gethex+0xca>
102e182c:	2100      	movs	r1, #0
102e182e:	2201      	movs	r2, #1
102e1830:	7823      	ldrb	r3, [r4, #0]
102e1832:	1c25      	adds	r5, r4, #0
102e1834:	910b      	str	r1, [sp, #44]	; 0x2c
102e1836:	4692      	mov	sl, r2
102e1838:	e6ae      	b.n	102e1598 <__gethex+0xa8>
102e183a:	46c0      	nop			; (mov r8, r8)
102e183c:	f03de54c 	.word	0xf03de54c
102e1840:	1bdc      	subs	r4, r3, r7
102e1842:	42a5      	cmp	r5, r4
102e1844:	dc58      	bgt.n	102e18f8 <__gethex+0x408>
102e1846:	68d2      	ldr	r2, [r2, #12]
102e1848:	2a02      	cmp	r2, #2
102e184a:	d100      	bne.n	102e184e <__gethex+0x35e>
102e184c:	e095      	b.n	102e197a <__gethex+0x48a>
102e184e:	2a03      	cmp	r2, #3
102e1850:	d100      	bne.n	102e1854 <__gethex+0x364>
102e1852:	e0c1      	b.n	102e19d8 <__gethex+0x4e8>
102e1854:	2a01      	cmp	r2, #1
102e1856:	d100      	bne.n	102e185a <__gethex+0x36a>
102e1858:	e0af      	b.n	102e19ba <__gethex+0x4ca>
102e185a:	990a      	ldr	r1, [sp, #40]	; 0x28
102e185c:	980c      	ldr	r0, [sp, #48]	; 0x30
102e185e:	f000 fd45 	bl	102e22ec <_Bfree>
102e1862:	991a      	ldr	r1, [sp, #104]	; 0x68
102e1864:	2300      	movs	r3, #0
102e1866:	600b      	str	r3, [r1, #0]
102e1868:	2450      	movs	r4, #80	; 0x50
102e186a:	e6a6      	b.n	102e15ba <__gethex+0xca>
102e186c:	2101      	movs	r1, #1
102e186e:	468c      	mov	ip, r1
102e1870:	1caa      	adds	r2, r5, #2
102e1872:	78ab      	ldrb	r3, [r5, #2]
102e1874:	e73f      	b.n	102e16f6 <__gethex+0x206>
102e1876:	2200      	movs	r2, #0
102e1878:	4694      	mov	ip, r2
102e187a:	e7f9      	b.n	102e1870 <__gethex+0x380>
102e187c:	1b64      	subs	r4, r4, r5
102e187e:	980a      	ldr	r0, [sp, #40]	; 0x28
102e1880:	1c21      	adds	r1, r4, #0
102e1882:	f001 f993 	bl	102e2bac <__any_on>
102e1886:	2600      	movs	r6, #0
102e1888:	2800      	cmp	r0, #0
102e188a:	d016      	beq.n	102e18ba <__gethex+0x3ca>
102e188c:	1e63      	subs	r3, r4, #1
102e188e:	221f      	movs	r2, #31
102e1890:	401a      	ands	r2, r3
102e1892:	2101      	movs	r1, #1
102e1894:	4091      	lsls	r1, r2
102e1896:	1c0a      	adds	r2, r1, #0
102e1898:	1159      	asrs	r1, r3, #5
102e189a:	3104      	adds	r1, #4
102e189c:	0089      	lsls	r1, r1, #2
102e189e:	1879      	adds	r1, r7, r1
102e18a0:	6849      	ldr	r1, [r1, #4]
102e18a2:	2601      	movs	r6, #1
102e18a4:	4211      	tst	r1, r2
102e18a6:	d008      	beq.n	102e18ba <__gethex+0x3ca>
102e18a8:	2b01      	cmp	r3, #1
102e18aa:	dd7b      	ble.n	102e19a4 <__gethex+0x4b4>
102e18ac:	1ea1      	subs	r1, r4, #2
102e18ae:	980a      	ldr	r0, [sp, #40]	; 0x28
102e18b0:	f001 f97c 	bl	102e2bac <__any_on>
102e18b4:	2800      	cmp	r0, #0
102e18b6:	d075      	beq.n	102e19a4 <__gethex+0x4b4>
102e18b8:	2603      	movs	r6, #3
102e18ba:	980a      	ldr	r0, [sp, #40]	; 0x28
102e18bc:	1c21      	adds	r1, r4, #0
102e18be:	f7ff fd89 	bl	102e13d4 <rshift>
102e18c2:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
102e18c4:	193f      	adds	r7, r7, r4
102e18c6:	970b      	str	r7, [sp, #44]	; 0x2c
102e18c8:	e6e0      	b.n	102e168c <__gethex+0x19c>
102e18ca:	2000      	movs	r0, #0
102e18cc:	900b      	str	r0, [sp, #44]	; 0x2c
102e18ce:	e663      	b.n	102e1598 <__gethex+0xa8>
102e18d0:	1b2c      	subs	r4, r5, r4
102e18d2:	980c      	ldr	r0, [sp, #48]	; 0x30
102e18d4:	990a      	ldr	r1, [sp, #40]	; 0x28
102e18d6:	1c22      	adds	r2, r4, #0
102e18d8:	f000 ff1a 	bl	102e2710 <__lshift>
102e18dc:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
102e18de:	900a      	str	r0, [sp, #40]	; 0x28
102e18e0:	1b3f      	subs	r7, r7, r4
102e18e2:	3014      	adds	r0, #20
102e18e4:	970b      	str	r7, [sp, #44]	; 0x2c
102e18e6:	900e      	str	r0, [sp, #56]	; 0x38
102e18e8:	e6d0      	b.n	102e168c <__gethex+0x19c>
102e18ea:	2700      	movs	r7, #0
102e18ec:	e62f      	b.n	102e154e <__gethex+0x5e>
102e18ee:	2100      	movs	r1, #0
102e18f0:	2201      	movs	r2, #1
102e18f2:	910b      	str	r1, [sp, #44]	; 0x2c
102e18f4:	4692      	mov	sl, r2
102e18f6:	e64f      	b.n	102e1598 <__gethex+0xa8>
102e18f8:	1e67      	subs	r7, r4, #1
102e18fa:	2e00      	cmp	r6, #0
102e18fc:	d12d      	bne.n	102e195a <__gethex+0x46a>
102e18fe:	2f00      	cmp	r7, #0
102e1900:	dd04      	ble.n	102e190c <__gethex+0x41c>
102e1902:	980a      	ldr	r0, [sp, #40]	; 0x28
102e1904:	1c39      	adds	r1, r7, #0
102e1906:	f001 f951 	bl	102e2bac <__any_on>
102e190a:	1c06      	adds	r6, r0, #0
102e190c:	221f      	movs	r2, #31
102e190e:	117b      	asrs	r3, r7, #5
102e1910:	4017      	ands	r7, r2
102e1912:	2201      	movs	r2, #1
102e1914:	40ba      	lsls	r2, r7
102e1916:	1c17      	adds	r7, r2, #0
102e1918:	9a0e      	ldr	r2, [sp, #56]	; 0x38
102e191a:	009b      	lsls	r3, r3, #2
102e191c:	58d3      	ldr	r3, [r2, r3]
102e191e:	423b      	tst	r3, r7
102e1920:	d001      	beq.n	102e1926 <__gethex+0x436>
102e1922:	2302      	movs	r3, #2
102e1924:	431e      	orrs	r6, r3
102e1926:	1c21      	adds	r1, r4, #0
102e1928:	980a      	ldr	r0, [sp, #40]	; 0x28
102e192a:	465f      	mov	r7, fp
102e192c:	f7ff fd52 	bl	102e13d4 <rshift>
102e1930:	687f      	ldr	r7, [r7, #4]
102e1932:	1b2d      	subs	r5, r5, r4
102e1934:	970b      	str	r7, [sp, #44]	; 0x2c
102e1936:	2402      	movs	r4, #2
102e1938:	e6b5      	b.n	102e16a6 <__gethex+0x1b6>
102e193a:	2200      	movs	r2, #0
102e193c:	4692      	mov	sl, r2
102e193e:	9b08      	ldr	r3, [sp, #32]
102e1940:	18e9      	adds	r1, r5, r3
102e1942:	780b      	ldrb	r3, [r1, #0]
102e1944:	5cf2      	ldrb	r2, [r6, r3]
102e1946:	1c0d      	adds	r5, r1, #0
102e1948:	2a00      	cmp	r2, #0
102e194a:	d004      	beq.n	102e1956 <__gethex+0x466>
102e194c:	3501      	adds	r5, #1
102e194e:	782b      	ldrb	r3, [r5, #0]
102e1950:	5cf2      	ldrb	r2, [r6, r3]
102e1952:	2a00      	cmp	r2, #0
102e1954:	d1fa      	bne.n	102e194c <__gethex+0x45c>
102e1956:	4689      	mov	r9, r1
102e1958:	e61a      	b.n	102e1590 <__gethex+0xa0>
102e195a:	2601      	movs	r6, #1
102e195c:	e7d6      	b.n	102e190c <__gethex+0x41c>
102e195e:	1c20      	adds	r0, r4, #0
102e1960:	9907      	ldr	r1, [sp, #28]
102e1962:	9a08      	ldr	r2, [sp, #32]
102e1964:	f7fe fb06 	bl	102dff74 <strncmp>
102e1968:	1c25      	adds	r5, r4, #0
102e196a:	2800      	cmp	r0, #0
102e196c:	d0e5      	beq.n	102e193a <__gethex+0x44a>
102e196e:	2100      	movs	r1, #0
102e1970:	468a      	mov	sl, r1
102e1972:	e608      	b.n	102e1586 <__gethex+0x96>
102e1974:	46a9      	mov	r9, r5
102e1976:	2701      	movs	r7, #1
102e1978:	e5f5      	b.n	102e1566 <__gethex+0x76>
102e197a:	991b      	ldr	r1, [sp, #108]	; 0x6c
102e197c:	2900      	cmp	r1, #0
102e197e:	d000      	beq.n	102e1982 <__gethex+0x492>
102e1980:	e76b      	b.n	102e185a <__gethex+0x36a>
102e1982:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
102e1984:	603b      	str	r3, [r7, #0]
102e1986:	9f0a      	ldr	r7, [sp, #40]	; 0x28
102e1988:	2301      	movs	r3, #1
102e198a:	613b      	str	r3, [r7, #16]
102e198c:	9f0e      	ldr	r7, [sp, #56]	; 0x38
102e198e:	981a      	ldr	r0, [sp, #104]	; 0x68
102e1990:	603b      	str	r3, [r7, #0]
102e1992:	9f0a      	ldr	r7, [sp, #40]	; 0x28
102e1994:	2462      	movs	r4, #98	; 0x62
102e1996:	6007      	str	r7, [r0, #0]
102e1998:	e60f      	b.n	102e15ba <__gethex+0xca>
102e199a:	9f0e      	ldr	r7, [sp, #56]	; 0x38
102e199c:	2000      	movs	r0, #0
102e199e:	46ba      	mov	sl, r7
102e19a0:	4680      	mov	r8, r0
102e19a2:	e65d      	b.n	102e1660 <__gethex+0x170>
102e19a4:	2602      	movs	r6, #2
102e19a6:	e788      	b.n	102e18ba <__gethex+0x3ca>
102e19a8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
102e19aa:	2b00      	cmp	r3, #0
102e19ac:	d100      	bne.n	102e19b0 <__gethex+0x4c0>
102e19ae:	e686      	b.n	102e16be <__gethex+0x1ce>
102e19b0:	e6f0      	b.n	102e1794 <__gethex+0x2a4>
102e19b2:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
102e19b4:	2301      	movs	r3, #1
102e19b6:	1bdb      	subs	r3, r3, r7
102e19b8:	e7f7      	b.n	102e19aa <__gethex+0x4ba>
102e19ba:	42ac      	cmp	r4, r5
102e19bc:	d000      	beq.n	102e19c0 <__gethex+0x4d0>
102e19be:	e74c      	b.n	102e185a <__gethex+0x36a>
102e19c0:	2d01      	cmp	r5, #1
102e19c2:	ddde      	ble.n	102e1982 <__gethex+0x492>
102e19c4:	1e69      	subs	r1, r5, #1
102e19c6:	980a      	ldr	r0, [sp, #40]	; 0x28
102e19c8:	f001 f8f0 	bl	102e2bac <__any_on>
102e19cc:	2800      	cmp	r0, #0
102e19ce:	d100      	bne.n	102e19d2 <__gethex+0x4e2>
102e19d0:	e743      	b.n	102e185a <__gethex+0x36a>
102e19d2:	4658      	mov	r0, fp
102e19d4:	6843      	ldr	r3, [r0, #4]
102e19d6:	e7d4      	b.n	102e1982 <__gethex+0x492>
102e19d8:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
102e19da:	2a00      	cmp	r2, #0
102e19dc:	d100      	bne.n	102e19e0 <__gethex+0x4f0>
102e19de:	e73c      	b.n	102e185a <__gethex+0x36a>
102e19e0:	e7cf      	b.n	102e1982 <__gethex+0x492>
102e19e2:	3201      	adds	r2, #1
102e19e4:	601a      	str	r2, [r3, #0]
102e19e6:	e6f2      	b.n	102e17ce <__gethex+0x2de>
102e19e8:	4658      	mov	r0, fp
102e19ea:	6803      	ldr	r3, [r0, #0]
102e19ec:	3b01      	subs	r3, #1
102e19ee:	2422      	movs	r4, #34	; 0x22
102e19f0:	42ab      	cmp	r3, r5
102e19f2:	d000      	beq.n	102e19f6 <__gethex+0x506>
102e19f4:	e665      	b.n	102e16c2 <__gethex+0x1d2>
102e19f6:	231f      	movs	r3, #31
102e19f8:	402b      	ands	r3, r5
102e19fa:	2201      	movs	r2, #1
102e19fc:	409a      	lsls	r2, r3
102e19fe:	1c13      	adds	r3, r2, #0
102e1a00:	116a      	asrs	r2, r5, #5
102e1a02:	3204      	adds	r2, #4
102e1a04:	9f0a      	ldr	r7, [sp, #40]	; 0x28
102e1a06:	0092      	lsls	r2, r2, #2
102e1a08:	18ba      	adds	r2, r7, r2
102e1a0a:	6852      	ldr	r2, [r2, #4]
102e1a0c:	4013      	ands	r3, r2
102e1a0e:	1e5a      	subs	r2, r3, #1
102e1a10:	4193      	sbcs	r3, r2
102e1a12:	1ae4      	subs	r4, r4, r3
102e1a14:	e655      	b.n	102e16c2 <__gethex+0x1d2>
102e1a16:	990a      	ldr	r1, [sp, #40]	; 0x28
102e1a18:	6849      	ldr	r1, [r1, #4]
102e1a1a:	980c      	ldr	r0, [sp, #48]	; 0x30
102e1a1c:	9103      	str	r1, [sp, #12]
102e1a1e:	3101      	adds	r1, #1
102e1a20:	f000 fc3a 	bl	102e2298 <_Balloc>
102e1a24:	9a0a      	ldr	r2, [sp, #40]	; 0x28
102e1a26:	6912      	ldr	r2, [r2, #16]
102e1a28:	990a      	ldr	r1, [sp, #40]	; 0x28
102e1a2a:	9202      	str	r2, [sp, #8]
102e1a2c:	3202      	adds	r2, #2
102e1a2e:	1c07      	adds	r7, r0, #0
102e1a30:	310c      	adds	r1, #12
102e1a32:	0092      	lsls	r2, r2, #2
102e1a34:	300c      	adds	r0, #12
102e1a36:	f7fd ff47 	bl	102df8c8 <memcpy>
102e1a3a:	980c      	ldr	r0, [sp, #48]	; 0x30
102e1a3c:	990a      	ldr	r1, [sp, #40]	; 0x28
102e1a3e:	f000 fc55 	bl	102e22ec <_Bfree>
102e1a42:	693b      	ldr	r3, [r7, #16]
102e1a44:	970a      	str	r7, [sp, #40]	; 0x28
102e1a46:	e6ba      	b.n	102e17be <__gethex+0x2ce>

102e1a48 <__hexnan>:
102e1a48:	b5f0      	push	{r4, r5, r6, r7, lr}
102e1a4a:	4644      	mov	r4, r8
102e1a4c:	465f      	mov	r7, fp
102e1a4e:	4656      	mov	r6, sl
102e1a50:	464d      	mov	r5, r9
102e1a52:	b4f0      	push	{r4, r5, r6, r7}
102e1a54:	b087      	sub	sp, #28
102e1a56:	9005      	str	r0, [sp, #20]
102e1a58:	4f72      	ldr	r7, [pc, #456]	; (102e1c24 <__hexnan+0x1dc>)
102e1a5a:	2330      	movs	r3, #48	; 0x30
102e1a5c:	5cfb      	ldrb	r3, [r7, r3]
102e1a5e:	1c0c      	adds	r4, r1, #0
102e1a60:	4690      	mov	r8, r2
102e1a62:	2b00      	cmp	r3, #0
102e1a64:	d100      	bne.n	102e1a68 <__hexnan+0x20>
102e1a66:	e0cd      	b.n	102e1c04 <__hexnan+0x1bc>
102e1a68:	6822      	ldr	r2, [r4, #0]
102e1a6a:	211f      	movs	r1, #31
102e1a6c:	1153      	asrs	r3, r2, #5
102e1a6e:	009b      	lsls	r3, r3, #2
102e1a70:	4011      	ands	r1, r2
102e1a72:	4443      	add	r3, r8
102e1a74:	9104      	str	r1, [sp, #16]
102e1a76:	2900      	cmp	r1, #0
102e1a78:	d000      	beq.n	102e1a7c <__hexnan+0x34>
102e1a7a:	3304      	adds	r3, #4
102e1a7c:	3b04      	subs	r3, #4
102e1a7e:	9303      	str	r3, [sp, #12]
102e1a80:	9903      	ldr	r1, [sp, #12]
102e1a82:	9c05      	ldr	r4, [sp, #20]
102e1a84:	2300      	movs	r3, #0
102e1a86:	600b      	str	r3, [r1, #0]
102e1a88:	6823      	ldr	r3, [r4, #0]
102e1a8a:	4689      	mov	r9, r1
102e1a8c:	1c0e      	adds	r6, r1, #0
102e1a8e:	2100      	movs	r1, #0
102e1a90:	9102      	str	r1, [sp, #8]
102e1a92:	7859      	ldrb	r1, [r3, #1]
102e1a94:	2200      	movs	r2, #0
102e1a96:	2000      	movs	r0, #0
102e1a98:	4694      	mov	ip, r2
102e1a9a:	2900      	cmp	r1, #0
102e1a9c:	d03c      	beq.n	102e1b18 <__hexnan+0xd0>
102e1a9e:	5c7a      	ldrb	r2, [r7, r1]
102e1aa0:	2a00      	cmp	r2, #0
102e1aa2:	d166      	bne.n	102e1b72 <__hexnan+0x12a>
102e1aa4:	2920      	cmp	r1, #32
102e1aa6:	d878      	bhi.n	102e1b9a <__hexnan+0x152>
102e1aa8:	9c02      	ldr	r4, [sp, #8]
102e1aaa:	45a4      	cmp	ip, r4
102e1aac:	dd30      	ble.n	102e1b10 <__hexnan+0xc8>
102e1aae:	0fc1      	lsrs	r1, r0, #31
102e1ab0:	2407      	movs	r4, #7
102e1ab2:	4284      	cmp	r4, r0
102e1ab4:	414a      	adcs	r2, r1
102e1ab6:	0612      	lsls	r2, r2, #24
102e1ab8:	d020      	beq.n	102e1afc <__hexnan+0xb4>
102e1aba:	454e      	cmp	r6, r9
102e1abc:	d21e      	bcs.n	102e1afc <__hexnan+0xb4>
102e1abe:	2108      	movs	r1, #8
102e1ac0:	1a08      	subs	r0, r1, r0
102e1ac2:	0080      	lsls	r0, r0, #2
102e1ac4:	4682      	mov	sl, r0
102e1ac6:	2220      	movs	r2, #32
102e1ac8:	1a14      	subs	r4, r2, r0
102e1aca:	1c1a      	adds	r2, r3, #0
102e1acc:	4653      	mov	r3, sl
102e1ace:	46a3      	mov	fp, r4
102e1ad0:	9300      	str	r3, [sp, #0]
102e1ad2:	6834      	ldr	r4, [r6, #0]
102e1ad4:	1c30      	adds	r0, r6, #0
102e1ad6:	1d31      	adds	r1, r6, #4
102e1ad8:	464d      	mov	r5, r9
102e1ada:	4692      	mov	sl, r2
102e1adc:	46b1      	mov	r9, r6
102e1ade:	465e      	mov	r6, fp
102e1ae0:	680a      	ldr	r2, [r1, #0]
102e1ae2:	1c13      	adds	r3, r2, #0
102e1ae4:	40b3      	lsls	r3, r6
102e1ae6:	431c      	orrs	r4, r3
102e1ae8:	9b00      	ldr	r3, [sp, #0]
102e1aea:	c010      	stmia	r0!, {r4}
102e1aec:	1c14      	adds	r4, r2, #0
102e1aee:	40dc      	lsrs	r4, r3
102e1af0:	c110      	stmia	r1!, {r4}
102e1af2:	4285      	cmp	r5, r0
102e1af4:	d8f4      	bhi.n	102e1ae0 <__hexnan+0x98>
102e1af6:	464e      	mov	r6, r9
102e1af8:	4653      	mov	r3, sl
102e1afa:	46a9      	mov	r9, r5
102e1afc:	2008      	movs	r0, #8
102e1afe:	4546      	cmp	r6, r8
102e1b00:	d906      	bls.n	102e1b10 <__hexnan+0xc8>
102e1b02:	3e04      	subs	r6, #4
102e1b04:	2400      	movs	r4, #0
102e1b06:	4662      	mov	r2, ip
102e1b08:	6034      	str	r4, [r6, #0]
102e1b0a:	9202      	str	r2, [sp, #8]
102e1b0c:	46b1      	mov	r9, r6
102e1b0e:	2000      	movs	r0, #0
102e1b10:	3301      	adds	r3, #1
102e1b12:	7859      	ldrb	r1, [r3, #1]
102e1b14:	2900      	cmp	r1, #0
102e1b16:	d1c2      	bne.n	102e1a9e <__hexnan+0x56>
102e1b18:	4662      	mov	r2, ip
102e1b1a:	2a00      	cmp	r2, #0
102e1b1c:	d040      	beq.n	102e1ba0 <__hexnan+0x158>
102e1b1e:	0fc3      	lsrs	r3, r0, #31
102e1b20:	2100      	movs	r1, #0
102e1b22:	2207      	movs	r2, #7
102e1b24:	4282      	cmp	r2, r0
102e1b26:	414b      	adcs	r3, r1
102e1b28:	061b      	lsls	r3, r3, #24
102e1b2a:	d001      	beq.n	102e1b30 <__hexnan+0xe8>
102e1b2c:	454e      	cmp	r6, r9
102e1b2e:	d341      	bcc.n	102e1bb4 <__hexnan+0x16c>
102e1b30:	45b0      	cmp	r8, r6
102e1b32:	d258      	bcs.n	102e1be6 <__hexnan+0x19e>
102e1b34:	9803      	ldr	r0, [sp, #12]
102e1b36:	4642      	mov	r2, r8
102e1b38:	ce02      	ldmia	r6!, {r1}
102e1b3a:	1c13      	adds	r3, r2, #0
102e1b3c:	c302      	stmia	r3!, {r1}
102e1b3e:	1c1a      	adds	r2, r3, #0
102e1b40:	42b0      	cmp	r0, r6
102e1b42:	d2f9      	bcs.n	102e1b38 <__hexnan+0xf0>
102e1b44:	9903      	ldr	r1, [sp, #12]
102e1b46:	2200      	movs	r2, #0
102e1b48:	c304      	stmia	r3!, {r2}
102e1b4a:	4299      	cmp	r1, r3
102e1b4c:	d2fc      	bcs.n	102e1b48 <__hexnan+0x100>
102e1b4e:	9903      	ldr	r1, [sp, #12]
102e1b50:	680b      	ldr	r3, [r1, #0]
102e1b52:	2b00      	cmp	r3, #0
102e1b54:	d10b      	bne.n	102e1b6e <__hexnan+0x126>
102e1b56:	9903      	ldr	r1, [sp, #12]
102e1b58:	4588      	cmp	r8, r1
102e1b5a:	d056      	beq.n	102e1c0a <__hexnan+0x1c2>
102e1b5c:	1c0b      	adds	r3, r1, #0
102e1b5e:	4642      	mov	r2, r8
102e1b60:	e001      	b.n	102e1b66 <__hexnan+0x11e>
102e1b62:	429a      	cmp	r2, r3
102e1b64:	d052      	beq.n	102e1c0c <__hexnan+0x1c4>
102e1b66:	3b04      	subs	r3, #4
102e1b68:	681c      	ldr	r4, [r3, #0]
102e1b6a:	2c00      	cmp	r4, #0
102e1b6c:	d0f9      	beq.n	102e1b62 <__hexnan+0x11a>
102e1b6e:	2005      	movs	r0, #5
102e1b70:	e017      	b.n	102e1ba2 <__hexnan+0x15a>
102e1b72:	2101      	movs	r1, #1
102e1b74:	3001      	adds	r0, #1
102e1b76:	448c      	add	ip, r1
102e1b78:	2808      	cmp	r0, #8
102e1b7a:	dc07      	bgt.n	102e1b8c <__hexnan+0x144>
102e1b7c:	6834      	ldr	r4, [r6, #0]
102e1b7e:	0121      	lsls	r1, r4, #4
102e1b80:	240f      	movs	r4, #15
102e1b82:	4022      	ands	r2, r4
102e1b84:	430a      	orrs	r2, r1
102e1b86:	6032      	str	r2, [r6, #0]
102e1b88:	3301      	adds	r3, #1
102e1b8a:	e7c2      	b.n	102e1b12 <__hexnan+0xca>
102e1b8c:	4546      	cmp	r6, r8
102e1b8e:	d9bf      	bls.n	102e1b10 <__hexnan+0xc8>
102e1b90:	3e04      	subs	r6, #4
102e1b92:	2100      	movs	r1, #0
102e1b94:	6031      	str	r1, [r6, #0]
102e1b96:	2001      	movs	r0, #1
102e1b98:	e7f2      	b.n	102e1b80 <__hexnan+0x138>
102e1b9a:	4662      	mov	r2, ip
102e1b9c:	2929      	cmp	r1, #41	; 0x29
102e1b9e:	d03c      	beq.n	102e1c1a <__hexnan+0x1d2>
102e1ba0:	2004      	movs	r0, #4
102e1ba2:	b007      	add	sp, #28
102e1ba4:	bc3c      	pop	{r2, r3, r4, r5}
102e1ba6:	4690      	mov	r8, r2
102e1ba8:	4699      	mov	r9, r3
102e1baa:	46a2      	mov	sl, r4
102e1bac:	46ab      	mov	fp, r5
102e1bae:	bcf0      	pop	{r4, r5, r6, r7}
102e1bb0:	bc02      	pop	{r1}
102e1bb2:	4708      	bx	r1
102e1bb4:	2308      	movs	r3, #8
102e1bb6:	1a18      	subs	r0, r3, r0
102e1bb8:	0080      	lsls	r0, r0, #2
102e1bba:	2720      	movs	r7, #32
102e1bbc:	1a3f      	subs	r7, r7, r0
102e1bbe:	6831      	ldr	r1, [r6, #0]
102e1bc0:	1c32      	adds	r2, r6, #0
102e1bc2:	1d33      	adds	r3, r6, #4
102e1bc4:	46b4      	mov	ip, r6
102e1bc6:	1c3e      	adds	r6, r7, #0
102e1bc8:	1c07      	adds	r7, r0, #0
102e1bca:	4648      	mov	r0, r9
102e1bcc:	681c      	ldr	r4, [r3, #0]
102e1bce:	1c25      	adds	r5, r4, #0
102e1bd0:	40b5      	lsls	r5, r6
102e1bd2:	4329      	orrs	r1, r5
102e1bd4:	c202      	stmia	r2!, {r1}
102e1bd6:	1c21      	adds	r1, r4, #0
102e1bd8:	40f9      	lsrs	r1, r7
102e1bda:	c302      	stmia	r3!, {r1}
102e1bdc:	4290      	cmp	r0, r2
102e1bde:	d8f5      	bhi.n	102e1bcc <__hexnan+0x184>
102e1be0:	4666      	mov	r6, ip
102e1be2:	45b0      	cmp	r8, r6
102e1be4:	d3a6      	bcc.n	102e1b34 <__hexnan+0xec>
102e1be6:	9a04      	ldr	r2, [sp, #16]
102e1be8:	2a00      	cmp	r2, #0
102e1bea:	d013      	beq.n	102e1c14 <__hexnan+0x1cc>
102e1bec:	9904      	ldr	r1, [sp, #16]
102e1bee:	2220      	movs	r2, #32
102e1bf0:	2301      	movs	r3, #1
102e1bf2:	1a52      	subs	r2, r2, r1
102e1bf4:	425b      	negs	r3, r3
102e1bf6:	40d3      	lsrs	r3, r2
102e1bf8:	9a03      	ldr	r2, [sp, #12]
102e1bfa:	6812      	ldr	r2, [r2, #0]
102e1bfc:	9c03      	ldr	r4, [sp, #12]
102e1bfe:	4013      	ands	r3, r2
102e1c00:	6023      	str	r3, [r4, #0]
102e1c02:	e7a6      	b.n	102e1b52 <__hexnan+0x10a>
102e1c04:	f7ff fc48 	bl	102e1498 <__hexdig_init>
102e1c08:	e72e      	b.n	102e1a68 <__hexnan+0x20>
102e1c0a:	4643      	mov	r3, r8
102e1c0c:	2201      	movs	r2, #1
102e1c0e:	601a      	str	r2, [r3, #0]
102e1c10:	2005      	movs	r0, #5
102e1c12:	e7c6      	b.n	102e1ba2 <__hexnan+0x15a>
102e1c14:	9c03      	ldr	r4, [sp, #12]
102e1c16:	6823      	ldr	r3, [r4, #0]
102e1c18:	e79b      	b.n	102e1b52 <__hexnan+0x10a>
102e1c1a:	9c05      	ldr	r4, [sp, #20]
102e1c1c:	3302      	adds	r3, #2
102e1c1e:	6023      	str	r3, [r4, #0]
102e1c20:	e77b      	b.n	102e1b1a <__hexnan+0xd2>
102e1c22:	46c0      	nop			; (mov r8, r8)
102e1c24:	f03de54c 	.word	0xf03de54c

102e1c28 <_setlocale_r>:
102e1c28:	b538      	push	{r3, r4, r5, lr}
102e1c2a:	1e14      	subs	r4, r2, #0
102e1c2c:	d005      	beq.n	102e1c3a <_setlocale_r+0x12>
102e1c2e:	1c20      	adds	r0, r4, #0
102e1c30:	490c      	ldr	r1, [pc, #48]	; (102e1c64 <_setlocale_r+0x3c>)
102e1c32:	f7fe f985 	bl	102dff40 <strcmp>
102e1c36:	2800      	cmp	r0, #0
102e1c38:	d104      	bne.n	102e1c44 <_setlocale_r+0x1c>
102e1c3a:	4d0b      	ldr	r5, [pc, #44]	; (102e1c68 <_setlocale_r+0x40>)
102e1c3c:	1c28      	adds	r0, r5, #0
102e1c3e:	bc38      	pop	{r3, r4, r5}
102e1c40:	bc02      	pop	{r1}
102e1c42:	4708      	bx	r1
102e1c44:	4d08      	ldr	r5, [pc, #32]	; (102e1c68 <_setlocale_r+0x40>)
102e1c46:	1c20      	adds	r0, r4, #0
102e1c48:	1c29      	adds	r1, r5, #0
102e1c4a:	f7fe f979 	bl	102dff40 <strcmp>
102e1c4e:	2800      	cmp	r0, #0
102e1c50:	d0f4      	beq.n	102e1c3c <_setlocale_r+0x14>
102e1c52:	1c20      	adds	r0, r4, #0
102e1c54:	4905      	ldr	r1, [pc, #20]	; (102e1c6c <_setlocale_r+0x44>)
102e1c56:	f7fe f973 	bl	102dff40 <strcmp>
102e1c5a:	4243      	negs	r3, r0
102e1c5c:	4158      	adcs	r0, r3
102e1c5e:	4240      	negs	r0, r0
102e1c60:	4028      	ands	r0, r5
102e1c62:	e7ec      	b.n	102e1c3e <_setlocale_r+0x16>
102e1c64:	102f036c 	.word	0x102f036c
102e1c68:	102f0368 	.word	0x102f0368
102e1c6c:	102f01ac 	.word	0x102f01ac

102e1c70 <__locale_charset>:
102e1c70:	4800      	ldr	r0, [pc, #0]	; (102e1c74 <__locale_charset+0x4>)
102e1c72:	4770      	bx	lr
102e1c74:	f03d4bc0 	.word	0xf03d4bc0

102e1c78 <__locale_mb_cur_max>:
102e1c78:	4b01      	ldr	r3, [pc, #4]	; (102e1c80 <__locale_mb_cur_max+0x8>)
102e1c7a:	6a18      	ldr	r0, [r3, #32]
102e1c7c:	4770      	bx	lr
102e1c7e:	46c0      	nop			; (mov r8, r8)
102e1c80:	f03d4bc0 	.word	0xf03d4bc0

102e1c84 <__locale_msgcharset>:
102e1c84:	4801      	ldr	r0, [pc, #4]	; (102e1c8c <__locale_msgcharset+0x8>)
102e1c86:	3024      	adds	r0, #36	; 0x24
102e1c88:	4770      	bx	lr
102e1c8a:	46c0      	nop			; (mov r8, r8)
102e1c8c:	f03d4bc0 	.word	0xf03d4bc0

102e1c90 <__locale_cjk_lang>:
102e1c90:	2000      	movs	r0, #0
102e1c92:	4770      	bx	lr

102e1c94 <_localeconv_r>:
102e1c94:	4801      	ldr	r0, [pc, #4]	; (102e1c9c <_localeconv_r+0x8>)
102e1c96:	3044      	adds	r0, #68	; 0x44
102e1c98:	4770      	bx	lr
102e1c9a:	46c0      	nop			; (mov r8, r8)
102e1c9c:	f03d4bc0 	.word	0xf03d4bc0

102e1ca0 <setlocale>:
102e1ca0:	b508      	push	{r3, lr}
102e1ca2:	1c0a      	adds	r2, r1, #0
102e1ca4:	4904      	ldr	r1, [pc, #16]	; (102e1cb8 <setlocale+0x18>)
102e1ca6:	1c03      	adds	r3, r0, #0
102e1ca8:	6808      	ldr	r0, [r1, #0]
102e1caa:	1c19      	adds	r1, r3, #0
102e1cac:	f7ff ffbc 	bl	102e1c28 <_setlocale_r>
102e1cb0:	bc08      	pop	{r3}
102e1cb2:	bc02      	pop	{r1}
102e1cb4:	4708      	bx	r1
102e1cb6:	46c0      	nop			; (mov r8, r8)
102e1cb8:	f03d4790 	.word	0xf03d4790

102e1cbc <localeconv>:
102e1cbc:	4801      	ldr	r0, [pc, #4]	; (102e1cc4 <localeconv+0x8>)
102e1cbe:	3044      	adds	r0, #68	; 0x44
102e1cc0:	4770      	bx	lr
102e1cc2:	46c0      	nop			; (mov r8, r8)
102e1cc4:	f03d4bc0 	.word	0xf03d4bc0

102e1cc8 <_malloc_r>:
102e1cc8:	b5f0      	push	{r4, r5, r6, r7, lr}
102e1cca:	4656      	mov	r6, sl
102e1ccc:	4644      	mov	r4, r8
102e1cce:	465f      	mov	r7, fp
102e1cd0:	464d      	mov	r5, r9
102e1cd2:	b4f0      	push	{r4, r5, r6, r7}
102e1cd4:	1c0c      	adds	r4, r1, #0
102e1cd6:	340b      	adds	r4, #11
102e1cd8:	b083      	sub	sp, #12
102e1cda:	1c06      	adds	r6, r0, #0
102e1cdc:	2c16      	cmp	r4, #22
102e1cde:	d92e      	bls.n	102e1d3e <_malloc_r+0x76>
102e1ce0:	2307      	movs	r3, #7
102e1ce2:	439c      	bics	r4, r3
102e1ce4:	0fe3      	lsrs	r3, r4, #31
102e1ce6:	428c      	cmp	r4, r1
102e1ce8:	d32d      	bcc.n	102e1d46 <_malloc_r+0x7e>
102e1cea:	2b00      	cmp	r3, #0
102e1cec:	d12b      	bne.n	102e1d46 <_malloc_r+0x7e>
102e1cee:	1c30      	adds	r0, r6, #0
102e1cf0:	f000 face 	bl	102e2290 <__malloc_lock>
102e1cf4:	4bbf      	ldr	r3, [pc, #764]	; (102e1ff4 <_malloc_r+0x32c>)
102e1cf6:	429c      	cmp	r4, r3
102e1cf8:	d829      	bhi.n	102e1d4e <_malloc_r+0x86>
102e1cfa:	08e2      	lsrs	r2, r4, #3
102e1cfc:	4dbe      	ldr	r5, [pc, #760]	; (102e1ff8 <_malloc_r+0x330>)
102e1cfe:	00d3      	lsls	r3, r2, #3
102e1d00:	18eb      	adds	r3, r5, r3
102e1d02:	68df      	ldr	r7, [r3, #12]
102e1d04:	429f      	cmp	r7, r3
102e1d06:	d100      	bne.n	102e1d0a <_malloc_r+0x42>
102e1d08:	e1d6      	b.n	102e20b8 <_malloc_r+0x3f0>
102e1d0a:	6879      	ldr	r1, [r7, #4]
102e1d0c:	2303      	movs	r3, #3
102e1d0e:	68fa      	ldr	r2, [r7, #12]
102e1d10:	4399      	bics	r1, r3
102e1d12:	68bb      	ldr	r3, [r7, #8]
102e1d14:	60da      	str	r2, [r3, #12]
102e1d16:	6093      	str	r3, [r2, #8]
102e1d18:	187b      	adds	r3, r7, r1
102e1d1a:	6858      	ldr	r0, [r3, #4]
102e1d1c:	2201      	movs	r2, #1
102e1d1e:	4302      	orrs	r2, r0
102e1d20:	605a      	str	r2, [r3, #4]
102e1d22:	1c30      	adds	r0, r6, #0
102e1d24:	f000 fab6 	bl	102e2294 <__malloc_unlock>
102e1d28:	1c38      	adds	r0, r7, #0
102e1d2a:	3008      	adds	r0, #8
102e1d2c:	b003      	add	sp, #12
102e1d2e:	bc3c      	pop	{r2, r3, r4, r5}
102e1d30:	4690      	mov	r8, r2
102e1d32:	4699      	mov	r9, r3
102e1d34:	46a2      	mov	sl, r4
102e1d36:	46ab      	mov	fp, r5
102e1d38:	bcf0      	pop	{r4, r5, r6, r7}
102e1d3a:	bc02      	pop	{r1}
102e1d3c:	4708      	bx	r1
102e1d3e:	2410      	movs	r4, #16
102e1d40:	2300      	movs	r3, #0
102e1d42:	428c      	cmp	r4, r1
102e1d44:	d2d1      	bcs.n	102e1cea <_malloc_r+0x22>
102e1d46:	230c      	movs	r3, #12
102e1d48:	6033      	str	r3, [r6, #0]
102e1d4a:	2000      	movs	r0, #0
102e1d4c:	e7ee      	b.n	102e1d2c <_malloc_r+0x64>
102e1d4e:	0a63      	lsrs	r3, r4, #9
102e1d50:	d100      	bne.n	102e1d54 <_malloc_r+0x8c>
102e1d52:	e08b      	b.n	102e1e6c <_malloc_r+0x1a4>
102e1d54:	2b04      	cmp	r3, #4
102e1d56:	d900      	bls.n	102e1d5a <_malloc_r+0x92>
102e1d58:	e140      	b.n	102e1fdc <_malloc_r+0x314>
102e1d5a:	09a3      	lsrs	r3, r4, #6
102e1d5c:	3338      	adds	r3, #56	; 0x38
102e1d5e:	4698      	mov	r8, r3
102e1d60:	0059      	lsls	r1, r3, #1
102e1d62:	4da5      	ldr	r5, [pc, #660]	; (102e1ff8 <_malloc_r+0x330>)
102e1d64:	0089      	lsls	r1, r1, #2
102e1d66:	1869      	adds	r1, r5, r1
102e1d68:	68cf      	ldr	r7, [r1, #12]
102e1d6a:	42b9      	cmp	r1, r7
102e1d6c:	d013      	beq.n	102e1d96 <_malloc_r+0xce>
102e1d6e:	687a      	ldr	r2, [r7, #4]
102e1d70:	2303      	movs	r3, #3
102e1d72:	439a      	bics	r2, r3
102e1d74:	1b13      	subs	r3, r2, r4
102e1d76:	2b0f      	cmp	r3, #15
102e1d78:	dc7c      	bgt.n	102e1e74 <_malloc_r+0x1ac>
102e1d7a:	2003      	movs	r0, #3
102e1d7c:	2b00      	cmp	r3, #0
102e1d7e:	db07      	blt.n	102e1d90 <_malloc_r+0xc8>
102e1d80:	e07c      	b.n	102e1e7c <_malloc_r+0x1b4>
102e1d82:	687a      	ldr	r2, [r7, #4]
102e1d84:	4382      	bics	r2, r0
102e1d86:	1b13      	subs	r3, r2, r4
102e1d88:	2b0f      	cmp	r3, #15
102e1d8a:	dc73      	bgt.n	102e1e74 <_malloc_r+0x1ac>
102e1d8c:	2b00      	cmp	r3, #0
102e1d8e:	da75      	bge.n	102e1e7c <_malloc_r+0x1b4>
102e1d90:	68ff      	ldr	r7, [r7, #12]
102e1d92:	42b9      	cmp	r1, r7
102e1d94:	d1f5      	bne.n	102e1d82 <_malloc_r+0xba>
102e1d96:	2101      	movs	r1, #1
102e1d98:	4488      	add	r8, r1
102e1d9a:	1c2b      	adds	r3, r5, #0
102e1d9c:	692f      	ldr	r7, [r5, #16]
102e1d9e:	3308      	adds	r3, #8
102e1da0:	429f      	cmp	r7, r3
102e1da2:	d100      	bne.n	102e1da6 <_malloc_r+0xde>
102e1da4:	e165      	b.n	102e2072 <_malloc_r+0x3aa>
102e1da6:	6878      	ldr	r0, [r7, #4]
102e1da8:	2203      	movs	r2, #3
102e1daa:	4390      	bics	r0, r2
102e1dac:	1c02      	adds	r2, r0, #0
102e1dae:	1b01      	subs	r1, r0, r4
102e1db0:	290f      	cmp	r1, #15
102e1db2:	dd00      	ble.n	102e1db6 <_malloc_r+0xee>
102e1db4:	e14c      	b.n	102e2050 <_malloc_r+0x388>
102e1db6:	616b      	str	r3, [r5, #20]
102e1db8:	612b      	str	r3, [r5, #16]
102e1dba:	2900      	cmp	r1, #0
102e1dbc:	da6d      	bge.n	102e1e9a <_malloc_r+0x1d2>
102e1dbe:	4b8f      	ldr	r3, [pc, #572]	; (102e1ffc <_malloc_r+0x334>)
102e1dc0:	4298      	cmp	r0, r3
102e1dc2:	d900      	bls.n	102e1dc6 <_malloc_r+0xfe>
102e1dc4:	e124      	b.n	102e2010 <_malloc_r+0x348>
102e1dc6:	08c2      	lsrs	r2, r0, #3
102e1dc8:	1093      	asrs	r3, r2, #2
102e1dca:	2001      	movs	r0, #1
102e1dcc:	4098      	lsls	r0, r3
102e1dce:	686b      	ldr	r3, [r5, #4]
102e1dd0:	00d2      	lsls	r2, r2, #3
102e1dd2:	4318      	orrs	r0, r3
102e1dd4:	18ab      	adds	r3, r5, r2
102e1dd6:	689a      	ldr	r2, [r3, #8]
102e1dd8:	60fb      	str	r3, [r7, #12]
102e1dda:	60ba      	str	r2, [r7, #8]
102e1ddc:	6068      	str	r0, [r5, #4]
102e1dde:	609f      	str	r7, [r3, #8]
102e1de0:	60d7      	str	r7, [r2, #12]
102e1de2:	4642      	mov	r2, r8
102e1de4:	1091      	asrs	r1, r2, #2
102e1de6:	2301      	movs	r3, #1
102e1de8:	408b      	lsls	r3, r1
102e1dea:	1c19      	adds	r1, r3, #0
102e1dec:	4283      	cmp	r3, r0
102e1dee:	d859      	bhi.n	102e1ea4 <_malloc_r+0x1dc>
102e1df0:	4203      	tst	r3, r0
102e1df2:	d10c      	bne.n	102e1e0e <_malloc_r+0x146>
102e1df4:	2303      	movs	r3, #3
102e1df6:	439a      	bics	r2, r3
102e1df8:	1c13      	adds	r3, r2, #0
102e1dfa:	3304      	adds	r3, #4
102e1dfc:	0049      	lsls	r1, r1, #1
102e1dfe:	4698      	mov	r8, r3
102e1e00:	4201      	tst	r1, r0
102e1e02:	d104      	bne.n	102e1e0e <_malloc_r+0x146>
102e1e04:	2304      	movs	r3, #4
102e1e06:	0049      	lsls	r1, r1, #1
102e1e08:	4498      	add	r8, r3
102e1e0a:	4201      	tst	r1, r0
102e1e0c:	d0fa      	beq.n	102e1e04 <_malloc_r+0x13c>
102e1e0e:	2003      	movs	r0, #3
102e1e10:	4684      	mov	ip, r0
102e1e12:	4642      	mov	r2, r8
102e1e14:	00d3      	lsls	r3, r2, #3
102e1e16:	195b      	adds	r3, r3, r5
102e1e18:	469a      	mov	sl, r3
102e1e1a:	1c18      	adds	r0, r3, #0
102e1e1c:	46c1      	mov	r9, r8
102e1e1e:	68c7      	ldr	r7, [r0, #12]
102e1e20:	42b8      	cmp	r0, r7
102e1e22:	d107      	bne.n	102e1e34 <_malloc_r+0x16c>
102e1e24:	e127      	b.n	102e2076 <_malloc_r+0x3ae>
102e1e26:	2b00      	cmp	r3, #0
102e1e28:	db00      	blt.n	102e1e2c <_malloc_r+0x164>
102e1e2a:	e14e      	b.n	102e20ca <_malloc_r+0x402>
102e1e2c:	68ff      	ldr	r7, [r7, #12]
102e1e2e:	42b8      	cmp	r0, r7
102e1e30:	d100      	bne.n	102e1e34 <_malloc_r+0x16c>
102e1e32:	e120      	b.n	102e2076 <_malloc_r+0x3ae>
102e1e34:	687a      	ldr	r2, [r7, #4]
102e1e36:	4663      	mov	r3, ip
102e1e38:	439a      	bics	r2, r3
102e1e3a:	1b13      	subs	r3, r2, r4
102e1e3c:	2b0f      	cmp	r3, #15
102e1e3e:	ddf2      	ble.n	102e1e26 <_malloc_r+0x15e>
102e1e40:	2001      	movs	r0, #1
102e1e42:	193a      	adds	r2, r7, r4
102e1e44:	4304      	orrs	r4, r0
102e1e46:	68b9      	ldr	r1, [r7, #8]
102e1e48:	607c      	str	r4, [r7, #4]
102e1e4a:	68fc      	ldr	r4, [r7, #12]
102e1e4c:	4318      	orrs	r0, r3
102e1e4e:	60cc      	str	r4, [r1, #12]
102e1e50:	60a1      	str	r1, [r4, #8]
102e1e52:	616a      	str	r2, [r5, #20]
102e1e54:	612a      	str	r2, [r5, #16]
102e1e56:	3508      	adds	r5, #8
102e1e58:	6050      	str	r0, [r2, #4]
102e1e5a:	60d5      	str	r5, [r2, #12]
102e1e5c:	1c30      	adds	r0, r6, #0
102e1e5e:	6095      	str	r5, [r2, #8]
102e1e60:	50d3      	str	r3, [r2, r3]
102e1e62:	f000 fa17 	bl	102e2294 <__malloc_unlock>
102e1e66:	1c38      	adds	r0, r7, #0
102e1e68:	3008      	adds	r0, #8
102e1e6a:	e75f      	b.n	102e1d2c <_malloc_r+0x64>
102e1e6c:	08e1      	lsrs	r1, r4, #3
102e1e6e:	4688      	mov	r8, r1
102e1e70:	0049      	lsls	r1, r1, #1
102e1e72:	e776      	b.n	102e1d62 <_malloc_r+0x9a>
102e1e74:	2301      	movs	r3, #1
102e1e76:	425b      	negs	r3, r3
102e1e78:	4498      	add	r8, r3
102e1e7a:	e78c      	b.n	102e1d96 <_malloc_r+0xce>
102e1e7c:	68bb      	ldr	r3, [r7, #8]
102e1e7e:	68f9      	ldr	r1, [r7, #12]
102e1e80:	18ba      	adds	r2, r7, r2
102e1e82:	6850      	ldr	r0, [r2, #4]
102e1e84:	60d9      	str	r1, [r3, #12]
102e1e86:	608b      	str	r3, [r1, #8]
102e1e88:	2301      	movs	r3, #1
102e1e8a:	4303      	orrs	r3, r0
102e1e8c:	1c30      	adds	r0, r6, #0
102e1e8e:	6053      	str	r3, [r2, #4]
102e1e90:	f000 fa00 	bl	102e2294 <__malloc_unlock>
102e1e94:	1c38      	adds	r0, r7, #0
102e1e96:	3008      	adds	r0, #8
102e1e98:	e748      	b.n	102e1d2c <_malloc_r+0x64>
102e1e9a:	183a      	adds	r2, r7, r0
102e1e9c:	6851      	ldr	r1, [r2, #4]
102e1e9e:	2301      	movs	r3, #1
102e1ea0:	430b      	orrs	r3, r1
102e1ea2:	e7f3      	b.n	102e1e8c <_malloc_r+0x1c4>
102e1ea4:	68af      	ldr	r7, [r5, #8]
102e1ea6:	6878      	ldr	r0, [r7, #4]
102e1ea8:	2303      	movs	r3, #3
102e1eaa:	4398      	bics	r0, r3
102e1eac:	4681      	mov	r9, r0
102e1eae:	4284      	cmp	r4, r0
102e1eb0:	d803      	bhi.n	102e1eba <_malloc_r+0x1f2>
102e1eb2:	1b03      	subs	r3, r0, r4
102e1eb4:	2b0f      	cmp	r3, #15
102e1eb6:	dd00      	ble.n	102e1eba <_malloc_r+0x1f2>
102e1eb8:	e082      	b.n	102e1fc0 <_malloc_r+0x2f8>
102e1eba:	4649      	mov	r1, r9
102e1ebc:	1879      	adds	r1, r7, r1
102e1ebe:	4a50      	ldr	r2, [pc, #320]	; (102e2000 <_malloc_r+0x338>)
102e1ec0:	9101      	str	r1, [sp, #4]
102e1ec2:	4950      	ldr	r1, [pc, #320]	; (102e2004 <_malloc_r+0x33c>)
102e1ec4:	6810      	ldr	r0, [r2, #0]
102e1ec6:	4692      	mov	sl, r2
102e1ec8:	688a      	ldr	r2, [r1, #8]
102e1eca:	1823      	adds	r3, r4, r0
102e1ecc:	468b      	mov	fp, r1
102e1ece:	3201      	adds	r2, #1
102e1ed0:	d100      	bne.n	102e1ed4 <_malloc_r+0x20c>
102e1ed2:	e13d      	b.n	102e2150 <_malloc_r+0x488>
102e1ed4:	484c      	ldr	r0, [pc, #304]	; (102e2008 <_malloc_r+0x340>)
102e1ed6:	181b      	adds	r3, r3, r0
102e1ed8:	0b1b      	lsrs	r3, r3, #12
102e1eda:	031b      	lsls	r3, r3, #12
102e1edc:	9300      	str	r3, [sp, #0]
102e1ede:	9900      	ldr	r1, [sp, #0]
102e1ee0:	1c30      	adds	r0, r6, #0
102e1ee2:	f000 fe91 	bl	102e2c08 <_sbrk_r>
102e1ee6:	1c01      	adds	r1, r0, #0
102e1ee8:	4680      	mov	r8, r0
102e1eea:	3101      	adds	r1, #1
102e1eec:	d05d      	beq.n	102e1faa <_malloc_r+0x2e2>
102e1eee:	9a01      	ldr	r2, [sp, #4]
102e1ef0:	4282      	cmp	r2, r0
102e1ef2:	d900      	bls.n	102e1ef6 <_malloc_r+0x22e>
102e1ef4:	e101      	b.n	102e20fa <_malloc_r+0x432>
102e1ef6:	4651      	mov	r1, sl
102e1ef8:	9800      	ldr	r0, [sp, #0]
102e1efa:	6849      	ldr	r1, [r1, #4]
102e1efc:	1843      	adds	r3, r0, r1
102e1efe:	9801      	ldr	r0, [sp, #4]
102e1f00:	4652      	mov	r2, sl
102e1f02:	6053      	str	r3, [r2, #4]
102e1f04:	4540      	cmp	r0, r8
102e1f06:	d100      	bne.n	102e1f0a <_malloc_r+0x242>
102e1f08:	e130      	b.n	102e216c <_malloc_r+0x4a4>
102e1f0a:	4659      	mov	r1, fp
102e1f0c:	6889      	ldr	r1, [r1, #8]
102e1f0e:	3101      	adds	r1, #1
102e1f10:	d100      	bne.n	102e1f14 <_malloc_r+0x24c>
102e1f12:	e141      	b.n	102e2198 <_malloc_r+0x4d0>
102e1f14:	9901      	ldr	r1, [sp, #4]
102e1f16:	4640      	mov	r0, r8
102e1f18:	1a42      	subs	r2, r0, r1
102e1f1a:	189b      	adds	r3, r3, r2
102e1f1c:	4652      	mov	r2, sl
102e1f1e:	6053      	str	r3, [r2, #4]
102e1f20:	2307      	movs	r3, #7
102e1f22:	4640      	mov	r0, r8
102e1f24:	4003      	ands	r3, r0
102e1f26:	d100      	bne.n	102e1f2a <_malloc_r+0x262>
102e1f28:	e0f9      	b.n	102e211e <_malloc_r+0x456>
102e1f2a:	1ac2      	subs	r2, r0, r3
102e1f2c:	3208      	adds	r2, #8
102e1f2e:	4690      	mov	r8, r2
102e1f30:	4a36      	ldr	r2, [pc, #216]	; (102e200c <_malloc_r+0x344>)
102e1f32:	1ad3      	subs	r3, r2, r3
102e1f34:	9a00      	ldr	r2, [sp, #0]
102e1f36:	4442      	add	r2, r8
102e1f38:	0512      	lsls	r2, r2, #20
102e1f3a:	0d12      	lsrs	r2, r2, #20
102e1f3c:	1a9a      	subs	r2, r3, r2
102e1f3e:	1c11      	adds	r1, r2, #0
102e1f40:	1c30      	adds	r0, r6, #0
102e1f42:	4693      	mov	fp, r2
102e1f44:	f000 fe60 	bl	102e2c08 <_sbrk_r>
102e1f48:	1c41      	adds	r1, r0, #1
102e1f4a:	d100      	bne.n	102e1f4e <_malloc_r+0x286>
102e1f4c:	e118      	b.n	102e2180 <_malloc_r+0x4b8>
102e1f4e:	4642      	mov	r2, r8
102e1f50:	1a80      	subs	r0, r0, r2
102e1f52:	4458      	add	r0, fp
102e1f54:	2301      	movs	r3, #1
102e1f56:	4318      	orrs	r0, r3
102e1f58:	4651      	mov	r1, sl
102e1f5a:	684b      	ldr	r3, [r1, #4]
102e1f5c:	4642      	mov	r2, r8
102e1f5e:	445b      	add	r3, fp
102e1f60:	604b      	str	r3, [r1, #4]
102e1f62:	60aa      	str	r2, [r5, #8]
102e1f64:	6050      	str	r0, [r2, #4]
102e1f66:	42af      	cmp	r7, r5
102e1f68:	d013      	beq.n	102e1f92 <_malloc_r+0x2ca>
102e1f6a:	4648      	mov	r0, r9
102e1f6c:	280f      	cmp	r0, #15
102e1f6e:	d800      	bhi.n	102e1f72 <_malloc_r+0x2aa>
102e1f70:	e0e1      	b.n	102e2136 <_malloc_r+0x46e>
102e1f72:	464a      	mov	r2, r9
102e1f74:	6878      	ldr	r0, [r7, #4]
102e1f76:	2107      	movs	r1, #7
102e1f78:	3a0c      	subs	r2, #12
102e1f7a:	438a      	bics	r2, r1
102e1f7c:	2101      	movs	r1, #1
102e1f7e:	4001      	ands	r1, r0
102e1f80:	4311      	orrs	r1, r2
102e1f82:	6079      	str	r1, [r7, #4]
102e1f84:	2005      	movs	r0, #5
102e1f86:	18b9      	adds	r1, r7, r2
102e1f88:	6048      	str	r0, [r1, #4]
102e1f8a:	6088      	str	r0, [r1, #8]
102e1f8c:	2a0f      	cmp	r2, #15
102e1f8e:	d900      	bls.n	102e1f92 <_malloc_r+0x2ca>
102e1f90:	e0fa      	b.n	102e2188 <_malloc_r+0x4c0>
102e1f92:	4652      	mov	r2, sl
102e1f94:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
102e1f96:	4293      	cmp	r3, r2
102e1f98:	d901      	bls.n	102e1f9e <_malloc_r+0x2d6>
102e1f9a:	4650      	mov	r0, sl
102e1f9c:	62c3      	str	r3, [r0, #44]	; 0x2c
102e1f9e:	4651      	mov	r1, sl
102e1fa0:	6b09      	ldr	r1, [r1, #48]	; 0x30
102e1fa2:	428b      	cmp	r3, r1
102e1fa4:	d901      	bls.n	102e1faa <_malloc_r+0x2e2>
102e1fa6:	4652      	mov	r2, sl
102e1fa8:	6313      	str	r3, [r2, #48]	; 0x30
102e1faa:	68af      	ldr	r7, [r5, #8]
102e1fac:	687a      	ldr	r2, [r7, #4]
102e1fae:	2303      	movs	r3, #3
102e1fb0:	439a      	bics	r2, r3
102e1fb2:	1b13      	subs	r3, r2, r4
102e1fb4:	4294      	cmp	r4, r2
102e1fb6:	d900      	bls.n	102e1fba <_malloc_r+0x2f2>
102e1fb8:	e0a3      	b.n	102e2102 <_malloc_r+0x43a>
102e1fba:	2b0f      	cmp	r3, #15
102e1fbc:	dc00      	bgt.n	102e1fc0 <_malloc_r+0x2f8>
102e1fbe:	e0a0      	b.n	102e2102 <_malloc_r+0x43a>
102e1fc0:	2201      	movs	r2, #1
102e1fc2:	1c21      	adds	r1, r4, #0
102e1fc4:	4311      	orrs	r1, r2
102e1fc6:	193c      	adds	r4, r7, r4
102e1fc8:	4313      	orrs	r3, r2
102e1fca:	6079      	str	r1, [r7, #4]
102e1fcc:	1c30      	adds	r0, r6, #0
102e1fce:	60ac      	str	r4, [r5, #8]
102e1fd0:	6063      	str	r3, [r4, #4]
102e1fd2:	f000 f95f 	bl	102e2294 <__malloc_unlock>
102e1fd6:	1c38      	adds	r0, r7, #0
102e1fd8:	3008      	adds	r0, #8
102e1fda:	e6a7      	b.n	102e1d2c <_malloc_r+0x64>
102e1fdc:	2b14      	cmp	r3, #20
102e1fde:	d800      	bhi.n	102e1fe2 <_malloc_r+0x31a>
102e1fe0:	e082      	b.n	102e20e8 <_malloc_r+0x420>
102e1fe2:	2b54      	cmp	r3, #84	; 0x54
102e1fe4:	d900      	bls.n	102e1fe8 <_malloc_r+0x320>
102e1fe6:	e091      	b.n	102e210c <_malloc_r+0x444>
102e1fe8:	0b23      	lsrs	r3, r4, #12
102e1fea:	336e      	adds	r3, #110	; 0x6e
102e1fec:	4698      	mov	r8, r3
102e1fee:	0059      	lsls	r1, r3, #1
102e1ff0:	e6b7      	b.n	102e1d62 <_malloc_r+0x9a>
102e1ff2:	46c0      	nop			; (mov r8, r8)
102e1ff4:	000001f7 	.word	0x000001f7
102e1ff8:	f03d4c3c 	.word	0xf03d4c3c
102e1ffc:	000001ff 	.word	0x000001ff
102e2000:	f03db790 	.word	0xf03db790
102e2004:	f03d503c 	.word	0xf03d503c
102e2008:	0000100f 	.word	0x0000100f
102e200c:	00001008 	.word	0x00001008
102e2010:	0a43      	lsrs	r3, r0, #9
102e2012:	2b04      	cmp	r3, #4
102e2014:	d96c      	bls.n	102e20f0 <_malloc_r+0x428>
102e2016:	2b14      	cmp	r3, #20
102e2018:	d900      	bls.n	102e201c <_malloc_r+0x354>
102e201a:	e09c      	b.n	102e2156 <_malloc_r+0x48e>
102e201c:	335b      	adds	r3, #91	; 0x5b
102e201e:	469a      	mov	sl, r3
102e2020:	0058      	lsls	r0, r3, #1
102e2022:	0080      	lsls	r0, r0, #2
102e2024:	1940      	adds	r0, r0, r5
102e2026:	6883      	ldr	r3, [r0, #8]
102e2028:	4681      	mov	r9, r0
102e202a:	2003      	movs	r0, #3
102e202c:	4684      	mov	ip, r0
102e202e:	454b      	cmp	r3, r9
102e2030:	d078      	beq.n	102e2124 <_malloc_r+0x45c>
102e2032:	6859      	ldr	r1, [r3, #4]
102e2034:	4660      	mov	r0, ip
102e2036:	4381      	bics	r1, r0
102e2038:	428a      	cmp	r2, r1
102e203a:	d202      	bcs.n	102e2042 <_malloc_r+0x37a>
102e203c:	689b      	ldr	r3, [r3, #8]
102e203e:	4599      	cmp	r9, r3
102e2040:	d1f7      	bne.n	102e2032 <_malloc_r+0x36a>
102e2042:	68da      	ldr	r2, [r3, #12]
102e2044:	6868      	ldr	r0, [r5, #4]
102e2046:	60fa      	str	r2, [r7, #12]
102e2048:	60bb      	str	r3, [r7, #8]
102e204a:	60df      	str	r7, [r3, #12]
102e204c:	6097      	str	r7, [r2, #8]
102e204e:	e6c8      	b.n	102e1de2 <_malloc_r+0x11a>
102e2050:	2001      	movs	r0, #1
102e2052:	193a      	adds	r2, r7, r4
102e2054:	4304      	orrs	r4, r0
102e2056:	4308      	orrs	r0, r1
102e2058:	607c      	str	r4, [r7, #4]
102e205a:	616a      	str	r2, [r5, #20]
102e205c:	612a      	str	r2, [r5, #16]
102e205e:	6050      	str	r0, [r2, #4]
102e2060:	60d3      	str	r3, [r2, #12]
102e2062:	1c30      	adds	r0, r6, #0
102e2064:	6093      	str	r3, [r2, #8]
102e2066:	5051      	str	r1, [r2, r1]
102e2068:	f000 f914 	bl	102e2294 <__malloc_unlock>
102e206c:	1c38      	adds	r0, r7, #0
102e206e:	3008      	adds	r0, #8
102e2070:	e65c      	b.n	102e1d2c <_malloc_r+0x64>
102e2072:	6868      	ldr	r0, [r5, #4]
102e2074:	e6b5      	b.n	102e1de2 <_malloc_r+0x11a>
102e2076:	2201      	movs	r2, #1
102e2078:	4491      	add	r9, r2
102e207a:	4663      	mov	r3, ip
102e207c:	464a      	mov	r2, r9
102e207e:	3008      	adds	r0, #8
102e2080:	4213      	tst	r3, r2
102e2082:	d000      	beq.n	102e2086 <_malloc_r+0x3be>
102e2084:	e6cb      	b.n	102e1e1e <_malloc_r+0x156>
102e2086:	4652      	mov	r2, sl
102e2088:	4643      	mov	r3, r8
102e208a:	4660      	mov	r0, ip
102e208c:	4218      	tst	r0, r3
102e208e:	d100      	bne.n	102e2092 <_malloc_r+0x3ca>
102e2090:	e097      	b.n	102e21c2 <_malloc_r+0x4fa>
102e2092:	1c10      	adds	r0, r2, #0
102e2094:	6812      	ldr	r2, [r2, #0]
102e2096:	3808      	subs	r0, #8
102e2098:	3b01      	subs	r3, #1
102e209a:	4282      	cmp	r2, r0
102e209c:	d0f5      	beq.n	102e208a <_malloc_r+0x3c2>
102e209e:	686b      	ldr	r3, [r5, #4]
102e20a0:	0049      	lsls	r1, r1, #1
102e20a2:	4299      	cmp	r1, r3
102e20a4:	d900      	bls.n	102e20a8 <_malloc_r+0x3e0>
102e20a6:	e6fd      	b.n	102e1ea4 <_malloc_r+0x1dc>
102e20a8:	2900      	cmp	r1, #0
102e20aa:	d100      	bne.n	102e20ae <_malloc_r+0x3e6>
102e20ac:	e6fa      	b.n	102e1ea4 <_malloc_r+0x1dc>
102e20ae:	4219      	tst	r1, r3
102e20b0:	d100      	bne.n	102e20b4 <_malloc_r+0x3ec>
102e20b2:	e08a      	b.n	102e21ca <_malloc_r+0x502>
102e20b4:	46c8      	mov	r8, r9
102e20b6:	e6ac      	b.n	102e1e12 <_malloc_r+0x14a>
102e20b8:	1c3b      	adds	r3, r7, #0
102e20ba:	697f      	ldr	r7, [r7, #20]
102e20bc:	3202      	adds	r2, #2
102e20be:	3308      	adds	r3, #8
102e20c0:	4690      	mov	r8, r2
102e20c2:	42bb      	cmp	r3, r7
102e20c4:	d100      	bne.n	102e20c8 <_malloc_r+0x400>
102e20c6:	e668      	b.n	102e1d9a <_malloc_r+0xd2>
102e20c8:	e61f      	b.n	102e1d0a <_malloc_r+0x42>
102e20ca:	18ba      	adds	r2, r7, r2
102e20cc:	6850      	ldr	r0, [r2, #4]
102e20ce:	2301      	movs	r3, #1
102e20d0:	4303      	orrs	r3, r0
102e20d2:	6053      	str	r3, [r2, #4]
102e20d4:	68fa      	ldr	r2, [r7, #12]
102e20d6:	68bb      	ldr	r3, [r7, #8]
102e20d8:	1c30      	adds	r0, r6, #0
102e20da:	60da      	str	r2, [r3, #12]
102e20dc:	6093      	str	r3, [r2, #8]
102e20de:	f000 f8d9 	bl	102e2294 <__malloc_unlock>
102e20e2:	1c38      	adds	r0, r7, #0
102e20e4:	3008      	adds	r0, #8
102e20e6:	e621      	b.n	102e1d2c <_malloc_r+0x64>
102e20e8:	335b      	adds	r3, #91	; 0x5b
102e20ea:	4698      	mov	r8, r3
102e20ec:	0059      	lsls	r1, r3, #1
102e20ee:	e638      	b.n	102e1d62 <_malloc_r+0x9a>
102e20f0:	0981      	lsrs	r1, r0, #6
102e20f2:	3138      	adds	r1, #56	; 0x38
102e20f4:	468a      	mov	sl, r1
102e20f6:	0048      	lsls	r0, r1, #1
102e20f8:	e793      	b.n	102e2022 <_malloc_r+0x35a>
102e20fa:	42af      	cmp	r7, r5
102e20fc:	d000      	beq.n	102e2100 <_malloc_r+0x438>
102e20fe:	e754      	b.n	102e1faa <_malloc_r+0x2e2>
102e2100:	e6f9      	b.n	102e1ef6 <_malloc_r+0x22e>
102e2102:	1c30      	adds	r0, r6, #0
102e2104:	f000 f8c6 	bl	102e2294 <__malloc_unlock>
102e2108:	2000      	movs	r0, #0
102e210a:	e60f      	b.n	102e1d2c <_malloc_r+0x64>
102e210c:	22aa      	movs	r2, #170	; 0xaa
102e210e:	0052      	lsls	r2, r2, #1
102e2110:	4293      	cmp	r3, r2
102e2112:	d815      	bhi.n	102e2140 <_malloc_r+0x478>
102e2114:	0be3      	lsrs	r3, r4, #15
102e2116:	3377      	adds	r3, #119	; 0x77
102e2118:	4698      	mov	r8, r3
102e211a:	0059      	lsls	r1, r3, #1
102e211c:	e621      	b.n	102e1d62 <_malloc_r+0x9a>
102e211e:	2380      	movs	r3, #128	; 0x80
102e2120:	015b      	lsls	r3, r3, #5
102e2122:	e707      	b.n	102e1f34 <_malloc_r+0x26c>
102e2124:	4652      	mov	r2, sl
102e2126:	1091      	asrs	r1, r2, #2
102e2128:	2001      	movs	r0, #1
102e212a:	4088      	lsls	r0, r1
102e212c:	6869      	ldr	r1, [r5, #4]
102e212e:	4308      	orrs	r0, r1
102e2130:	6068      	str	r0, [r5, #4]
102e2132:	1c1a      	adds	r2, r3, #0
102e2134:	e787      	b.n	102e2046 <_malloc_r+0x37e>
102e2136:	2301      	movs	r3, #1
102e2138:	6053      	str	r3, [r2, #4]
102e213a:	4647      	mov	r7, r8
102e213c:	2200      	movs	r2, #0
102e213e:	e738      	b.n	102e1fb2 <_malloc_r+0x2ea>
102e2140:	4a26      	ldr	r2, [pc, #152]	; (102e21dc <_malloc_r+0x514>)
102e2142:	4293      	cmp	r3, r2
102e2144:	d80e      	bhi.n	102e2164 <_malloc_r+0x49c>
102e2146:	0ca3      	lsrs	r3, r4, #18
102e2148:	337c      	adds	r3, #124	; 0x7c
102e214a:	4698      	mov	r8, r3
102e214c:	0059      	lsls	r1, r3, #1
102e214e:	e608      	b.n	102e1d62 <_malloc_r+0x9a>
102e2150:	3310      	adds	r3, #16
102e2152:	9300      	str	r3, [sp, #0]
102e2154:	e6c3      	b.n	102e1ede <_malloc_r+0x216>
102e2156:	2b54      	cmp	r3, #84	; 0x54
102e2158:	d822      	bhi.n	102e21a0 <_malloc_r+0x4d8>
102e215a:	0b01      	lsrs	r1, r0, #12
102e215c:	316e      	adds	r1, #110	; 0x6e
102e215e:	468a      	mov	sl, r1
102e2160:	0048      	lsls	r0, r1, #1
102e2162:	e75e      	b.n	102e2022 <_malloc_r+0x35a>
102e2164:	227e      	movs	r2, #126	; 0x7e
102e2166:	21fc      	movs	r1, #252	; 0xfc
102e2168:	4690      	mov	r8, r2
102e216a:	e5fa      	b.n	102e1d62 <_malloc_r+0x9a>
102e216c:	0502      	lsls	r2, r0, #20
102e216e:	d000      	beq.n	102e2172 <_malloc_r+0x4aa>
102e2170:	e6cb      	b.n	102e1f0a <_malloc_r+0x242>
102e2172:	9800      	ldr	r0, [sp, #0]
102e2174:	68aa      	ldr	r2, [r5, #8]
102e2176:	4448      	add	r0, r9
102e2178:	2101      	movs	r1, #1
102e217a:	4301      	orrs	r1, r0
102e217c:	6051      	str	r1, [r2, #4]
102e217e:	e708      	b.n	102e1f92 <_malloc_r+0x2ca>
102e2180:	2300      	movs	r3, #0
102e2182:	2001      	movs	r0, #1
102e2184:	469b      	mov	fp, r3
102e2186:	e6e7      	b.n	102e1f58 <_malloc_r+0x290>
102e2188:	1c39      	adds	r1, r7, #0
102e218a:	3108      	adds	r1, #8
102e218c:	1c30      	adds	r0, r6, #0
102e218e:	f7ff f857 	bl	102e1240 <_free_r>
102e2192:	4651      	mov	r1, sl
102e2194:	684b      	ldr	r3, [r1, #4]
102e2196:	e6fc      	b.n	102e1f92 <_malloc_r+0x2ca>
102e2198:	4642      	mov	r2, r8
102e219a:	465b      	mov	r3, fp
102e219c:	609a      	str	r2, [r3, #8]
102e219e:	e6bf      	b.n	102e1f20 <_malloc_r+0x258>
102e21a0:	21aa      	movs	r1, #170	; 0xaa
102e21a2:	0049      	lsls	r1, r1, #1
102e21a4:	428b      	cmp	r3, r1
102e21a6:	d804      	bhi.n	102e21b2 <_malloc_r+0x4ea>
102e21a8:	0bc1      	lsrs	r1, r0, #15
102e21aa:	3177      	adds	r1, #119	; 0x77
102e21ac:	468a      	mov	sl, r1
102e21ae:	0048      	lsls	r0, r1, #1
102e21b0:	e737      	b.n	102e2022 <_malloc_r+0x35a>
102e21b2:	490a      	ldr	r1, [pc, #40]	; (102e21dc <_malloc_r+0x514>)
102e21b4:	428b      	cmp	r3, r1
102e21b6:	d80c      	bhi.n	102e21d2 <_malloc_r+0x50a>
102e21b8:	0c81      	lsrs	r1, r0, #18
102e21ba:	317c      	adds	r1, #124	; 0x7c
102e21bc:	468a      	mov	sl, r1
102e21be:	0048      	lsls	r0, r1, #1
102e21c0:	e72f      	b.n	102e2022 <_malloc_r+0x35a>
102e21c2:	686b      	ldr	r3, [r5, #4]
102e21c4:	438b      	bics	r3, r1
102e21c6:	606b      	str	r3, [r5, #4]
102e21c8:	e76a      	b.n	102e20a0 <_malloc_r+0x3d8>
102e21ca:	2204      	movs	r2, #4
102e21cc:	4491      	add	r9, r2
102e21ce:	0049      	lsls	r1, r1, #1
102e21d0:	e76d      	b.n	102e20ae <_malloc_r+0x3e6>
102e21d2:	217e      	movs	r1, #126	; 0x7e
102e21d4:	20fc      	movs	r0, #252	; 0xfc
102e21d6:	468a      	mov	sl, r1
102e21d8:	e723      	b.n	102e2022 <_malloc_r+0x35a>
102e21da:	46c0      	nop			; (mov r8, r8)
102e21dc:	00000554 	.word	0x00000554

102e21e0 <memmove>:
102e21e0:	b5f0      	push	{r4, r5, r6, r7, lr}
102e21e2:	4288      	cmp	r0, r1
102e21e4:	d910      	bls.n	102e2208 <memmove+0x28>
102e21e6:	188d      	adds	r5, r1, r2
102e21e8:	42a8      	cmp	r0, r5
102e21ea:	d20d      	bcs.n	102e2208 <memmove+0x28>
102e21ec:	1886      	adds	r6, r0, r2
102e21ee:	1e53      	subs	r3, r2, #1
102e21f0:	4251      	negs	r1, r2
102e21f2:	2a00      	cmp	r2, #0
102e21f4:	d005      	beq.n	102e2202 <memmove+0x22>
102e21f6:	186a      	adds	r2, r5, r1
102e21f8:	5cd4      	ldrb	r4, [r2, r3]
102e21fa:	1872      	adds	r2, r6, r1
102e21fc:	54d4      	strb	r4, [r2, r3]
102e21fe:	3b01      	subs	r3, #1
102e2200:	d2f9      	bcs.n	102e21f6 <memmove+0x16>
102e2202:	bcf0      	pop	{r4, r5, r6, r7}
102e2204:	bc02      	pop	{r1}
102e2206:	4708      	bx	r1
102e2208:	2a0f      	cmp	r2, #15
102e220a:	d80b      	bhi.n	102e2224 <memmove+0x44>
102e220c:	1c0c      	adds	r4, r1, #0
102e220e:	1c03      	adds	r3, r0, #0
102e2210:	2a00      	cmp	r2, #0
102e2212:	d0f6      	beq.n	102e2202 <memmove+0x22>
102e2214:	189a      	adds	r2, r3, r2
102e2216:	7821      	ldrb	r1, [r4, #0]
102e2218:	7019      	strb	r1, [r3, #0]
102e221a:	3301      	adds	r3, #1
102e221c:	3401      	adds	r4, #1
102e221e:	4293      	cmp	r3, r2
102e2220:	d1f9      	bne.n	102e2216 <memmove+0x36>
102e2222:	e7ee      	b.n	102e2202 <memmove+0x22>
102e2224:	1c0b      	adds	r3, r1, #0
102e2226:	4303      	orrs	r3, r0
102e2228:	079c      	lsls	r4, r3, #30
102e222a:	d12b      	bne.n	102e2284 <memmove+0xa4>
102e222c:	1c13      	adds	r3, r2, #0
102e222e:	3b10      	subs	r3, #16
102e2230:	091b      	lsrs	r3, r3, #4
102e2232:	3301      	adds	r3, #1
102e2234:	011b      	lsls	r3, r3, #4
102e2236:	18cc      	adds	r4, r1, r3
102e2238:	1c05      	adds	r5, r0, #0
102e223a:	680e      	ldr	r6, [r1, #0]
102e223c:	602e      	str	r6, [r5, #0]
102e223e:	684e      	ldr	r6, [r1, #4]
102e2240:	606e      	str	r6, [r5, #4]
102e2242:	688e      	ldr	r6, [r1, #8]
102e2244:	60ae      	str	r6, [r5, #8]
102e2246:	68ce      	ldr	r6, [r1, #12]
102e2248:	3110      	adds	r1, #16
102e224a:	60ee      	str	r6, [r5, #12]
102e224c:	3510      	adds	r5, #16
102e224e:	428c      	cmp	r4, r1
102e2250:	d1f3      	bne.n	102e223a <memmove+0x5a>
102e2252:	250f      	movs	r5, #15
102e2254:	18c3      	adds	r3, r0, r3
102e2256:	4015      	ands	r5, r2
102e2258:	2d03      	cmp	r5, #3
102e225a:	d916      	bls.n	102e228a <memmove+0xaa>
102e225c:	3d04      	subs	r5, #4
102e225e:	08ad      	lsrs	r5, r5, #2
102e2260:	00af      	lsls	r7, r5, #2
102e2262:	3704      	adds	r7, #4
102e2264:	46ac      	mov	ip, r5
102e2266:	1c21      	adds	r1, r4, #0
102e2268:	19e7      	adds	r7, r4, r7
102e226a:	1c1d      	adds	r5, r3, #0
102e226c:	c940      	ldmia	r1!, {r6}
102e226e:	c540      	stmia	r5!, {r6}
102e2270:	42b9      	cmp	r1, r7
102e2272:	d1fb      	bne.n	102e226c <memmove+0x8c>
102e2274:	4661      	mov	r1, ip
102e2276:	3101      	adds	r1, #1
102e2278:	0089      	lsls	r1, r1, #2
102e227a:	2503      	movs	r5, #3
102e227c:	402a      	ands	r2, r5
102e227e:	1864      	adds	r4, r4, r1
102e2280:	185b      	adds	r3, r3, r1
102e2282:	e7c5      	b.n	102e2210 <memmove+0x30>
102e2284:	1c03      	adds	r3, r0, #0
102e2286:	1c0c      	adds	r4, r1, #0
102e2288:	e7c4      	b.n	102e2214 <memmove+0x34>
102e228a:	1c2a      	adds	r2, r5, #0
102e228c:	e7c0      	b.n	102e2210 <memmove+0x30>
102e228e:	46c0      	nop			; (mov r8, r8)

102e2290 <__malloc_lock>:
102e2290:	4770      	bx	lr
102e2292:	46c0      	nop			; (mov r8, r8)

102e2294 <__malloc_unlock>:
102e2294:	4770      	bx	lr
102e2296:	46c0      	nop			; (mov r8, r8)

102e2298 <_Balloc>:
102e2298:	b570      	push	{r4, r5, r6, lr}
102e229a:	1c04      	adds	r4, r0, #0
102e229c:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
102e229e:	1c0d      	adds	r5, r1, #0
102e22a0:	2800      	cmp	r0, #0
102e22a2:	d00c      	beq.n	102e22be <_Balloc+0x26>
102e22a4:	00aa      	lsls	r2, r5, #2
102e22a6:	1882      	adds	r2, r0, r2
102e22a8:	6810      	ldr	r0, [r2, #0]
102e22aa:	2800      	cmp	r0, #0
102e22ac:	d011      	beq.n	102e22d2 <_Balloc+0x3a>
102e22ae:	6803      	ldr	r3, [r0, #0]
102e22b0:	6013      	str	r3, [r2, #0]
102e22b2:	2200      	movs	r2, #0
102e22b4:	6102      	str	r2, [r0, #16]
102e22b6:	60c2      	str	r2, [r0, #12]
102e22b8:	bc70      	pop	{r4, r5, r6}
102e22ba:	bc02      	pop	{r1}
102e22bc:	4708      	bx	r1
102e22be:	1c20      	adds	r0, r4, #0
102e22c0:	2104      	movs	r1, #4
102e22c2:	2221      	movs	r2, #33	; 0x21
102e22c4:	f000 fcb4 	bl	102e2c30 <_calloc_r>
102e22c8:	64e0      	str	r0, [r4, #76]	; 0x4c
102e22ca:	2800      	cmp	r0, #0
102e22cc:	d1ea      	bne.n	102e22a4 <_Balloc+0xc>
102e22ce:	2000      	movs	r0, #0
102e22d0:	e7f2      	b.n	102e22b8 <_Balloc+0x20>
102e22d2:	2601      	movs	r6, #1
102e22d4:	40ae      	lsls	r6, r5
102e22d6:	1d72      	adds	r2, r6, #5
102e22d8:	0092      	lsls	r2, r2, #2
102e22da:	1c20      	adds	r0, r4, #0
102e22dc:	2101      	movs	r1, #1
102e22de:	f000 fca7 	bl	102e2c30 <_calloc_r>
102e22e2:	2800      	cmp	r0, #0
102e22e4:	d0f3      	beq.n	102e22ce <_Balloc+0x36>
102e22e6:	6045      	str	r5, [r0, #4]
102e22e8:	6086      	str	r6, [r0, #8]
102e22ea:	e7e2      	b.n	102e22b2 <_Balloc+0x1a>

102e22ec <_Bfree>:
102e22ec:	b500      	push	{lr}
102e22ee:	2900      	cmp	r1, #0
102e22f0:	d006      	beq.n	102e2300 <_Bfree+0x14>
102e22f2:	684a      	ldr	r2, [r1, #4]
102e22f4:	0093      	lsls	r3, r2, #2
102e22f6:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
102e22f8:	18d3      	adds	r3, r2, r3
102e22fa:	681a      	ldr	r2, [r3, #0]
102e22fc:	600a      	str	r2, [r1, #0]
102e22fe:	6019      	str	r1, [r3, #0]
102e2300:	bc01      	pop	{r0}
102e2302:	4700      	bx	r0

102e2304 <__multadd>:
102e2304:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
102e2306:	464d      	mov	r5, r9
102e2308:	4644      	mov	r4, r8
102e230a:	465f      	mov	r7, fp
102e230c:	4656      	mov	r6, sl
102e230e:	468a      	mov	sl, r1
102e2310:	6909      	ldr	r1, [r1, #16]
102e2312:	b4f0      	push	{r4, r5, r6, r7}
102e2314:	4655      	mov	r5, sl
102e2316:	4683      	mov	fp, r0
102e2318:	4698      	mov	r8, r3
102e231a:	4689      	mov	r9, r1
102e231c:	3514      	adds	r5, #20
102e231e:	2400      	movs	r4, #0
102e2320:	682e      	ldr	r6, [r5, #0]
102e2322:	0437      	lsls	r7, r6, #16
102e2324:	0c3f      	lsrs	r7, r7, #16
102e2326:	4357      	muls	r7, r2
102e2328:	0c36      	lsrs	r6, r6, #16
102e232a:	4356      	muls	r6, r2
102e232c:	4447      	add	r7, r8
102e232e:	0c3b      	lsrs	r3, r7, #16
102e2330:	199e      	adds	r6, r3, r6
102e2332:	043f      	lsls	r7, r7, #16
102e2334:	0c33      	lsrs	r3, r6, #16
102e2336:	0c3f      	lsrs	r7, r7, #16
102e2338:	0436      	lsls	r6, r6, #16
102e233a:	19f6      	adds	r6, r6, r7
102e233c:	3401      	adds	r4, #1
102e233e:	4698      	mov	r8, r3
102e2340:	c540      	stmia	r5!, {r6}
102e2342:	45a1      	cmp	r9, r4
102e2344:	dcec      	bgt.n	102e2320 <__multadd+0x1c>
102e2346:	2b00      	cmp	r3, #0
102e2348:	d00d      	beq.n	102e2366 <__multadd+0x62>
102e234a:	4651      	mov	r1, sl
102e234c:	6889      	ldr	r1, [r1, #8]
102e234e:	4589      	cmp	r9, r1
102e2350:	da12      	bge.n	102e2378 <__multadd+0x74>
102e2352:	464b      	mov	r3, r9
102e2354:	3304      	adds	r3, #4
102e2356:	009b      	lsls	r3, r3, #2
102e2358:	4453      	add	r3, sl
102e235a:	4642      	mov	r2, r8
102e235c:	605a      	str	r2, [r3, #4]
102e235e:	464b      	mov	r3, r9
102e2360:	3301      	adds	r3, #1
102e2362:	4651      	mov	r1, sl
102e2364:	610b      	str	r3, [r1, #16]
102e2366:	4650      	mov	r0, sl
102e2368:	bc3c      	pop	{r2, r3, r4, r5}
102e236a:	4690      	mov	r8, r2
102e236c:	4699      	mov	r9, r3
102e236e:	46a2      	mov	sl, r4
102e2370:	46ab      	mov	fp, r5
102e2372:	bcf8      	pop	{r3, r4, r5, r6, r7}
102e2374:	bc02      	pop	{r1}
102e2376:	4708      	bx	r1
102e2378:	4652      	mov	r2, sl
102e237a:	6851      	ldr	r1, [r2, #4]
102e237c:	4658      	mov	r0, fp
102e237e:	3101      	adds	r1, #1
102e2380:	f7ff ff8a 	bl	102e2298 <_Balloc>
102e2384:	4653      	mov	r3, sl
102e2386:	691a      	ldr	r2, [r3, #16]
102e2388:	4651      	mov	r1, sl
102e238a:	3202      	adds	r2, #2
102e238c:	1c04      	adds	r4, r0, #0
102e238e:	310c      	adds	r1, #12
102e2390:	0092      	lsls	r2, r2, #2
102e2392:	300c      	adds	r0, #12
102e2394:	f7fd fa98 	bl	102df8c8 <memcpy>
102e2398:	4651      	mov	r1, sl
102e239a:	6849      	ldr	r1, [r1, #4]
102e239c:	008b      	lsls	r3, r1, #2
102e239e:	4659      	mov	r1, fp
102e23a0:	6cca      	ldr	r2, [r1, #76]	; 0x4c
102e23a2:	18d3      	adds	r3, r2, r3
102e23a4:	681a      	ldr	r2, [r3, #0]
102e23a6:	4651      	mov	r1, sl
102e23a8:	600a      	str	r2, [r1, #0]
102e23aa:	46a2      	mov	sl, r4
102e23ac:	6019      	str	r1, [r3, #0]
102e23ae:	e7d0      	b.n	102e2352 <__multadd+0x4e>

102e23b0 <__s2b>:
102e23b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
102e23b2:	4646      	mov	r6, r8
102e23b4:	464f      	mov	r7, r9
102e23b6:	b4c0      	push	{r6, r7}
102e23b8:	1c06      	adds	r6, r0, #0
102e23ba:	1c18      	adds	r0, r3, #0
102e23bc:	1c0c      	adds	r4, r1, #0
102e23be:	3008      	adds	r0, #8
102e23c0:	2109      	movs	r1, #9
102e23c2:	4690      	mov	r8, r2
102e23c4:	1c1f      	adds	r7, r3, #0
102e23c6:	f001 fd73 	bl	102e3eb0 <____aeabi_idiv_from_thumb>
102e23ca:	2801      	cmp	r0, #1
102e23cc:	dd3b      	ble.n	102e2446 <__s2b+0x96>
102e23ce:	2501      	movs	r5, #1
102e23d0:	2100      	movs	r1, #0
102e23d2:	006d      	lsls	r5, r5, #1
102e23d4:	3101      	adds	r1, #1
102e23d6:	42a8      	cmp	r0, r5
102e23d8:	dcfb      	bgt.n	102e23d2 <__s2b+0x22>
102e23da:	1c30      	adds	r0, r6, #0
102e23dc:	f7ff ff5c 	bl	102e2298 <_Balloc>
102e23e0:	9b08      	ldr	r3, [sp, #32]
102e23e2:	6143      	str	r3, [r0, #20]
102e23e4:	2301      	movs	r3, #1
102e23e6:	6103      	str	r3, [r0, #16]
102e23e8:	4643      	mov	r3, r8
102e23ea:	1c01      	adds	r1, r0, #0
102e23ec:	2b09      	cmp	r3, #9
102e23ee:	dd27      	ble.n	102e2440 <__s2b+0x90>
102e23f0:	2309      	movs	r3, #9
102e23f2:	191b      	adds	r3, r3, r4
102e23f4:	4699      	mov	r9, r3
102e23f6:	4444      	add	r4, r8
102e23f8:	1c1d      	adds	r5, r3, #0
102e23fa:	782b      	ldrb	r3, [r5, #0]
102e23fc:	1c30      	adds	r0, r6, #0
102e23fe:	3b30      	subs	r3, #48	; 0x30
102e2400:	220a      	movs	r2, #10
102e2402:	f7ff ff7f 	bl	102e2304 <__multadd>
102e2406:	3501      	adds	r5, #1
102e2408:	1c01      	adds	r1, r0, #0
102e240a:	42a5      	cmp	r5, r4
102e240c:	d1f5      	bne.n	102e23fa <__s2b+0x4a>
102e240e:	464c      	mov	r4, r9
102e2410:	4444      	add	r4, r8
102e2412:	3c08      	subs	r4, #8
102e2414:	4643      	mov	r3, r8
102e2416:	429f      	cmp	r7, r3
102e2418:	dd0b      	ble.n	102e2432 <__s2b+0x82>
102e241a:	1aff      	subs	r7, r7, r3
102e241c:	19e7      	adds	r7, r4, r7
102e241e:	7823      	ldrb	r3, [r4, #0]
102e2420:	1c30      	adds	r0, r6, #0
102e2422:	3b30      	subs	r3, #48	; 0x30
102e2424:	220a      	movs	r2, #10
102e2426:	f7ff ff6d 	bl	102e2304 <__multadd>
102e242a:	3401      	adds	r4, #1
102e242c:	1c01      	adds	r1, r0, #0
102e242e:	42bc      	cmp	r4, r7
102e2430:	d1f5      	bne.n	102e241e <__s2b+0x6e>
102e2432:	1c08      	adds	r0, r1, #0
102e2434:	bc0c      	pop	{r2, r3}
102e2436:	4690      	mov	r8, r2
102e2438:	4699      	mov	r9, r3
102e243a:	bcf8      	pop	{r3, r4, r5, r6, r7}
102e243c:	bc02      	pop	{r1}
102e243e:	4708      	bx	r1
102e2440:	340a      	adds	r4, #10
102e2442:	2309      	movs	r3, #9
102e2444:	e7e7      	b.n	102e2416 <__s2b+0x66>
102e2446:	2100      	movs	r1, #0
102e2448:	e7c7      	b.n	102e23da <__s2b+0x2a>
102e244a:	46c0      	nop			; (mov r8, r8)

102e244c <__hi0bits>:
102e244c:	1c03      	adds	r3, r0, #0
102e244e:	0c02      	lsrs	r2, r0, #16
102e2450:	b500      	push	{lr}
102e2452:	2000      	movs	r0, #0
102e2454:	2a00      	cmp	r2, #0
102e2456:	d101      	bne.n	102e245c <__hi0bits+0x10>
102e2458:	041b      	lsls	r3, r3, #16
102e245a:	2010      	movs	r0, #16
102e245c:	0e1a      	lsrs	r2, r3, #24
102e245e:	d101      	bne.n	102e2464 <__hi0bits+0x18>
102e2460:	3008      	adds	r0, #8
102e2462:	021b      	lsls	r3, r3, #8
102e2464:	0f1a      	lsrs	r2, r3, #28
102e2466:	d101      	bne.n	102e246c <__hi0bits+0x20>
102e2468:	3004      	adds	r0, #4
102e246a:	011b      	lsls	r3, r3, #4
102e246c:	0f9a      	lsrs	r2, r3, #30
102e246e:	d101      	bne.n	102e2474 <__hi0bits+0x28>
102e2470:	3002      	adds	r0, #2
102e2472:	009b      	lsls	r3, r3, #2
102e2474:	2b00      	cmp	r3, #0
102e2476:	db03      	blt.n	102e2480 <__hi0bits+0x34>
102e2478:	3001      	adds	r0, #1
102e247a:	005a      	lsls	r2, r3, #1
102e247c:	d400      	bmi.n	102e2480 <__hi0bits+0x34>
102e247e:	2020      	movs	r0, #32
102e2480:	bc02      	pop	{r1}
102e2482:	4708      	bx	r1

102e2484 <__lo0bits>:
102e2484:	6803      	ldr	r3, [r0, #0]
102e2486:	b500      	push	{lr}
102e2488:	0759      	lsls	r1, r3, #29
102e248a:	d00a      	beq.n	102e24a2 <__lo0bits+0x1e>
102e248c:	2200      	movs	r2, #0
102e248e:	07d9      	lsls	r1, r3, #31
102e2490:	d404      	bmi.n	102e249c <__lo0bits+0x18>
102e2492:	079a      	lsls	r2, r3, #30
102e2494:	d421      	bmi.n	102e24da <__lo0bits+0x56>
102e2496:	089b      	lsrs	r3, r3, #2
102e2498:	6003      	str	r3, [r0, #0]
102e249a:	2202      	movs	r2, #2
102e249c:	1c10      	adds	r0, r2, #0
102e249e:	bc02      	pop	{r1}
102e24a0:	4708      	bx	r1
102e24a2:	0419      	lsls	r1, r3, #16
102e24a4:	2200      	movs	r2, #0
102e24a6:	2900      	cmp	r1, #0
102e24a8:	d101      	bne.n	102e24ae <__lo0bits+0x2a>
102e24aa:	0c1b      	lsrs	r3, r3, #16
102e24ac:	2210      	movs	r2, #16
102e24ae:	21ff      	movs	r1, #255	; 0xff
102e24b0:	4219      	tst	r1, r3
102e24b2:	d101      	bne.n	102e24b8 <__lo0bits+0x34>
102e24b4:	3208      	adds	r2, #8
102e24b6:	0a1b      	lsrs	r3, r3, #8
102e24b8:	0719      	lsls	r1, r3, #28
102e24ba:	d101      	bne.n	102e24c0 <__lo0bits+0x3c>
102e24bc:	3204      	adds	r2, #4
102e24be:	091b      	lsrs	r3, r3, #4
102e24c0:	0799      	lsls	r1, r3, #30
102e24c2:	d101      	bne.n	102e24c8 <__lo0bits+0x44>
102e24c4:	3202      	adds	r2, #2
102e24c6:	089b      	lsrs	r3, r3, #2
102e24c8:	07d9      	lsls	r1, r3, #31
102e24ca:	d404      	bmi.n	102e24d6 <__lo0bits+0x52>
102e24cc:	085b      	lsrs	r3, r3, #1
102e24ce:	d101      	bne.n	102e24d4 <__lo0bits+0x50>
102e24d0:	2220      	movs	r2, #32
102e24d2:	e7e3      	b.n	102e249c <__lo0bits+0x18>
102e24d4:	3201      	adds	r2, #1
102e24d6:	6003      	str	r3, [r0, #0]
102e24d8:	e7e0      	b.n	102e249c <__lo0bits+0x18>
102e24da:	085b      	lsrs	r3, r3, #1
102e24dc:	6003      	str	r3, [r0, #0]
102e24de:	2201      	movs	r2, #1
102e24e0:	e7dc      	b.n	102e249c <__lo0bits+0x18>
102e24e2:	46c0      	nop			; (mov r8, r8)

102e24e4 <__i2b>:
102e24e4:	b510      	push	{r4, lr}
102e24e6:	1c0c      	adds	r4, r1, #0
102e24e8:	2101      	movs	r1, #1
102e24ea:	f7ff fed5 	bl	102e2298 <_Balloc>
102e24ee:	2301      	movs	r3, #1
102e24f0:	6144      	str	r4, [r0, #20]
102e24f2:	6103      	str	r3, [r0, #16]
102e24f4:	bc10      	pop	{r4}
102e24f6:	bc02      	pop	{r1}
102e24f8:	4708      	bx	r1
102e24fa:	46c0      	nop			; (mov r8, r8)

102e24fc <__multiply>:
102e24fc:	b5f0      	push	{r4, r5, r6, r7, lr}
102e24fe:	465f      	mov	r7, fp
102e2500:	4656      	mov	r6, sl
102e2502:	464d      	mov	r5, r9
102e2504:	4644      	mov	r4, r8
102e2506:	b4f0      	push	{r4, r5, r6, r7}
102e2508:	690e      	ldr	r6, [r1, #16]
102e250a:	6917      	ldr	r7, [r2, #16]
102e250c:	b085      	sub	sp, #20
102e250e:	1c0d      	adds	r5, r1, #0
102e2510:	4690      	mov	r8, r2
102e2512:	42be      	cmp	r6, r7
102e2514:	da04      	bge.n	102e2520 <__multiply+0x24>
102e2516:	1c33      	adds	r3, r6, #0
102e2518:	1c15      	adds	r5, r2, #0
102e251a:	1c3e      	adds	r6, r7, #0
102e251c:	4688      	mov	r8, r1
102e251e:	1c1f      	adds	r7, r3, #0
102e2520:	68ab      	ldr	r3, [r5, #8]
102e2522:	19f2      	adds	r2, r6, r7
102e2524:	6869      	ldr	r1, [r5, #4]
102e2526:	4691      	mov	r9, r2
102e2528:	429a      	cmp	r2, r3
102e252a:	dd00      	ble.n	102e252e <__multiply+0x32>
102e252c:	3101      	adds	r1, #1
102e252e:	f7ff feb3 	bl	102e2298 <_Balloc>
102e2532:	464b      	mov	r3, r9
102e2534:	3304      	adds	r3, #4
102e2536:	009b      	lsls	r3, r3, #2
102e2538:	18c3      	adds	r3, r0, r3
102e253a:	1c02      	adds	r2, r0, #0
102e253c:	3304      	adds	r3, #4
102e253e:	469c      	mov	ip, r3
102e2540:	3214      	adds	r2, #20
102e2542:	9003      	str	r0, [sp, #12]
102e2544:	1c13      	adds	r3, r2, #0
102e2546:	2100      	movs	r1, #0
102e2548:	4660      	mov	r0, ip
102e254a:	4562      	cmp	r2, ip
102e254c:	d203      	bcs.n	102e2556 <__multiply+0x5a>
102e254e:	c302      	stmia	r3!, {r1}
102e2550:	4298      	cmp	r0, r3
102e2552:	d8fc      	bhi.n	102e254e <__multiply+0x52>
102e2554:	4684      	mov	ip, r0
102e2556:	3604      	adds	r6, #4
102e2558:	1d3b      	adds	r3, r7, #4
102e255a:	00b6      	lsls	r6, r6, #2
102e255c:	009b      	lsls	r3, r3, #2
102e255e:	1c29      	adds	r1, r5, #0
102e2560:	4443      	add	r3, r8
102e2562:	19ad      	adds	r5, r5, r6
102e2564:	4646      	mov	r6, r8
102e2566:	3114      	adds	r1, #20
102e2568:	3304      	adds	r3, #4
102e256a:	3614      	adds	r6, #20
102e256c:	9102      	str	r1, [sp, #8]
102e256e:	3504      	adds	r5, #4
102e2570:	9301      	str	r3, [sp, #4]
102e2572:	4693      	mov	fp, r2
102e2574:	429e      	cmp	r6, r3
102e2576:	d253      	bcs.n	102e2620 <__multiply+0x124>
102e2578:	6833      	ldr	r3, [r6, #0]
102e257a:	041f      	lsls	r7, r3, #16
102e257c:	0c3f      	lsrs	r7, r7, #16
102e257e:	d023      	beq.n	102e25c8 <__multiply+0xcc>
102e2580:	1c39      	adds	r1, r7, #0
102e2582:	2400      	movs	r4, #0
102e2584:	9a02      	ldr	r2, [sp, #8]
102e2586:	46aa      	mov	sl, r5
102e2588:	465b      	mov	r3, fp
102e258a:	1c27      	adds	r7, r4, #0
102e258c:	46b0      	mov	r8, r6
102e258e:	1c0d      	adds	r5, r1, #0
102e2590:	ca10      	ldmia	r2!, {r4}
102e2592:	0420      	lsls	r0, r4, #16
102e2594:	0c00      	lsrs	r0, r0, #16
102e2596:	1c29      	adds	r1, r5, #0
102e2598:	4341      	muls	r1, r0
102e259a:	0c24      	lsrs	r4, r4, #16
102e259c:	436c      	muls	r4, r5
102e259e:	681e      	ldr	r6, [r3, #0]
102e25a0:	0430      	lsls	r0, r6, #16
102e25a2:	0c00      	lsrs	r0, r0, #16
102e25a4:	1808      	adds	r0, r1, r0
102e25a6:	19c0      	adds	r0, r0, r7
102e25a8:	0c31      	lsrs	r1, r6, #16
102e25aa:	0c07      	lsrs	r7, r0, #16
102e25ac:	1861      	adds	r1, r4, r1
102e25ae:	19c9      	adds	r1, r1, r7
102e25b0:	0400      	lsls	r0, r0, #16
102e25b2:	0c0f      	lsrs	r7, r1, #16
102e25b4:	0c00      	lsrs	r0, r0, #16
102e25b6:	0409      	lsls	r1, r1, #16
102e25b8:	4301      	orrs	r1, r0
102e25ba:	c302      	stmia	r3!, {r1}
102e25bc:	4592      	cmp	sl, r2
102e25be:	d8e7      	bhi.n	102e2590 <__multiply+0x94>
102e25c0:	601f      	str	r7, [r3, #0]
102e25c2:	4646      	mov	r6, r8
102e25c4:	6833      	ldr	r3, [r6, #0]
102e25c6:	4655      	mov	r5, sl
102e25c8:	0c1f      	lsrs	r7, r3, #16
102e25ca:	d023      	beq.n	102e2614 <__multiply+0x118>
102e25cc:	4659      	mov	r1, fp
102e25ce:	680a      	ldr	r2, [r1, #0]
102e25d0:	9b02      	ldr	r3, [sp, #8]
102e25d2:	9500      	str	r5, [sp, #0]
102e25d4:	1c10      	adds	r0, r2, #0
102e25d6:	2400      	movs	r4, #0
102e25d8:	46b2      	mov	sl, r6
102e25da:	4698      	mov	r8, r3
102e25dc:	cb40      	ldmia	r3!, {r6}
102e25de:	0436      	lsls	r6, r6, #16
102e25e0:	0c36      	lsrs	r6, r6, #16
102e25e2:	437e      	muls	r6, r7
102e25e4:	0c00      	lsrs	r0, r0, #16
102e25e6:	1830      	adds	r0, r6, r0
102e25e8:	1904      	adds	r4, r0, r4
102e25ea:	0412      	lsls	r2, r2, #16
102e25ec:	0420      	lsls	r0, r4, #16
102e25ee:	0c12      	lsrs	r2, r2, #16
102e25f0:	4302      	orrs	r2, r0
102e25f2:	c104      	stmia	r1!, {r2}
102e25f4:	6808      	ldr	r0, [r1, #0]
102e25f6:	4645      	mov	r5, r8
102e25f8:	0402      	lsls	r2, r0, #16
102e25fa:	0c16      	lsrs	r6, r2, #16
102e25fc:	886a      	ldrh	r2, [r5, #2]
102e25fe:	437a      	muls	r2, r7
102e2600:	0c24      	lsrs	r4, r4, #16
102e2602:	18b2      	adds	r2, r6, r2
102e2604:	9e00      	ldr	r6, [sp, #0]
102e2606:	1912      	adds	r2, r2, r4
102e2608:	0c14      	lsrs	r4, r2, #16
102e260a:	429e      	cmp	r6, r3
102e260c:	d8e5      	bhi.n	102e25da <__multiply+0xde>
102e260e:	9d00      	ldr	r5, [sp, #0]
102e2610:	600a      	str	r2, [r1, #0]
102e2612:	4656      	mov	r6, sl
102e2614:	9a01      	ldr	r2, [sp, #4]
102e2616:	2104      	movs	r1, #4
102e2618:	3604      	adds	r6, #4
102e261a:	448b      	add	fp, r1
102e261c:	42b2      	cmp	r2, r6
102e261e:	d8ab      	bhi.n	102e2578 <__multiply+0x7c>
102e2620:	464a      	mov	r2, r9
102e2622:	2a00      	cmp	r2, #0
102e2624:	dd0e      	ble.n	102e2644 <__multiply+0x148>
102e2626:	4663      	mov	r3, ip
102e2628:	3b04      	subs	r3, #4
102e262a:	681c      	ldr	r4, [r3, #0]
102e262c:	2c00      	cmp	r4, #0
102e262e:	d109      	bne.n	102e2644 <__multiply+0x148>
102e2630:	464a      	mov	r2, r9
102e2632:	e003      	b.n	102e263c <__multiply+0x140>
102e2634:	3b04      	subs	r3, #4
102e2636:	681d      	ldr	r5, [r3, #0]
102e2638:	2d00      	cmp	r5, #0
102e263a:	d102      	bne.n	102e2642 <__multiply+0x146>
102e263c:	3a01      	subs	r2, #1
102e263e:	2a00      	cmp	r2, #0
102e2640:	d1f8      	bne.n	102e2634 <__multiply+0x138>
102e2642:	4691      	mov	r9, r2
102e2644:	9903      	ldr	r1, [sp, #12]
102e2646:	464e      	mov	r6, r9
102e2648:	1c08      	adds	r0, r1, #0
102e264a:	610e      	str	r6, [r1, #16]
102e264c:	b005      	add	sp, #20
102e264e:	bc3c      	pop	{r2, r3, r4, r5}
102e2650:	4690      	mov	r8, r2
102e2652:	4699      	mov	r9, r3
102e2654:	46a2      	mov	sl, r4
102e2656:	46ab      	mov	fp, r5
102e2658:	bcf0      	pop	{r4, r5, r6, r7}
102e265a:	bc02      	pop	{r1}
102e265c:	4708      	bx	r1
102e265e:	46c0      	nop			; (mov r8, r8)

102e2660 <__pow5mult>:
102e2660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
102e2662:	464f      	mov	r7, r9
102e2664:	4646      	mov	r6, r8
102e2666:	2303      	movs	r3, #3
102e2668:	b4c0      	push	{r6, r7}
102e266a:	4681      	mov	r9, r0
102e266c:	1c0f      	adds	r7, r1, #0
102e266e:	1c14      	adds	r4, r2, #0
102e2670:	4013      	ands	r3, r2
102e2672:	d136      	bne.n	102e26e2 <__pow5mult+0x82>
102e2674:	10a4      	asrs	r4, r4, #2
102e2676:	d022      	beq.n	102e26be <__pow5mult+0x5e>
102e2678:	4649      	mov	r1, r9
102e267a:	6c8e      	ldr	r6, [r1, #72]	; 0x48
102e267c:	2e00      	cmp	r6, #0
102e267e:	d039      	beq.n	102e26f4 <__pow5mult+0x94>
102e2680:	2301      	movs	r3, #1
102e2682:	4698      	mov	r8, r3
102e2684:	e005      	b.n	102e2692 <__pow5mult+0x32>
102e2686:	1064      	asrs	r4, r4, #1
102e2688:	d019      	beq.n	102e26be <__pow5mult+0x5e>
102e268a:	6835      	ldr	r5, [r6, #0]
102e268c:	2d00      	cmp	r5, #0
102e268e:	d01d      	beq.n	102e26cc <__pow5mult+0x6c>
102e2690:	1c2e      	adds	r6, r5, #0
102e2692:	4641      	mov	r1, r8
102e2694:	4221      	tst	r1, r4
102e2696:	d0f6      	beq.n	102e2686 <__pow5mult+0x26>
102e2698:	4648      	mov	r0, r9
102e269a:	1c39      	adds	r1, r7, #0
102e269c:	1c32      	adds	r2, r6, #0
102e269e:	f7ff ff2d 	bl	102e24fc <__multiply>
102e26a2:	2f00      	cmp	r7, #0
102e26a4:	d01b      	beq.n	102e26de <__pow5mult+0x7e>
102e26a6:	687a      	ldr	r2, [r7, #4]
102e26a8:	4649      	mov	r1, r9
102e26aa:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
102e26ac:	0093      	lsls	r3, r2, #2
102e26ae:	18cb      	adds	r3, r1, r3
102e26b0:	681a      	ldr	r2, [r3, #0]
102e26b2:	1064      	asrs	r4, r4, #1
102e26b4:	603a      	str	r2, [r7, #0]
102e26b6:	601f      	str	r7, [r3, #0]
102e26b8:	1c07      	adds	r7, r0, #0
102e26ba:	2c00      	cmp	r4, #0
102e26bc:	d1e5      	bne.n	102e268a <__pow5mult+0x2a>
102e26be:	1c38      	adds	r0, r7, #0
102e26c0:	bc0c      	pop	{r2, r3}
102e26c2:	4690      	mov	r8, r2
102e26c4:	4699      	mov	r9, r3
102e26c6:	bcf8      	pop	{r3, r4, r5, r6, r7}
102e26c8:	bc02      	pop	{r1}
102e26ca:	4708      	bx	r1
102e26cc:	1c31      	adds	r1, r6, #0
102e26ce:	1c32      	adds	r2, r6, #0
102e26d0:	4648      	mov	r0, r9
102e26d2:	f7ff ff13 	bl	102e24fc <__multiply>
102e26d6:	6030      	str	r0, [r6, #0]
102e26d8:	6005      	str	r5, [r0, #0]
102e26da:	1c06      	adds	r6, r0, #0
102e26dc:	e7d9      	b.n	102e2692 <__pow5mult+0x32>
102e26de:	1c07      	adds	r7, r0, #0
102e26e0:	e7d1      	b.n	102e2686 <__pow5mult+0x26>
102e26e2:	4a09      	ldr	r2, [pc, #36]	; (102e2708 <__pow5mult+0xa8>)
102e26e4:	3b01      	subs	r3, #1
102e26e6:	009b      	lsls	r3, r3, #2
102e26e8:	589a      	ldr	r2, [r3, r2]
102e26ea:	2300      	movs	r3, #0
102e26ec:	f7ff fe0a 	bl	102e2304 <__multadd>
102e26f0:	1c07      	adds	r7, r0, #0
102e26f2:	e7bf      	b.n	102e2674 <__pow5mult+0x14>
102e26f4:	4648      	mov	r0, r9
102e26f6:	4905      	ldr	r1, [pc, #20]	; (102e270c <__pow5mult+0xac>)
102e26f8:	f7ff fef4 	bl	102e24e4 <__i2b>
102e26fc:	464a      	mov	r2, r9
102e26fe:	2300      	movs	r3, #0
102e2700:	6490      	str	r0, [r2, #72]	; 0x48
102e2702:	1c06      	adds	r6, r0, #0
102e2704:	6003      	str	r3, [r0, #0]
102e2706:	e7bb      	b.n	102e2680 <__pow5mult+0x20>
102e2708:	102edcd8 	.word	0x102edcd8
102e270c:	00000271 	.word	0x00000271

102e2710 <__lshift>:
102e2710:	b5f0      	push	{r4, r5, r6, r7, lr}
102e2712:	464d      	mov	r5, r9
102e2714:	4644      	mov	r4, r8
102e2716:	4656      	mov	r6, sl
102e2718:	465f      	mov	r7, fp
102e271a:	b4f0      	push	{r4, r5, r6, r7}
102e271c:	1c0e      	adds	r6, r1, #0
102e271e:	b083      	sub	sp, #12
102e2720:	9001      	str	r0, [sp, #4]
102e2722:	6930      	ldr	r0, [r6, #16]
102e2724:	1155      	asrs	r5, r2, #5
102e2726:	1940      	adds	r0, r0, r5
102e2728:	1c04      	adds	r4, r0, #0
102e272a:	68b3      	ldr	r3, [r6, #8]
102e272c:	3401      	adds	r4, #1
102e272e:	4690      	mov	r8, r2
102e2730:	6849      	ldr	r1, [r1, #4]
102e2732:	4681      	mov	r9, r0
102e2734:	429c      	cmp	r4, r3
102e2736:	dd03      	ble.n	102e2740 <__lshift+0x30>
102e2738:	3101      	adds	r1, #1
102e273a:	005b      	lsls	r3, r3, #1
102e273c:	429c      	cmp	r4, r3
102e273e:	dcfb      	bgt.n	102e2738 <__lshift+0x28>
102e2740:	9801      	ldr	r0, [sp, #4]
102e2742:	f7ff fda9 	bl	102e2298 <_Balloc>
102e2746:	1c02      	adds	r2, r0, #0
102e2748:	4683      	mov	fp, r0
102e274a:	3214      	adds	r2, #20
102e274c:	2d00      	cmp	r5, #0
102e274e:	dd09      	ble.n	102e2764 <__lshift+0x54>
102e2750:	2300      	movs	r3, #0
102e2752:	2100      	movs	r1, #0
102e2754:	3301      	adds	r3, #1
102e2756:	c202      	stmia	r2!, {r1}
102e2758:	42ab      	cmp	r3, r5
102e275a:	d1fb      	bne.n	102e2754 <__lshift+0x44>
102e275c:	1d1a      	adds	r2, r3, #4
102e275e:	0092      	lsls	r2, r2, #2
102e2760:	445a      	add	r2, fp
102e2762:	3204      	adds	r2, #4
102e2764:	6935      	ldr	r5, [r6, #16]
102e2766:	3504      	adds	r5, #4
102e2768:	4641      	mov	r1, r8
102e276a:	00ad      	lsls	r5, r5, #2
102e276c:	201f      	movs	r0, #31
102e276e:	1c33      	adds	r3, r6, #0
102e2770:	1975      	adds	r5, r6, r5
102e2772:	4001      	ands	r1, r0
102e2774:	3314      	adds	r3, #20
102e2776:	3504      	adds	r5, #4
102e2778:	4688      	mov	r8, r1
102e277a:	2900      	cmp	r1, #0
102e277c:	d027      	beq.n	102e27ce <__lshift+0xbe>
102e277e:	2020      	movs	r0, #32
102e2780:	1a41      	subs	r1, r0, r1
102e2782:	468c      	mov	ip, r1
102e2784:	2100      	movs	r1, #0
102e2786:	681f      	ldr	r7, [r3, #0]
102e2788:	4640      	mov	r0, r8
102e278a:	4087      	lsls	r7, r0
102e278c:	4339      	orrs	r1, r7
102e278e:	c202      	stmia	r2!, {r1}
102e2790:	cb02      	ldmia	r3!, {r1}
102e2792:	4667      	mov	r7, ip
102e2794:	40f9      	lsrs	r1, r7
102e2796:	429d      	cmp	r5, r3
102e2798:	d8f5      	bhi.n	102e2786 <__lshift+0x76>
102e279a:	6011      	str	r1, [r2, #0]
102e279c:	2900      	cmp	r1, #0
102e279e:	d001      	beq.n	102e27a4 <__lshift+0x94>
102e27a0:	464c      	mov	r4, r9
102e27a2:	3402      	adds	r4, #2
102e27a4:	9f01      	ldr	r7, [sp, #4]
102e27a6:	6871      	ldr	r1, [r6, #4]
102e27a8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
102e27aa:	008b      	lsls	r3, r1, #2
102e27ac:	4658      	mov	r0, fp
102e27ae:	18d3      	adds	r3, r2, r3
102e27b0:	3c01      	subs	r4, #1
102e27b2:	6104      	str	r4, [r0, #16]
102e27b4:	6818      	ldr	r0, [r3, #0]
102e27b6:	6030      	str	r0, [r6, #0]
102e27b8:	4658      	mov	r0, fp
102e27ba:	601e      	str	r6, [r3, #0]
102e27bc:	b003      	add	sp, #12
102e27be:	bc3c      	pop	{r2, r3, r4, r5}
102e27c0:	4690      	mov	r8, r2
102e27c2:	4699      	mov	r9, r3
102e27c4:	46a2      	mov	sl, r4
102e27c6:	46ab      	mov	fp, r5
102e27c8:	bcf0      	pop	{r4, r5, r6, r7}
102e27ca:	bc02      	pop	{r1}
102e27cc:	4708      	bx	r1
102e27ce:	cb02      	ldmia	r3!, {r1}
102e27d0:	c202      	stmia	r2!, {r1}
102e27d2:	429d      	cmp	r5, r3
102e27d4:	d9e6      	bls.n	102e27a4 <__lshift+0x94>
102e27d6:	cb02      	ldmia	r3!, {r1}
102e27d8:	c202      	stmia	r2!, {r1}
102e27da:	429d      	cmp	r5, r3
102e27dc:	d8f7      	bhi.n	102e27ce <__lshift+0xbe>
102e27de:	e7e1      	b.n	102e27a4 <__lshift+0x94>

102e27e0 <__mcmp>:
102e27e0:	b530      	push	{r4, r5, lr}
102e27e2:	690a      	ldr	r2, [r1, #16]
102e27e4:	6904      	ldr	r4, [r0, #16]
102e27e6:	1c03      	adds	r3, r0, #0
102e27e8:	1aa0      	subs	r0, r4, r2
102e27ea:	d10f      	bne.n	102e280c <__mcmp+0x2c>
102e27ec:	3204      	adds	r2, #4
102e27ee:	0092      	lsls	r2, r2, #2
102e27f0:	1c1d      	adds	r5, r3, #0
102e27f2:	1889      	adds	r1, r1, r2
102e27f4:	189b      	adds	r3, r3, r2
102e27f6:	3514      	adds	r5, #20
102e27f8:	3304      	adds	r3, #4
102e27fa:	3104      	adds	r1, #4
102e27fc:	3b04      	subs	r3, #4
102e27fe:	3904      	subs	r1, #4
102e2800:	681c      	ldr	r4, [r3, #0]
102e2802:	680a      	ldr	r2, [r1, #0]
102e2804:	4294      	cmp	r4, r2
102e2806:	d104      	bne.n	102e2812 <__mcmp+0x32>
102e2808:	429d      	cmp	r5, r3
102e280a:	d3f7      	bcc.n	102e27fc <__mcmp+0x1c>
102e280c:	bc30      	pop	{r4, r5}
102e280e:	bc02      	pop	{r1}
102e2810:	4708      	bx	r1
102e2812:	4294      	cmp	r4, r2
102e2814:	4180      	sbcs	r0, r0
102e2816:	2301      	movs	r3, #1
102e2818:	4318      	orrs	r0, r3
102e281a:	e7f7      	b.n	102e280c <__mcmp+0x2c>

102e281c <__mdiff>:
102e281c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
102e281e:	464f      	mov	r7, r9
102e2820:	4646      	mov	r6, r8
102e2822:	b4c0      	push	{r6, r7}
102e2824:	1c0c      	adds	r4, r1, #0
102e2826:	1c07      	adds	r7, r0, #0
102e2828:	1c08      	adds	r0, r1, #0
102e282a:	1c11      	adds	r1, r2, #0
102e282c:	1c15      	adds	r5, r2, #0
102e282e:	f7ff ffd7 	bl	102e27e0 <__mcmp>
102e2832:	1e06      	subs	r6, r0, #0
102e2834:	d060      	beq.n	102e28f8 <__mdiff+0xdc>
102e2836:	db5a      	blt.n	102e28ee <__mdiff+0xd2>
102e2838:	2600      	movs	r6, #0
102e283a:	1c38      	adds	r0, r7, #0
102e283c:	6861      	ldr	r1, [r4, #4]
102e283e:	f7ff fd2b 	bl	102e2298 <_Balloc>
102e2842:	4684      	mov	ip, r0
102e2844:	60c6      	str	r6, [r0, #12]
102e2846:	6920      	ldr	r0, [r4, #16]
102e2848:	1d03      	adds	r3, r0, #4
102e284a:	009b      	lsls	r3, r3, #2
102e284c:	18e3      	adds	r3, r4, r3
102e284e:	3304      	adds	r3, #4
102e2850:	4698      	mov	r8, r3
102e2852:	692b      	ldr	r3, [r5, #16]
102e2854:	3304      	adds	r3, #4
102e2856:	009b      	lsls	r3, r3, #2
102e2858:	18eb      	adds	r3, r5, r3
102e285a:	3304      	adds	r3, #4
102e285c:	1c21      	adds	r1, r4, #0
102e285e:	1c2a      	adds	r2, r5, #0
102e2860:	4667      	mov	r7, ip
102e2862:	4699      	mov	r9, r3
102e2864:	3114      	adds	r1, #20
102e2866:	3214      	adds	r2, #20
102e2868:	3714      	adds	r7, #20
102e286a:	2600      	movs	r6, #0
102e286c:	c920      	ldmia	r1!, {r5}
102e286e:	ca10      	ldmia	r2!, {r4}
102e2870:	042b      	lsls	r3, r5, #16
102e2872:	0c1b      	lsrs	r3, r3, #16
102e2874:	199e      	adds	r6, r3, r6
102e2876:	0423      	lsls	r3, r4, #16
102e2878:	0c1b      	lsrs	r3, r3, #16
102e287a:	1af3      	subs	r3, r6, r3
102e287c:	0c24      	lsrs	r4, r4, #16
102e287e:	0c2d      	lsrs	r5, r5, #16
102e2880:	141e      	asrs	r6, r3, #16
102e2882:	1b2d      	subs	r5, r5, r4
102e2884:	19ad      	adds	r5, r5, r6
102e2886:	041b      	lsls	r3, r3, #16
102e2888:	0c1b      	lsrs	r3, r3, #16
102e288a:	142e      	asrs	r6, r5, #16
102e288c:	042d      	lsls	r5, r5, #16
102e288e:	431d      	orrs	r5, r3
102e2890:	1c3b      	adds	r3, r7, #0
102e2892:	c320      	stmia	r3!, {r5}
102e2894:	1c0c      	adds	r4, r1, #0
102e2896:	1c1f      	adds	r7, r3, #0
102e2898:	4591      	cmp	r9, r2
102e289a:	d8e7      	bhi.n	102e286c <__mdiff+0x50>
102e289c:	4699      	mov	r9, r3
102e289e:	4588      	cmp	r8, r1
102e28a0:	d914      	bls.n	102e28cc <__mdiff+0xb0>
102e28a2:	cc80      	ldmia	r4!, {r7}
102e28a4:	043a      	lsls	r2, r7, #16
102e28a6:	0c12      	lsrs	r2, r2, #16
102e28a8:	1992      	adds	r2, r2, r6
102e28aa:	1415      	asrs	r5, r2, #16
102e28ac:	0c3f      	lsrs	r7, r7, #16
102e28ae:	19ed      	adds	r5, r5, r7
102e28b0:	0412      	lsls	r2, r2, #16
102e28b2:	142e      	asrs	r6, r5, #16
102e28b4:	0c12      	lsrs	r2, r2, #16
102e28b6:	042d      	lsls	r5, r5, #16
102e28b8:	4315      	orrs	r5, r2
102e28ba:	c320      	stmia	r3!, {r5}
102e28bc:	45a0      	cmp	r8, r4
102e28be:	d8f0      	bhi.n	102e28a2 <__mdiff+0x86>
102e28c0:	43cb      	mvns	r3, r1
102e28c2:	4443      	add	r3, r8
102e28c4:	089b      	lsrs	r3, r3, #2
102e28c6:	3301      	adds	r3, #1
102e28c8:	009b      	lsls	r3, r3, #2
102e28ca:	444b      	add	r3, r9
102e28cc:	3b04      	subs	r3, #4
102e28ce:	2d00      	cmp	r5, #0
102e28d0:	d104      	bne.n	102e28dc <__mdiff+0xc0>
102e28d2:	3b04      	subs	r3, #4
102e28d4:	681a      	ldr	r2, [r3, #0]
102e28d6:	3801      	subs	r0, #1
102e28d8:	2a00      	cmp	r2, #0
102e28da:	d0fa      	beq.n	102e28d2 <__mdiff+0xb6>
102e28dc:	4663      	mov	r3, ip
102e28de:	6118      	str	r0, [r3, #16]
102e28e0:	4660      	mov	r0, ip
102e28e2:	bc0c      	pop	{r2, r3}
102e28e4:	4690      	mov	r8, r2
102e28e6:	4699      	mov	r9, r3
102e28e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
102e28ea:	bc02      	pop	{r1}
102e28ec:	4708      	bx	r1
102e28ee:	1c23      	adds	r3, r4, #0
102e28f0:	2601      	movs	r6, #1
102e28f2:	1c2c      	adds	r4, r5, #0
102e28f4:	1c1d      	adds	r5, r3, #0
102e28f6:	e7a0      	b.n	102e283a <__mdiff+0x1e>
102e28f8:	1c38      	adds	r0, r7, #0
102e28fa:	2100      	movs	r1, #0
102e28fc:	f7ff fccc 	bl	102e2298 <_Balloc>
102e2900:	2301      	movs	r3, #1
102e2902:	4684      	mov	ip, r0
102e2904:	6103      	str	r3, [r0, #16]
102e2906:	6146      	str	r6, [r0, #20]
102e2908:	e7ea      	b.n	102e28e0 <__mdiff+0xc4>
102e290a:	46c0      	nop			; (mov r8, r8)

102e290c <__ulp>:
102e290c:	4b0f      	ldr	r3, [pc, #60]	; (102e294c <__ulp+0x40>)
102e290e:	4a10      	ldr	r2, [pc, #64]	; (102e2950 <__ulp+0x44>)
102e2910:	400b      	ands	r3, r1
102e2912:	189b      	adds	r3, r3, r2
102e2914:	b510      	push	{r4, lr}
102e2916:	2b00      	cmp	r3, #0
102e2918:	dd04      	ble.n	102e2924 <__ulp+0x18>
102e291a:	1c19      	adds	r1, r3, #0
102e291c:	2000      	movs	r0, #0
102e291e:	bc10      	pop	{r4}
102e2920:	bc04      	pop	{r2}
102e2922:	4710      	bx	r2
102e2924:	425b      	negs	r3, r3
102e2926:	151b      	asrs	r3, r3, #20
102e2928:	2000      	movs	r0, #0
102e292a:	2100      	movs	r1, #0
102e292c:	2b13      	cmp	r3, #19
102e292e:	dd07      	ble.n	102e2940 <__ulp+0x34>
102e2930:	2201      	movs	r2, #1
102e2932:	2b32      	cmp	r3, #50	; 0x32
102e2934:	dc02      	bgt.n	102e293c <__ulp+0x30>
102e2936:	2433      	movs	r4, #51	; 0x33
102e2938:	1ae3      	subs	r3, r4, r3
102e293a:	409a      	lsls	r2, r3
102e293c:	1c10      	adds	r0, r2, #0
102e293e:	e7ee      	b.n	102e291e <__ulp+0x12>
102e2940:	2280      	movs	r2, #128	; 0x80
102e2942:	0312      	lsls	r2, r2, #12
102e2944:	1c11      	adds	r1, r2, #0
102e2946:	4119      	asrs	r1, r3
102e2948:	2000      	movs	r0, #0
102e294a:	e7e8      	b.n	102e291e <__ulp+0x12>
102e294c:	7ff00000 	.word	0x7ff00000
102e2950:	fcc00000 	.word	0xfcc00000

102e2954 <__b2d>:
102e2954:	b5f0      	push	{r4, r5, r6, r7, lr}
102e2956:	6904      	ldr	r4, [r0, #16]
102e2958:	3404      	adds	r4, #4
102e295a:	00a4      	lsls	r4, r4, #2
102e295c:	1904      	adds	r4, r0, r4
102e295e:	6825      	ldr	r5, [r4, #0]
102e2960:	4647      	mov	r7, r8
102e2962:	b480      	push	{r7}
102e2964:	1c06      	adds	r6, r0, #0
102e2966:	1c28      	adds	r0, r5, #0
102e2968:	1c0f      	adds	r7, r1, #0
102e296a:	f7ff fd6f 	bl	102e244c <__hi0bits>
102e296e:	2320      	movs	r3, #32
102e2970:	1a1b      	subs	r3, r3, r0
102e2972:	3614      	adds	r6, #20
102e2974:	603b      	str	r3, [r7, #0]
102e2976:	280a      	cmp	r0, #10
102e2978:	dc19      	bgt.n	102e29ae <__b2d+0x5a>
102e297a:	270b      	movs	r7, #11
102e297c:	1a3f      	subs	r7, r7, r0
102e297e:	1c29      	adds	r1, r5, #0
102e2980:	40f9      	lsrs	r1, r7
102e2982:	4688      	mov	r8, r1
102e2984:	491b      	ldr	r1, [pc, #108]	; (102e29f4 <__b2d+0xa0>)
102e2986:	1c0b      	adds	r3, r1, #0
102e2988:	4641      	mov	r1, r8
102e298a:	430b      	orrs	r3, r1
102e298c:	2100      	movs	r1, #0
102e298e:	42a6      	cmp	r6, r4
102e2990:	d202      	bcs.n	102e2998 <__b2d+0x44>
102e2992:	3c04      	subs	r4, #4
102e2994:	6821      	ldr	r1, [r4, #0]
102e2996:	40f9      	lsrs	r1, r7
102e2998:	3015      	adds	r0, #21
102e299a:	4085      	lsls	r5, r0
102e299c:	1c0a      	adds	r2, r1, #0
102e299e:	432a      	orrs	r2, r5
102e29a0:	1c10      	adds	r0, r2, #0
102e29a2:	1c19      	adds	r1, r3, #0
102e29a4:	bc04      	pop	{r2}
102e29a6:	4690      	mov	r8, r2
102e29a8:	bcf0      	pop	{r4, r5, r6, r7}
102e29aa:	bc04      	pop	{r2}
102e29ac:	4710      	bx	r2
102e29ae:	2100      	movs	r1, #0
102e29b0:	42a6      	cmp	r6, r4
102e29b2:	d201      	bcs.n	102e29b8 <__b2d+0x64>
102e29b4:	3c04      	subs	r4, #4
102e29b6:	6821      	ldr	r1, [r4, #0]
102e29b8:	1c07      	adds	r7, r0, #0
102e29ba:	3f0b      	subs	r7, #11
102e29bc:	2f00      	cmp	r7, #0
102e29be:	d013      	beq.n	102e29e8 <__b2d+0x94>
102e29c0:	232b      	movs	r3, #43	; 0x2b
102e29c2:	1a18      	subs	r0, r3, r0
102e29c4:	4b0b      	ldr	r3, [pc, #44]	; (102e29f4 <__b2d+0xa0>)
102e29c6:	40bd      	lsls	r5, r7
102e29c8:	432b      	orrs	r3, r5
102e29ca:	469c      	mov	ip, r3
102e29cc:	1c0d      	adds	r5, r1, #0
102e29ce:	40c5      	lsrs	r5, r0
102e29d0:	4663      	mov	r3, ip
102e29d2:	432b      	orrs	r3, r5
102e29d4:	2500      	movs	r5, #0
102e29d6:	42b4      	cmp	r4, r6
102e29d8:	d902      	bls.n	102e29e0 <__b2d+0x8c>
102e29da:	3c04      	subs	r4, #4
102e29dc:	6825      	ldr	r5, [r4, #0]
102e29de:	40c5      	lsrs	r5, r0
102e29e0:	40b9      	lsls	r1, r7
102e29e2:	1c2a      	adds	r2, r5, #0
102e29e4:	430a      	orrs	r2, r1
102e29e6:	e7db      	b.n	102e29a0 <__b2d+0x4c>
102e29e8:	4802      	ldr	r0, [pc, #8]	; (102e29f4 <__b2d+0xa0>)
102e29ea:	1c03      	adds	r3, r0, #0
102e29ec:	432b      	orrs	r3, r5
102e29ee:	1c0a      	adds	r2, r1, #0
102e29f0:	e7d6      	b.n	102e29a0 <__b2d+0x4c>
102e29f2:	46c0      	nop			; (mov r8, r8)
102e29f4:	3ff00000 	.word	0x3ff00000

102e29f8 <__d2b>:
102e29f8:	b5f0      	push	{r4, r5, r6, r7, lr}
102e29fa:	2101      	movs	r1, #1
102e29fc:	b083      	sub	sp, #12
102e29fe:	1c1d      	adds	r5, r3, #0
102e2a00:	1c14      	adds	r4, r2, #0
102e2a02:	f7ff fc49 	bl	102e2298 <_Balloc>
102e2a06:	032a      	lsls	r2, r5, #12
102e2a08:	006b      	lsls	r3, r5, #1
102e2a0a:	1c06      	adds	r6, r0, #0
102e2a0c:	0b12      	lsrs	r2, r2, #12
102e2a0e:	0d5f      	lsrs	r7, r3, #21
102e2a10:	d002      	beq.n	102e2a18 <__d2b+0x20>
102e2a12:	2380      	movs	r3, #128	; 0x80
102e2a14:	035b      	lsls	r3, r3, #13
102e2a16:	431a      	orrs	r2, r3
102e2a18:	9201      	str	r2, [sp, #4]
102e2a1a:	2c00      	cmp	r4, #0
102e2a1c:	d01a      	beq.n	102e2a54 <__d2b+0x5c>
102e2a1e:	4668      	mov	r0, sp
102e2a20:	9400      	str	r4, [sp, #0]
102e2a22:	f7ff fd2f 	bl	102e2484 <__lo0bits>
102e2a26:	2800      	cmp	r0, #0
102e2a28:	d132      	bne.n	102e2a90 <__d2b+0x98>
102e2a2a:	9b00      	ldr	r3, [sp, #0]
102e2a2c:	9c01      	ldr	r4, [sp, #4]
102e2a2e:	6173      	str	r3, [r6, #20]
102e2a30:	61b4      	str	r4, [r6, #24]
102e2a32:	4263      	negs	r3, r4
102e2a34:	4163      	adcs	r3, r4
102e2a36:	2402      	movs	r4, #2
102e2a38:	1ae4      	subs	r4, r4, r3
102e2a3a:	6134      	str	r4, [r6, #16]
102e2a3c:	2f00      	cmp	r7, #0
102e2a3e:	d014      	beq.n	102e2a6a <__d2b+0x72>
102e2a40:	4a19      	ldr	r2, [pc, #100]	; (102e2aa8 <__d2b+0xb0>)
102e2a42:	9908      	ldr	r1, [sp, #32]
102e2a44:	18bb      	adds	r3, r7, r2
102e2a46:	181b      	adds	r3, r3, r0
102e2a48:	600b      	str	r3, [r1, #0]
102e2a4a:	9a09      	ldr	r2, [sp, #36]	; 0x24
102e2a4c:	2335      	movs	r3, #53	; 0x35
102e2a4e:	1a18      	subs	r0, r3, r0
102e2a50:	6010      	str	r0, [r2, #0]
102e2a52:	e018      	b.n	102e2a86 <__d2b+0x8e>
102e2a54:	a801      	add	r0, sp, #4
102e2a56:	f7ff fd15 	bl	102e2484 <__lo0bits>
102e2a5a:	9901      	ldr	r1, [sp, #4]
102e2a5c:	2301      	movs	r3, #1
102e2a5e:	6171      	str	r1, [r6, #20]
102e2a60:	6133      	str	r3, [r6, #16]
102e2a62:	3020      	adds	r0, #32
102e2a64:	2401      	movs	r4, #1
102e2a66:	2f00      	cmp	r7, #0
102e2a68:	d1ea      	bne.n	102e2a40 <__d2b+0x48>
102e2a6a:	4b10      	ldr	r3, [pc, #64]	; (102e2aac <__d2b+0xb4>)
102e2a6c:	18c0      	adds	r0, r0, r3
102e2a6e:	1ce3      	adds	r3, r4, #3
102e2a70:	9908      	ldr	r1, [sp, #32]
102e2a72:	009b      	lsls	r3, r3, #2
102e2a74:	18f3      	adds	r3, r6, r3
102e2a76:	6008      	str	r0, [r1, #0]
102e2a78:	6858      	ldr	r0, [r3, #4]
102e2a7a:	f7ff fce7 	bl	102e244c <__hi0bits>
102e2a7e:	0164      	lsls	r4, r4, #5
102e2a80:	9a09      	ldr	r2, [sp, #36]	; 0x24
102e2a82:	1a24      	subs	r4, r4, r0
102e2a84:	6014      	str	r4, [r2, #0]
102e2a86:	1c30      	adds	r0, r6, #0
102e2a88:	b003      	add	sp, #12
102e2a8a:	bcf0      	pop	{r4, r5, r6, r7}
102e2a8c:	bc02      	pop	{r1}
102e2a8e:	4708      	bx	r1
102e2a90:	9c01      	ldr	r4, [sp, #4]
102e2a92:	2320      	movs	r3, #32
102e2a94:	1a1b      	subs	r3, r3, r0
102e2a96:	1c21      	adds	r1, r4, #0
102e2a98:	4099      	lsls	r1, r3
102e2a9a:	9a00      	ldr	r2, [sp, #0]
102e2a9c:	1c0b      	adds	r3, r1, #0
102e2a9e:	4313      	orrs	r3, r2
102e2aa0:	40c4      	lsrs	r4, r0
102e2aa2:	6173      	str	r3, [r6, #20]
102e2aa4:	9401      	str	r4, [sp, #4]
102e2aa6:	e7c3      	b.n	102e2a30 <__d2b+0x38>
102e2aa8:	fffffbcd 	.word	0xfffffbcd
102e2aac:	fffffbce 	.word	0xfffffbce

102e2ab0 <__ratio>:
102e2ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
102e2ab2:	4657      	mov	r7, sl
102e2ab4:	464e      	mov	r6, r9
102e2ab6:	4645      	mov	r5, r8
102e2ab8:	b4e0      	push	{r5, r6, r7}
102e2aba:	b084      	sub	sp, #16
102e2abc:	4689      	mov	r9, r1
102e2abe:	a902      	add	r1, sp, #8
102e2ac0:	4680      	mov	r8, r0
102e2ac2:	f7ff ff47 	bl	102e2954 <__b2d>
102e2ac6:	1c06      	adds	r6, r0, #0
102e2ac8:	1c0f      	adds	r7, r1, #0
102e2aca:	4648      	mov	r0, r9
102e2acc:	a903      	add	r1, sp, #12
102e2ace:	f7ff ff41 	bl	102e2954 <__b2d>
102e2ad2:	1c02      	adds	r2, r0, #0
102e2ad4:	1c0b      	adds	r3, r1, #0
102e2ad6:	9802      	ldr	r0, [sp, #8]
102e2ad8:	9903      	ldr	r1, [sp, #12]
102e2ada:	1a40      	subs	r0, r0, r1
102e2adc:	4682      	mov	sl, r0
102e2ade:	4640      	mov	r0, r8
102e2ae0:	6900      	ldr	r0, [r0, #16]
102e2ae2:	4684      	mov	ip, r0
102e2ae4:	4648      	mov	r0, r9
102e2ae6:	6901      	ldr	r1, [r0, #16]
102e2ae8:	4660      	mov	r0, ip
102e2aea:	1a41      	subs	r1, r0, r1
102e2aec:	0149      	lsls	r1, r1, #5
102e2aee:	4451      	add	r1, sl
102e2af0:	9200      	str	r2, [sp, #0]
102e2af2:	9301      	str	r3, [sp, #4]
102e2af4:	2900      	cmp	r1, #0
102e2af6:	dd0e      	ble.n	102e2b16 <__ratio+0x66>
102e2af8:	0509      	lsls	r1, r1, #20
102e2afa:	19cd      	adds	r5, r1, r7
102e2afc:	1c2f      	adds	r7, r5, #0
102e2afe:	1c30      	adds	r0, r6, #0
102e2b00:	1c39      	adds	r1, r7, #0
102e2b02:	f001 f9f3 	bl	102e3eec <____aeabi_ddiv_from_thumb>
102e2b06:	b004      	add	sp, #16
102e2b08:	bc1c      	pop	{r2, r3, r4}
102e2b0a:	4690      	mov	r8, r2
102e2b0c:	4699      	mov	r9, r3
102e2b0e:	46a2      	mov	sl, r4
102e2b10:	bcf0      	pop	{r4, r5, r6, r7}
102e2b12:	bc04      	pop	{r2}
102e2b14:	4710      	bx	r2
102e2b16:	9b01      	ldr	r3, [sp, #4]
102e2b18:	0509      	lsls	r1, r1, #20
102e2b1a:	1a59      	subs	r1, r3, r1
102e2b1c:	9101      	str	r1, [sp, #4]
102e2b1e:	9a00      	ldr	r2, [sp, #0]
102e2b20:	9b01      	ldr	r3, [sp, #4]
102e2b22:	e7ec      	b.n	102e2afe <__ratio+0x4e>

102e2b24 <_mprec_log10>:
102e2b24:	b510      	push	{r4, lr}
102e2b26:	1c04      	adds	r4, r0, #0
102e2b28:	2817      	cmp	r0, #23
102e2b2a:	dd0b      	ble.n	102e2b44 <_mprec_log10+0x20>
102e2b2c:	4909      	ldr	r1, [pc, #36]	; (102e2b54 <_mprec_log10+0x30>)
102e2b2e:	4808      	ldr	r0, [pc, #32]	; (102e2b50 <_mprec_log10+0x2c>)
102e2b30:	4a09      	ldr	r2, [pc, #36]	; (102e2b58 <_mprec_log10+0x34>)
102e2b32:	4b0a      	ldr	r3, [pc, #40]	; (102e2b5c <_mprec_log10+0x38>)
102e2b34:	3c01      	subs	r4, #1
102e2b36:	f001 fa05 	bl	102e3f44 <____aeabi_dmul_from_thumb>
102e2b3a:	2c00      	cmp	r4, #0
102e2b3c:	d1f8      	bne.n	102e2b30 <_mprec_log10+0xc>
102e2b3e:	bc10      	pop	{r4}
102e2b40:	bc04      	pop	{r2}
102e2b42:	4710      	bx	r2
102e2b44:	4b06      	ldr	r3, [pc, #24]	; (102e2b60 <_mprec_log10+0x3c>)
102e2b46:	00c4      	lsls	r4, r0, #3
102e2b48:	191c      	adds	r4, r3, r4
102e2b4a:	6920      	ldr	r0, [r4, #16]
102e2b4c:	6961      	ldr	r1, [r4, #20]
102e2b4e:	e7f6      	b.n	102e2b3e <_mprec_log10+0x1a>
102e2b50:	00000000 	.word	0x00000000
102e2b54:	3ff00000 	.word	0x3ff00000
102e2b58:	00000000 	.word	0x00000000
102e2b5c:	40240000 	.word	0x40240000
102e2b60:	102edcd8 	.word	0x102edcd8

102e2b64 <__copybits>:
102e2b64:	b570      	push	{r4, r5, r6, lr}
102e2b66:	6915      	ldr	r5, [r2, #16]
102e2b68:	1e4e      	subs	r6, r1, #1
102e2b6a:	3504      	adds	r5, #4
102e2b6c:	1176      	asrs	r6, r6, #5
102e2b6e:	00ad      	lsls	r5, r5, #2
102e2b70:	3601      	adds	r6, #1
102e2b72:	1c13      	adds	r3, r2, #0
102e2b74:	1955      	adds	r5, r2, r5
102e2b76:	00b6      	lsls	r6, r6, #2
102e2b78:	3314      	adds	r3, #20
102e2b7a:	3504      	adds	r5, #4
102e2b7c:	1986      	adds	r6, r0, r6
102e2b7e:	42ab      	cmp	r3, r5
102e2b80:	d20a      	bcs.n	102e2b98 <__copybits+0x34>
102e2b82:	1c01      	adds	r1, r0, #0
102e2b84:	cb10      	ldmia	r3!, {r4}
102e2b86:	c110      	stmia	r1!, {r4}
102e2b88:	429d      	cmp	r5, r3
102e2b8a:	d8fb      	bhi.n	102e2b84 <__copybits+0x20>
102e2b8c:	1aab      	subs	r3, r5, r2
102e2b8e:	3b15      	subs	r3, #21
102e2b90:	089b      	lsrs	r3, r3, #2
102e2b92:	3301      	adds	r3, #1
102e2b94:	009b      	lsls	r3, r3, #2
102e2b96:	18c0      	adds	r0, r0, r3
102e2b98:	2300      	movs	r3, #0
102e2b9a:	4286      	cmp	r6, r0
102e2b9c:	d902      	bls.n	102e2ba4 <__copybits+0x40>
102e2b9e:	c008      	stmia	r0!, {r3}
102e2ba0:	4286      	cmp	r6, r0
102e2ba2:	d8fc      	bhi.n	102e2b9e <__copybits+0x3a>
102e2ba4:	bc70      	pop	{r4, r5, r6}
102e2ba6:	bc01      	pop	{r0}
102e2ba8:	4700      	bx	r0
102e2baa:	46c0      	nop			; (mov r8, r8)

102e2bac <__any_on>:
102e2bac:	1c03      	adds	r3, r0, #0
102e2bae:	1c02      	adds	r2, r0, #0
102e2bb0:	6900      	ldr	r0, [r0, #16]
102e2bb2:	b530      	push	{r4, r5, lr}
102e2bb4:	3314      	adds	r3, #20
102e2bb6:	114c      	asrs	r4, r1, #5
102e2bb8:	42a0      	cmp	r0, r4
102e2bba:	da11      	bge.n	102e2be0 <__any_on+0x34>
102e2bbc:	1c04      	adds	r4, r0, #0
102e2bbe:	1d20      	adds	r0, r4, #4
102e2bc0:	0080      	lsls	r0, r0, #2
102e2bc2:	1810      	adds	r0, r2, r0
102e2bc4:	1d02      	adds	r2, r0, #4
102e2bc6:	4293      	cmp	r3, r2
102e2bc8:	d303      	bcc.n	102e2bd2 <__any_on+0x26>
102e2bca:	e01a      	b.n	102e2c02 <__any_on+0x56>
102e2bcc:	4283      	cmp	r3, r0
102e2bce:	d218      	bcs.n	102e2c02 <__any_on+0x56>
102e2bd0:	3804      	subs	r0, #4
102e2bd2:	6802      	ldr	r2, [r0, #0]
102e2bd4:	2a00      	cmp	r2, #0
102e2bd6:	d0f9      	beq.n	102e2bcc <__any_on+0x20>
102e2bd8:	2001      	movs	r0, #1
102e2bda:	bc30      	pop	{r4, r5}
102e2bdc:	bc02      	pop	{r1}
102e2bde:	4708      	bx	r1
102e2be0:	42a0      	cmp	r0, r4
102e2be2:	ddec      	ble.n	102e2bbe <__any_on+0x12>
102e2be4:	201f      	movs	r0, #31
102e2be6:	4001      	ands	r1, r0
102e2be8:	d0e9      	beq.n	102e2bbe <__any_on+0x12>
102e2bea:	1d20      	adds	r0, r4, #4
102e2bec:	0080      	lsls	r0, r0, #2
102e2bee:	1810      	adds	r0, r2, r0
102e2bf0:	6845      	ldr	r5, [r0, #4]
102e2bf2:	1c28      	adds	r0, r5, #0
102e2bf4:	40c8      	lsrs	r0, r1
102e2bf6:	4088      	lsls	r0, r1
102e2bf8:	1c01      	adds	r1, r0, #0
102e2bfa:	2001      	movs	r0, #1
102e2bfc:	42a9      	cmp	r1, r5
102e2bfe:	d1ec      	bne.n	102e2bda <__any_on+0x2e>
102e2c00:	e7dd      	b.n	102e2bbe <__any_on+0x12>
102e2c02:	2000      	movs	r0, #0
102e2c04:	e7e9      	b.n	102e2bda <__any_on+0x2e>
102e2c06:	46c0      	nop			; (mov r8, r8)

102e2c08 <_sbrk_r>:
102e2c08:	b538      	push	{r3, r4, r5, lr}
102e2c0a:	4c08      	ldr	r4, [pc, #32]	; (102e2c2c <_sbrk_r+0x24>)
102e2c0c:	2300      	movs	r3, #0
102e2c0e:	1c05      	adds	r5, r0, #0
102e2c10:	1c08      	adds	r0, r1, #0
102e2c12:	6023      	str	r3, [r4, #0]
102e2c14:	f001 f986 	bl	102e3f24 <___sbrk_from_thumb>
102e2c18:	1c43      	adds	r3, r0, #1
102e2c1a:	d002      	beq.n	102e2c22 <_sbrk_r+0x1a>
102e2c1c:	bc38      	pop	{r3, r4, r5}
102e2c1e:	bc02      	pop	{r1}
102e2c20:	4708      	bx	r1
102e2c22:	6823      	ldr	r3, [r4, #0]
102e2c24:	2b00      	cmp	r3, #0
102e2c26:	d0f9      	beq.n	102e2c1c <_sbrk_r+0x14>
102e2c28:	602b      	str	r3, [r5, #0]
102e2c2a:	e7f7      	b.n	102e2c1c <_sbrk_r+0x14>
102e2c2c:	f03de64c 	.word	0xf03de64c

102e2c30 <_calloc_r>:
102e2c30:	b510      	push	{r4, lr}
102e2c32:	4351      	muls	r1, r2
102e2c34:	f7ff f848 	bl	102e1cc8 <_malloc_r>
102e2c38:	1e04      	subs	r4, r0, #0
102e2c3a:	d00e      	beq.n	102e2c5a <_calloc_r+0x2a>
102e2c3c:	1c23      	adds	r3, r4, #0
102e2c3e:	3b08      	subs	r3, #8
102e2c40:	685a      	ldr	r2, [r3, #4]
102e2c42:	2303      	movs	r3, #3
102e2c44:	439a      	bics	r2, r3
102e2c46:	3a04      	subs	r2, #4
102e2c48:	2a24      	cmp	r2, #36	; 0x24
102e2c4a:	d816      	bhi.n	102e2c7a <_calloc_r+0x4a>
102e2c4c:	1c23      	adds	r3, r4, #0
102e2c4e:	2a13      	cmp	r2, #19
102e2c50:	d807      	bhi.n	102e2c62 <_calloc_r+0x32>
102e2c52:	2200      	movs	r2, #0
102e2c54:	601a      	str	r2, [r3, #0]
102e2c56:	605a      	str	r2, [r3, #4]
102e2c58:	609a      	str	r2, [r3, #8]
102e2c5a:	1c20      	adds	r0, r4, #0
102e2c5c:	bc10      	pop	{r4}
102e2c5e:	bc02      	pop	{r1}
102e2c60:	4708      	bx	r1
102e2c62:	2300      	movs	r3, #0
102e2c64:	6023      	str	r3, [r4, #0]
102e2c66:	6063      	str	r3, [r4, #4]
102e2c68:	2a1b      	cmp	r2, #27
102e2c6a:	d90b      	bls.n	102e2c84 <_calloc_r+0x54>
102e2c6c:	60a3      	str	r3, [r4, #8]
102e2c6e:	60e3      	str	r3, [r4, #12]
102e2c70:	2a24      	cmp	r2, #36	; 0x24
102e2c72:	d00a      	beq.n	102e2c8a <_calloc_r+0x5a>
102e2c74:	1c23      	adds	r3, r4, #0
102e2c76:	3310      	adds	r3, #16
102e2c78:	e7eb      	b.n	102e2c52 <_calloc_r+0x22>
102e2c7a:	1c20      	adds	r0, r4, #0
102e2c7c:	2100      	movs	r1, #0
102e2c7e:	f7fc fea9 	bl	102df9d4 <memset>
102e2c82:	e7ea      	b.n	102e2c5a <_calloc_r+0x2a>
102e2c84:	1c23      	adds	r3, r4, #0
102e2c86:	3308      	adds	r3, #8
102e2c88:	e7e3      	b.n	102e2c52 <_calloc_r+0x22>
102e2c8a:	6123      	str	r3, [r4, #16]
102e2c8c:	6163      	str	r3, [r4, #20]
102e2c8e:	1c23      	adds	r3, r4, #0
102e2c90:	3318      	adds	r3, #24
102e2c92:	e7de      	b.n	102e2c52 <_calloc_r+0x22>

102e2c94 <__aeabi_uidiv>:
102e2c94:	e2512001 	subs	r2, r1, #1
102e2c98:	012fff1e 	bxeq	lr
102e2c9c:	3a000036 	bcc	102e2d7c <__aeabi_uidiv+0xe8>
102e2ca0:	e1500001 	cmp	r0, r1
102e2ca4:	9a000022 	bls	102e2d34 <__aeabi_uidiv+0xa0>
102e2ca8:	e1110002 	tst	r1, r2
102e2cac:	0a000023 	beq	102e2d40 <__aeabi_uidiv+0xac>
102e2cb0:	e311020e 	tst	r1, #-536870912	; 0xe0000000
102e2cb4:	01a01181 	lsleq	r1, r1, #3
102e2cb8:	03a03008 	moveq	r3, #8
102e2cbc:	13a03001 	movne	r3, #1
102e2cc0:	e3510201 	cmp	r1, #268435456	; 0x10000000
102e2cc4:	31510000 	cmpcc	r1, r0
102e2cc8:	31a01201 	lslcc	r1, r1, #4
102e2ccc:	31a03203 	lslcc	r3, r3, #4
102e2cd0:	3afffffa 	bcc	102e2cc0 <__aeabi_uidiv+0x2c>
102e2cd4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
102e2cd8:	31510000 	cmpcc	r1, r0
102e2cdc:	31a01081 	lslcc	r1, r1, #1
102e2ce0:	31a03083 	lslcc	r3, r3, #1
102e2ce4:	3afffffa 	bcc	102e2cd4 <__aeabi_uidiv+0x40>
102e2ce8:	e3a02000 	mov	r2, #0
102e2cec:	e1500001 	cmp	r0, r1
102e2cf0:	20400001 	subcs	r0, r0, r1
102e2cf4:	21822003 	orrcs	r2, r2, r3
102e2cf8:	e15000a1 	cmp	r0, r1, lsr #1
102e2cfc:	204000a1 	subcs	r0, r0, r1, lsr #1
102e2d00:	218220a3 	orrcs	r2, r2, r3, lsr #1
102e2d04:	e1500121 	cmp	r0, r1, lsr #2
102e2d08:	20400121 	subcs	r0, r0, r1, lsr #2
102e2d0c:	21822123 	orrcs	r2, r2, r3, lsr #2
102e2d10:	e15001a1 	cmp	r0, r1, lsr #3
102e2d14:	204001a1 	subcs	r0, r0, r1, lsr #3
102e2d18:	218221a3 	orrcs	r2, r2, r3, lsr #3
102e2d1c:	e3500000 	cmp	r0, #0
102e2d20:	11b03223 	lsrsne	r3, r3, #4
102e2d24:	11a01221 	lsrne	r1, r1, #4
102e2d28:	1affffef 	bne	102e2cec <__aeabi_uidiv+0x58>
102e2d2c:	e1a00002 	mov	r0, r2
102e2d30:	e12fff1e 	bx	lr
102e2d34:	03a00001 	moveq	r0, #1
102e2d38:	13a00000 	movne	r0, #0
102e2d3c:	e12fff1e 	bx	lr
102e2d40:	e3510801 	cmp	r1, #65536	; 0x10000
102e2d44:	21a01821 	lsrcs	r1, r1, #16
102e2d48:	23a02010 	movcs	r2, #16
102e2d4c:	33a02000 	movcc	r2, #0
102e2d50:	e3510c01 	cmp	r1, #256	; 0x100
102e2d54:	21a01421 	lsrcs	r1, r1, #8
102e2d58:	22822008 	addcs	r2, r2, #8
102e2d5c:	e3510010 	cmp	r1, #16
102e2d60:	21a01221 	lsrcs	r1, r1, #4
102e2d64:	22822004 	addcs	r2, r2, #4
102e2d68:	e3510004 	cmp	r1, #4
102e2d6c:	82822003 	addhi	r2, r2, #3
102e2d70:	908220a1 	addls	r2, r2, r1, lsr #1
102e2d74:	e1a00230 	lsr	r0, r0, r2
102e2d78:	e12fff1e 	bx	lr
102e2d7c:	e12fff1f 	bx	pc
102e2d80:	e1a00000 	nop			; (mov r0, r0)
102e2d84:	e3500000 	cmp	r0, #0
102e2d88:	13e00000 	mvnne	r0, #0
102e2d8c:	ea000449 	b	102e3eb8 <____aeabi_idiv0_from_arm>

102e2d90 <__aeabi_uidivmod>:
102e2d90:	e3510000 	cmp	r1, #0
102e2d94:	0afffff8 	beq	102e2d7c <__aeabi_uidiv+0xe8>
102e2d98:	e92d4003 	push	{r0, r1, lr}
102e2d9c:	ebffffbc 	bl	102e2c94 <__aeabi_uidiv>
102e2da0:	e8bd4006 	pop	{r1, r2, lr}
102e2da4:	e0030092 	mul	r3, r2, r0
102e2da8:	e0411003 	sub	r1, r1, r3
102e2dac:	e12fff1e 	bx	lr

102e2db0 <__aeabi_idiv>:
102e2db0:	e3510000 	cmp	r1, #0
102e2db4:	0a000043 	beq	102e2ec8 <.divsi3_skip_div0_test+0x110>

102e2db8 <.divsi3_skip_div0_test>:
102e2db8:	e020c001 	eor	ip, r0, r1
102e2dbc:	42611000 	rsbmi	r1, r1, #0
102e2dc0:	e2512001 	subs	r2, r1, #1
102e2dc4:	0a000027 	beq	102e2e68 <.divsi3_skip_div0_test+0xb0>
102e2dc8:	e1b03000 	movs	r3, r0
102e2dcc:	42603000 	rsbmi	r3, r0, #0
102e2dd0:	e1530001 	cmp	r3, r1
102e2dd4:	9a000026 	bls	102e2e74 <.divsi3_skip_div0_test+0xbc>
102e2dd8:	e1110002 	tst	r1, r2
102e2ddc:	0a000028 	beq	102e2e84 <.divsi3_skip_div0_test+0xcc>
102e2de0:	e311020e 	tst	r1, #-536870912	; 0xe0000000
102e2de4:	01a01181 	lsleq	r1, r1, #3
102e2de8:	03a02008 	moveq	r2, #8
102e2dec:	13a02001 	movne	r2, #1
102e2df0:	e3510201 	cmp	r1, #268435456	; 0x10000000
102e2df4:	31510003 	cmpcc	r1, r3
102e2df8:	31a01201 	lslcc	r1, r1, #4
102e2dfc:	31a02202 	lslcc	r2, r2, #4
102e2e00:	3afffffa 	bcc	102e2df0 <.divsi3_skip_div0_test+0x38>
102e2e04:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
102e2e08:	31510003 	cmpcc	r1, r3
102e2e0c:	31a01081 	lslcc	r1, r1, #1
102e2e10:	31a02082 	lslcc	r2, r2, #1
102e2e14:	3afffffa 	bcc	102e2e04 <.divsi3_skip_div0_test+0x4c>
102e2e18:	e3a00000 	mov	r0, #0
102e2e1c:	e1530001 	cmp	r3, r1
102e2e20:	20433001 	subcs	r3, r3, r1
102e2e24:	21800002 	orrcs	r0, r0, r2
102e2e28:	e15300a1 	cmp	r3, r1, lsr #1
102e2e2c:	204330a1 	subcs	r3, r3, r1, lsr #1
102e2e30:	218000a2 	orrcs	r0, r0, r2, lsr #1
102e2e34:	e1530121 	cmp	r3, r1, lsr #2
102e2e38:	20433121 	subcs	r3, r3, r1, lsr #2
102e2e3c:	21800122 	orrcs	r0, r0, r2, lsr #2
102e2e40:	e15301a1 	cmp	r3, r1, lsr #3
102e2e44:	204331a1 	subcs	r3, r3, r1, lsr #3
102e2e48:	218001a2 	orrcs	r0, r0, r2, lsr #3
102e2e4c:	e3530000 	cmp	r3, #0
102e2e50:	11b02222 	lsrsne	r2, r2, #4
102e2e54:	11a01221 	lsrne	r1, r1, #4
102e2e58:	1affffef 	bne	102e2e1c <.divsi3_skip_div0_test+0x64>
102e2e5c:	e35c0000 	cmp	ip, #0
102e2e60:	42600000 	rsbmi	r0, r0, #0
102e2e64:	e12fff1e 	bx	lr
102e2e68:	e13c0000 	teq	ip, r0
102e2e6c:	42600000 	rsbmi	r0, r0, #0
102e2e70:	e12fff1e 	bx	lr
102e2e74:	33a00000 	movcc	r0, #0
102e2e78:	01a00fcc 	asreq	r0, ip, #31
102e2e7c:	03800001 	orreq	r0, r0, #1
102e2e80:	e12fff1e 	bx	lr
102e2e84:	e3510801 	cmp	r1, #65536	; 0x10000
102e2e88:	21a01821 	lsrcs	r1, r1, #16
102e2e8c:	23a02010 	movcs	r2, #16
102e2e90:	33a02000 	movcc	r2, #0
102e2e94:	e3510c01 	cmp	r1, #256	; 0x100
102e2e98:	21a01421 	lsrcs	r1, r1, #8
102e2e9c:	22822008 	addcs	r2, r2, #8
102e2ea0:	e3510010 	cmp	r1, #16
102e2ea4:	21a01221 	lsrcs	r1, r1, #4
102e2ea8:	22822004 	addcs	r2, r2, #4
102e2eac:	e3510004 	cmp	r1, #4
102e2eb0:	82822003 	addhi	r2, r2, #3
102e2eb4:	908220a1 	addls	r2, r2, r1, lsr #1
102e2eb8:	e35c0000 	cmp	ip, #0
102e2ebc:	e1a00233 	lsr	r0, r3, r2
102e2ec0:	42600000 	rsbmi	r0, r0, #0
102e2ec4:	e12fff1e 	bx	lr
102e2ec8:	e12fff1f 	bx	pc
102e2ecc:	e1a00000 	nop			; (mov r0, r0)
102e2ed0:	e3500000 	cmp	r0, #0
102e2ed4:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
102e2ed8:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
102e2edc:	ea0003f5 	b	102e3eb8 <____aeabi_idiv0_from_arm>

102e2ee0 <__aeabi_idivmod>:
102e2ee0:	e3510000 	cmp	r1, #0
102e2ee4:	0afffff7 	beq	102e2ec8 <.divsi3_skip_div0_test+0x110>
102e2ee8:	e92d4003 	push	{r0, r1, lr}
102e2eec:	ebffffb1 	bl	102e2db8 <.divsi3_skip_div0_test>
102e2ef0:	e8bd4006 	pop	{r1, r2, lr}
102e2ef4:	e0030092 	mul	r3, r2, r0
102e2ef8:	e0411003 	sub	r1, r1, r3
102e2efc:	e12fff1e 	bx	lr

102e2f00 <__aeabi_idiv0>:
102e2f00:	4770      	bx	lr
102e2f02:	46c0      	nop			; (mov r8, r8)

102e2f04 <__aeabi_drsub>:
102e2f04:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000
102e2f08:	ea000000 	b	102e2f10 <__adddf3>

102e2f0c <__aeabi_dsub>:
102e2f0c:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000

102e2f10 <__adddf3>:
102e2f10:	e92d4030 	push	{r4, r5, lr}
102e2f14:	e1a04081 	lsl	r4, r1, #1
102e2f18:	e1a05083 	lsl	r5, r3, #1
102e2f1c:	e1340005 	teq	r4, r5
102e2f20:	01300002 	teqeq	r0, r2
102e2f24:	1194c000 	orrsne	ip, r4, r0
102e2f28:	1195c002 	orrsne	ip, r5, r2
102e2f2c:	11f0cac4 	mvnsne	ip, r4, asr #21
102e2f30:	11f0cac5 	mvnsne	ip, r5, asr #21
102e2f34:	0a00008c 	beq	102e316c <__adddf3+0x25c>
102e2f38:	e1a04aa4 	lsr	r4, r4, #21
102e2f3c:	e0745aa5 	rsbs	r5, r4, r5, lsr #21
102e2f40:	b2655000 	rsblt	r5, r5, #0
102e2f44:	da000006 	ble	102e2f64 <__adddf3+0x54>
102e2f48:	e0844005 	add	r4, r4, r5
102e2f4c:	e0202002 	eor	r2, r0, r2
102e2f50:	e0213003 	eor	r3, r1, r3
102e2f54:	e0220000 	eor	r0, r2, r0
102e2f58:	e0231001 	eor	r1, r3, r1
102e2f5c:	e0202002 	eor	r2, r0, r2
102e2f60:	e0213003 	eor	r3, r1, r3
102e2f64:	e3550036 	cmp	r5, #54	; 0x36
102e2f68:	88bd4030 	pophi	{r4, r5, lr}
102e2f6c:	812fff1e 	bxhi	lr
102e2f70:	e3110102 	tst	r1, #-2147483648	; 0x80000000
102e2f74:	e1a01601 	lsl	r1, r1, #12
102e2f78:	e3a0c601 	mov	ip, #1048576	; 0x100000
102e2f7c:	e18c1621 	orr	r1, ip, r1, lsr #12
102e2f80:	0a000001 	beq	102e2f8c <__adddf3+0x7c>
102e2f84:	e2700000 	rsbs	r0, r0, #0
102e2f88:	e2e11000 	rsc	r1, r1, #0
102e2f8c:	e3130102 	tst	r3, #-2147483648	; 0x80000000
102e2f90:	e1a03603 	lsl	r3, r3, #12
102e2f94:	e18c3623 	orr	r3, ip, r3, lsr #12
102e2f98:	0a000001 	beq	102e2fa4 <__adddf3+0x94>
102e2f9c:	e2722000 	rsbs	r2, r2, #0
102e2fa0:	e2e33000 	rsc	r3, r3, #0
102e2fa4:	e1340005 	teq	r4, r5
102e2fa8:	0a000069 	beq	102e3154 <__adddf3+0x244>
102e2fac:	e2444001 	sub	r4, r4, #1
102e2fb0:	e275e020 	rsbs	lr, r5, #32
102e2fb4:	ba000005 	blt	102e2fd0 <__adddf3+0xc0>
102e2fb8:	e1a0ce12 	lsl	ip, r2, lr
102e2fbc:	e0900532 	adds	r0, r0, r2, lsr r5
102e2fc0:	e2a11000 	adc	r1, r1, #0
102e2fc4:	e0900e13 	adds	r0, r0, r3, lsl lr
102e2fc8:	e0b11553 	adcs	r1, r1, r3, asr r5
102e2fcc:	ea000006 	b	102e2fec <__adddf3+0xdc>
102e2fd0:	e2455020 	sub	r5, r5, #32
102e2fd4:	e28ee020 	add	lr, lr, #32
102e2fd8:	e3520001 	cmp	r2, #1
102e2fdc:	e1a0ce13 	lsl	ip, r3, lr
102e2fe0:	238cc002 	orrcs	ip, ip, #2
102e2fe4:	e0900553 	adds	r0, r0, r3, asr r5
102e2fe8:	e0b11fc3 	adcs	r1, r1, r3, asr #31
102e2fec:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
102e2ff0:	5a000002 	bpl	102e3000 <__adddf3+0xf0>
102e2ff4:	e27cc000 	rsbs	ip, ip, #0
102e2ff8:	e2f00000 	rscs	r0, r0, #0
102e2ffc:	e2e11000 	rsc	r1, r1, #0
102e3000:	e3510601 	cmp	r1, #1048576	; 0x100000
102e3004:	3a00000f 	bcc	102e3048 <__adddf3+0x138>
102e3008:	e3510602 	cmp	r1, #2097152	; 0x200000
102e300c:	3a000006 	bcc	102e302c <__adddf3+0x11c>
102e3010:	e1b010a1 	lsrs	r1, r1, #1
102e3014:	e1b00060 	rrxs	r0, r0
102e3018:	e1a0c06c 	rrx	ip, ip
102e301c:	e2844001 	add	r4, r4, #1
102e3020:	e1a02a84 	lsl	r2, r4, #21
102e3024:	e3720501 	cmn	r2, #4194304	; 0x400000
102e3028:	2a00006b 	bcs	102e31dc <__adddf3+0x2cc>
102e302c:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
102e3030:	01b0c0a0 	lsrseq	ip, r0, #1
102e3034:	e2b00000 	adcs	r0, r0, #0
102e3038:	e0a11a04 	adc	r1, r1, r4, lsl #20
102e303c:	e1811005 	orr	r1, r1, r5
102e3040:	e8bd4030 	pop	{r4, r5, lr}
102e3044:	e12fff1e 	bx	lr
102e3048:	e1b0c08c 	lsls	ip, ip, #1
102e304c:	e0b00000 	adcs	r0, r0, r0
102e3050:	e0a11001 	adc	r1, r1, r1
102e3054:	e3110601 	tst	r1, #1048576	; 0x100000
102e3058:	e2444001 	sub	r4, r4, #1
102e305c:	1afffff2 	bne	102e302c <__adddf3+0x11c>
102e3060:	e3310000 	teq	r1, #0
102e3064:	13a03014 	movne	r3, #20
102e3068:	03a03034 	moveq	r3, #52	; 0x34
102e306c:	01a01000 	moveq	r1, r0
102e3070:	03a00000 	moveq	r0, #0
102e3074:	e1a02001 	mov	r2, r1
102e3078:	e3520801 	cmp	r2, #65536	; 0x10000
102e307c:	21a02822 	lsrcs	r2, r2, #16
102e3080:	22433010 	subcs	r3, r3, #16
102e3084:	e3520c01 	cmp	r2, #256	; 0x100
102e3088:	21a02422 	lsrcs	r2, r2, #8
102e308c:	22433008 	subcs	r3, r3, #8
102e3090:	e3520010 	cmp	r2, #16
102e3094:	21a02222 	lsrcs	r2, r2, #4
102e3098:	22433004 	subcs	r3, r3, #4
102e309c:	e3520004 	cmp	r2, #4
102e30a0:	22433002 	subcs	r3, r3, #2
102e30a4:	304330a2 	subcc	r3, r3, r2, lsr #1
102e30a8:	e04331a2 	sub	r3, r3, r2, lsr #3
102e30ac:	e2532020 	subs	r2, r3, #32
102e30b0:	aa000007 	bge	102e30d4 <__adddf3+0x1c4>
102e30b4:	e292200c 	adds	r2, r2, #12
102e30b8:	da000004 	ble	102e30d0 <__adddf3+0x1c0>
102e30bc:	e282c014 	add	ip, r2, #20
102e30c0:	e262200c 	rsb	r2, r2, #12
102e30c4:	e1a00c11 	lsl	r0, r1, ip
102e30c8:	e1a01231 	lsr	r1, r1, r2
102e30cc:	ea000004 	b	102e30e4 <__adddf3+0x1d4>
102e30d0:	e2822014 	add	r2, r2, #20
102e30d4:	d262c020 	rsble	ip, r2, #32
102e30d8:	e1a01211 	lsl	r1, r1, r2
102e30dc:	d1811c30 	orrle	r1, r1, r0, lsr ip
102e30e0:	d1a00210 	lslle	r0, r0, r2
102e30e4:	e0544003 	subs	r4, r4, r3
102e30e8:	a0811a04 	addge	r1, r1, r4, lsl #20
102e30ec:	a1811005 	orrge	r1, r1, r5
102e30f0:	a8bd4030 	popge	{r4, r5, lr}
102e30f4:	a12fff1e 	bxge	lr
102e30f8:	e1e04004 	mvn	r4, r4
102e30fc:	e254401f 	subs	r4, r4, #31
102e3100:	aa00000f 	bge	102e3144 <__adddf3+0x234>
102e3104:	e294400c 	adds	r4, r4, #12
102e3108:	ca000006 	bgt	102e3128 <__adddf3+0x218>
102e310c:	e2844014 	add	r4, r4, #20
102e3110:	e2642020 	rsb	r2, r4, #32
102e3114:	e1a00430 	lsr	r0, r0, r4
102e3118:	e1800211 	orr	r0, r0, r1, lsl r2
102e311c:	e1851431 	orr	r1, r5, r1, lsr r4
102e3120:	e8bd4030 	pop	{r4, r5, lr}
102e3124:	e12fff1e 	bx	lr
102e3128:	e264400c 	rsb	r4, r4, #12
102e312c:	e2642020 	rsb	r2, r4, #32
102e3130:	e1a00230 	lsr	r0, r0, r2
102e3134:	e1800411 	orr	r0, r0, r1, lsl r4
102e3138:	e1a01005 	mov	r1, r5
102e313c:	e8bd4030 	pop	{r4, r5, lr}
102e3140:	e12fff1e 	bx	lr
102e3144:	e1a00431 	lsr	r0, r1, r4
102e3148:	e1a01005 	mov	r1, r5
102e314c:	e8bd4030 	pop	{r4, r5, lr}
102e3150:	e12fff1e 	bx	lr
102e3154:	e3340000 	teq	r4, #0
102e3158:	e2233601 	eor	r3, r3, #1048576	; 0x100000
102e315c:	02211601 	eoreq	r1, r1, #1048576	; 0x100000
102e3160:	02844001 	addeq	r4, r4, #1
102e3164:	12455001 	subne	r5, r5, #1
102e3168:	eaffff8f 	b	102e2fac <__adddf3+0x9c>
102e316c:	e1f0cac4 	mvns	ip, r4, asr #21
102e3170:	11f0cac5 	mvnsne	ip, r5, asr #21
102e3174:	0a00001d 	beq	102e31f0 <__adddf3+0x2e0>
102e3178:	e1340005 	teq	r4, r5
102e317c:	01300002 	teqeq	r0, r2
102e3180:	0a000004 	beq	102e3198 <__adddf3+0x288>
102e3184:	e194c000 	orrs	ip, r4, r0
102e3188:	01a01003 	moveq	r1, r3
102e318c:	01a00002 	moveq	r0, r2
102e3190:	e8bd4030 	pop	{r4, r5, lr}
102e3194:	e12fff1e 	bx	lr
102e3198:	e1310003 	teq	r1, r3
102e319c:	13a01000 	movne	r1, #0
102e31a0:	13a00000 	movne	r0, #0
102e31a4:	18bd4030 	popne	{r4, r5, lr}
102e31a8:	112fff1e 	bxne	lr
102e31ac:	e1b0caa4 	lsrs	ip, r4, #21
102e31b0:	1a000004 	bne	102e31c8 <__adddf3+0x2b8>
102e31b4:	e1b00080 	lsls	r0, r0, #1
102e31b8:	e0b11001 	adcs	r1, r1, r1
102e31bc:	23811102 	orrcs	r1, r1, #-2147483648	; 0x80000000
102e31c0:	e8bd4030 	pop	{r4, r5, lr}
102e31c4:	e12fff1e 	bx	lr
102e31c8:	e2944501 	adds	r4, r4, #4194304	; 0x400000
102e31cc:	32811601 	addcc	r1, r1, #1048576	; 0x100000
102e31d0:	38bd4030 	popcc	{r4, r5, lr}
102e31d4:	312fff1e 	bxcc	lr
102e31d8:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
102e31dc:	e385147f 	orr	r1, r5, #2130706432	; 0x7f000000
102e31e0:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
102e31e4:	e3a00000 	mov	r0, #0
102e31e8:	e8bd4030 	pop	{r4, r5, lr}
102e31ec:	e12fff1e 	bx	lr
102e31f0:	e1f0cac4 	mvns	ip, r4, asr #21
102e31f4:	11a01003 	movne	r1, r3
102e31f8:	11a00002 	movne	r0, r2
102e31fc:	01f0cac5 	mvnseq	ip, r5, asr #21
102e3200:	11a03001 	movne	r3, r1
102e3204:	11a02000 	movne	r2, r0
102e3208:	e1904601 	orrs	r4, r0, r1, lsl #12
102e320c:	01925603 	orrseq	r5, r2, r3, lsl #12
102e3210:	01310003 	teqeq	r1, r3
102e3214:	13811702 	orrne	r1, r1, #524288	; 0x80000
102e3218:	e8bd4030 	pop	{r4, r5, lr}
102e321c:	e12fff1e 	bx	lr

102e3220 <__aeabi_ui2d>:
102e3220:	e3300000 	teq	r0, #0
102e3224:	03a01000 	moveq	r1, #0
102e3228:	012fff1e 	bxeq	lr
102e322c:	e92d4030 	push	{r4, r5, lr}
102e3230:	e3a04b01 	mov	r4, #1024	; 0x400
102e3234:	e2844032 	add	r4, r4, #50	; 0x32
102e3238:	e3a05000 	mov	r5, #0
102e323c:	e3a01000 	mov	r1, #0
102e3240:	eaffff86 	b	102e3060 <__adddf3+0x150>

102e3244 <__aeabi_i2d>:
102e3244:	e3300000 	teq	r0, #0
102e3248:	03a01000 	moveq	r1, #0
102e324c:	012fff1e 	bxeq	lr
102e3250:	e92d4030 	push	{r4, r5, lr}
102e3254:	e3a04b01 	mov	r4, #1024	; 0x400
102e3258:	e2844032 	add	r4, r4, #50	; 0x32
102e325c:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
102e3260:	42600000 	rsbmi	r0, r0, #0
102e3264:	e3a01000 	mov	r1, #0
102e3268:	eaffff7c 	b	102e3060 <__adddf3+0x150>

102e326c <__aeabi_f2d>:
102e326c:	e1b02080 	lsls	r2, r0, #1
102e3270:	e1a011c2 	asr	r1, r2, #3
102e3274:	e1a01061 	rrx	r1, r1
102e3278:	e1a00e02 	lsl	r0, r2, #28
102e327c:	121234ff 	andsne	r3, r2, #-16777216	; 0xff000000
102e3280:	133304ff 	teqne	r3, #-16777216	; 0xff000000
102e3284:	1221130e 	eorne	r1, r1, #939524096	; 0x38000000
102e3288:	112fff1e 	bxne	lr
102e328c:	e3320000 	teq	r2, #0
102e3290:	133304ff 	teqne	r3, #-16777216	; 0xff000000
102e3294:	012fff1e 	bxeq	lr
102e3298:	e92d4030 	push	{r4, r5, lr}
102e329c:	e3a04d0e 	mov	r4, #896	; 0x380
102e32a0:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
102e32a4:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
102e32a8:	eaffff6c 	b	102e3060 <__adddf3+0x150>

102e32ac <__aeabi_ul2d>:
102e32ac:	e1902001 	orrs	r2, r0, r1
102e32b0:	012fff1e 	bxeq	lr
102e32b4:	e92d4030 	push	{r4, r5, lr}
102e32b8:	e3a05000 	mov	r5, #0
102e32bc:	ea000006 	b	102e32dc <__aeabi_l2d+0x1c>

102e32c0 <__aeabi_l2d>:
102e32c0:	e1902001 	orrs	r2, r0, r1
102e32c4:	012fff1e 	bxeq	lr
102e32c8:	e92d4030 	push	{r4, r5, lr}
102e32cc:	e2115102 	ands	r5, r1, #-2147483648	; 0x80000000
102e32d0:	5a000001 	bpl	102e32dc <__aeabi_l2d+0x1c>
102e32d4:	e2700000 	rsbs	r0, r0, #0
102e32d8:	e2e11000 	rsc	r1, r1, #0
102e32dc:	e3a04b01 	mov	r4, #1024	; 0x400
102e32e0:	e2844032 	add	r4, r4, #50	; 0x32
102e32e4:	e1b0cb21 	lsrs	ip, r1, #22
102e32e8:	0affff44 	beq	102e3000 <__adddf3+0xf0>
102e32ec:	e3a02003 	mov	r2, #3
102e32f0:	e1b0c1ac 	lsrs	ip, ip, #3
102e32f4:	12822003 	addne	r2, r2, #3
102e32f8:	e1b0c1ac 	lsrs	ip, ip, #3
102e32fc:	12822003 	addne	r2, r2, #3
102e3300:	e08221ac 	add	r2, r2, ip, lsr #3
102e3304:	e2623020 	rsb	r3, r2, #32
102e3308:	e1a0c310 	lsl	ip, r0, r3
102e330c:	e1a00230 	lsr	r0, r0, r2
102e3310:	e1800311 	orr	r0, r0, r1, lsl r3
102e3314:	e1a01231 	lsr	r1, r1, r2
102e3318:	e0844002 	add	r4, r4, r2
102e331c:	eaffff37 	b	102e3000 <__adddf3+0xf0>

102e3320 <__aeabi_dmul>:
102e3320:	e92d4070 	push	{r4, r5, r6, lr}
102e3324:	e3a0c0ff 	mov	ip, #255	; 0xff
102e3328:	e38ccc07 	orr	ip, ip, #1792	; 0x700
102e332c:	e01c4a21 	ands	r4, ip, r1, lsr #20
102e3330:	101c5a23 	andsne	r5, ip, r3, lsr #20
102e3334:	1134000c 	teqne	r4, ip
102e3338:	1135000c 	teqne	r5, ip
102e333c:	0b000075 	bleq	102e3518 <__aeabi_dmul+0x1f8>
102e3340:	e0844005 	add	r4, r4, r5
102e3344:	e0216003 	eor	r6, r1, r3
102e3348:	e1c11a8c 	bic	r1, r1, ip, lsl #21
102e334c:	e1c33a8c 	bic	r3, r3, ip, lsl #21
102e3350:	e1905601 	orrs	r5, r0, r1, lsl #12
102e3354:	11925603 	orrsne	r5, r2, r3, lsl #12
102e3358:	e3811601 	orr	r1, r1, #1048576	; 0x100000
102e335c:	e3833601 	orr	r3, r3, #1048576	; 0x100000
102e3360:	0a00001d 	beq	102e33dc <__aeabi_dmul+0xbc>
102e3364:	e08ec290 	umull	ip, lr, r0, r2
102e3368:	e3a05000 	mov	r5, #0
102e336c:	e0a5e291 	umlal	lr, r5, r1, r2
102e3370:	e2062102 	and	r2, r6, #-2147483648	; 0x80000000
102e3374:	e0a5e390 	umlal	lr, r5, r0, r3
102e3378:	e3a06000 	mov	r6, #0
102e337c:	e0a65391 	umlal	r5, r6, r1, r3
102e3380:	e33c0000 	teq	ip, #0
102e3384:	138ee001 	orrne	lr, lr, #1
102e3388:	e24440ff 	sub	r4, r4, #255	; 0xff
102e338c:	e3560c02 	cmp	r6, #512	; 0x200
102e3390:	e2c44c03 	sbc	r4, r4, #768	; 0x300
102e3394:	2a000002 	bcs	102e33a4 <__aeabi_dmul+0x84>
102e3398:	e1b0e08e 	lsls	lr, lr, #1
102e339c:	e0b55005 	adcs	r5, r5, r5
102e33a0:	e0a66006 	adc	r6, r6, r6
102e33a4:	e1821586 	orr	r1, r2, r6, lsl #11
102e33a8:	e1811aa5 	orr	r1, r1, r5, lsr #21
102e33ac:	e1a00585 	lsl	r0, r5, #11
102e33b0:	e1800aae 	orr	r0, r0, lr, lsr #21
102e33b4:	e1a0e58e 	lsl	lr, lr, #11
102e33b8:	e254c0fd 	subs	ip, r4, #253	; 0xfd
102e33bc:	835c0c07 	cmphi	ip, #1792	; 0x700
102e33c0:	8a000011 	bhi	102e340c <__aeabi_dmul+0xec>
102e33c4:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
102e33c8:	01b0e0a0 	lsrseq	lr, r0, #1
102e33cc:	e2b00000 	adcs	r0, r0, #0
102e33d0:	e0a11a04 	adc	r1, r1, r4, lsl #20
102e33d4:	e8bd4070 	pop	{r4, r5, r6, lr}
102e33d8:	e12fff1e 	bx	lr
102e33dc:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
102e33e0:	e1861001 	orr	r1, r6, r1
102e33e4:	e1800002 	orr	r0, r0, r2
102e33e8:	e0211003 	eor	r1, r1, r3
102e33ec:	e05440ac 	subs	r4, r4, ip, lsr #1
102e33f0:	c074500c 	rsbsgt	r5, r4, ip
102e33f4:	c1811a04 	orrgt	r1, r1, r4, lsl #20
102e33f8:	c8bd4070 	popgt	{r4, r5, r6, lr}
102e33fc:	c12fff1e 	bxgt	lr
102e3400:	e3811601 	orr	r1, r1, #1048576	; 0x100000
102e3404:	e3a0e000 	mov	lr, #0
102e3408:	e2544001 	subs	r4, r4, #1
102e340c:	ca00005d 	bgt	102e3588 <__aeabi_dmul+0x268>
102e3410:	e3740036 	cmn	r4, #54	; 0x36
102e3414:	d3a00000 	movle	r0, #0
102e3418:	d2011102 	andle	r1, r1, #-2147483648	; 0x80000000
102e341c:	d8bd4070 	pople	{r4, r5, r6, lr}
102e3420:	d12fff1e 	bxle	lr
102e3424:	e2644000 	rsb	r4, r4, #0
102e3428:	e2544020 	subs	r4, r4, #32
102e342c:	aa00001a 	bge	102e349c <__aeabi_dmul+0x17c>
102e3430:	e294400c 	adds	r4, r4, #12
102e3434:	ca00000c 	bgt	102e346c <__aeabi_dmul+0x14c>
102e3438:	e2844014 	add	r4, r4, #20
102e343c:	e2645020 	rsb	r5, r4, #32
102e3440:	e1a03510 	lsl	r3, r0, r5
102e3444:	e1a00430 	lsr	r0, r0, r4
102e3448:	e1800511 	orr	r0, r0, r1, lsl r5
102e344c:	e2012102 	and	r2, r1, #-2147483648	; 0x80000000
102e3450:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
102e3454:	e0900fa3 	adds	r0, r0, r3, lsr #31
102e3458:	e0a21431 	adc	r1, r2, r1, lsr r4
102e345c:	e19ee083 	orrs	lr, lr, r3, lsl #1
102e3460:	01c00fa3 	biceq	r0, r0, r3, lsr #31
102e3464:	e8bd4070 	pop	{r4, r5, r6, lr}
102e3468:	e12fff1e 	bx	lr
102e346c:	e264400c 	rsb	r4, r4, #12
102e3470:	e2645020 	rsb	r5, r4, #32
102e3474:	e1a03410 	lsl	r3, r0, r4
102e3478:	e1a00530 	lsr	r0, r0, r5
102e347c:	e1800411 	orr	r0, r0, r1, lsl r4
102e3480:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
102e3484:	e0900fa3 	adds	r0, r0, r3, lsr #31
102e3488:	e2a11000 	adc	r1, r1, #0
102e348c:	e19ee083 	orrs	lr, lr, r3, lsl #1
102e3490:	01c00fa3 	biceq	r0, r0, r3, lsr #31
102e3494:	e8bd4070 	pop	{r4, r5, r6, lr}
102e3498:	e12fff1e 	bx	lr
102e349c:	e2645020 	rsb	r5, r4, #32
102e34a0:	e18ee510 	orr	lr, lr, r0, lsl r5
102e34a4:	e1a03430 	lsr	r3, r0, r4
102e34a8:	e1833511 	orr	r3, r3, r1, lsl r5
102e34ac:	e1a00431 	lsr	r0, r1, r4
102e34b0:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
102e34b4:	e1c00431 	bic	r0, r0, r1, lsr r4
102e34b8:	e0800fa3 	add	r0, r0, r3, lsr #31
102e34bc:	e19ee083 	orrs	lr, lr, r3, lsl #1
102e34c0:	01c00fa3 	biceq	r0, r0, r3, lsr #31
102e34c4:	e8bd4070 	pop	{r4, r5, r6, lr}
102e34c8:	e12fff1e 	bx	lr
102e34cc:	e3340000 	teq	r4, #0
102e34d0:	1a000008 	bne	102e34f8 <__aeabi_dmul+0x1d8>
102e34d4:	e2016102 	and	r6, r1, #-2147483648	; 0x80000000
102e34d8:	e1b00080 	lsls	r0, r0, #1
102e34dc:	e0a11001 	adc	r1, r1, r1
102e34e0:	e3110601 	tst	r1, #1048576	; 0x100000
102e34e4:	02444001 	subeq	r4, r4, #1
102e34e8:	0afffffa 	beq	102e34d8 <__aeabi_dmul+0x1b8>
102e34ec:	e1811006 	orr	r1, r1, r6
102e34f0:	e3350000 	teq	r5, #0
102e34f4:	112fff1e 	bxne	lr
102e34f8:	e2036102 	and	r6, r3, #-2147483648	; 0x80000000
102e34fc:	e1b02082 	lsls	r2, r2, #1
102e3500:	e0a33003 	adc	r3, r3, r3
102e3504:	e3130601 	tst	r3, #1048576	; 0x100000
102e3508:	02455001 	subeq	r5, r5, #1
102e350c:	0afffffa 	beq	102e34fc <__aeabi_dmul+0x1dc>
102e3510:	e1833006 	orr	r3, r3, r6
102e3514:	e12fff1e 	bx	lr
102e3518:	e134000c 	teq	r4, ip
102e351c:	e00c5a23 	and	r5, ip, r3, lsr #20
102e3520:	1135000c 	teqne	r5, ip
102e3524:	0a000007 	beq	102e3548 <__aeabi_dmul+0x228>
102e3528:	e1906081 	orrs	r6, r0, r1, lsl #1
102e352c:	11926083 	orrsne	r6, r2, r3, lsl #1
102e3530:	1affffe5 	bne	102e34cc <__aeabi_dmul+0x1ac>
102e3534:	e0211003 	eor	r1, r1, r3
102e3538:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
102e353c:	e3a00000 	mov	r0, #0
102e3540:	e8bd4070 	pop	{r4, r5, r6, lr}
102e3544:	e12fff1e 	bx	lr
102e3548:	e1906081 	orrs	r6, r0, r1, lsl #1
102e354c:	01a00002 	moveq	r0, r2
102e3550:	01a01003 	moveq	r1, r3
102e3554:	11926083 	orrsne	r6, r2, r3, lsl #1
102e3558:	0a000010 	beq	102e35a0 <__aeabi_dmul+0x280>
102e355c:	e134000c 	teq	r4, ip
102e3560:	1a000001 	bne	102e356c <__aeabi_dmul+0x24c>
102e3564:	e1906601 	orrs	r6, r0, r1, lsl #12
102e3568:	1a00000c 	bne	102e35a0 <__aeabi_dmul+0x280>
102e356c:	e135000c 	teq	r5, ip
102e3570:	1a000003 	bne	102e3584 <__aeabi_dmul+0x264>
102e3574:	e1926603 	orrs	r6, r2, r3, lsl #12
102e3578:	11a00002 	movne	r0, r2
102e357c:	11a01003 	movne	r1, r3
102e3580:	1a000006 	bne	102e35a0 <__aeabi_dmul+0x280>
102e3584:	e0211003 	eor	r1, r1, r3
102e3588:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
102e358c:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
102e3590:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
102e3594:	e3a00000 	mov	r0, #0
102e3598:	e8bd4070 	pop	{r4, r5, r6, lr}
102e359c:	e12fff1e 	bx	lr
102e35a0:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
102e35a4:	e381173e 	orr	r1, r1, #16252928	; 0xf80000
102e35a8:	e8bd4070 	pop	{r4, r5, r6, lr}
102e35ac:	e12fff1e 	bx	lr

102e35b0 <__aeabi_ddiv>:
102e35b0:	e92d4070 	push	{r4, r5, r6, lr}
102e35b4:	e3a0c0ff 	mov	ip, #255	; 0xff
102e35b8:	e38ccc07 	orr	ip, ip, #1792	; 0x700
102e35bc:	e01c4a21 	ands	r4, ip, r1, lsr #20
102e35c0:	101c5a23 	andsne	r5, ip, r3, lsr #20
102e35c4:	1134000c 	teqne	r4, ip
102e35c8:	1135000c 	teqne	r5, ip
102e35cc:	0b00005e 	bleq	102e374c <__aeabi_ddiv+0x19c>
102e35d0:	e0444005 	sub	r4, r4, r5
102e35d4:	e021e003 	eor	lr, r1, r3
102e35d8:	e1925603 	orrs	r5, r2, r3, lsl #12
102e35dc:	e1a01601 	lsl	r1, r1, #12
102e35e0:	0a00004c 	beq	102e3718 <__aeabi_ddiv+0x168>
102e35e4:	e1a03603 	lsl	r3, r3, #12
102e35e8:	e3a05201 	mov	r5, #268435456	; 0x10000000
102e35ec:	e1853223 	orr	r3, r5, r3, lsr #4
102e35f0:	e1833c22 	orr	r3, r3, r2, lsr #24
102e35f4:	e1a02402 	lsl	r2, r2, #8
102e35f8:	e1855221 	orr	r5, r5, r1, lsr #4
102e35fc:	e1855c20 	orr	r5, r5, r0, lsr #24
102e3600:	e1a06400 	lsl	r6, r0, #8
102e3604:	e20e1102 	and	r1, lr, #-2147483648	; 0x80000000
102e3608:	e1550003 	cmp	r5, r3
102e360c:	01560002 	cmpeq	r6, r2
102e3610:	e2a440fd 	adc	r4, r4, #253	; 0xfd
102e3614:	e2844c03 	add	r4, r4, #768	; 0x300
102e3618:	2a000001 	bcs	102e3624 <__aeabi_ddiv+0x74>
102e361c:	e1b030a3 	lsrs	r3, r3, #1
102e3620:	e1a02062 	rrx	r2, r2
102e3624:	e0566002 	subs	r6, r6, r2
102e3628:	e0c55003 	sbc	r5, r5, r3
102e362c:	e1b030a3 	lsrs	r3, r3, #1
102e3630:	e1a02062 	rrx	r2, r2
102e3634:	e3a00601 	mov	r0, #1048576	; 0x100000
102e3638:	e3a0c702 	mov	ip, #524288	; 0x80000
102e363c:	e056e002 	subs	lr, r6, r2
102e3640:	e0d5e003 	sbcs	lr, r5, r3
102e3644:	20466002 	subcs	r6, r6, r2
102e3648:	21a0500e 	movcs	r5, lr
102e364c:	2180000c 	orrcs	r0, r0, ip
102e3650:	e1b030a3 	lsrs	r3, r3, #1
102e3654:	e1a02062 	rrx	r2, r2
102e3658:	e056e002 	subs	lr, r6, r2
102e365c:	e0d5e003 	sbcs	lr, r5, r3
102e3660:	20466002 	subcs	r6, r6, r2
102e3664:	21a0500e 	movcs	r5, lr
102e3668:	218000ac 	orrcs	r0, r0, ip, lsr #1
102e366c:	e1b030a3 	lsrs	r3, r3, #1
102e3670:	e1a02062 	rrx	r2, r2
102e3674:	e056e002 	subs	lr, r6, r2
102e3678:	e0d5e003 	sbcs	lr, r5, r3
102e367c:	20466002 	subcs	r6, r6, r2
102e3680:	21a0500e 	movcs	r5, lr
102e3684:	2180012c 	orrcs	r0, r0, ip, lsr #2
102e3688:	e1b030a3 	lsrs	r3, r3, #1
102e368c:	e1a02062 	rrx	r2, r2
102e3690:	e056e002 	subs	lr, r6, r2
102e3694:	e0d5e003 	sbcs	lr, r5, r3
102e3698:	20466002 	subcs	r6, r6, r2
102e369c:	21a0500e 	movcs	r5, lr
102e36a0:	218001ac 	orrcs	r0, r0, ip, lsr #3
102e36a4:	e195e006 	orrs	lr, r5, r6
102e36a8:	0a00000d 	beq	102e36e4 <__aeabi_ddiv+0x134>
102e36ac:	e1a05205 	lsl	r5, r5, #4
102e36b0:	e1855e26 	orr	r5, r5, r6, lsr #28
102e36b4:	e1a06206 	lsl	r6, r6, #4
102e36b8:	e1a03183 	lsl	r3, r3, #3
102e36bc:	e1833ea2 	orr	r3, r3, r2, lsr #29
102e36c0:	e1a02182 	lsl	r2, r2, #3
102e36c4:	e1b0c22c 	lsrs	ip, ip, #4
102e36c8:	1affffdb 	bne	102e363c <__aeabi_ddiv+0x8c>
102e36cc:	e3110601 	tst	r1, #1048576	; 0x100000
102e36d0:	1a000006 	bne	102e36f0 <__aeabi_ddiv+0x140>
102e36d4:	e1811000 	orr	r1, r1, r0
102e36d8:	e3a00000 	mov	r0, #0
102e36dc:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
102e36e0:	eaffffd5 	b	102e363c <__aeabi_ddiv+0x8c>
102e36e4:	e3110601 	tst	r1, #1048576	; 0x100000
102e36e8:	01811000 	orreq	r1, r1, r0
102e36ec:	03a00000 	moveq	r0, #0
102e36f0:	e254c0fd 	subs	ip, r4, #253	; 0xfd
102e36f4:	835c0c07 	cmphi	ip, #1792	; 0x700
102e36f8:	8affff43 	bhi	102e340c <__aeabi_dmul+0xec>
102e36fc:	e055c003 	subs	ip, r5, r3
102e3700:	0056c002 	subseq	ip, r6, r2
102e3704:	01b0c0a0 	lsrseq	ip, r0, #1
102e3708:	e2b00000 	adcs	r0, r0, #0
102e370c:	e0a11a04 	adc	r1, r1, r4, lsl #20
102e3710:	e8bd4070 	pop	{r4, r5, r6, lr}
102e3714:	e12fff1e 	bx	lr
102e3718:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
102e371c:	e18e1621 	orr	r1, lr, r1, lsr #12
102e3720:	e09440ac 	adds	r4, r4, ip, lsr #1
102e3724:	c074500c 	rsbsgt	r5, r4, ip
102e3728:	c1811a04 	orrgt	r1, r1, r4, lsl #20
102e372c:	c8bd4070 	popgt	{r4, r5, r6, lr}
102e3730:	c12fff1e 	bxgt	lr
102e3734:	e3811601 	orr	r1, r1, #1048576	; 0x100000
102e3738:	e3a0e000 	mov	lr, #0
102e373c:	e2544001 	subs	r4, r4, #1
102e3740:	eaffff31 	b	102e340c <__aeabi_dmul+0xec>
102e3744:	e185e006 	orr	lr, r5, r6
102e3748:	eaffff2f 	b	102e340c <__aeabi_dmul+0xec>
102e374c:	e00c5a23 	and	r5, ip, r3, lsr #20
102e3750:	e134000c 	teq	r4, ip
102e3754:	0135000c 	teqeq	r5, ip
102e3758:	0affff90 	beq	102e35a0 <__aeabi_dmul+0x280>
102e375c:	e134000c 	teq	r4, ip
102e3760:	1a000006 	bne	102e3780 <__aeabi_ddiv+0x1d0>
102e3764:	e1904601 	orrs	r4, r0, r1, lsl #12
102e3768:	1affff8c 	bne	102e35a0 <__aeabi_dmul+0x280>
102e376c:	e135000c 	teq	r5, ip
102e3770:	1affff83 	bne	102e3584 <__aeabi_dmul+0x264>
102e3774:	e1a00002 	mov	r0, r2
102e3778:	e1a01003 	mov	r1, r3
102e377c:	eaffff87 	b	102e35a0 <__aeabi_dmul+0x280>
102e3780:	e135000c 	teq	r5, ip
102e3784:	1a000004 	bne	102e379c <__aeabi_ddiv+0x1ec>
102e3788:	e1925603 	orrs	r5, r2, r3, lsl #12
102e378c:	0affff68 	beq	102e3534 <__aeabi_dmul+0x214>
102e3790:	e1a00002 	mov	r0, r2
102e3794:	e1a01003 	mov	r1, r3
102e3798:	eaffff80 	b	102e35a0 <__aeabi_dmul+0x280>
102e379c:	e1906081 	orrs	r6, r0, r1, lsl #1
102e37a0:	11926083 	orrsne	r6, r2, r3, lsl #1
102e37a4:	1affff48 	bne	102e34cc <__aeabi_dmul+0x1ac>
102e37a8:	e1904081 	orrs	r4, r0, r1, lsl #1
102e37ac:	1affff74 	bne	102e3584 <__aeabi_dmul+0x264>
102e37b0:	e1925083 	orrs	r5, r2, r3, lsl #1
102e37b4:	1affff5e 	bne	102e3534 <__aeabi_dmul+0x214>
102e37b8:	eaffff78 	b	102e35a0 <__aeabi_dmul+0x280>

102e37bc <__gedf2>:
102e37bc:	e3e0c000 	mvn	ip, #0
102e37c0:	ea000002 	b	102e37d0 <__cmpdf2+0x4>

102e37c4 <__ledf2>:
102e37c4:	e3a0c001 	mov	ip, #1
102e37c8:	ea000000 	b	102e37d0 <__cmpdf2+0x4>

102e37cc <__cmpdf2>:
102e37cc:	e3a0c001 	mov	ip, #1
102e37d0:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
102e37d4:	e1a0c081 	lsl	ip, r1, #1
102e37d8:	e1f0cacc 	mvns	ip, ip, asr #21
102e37dc:	e1a0c083 	lsl	ip, r3, #1
102e37e0:	11f0cacc 	mvnsne	ip, ip, asr #21
102e37e4:	0a00000e 	beq	102e3824 <__cmpdf2+0x58>
102e37e8:	e28dd004 	add	sp, sp, #4
102e37ec:	e190c081 	orrs	ip, r0, r1, lsl #1
102e37f0:	0192c083 	orrseq	ip, r2, r3, lsl #1
102e37f4:	11310003 	teqne	r1, r3
102e37f8:	01300002 	teqeq	r0, r2
102e37fc:	03a00000 	moveq	r0, #0
102e3800:	012fff1e 	bxeq	lr
102e3804:	e3700000 	cmn	r0, #0
102e3808:	e1310003 	teq	r1, r3
102e380c:	51510003 	cmppl	r1, r3
102e3810:	01500002 	cmpeq	r0, r2
102e3814:	21a00fc3 	asrcs	r0, r3, #31
102e3818:	31e00fc3 	mvncc	r0, r3, asr #31
102e381c:	e3800001 	orr	r0, r0, #1
102e3820:	e12fff1e 	bx	lr
102e3824:	e1a0c081 	lsl	ip, r1, #1
102e3828:	e1f0cacc 	mvns	ip, ip, asr #21
102e382c:	1a000001 	bne	102e3838 <__cmpdf2+0x6c>
102e3830:	e190c601 	orrs	ip, r0, r1, lsl #12
102e3834:	1a000004 	bne	102e384c <__cmpdf2+0x80>
102e3838:	e1a0c083 	lsl	ip, r3, #1
102e383c:	e1f0cacc 	mvns	ip, ip, asr #21
102e3840:	1affffe8 	bne	102e37e8 <__cmpdf2+0x1c>
102e3844:	e192c603 	orrs	ip, r2, r3, lsl #12
102e3848:	0affffe6 	beq	102e37e8 <__cmpdf2+0x1c>
102e384c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
102e3850:	e12fff1e 	bx	lr

102e3854 <__aeabi_cdrcmple>:
102e3854:	e1a0c000 	mov	ip, r0
102e3858:	e1a00002 	mov	r0, r2
102e385c:	e1a0200c 	mov	r2, ip
102e3860:	e1a0c001 	mov	ip, r1
102e3864:	e1a01003 	mov	r1, r3
102e3868:	e1a0300c 	mov	r3, ip
102e386c:	eaffffff 	b	102e3870 <__aeabi_cdcmpeq>

102e3870 <__aeabi_cdcmpeq>:
102e3870:	e92d4001 	push	{r0, lr}
102e3874:	ebffffd4 	bl	102e37cc <__cmpdf2>
102e3878:	e3500000 	cmp	r0, #0
102e387c:	43700000 	cmnmi	r0, #0
102e3880:	e8bd4001 	pop	{r0, lr}
102e3884:	e12fff1e 	bx	lr

102e3888 <__aeabi_dcmpeq>:
102e3888:	e52de008 	str	lr, [sp, #-8]!
102e388c:	ebfffff7 	bl	102e3870 <__aeabi_cdcmpeq>
102e3890:	03a00001 	moveq	r0, #1
102e3894:	13a00000 	movne	r0, #0
102e3898:	e49de008 	ldr	lr, [sp], #8
102e389c:	e12fff1e 	bx	lr

102e38a0 <__aeabi_dcmplt>:
102e38a0:	e52de008 	str	lr, [sp, #-8]!
102e38a4:	ebfffff1 	bl	102e3870 <__aeabi_cdcmpeq>
102e38a8:	33a00001 	movcc	r0, #1
102e38ac:	23a00000 	movcs	r0, #0
102e38b0:	e49de008 	ldr	lr, [sp], #8
102e38b4:	e12fff1e 	bx	lr

102e38b8 <__aeabi_dcmple>:
102e38b8:	e52de008 	str	lr, [sp, #-8]!
102e38bc:	ebffffeb 	bl	102e3870 <__aeabi_cdcmpeq>
102e38c0:	93a00001 	movls	r0, #1
102e38c4:	83a00000 	movhi	r0, #0
102e38c8:	e49de008 	ldr	lr, [sp], #8
102e38cc:	e12fff1e 	bx	lr

102e38d0 <__aeabi_dcmpge>:
102e38d0:	e52de008 	str	lr, [sp, #-8]!
102e38d4:	ebffffde 	bl	102e3854 <__aeabi_cdrcmple>
102e38d8:	93a00001 	movls	r0, #1
102e38dc:	83a00000 	movhi	r0, #0
102e38e0:	e49de008 	ldr	lr, [sp], #8
102e38e4:	e12fff1e 	bx	lr

102e38e8 <__aeabi_dcmpgt>:
102e38e8:	e52de008 	str	lr, [sp, #-8]!
102e38ec:	ebffffd8 	bl	102e3854 <__aeabi_cdrcmple>
102e38f0:	33a00001 	movcc	r0, #1
102e38f4:	23a00000 	movcs	r0, #0
102e38f8:	e49de008 	ldr	lr, [sp], #8
102e38fc:	e12fff1e 	bx	lr

102e3900 <__aeabi_d2iz>:
102e3900:	e1a02081 	lsl	r2, r1, #1
102e3904:	e2922602 	adds	r2, r2, #2097152	; 0x200000
102e3908:	2a00000c 	bcs	102e3940 <__aeabi_d2iz+0x40>
102e390c:	5a000009 	bpl	102e3938 <__aeabi_d2iz+0x38>
102e3910:	e3e03e3e 	mvn	r3, #992	; 0x3e0
102e3914:	e0532ac2 	subs	r2, r3, r2, asr #21
102e3918:	9a00000a 	bls	102e3948 <__aeabi_d2iz+0x48>
102e391c:	e1a03581 	lsl	r3, r1, #11
102e3920:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
102e3924:	e1833aa0 	orr	r3, r3, r0, lsr #21
102e3928:	e3110102 	tst	r1, #-2147483648	; 0x80000000
102e392c:	e1a00233 	lsr	r0, r3, r2
102e3930:	12600000 	rsbne	r0, r0, #0
102e3934:	e12fff1e 	bx	lr
102e3938:	e3a00000 	mov	r0, #0
102e393c:	e12fff1e 	bx	lr
102e3940:	e1900601 	orrs	r0, r0, r1, lsl #12
102e3944:	1a000002 	bne	102e3954 <__aeabi_d2iz+0x54>
102e3948:	e2110102 	ands	r0, r1, #-2147483648	; 0x80000000
102e394c:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
102e3950:	e12fff1e 	bx	lr
102e3954:	e3a00000 	mov	r0, #0
102e3958:	e12fff1e 	bx	lr

102e395c <__aeabi_d2uiz>:
102e395c:	e1b02081 	lsls	r2, r1, #1
102e3960:	2a00000a 	bcs	102e3990 <__aeabi_d2uiz+0x34>
102e3964:	e2922602 	adds	r2, r2, #2097152	; 0x200000
102e3968:	2a00000a 	bcs	102e3998 <__aeabi_d2uiz+0x3c>
102e396c:	5a000007 	bpl	102e3990 <__aeabi_d2uiz+0x34>
102e3970:	e3e03e3e 	mvn	r3, #992	; 0x3e0
102e3974:	e0532ac2 	subs	r2, r3, r2, asr #21
102e3978:	4a000008 	bmi	102e39a0 <__aeabi_d2uiz+0x44>
102e397c:	e1a03581 	lsl	r3, r1, #11
102e3980:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
102e3984:	e1833aa0 	orr	r3, r3, r0, lsr #21
102e3988:	e1a00233 	lsr	r0, r3, r2
102e398c:	e12fff1e 	bx	lr
102e3990:	e3a00000 	mov	r0, #0
102e3994:	e12fff1e 	bx	lr
102e3998:	e1900601 	orrs	r0, r0, r1, lsl #12
102e399c:	1a000001 	bne	102e39a8 <__aeabi_d2uiz+0x4c>
102e39a0:	e3e00000 	mvn	r0, #0
102e39a4:	e12fff1e 	bx	lr
102e39a8:	e3a00000 	mov	r0, #0
102e39ac:	e12fff1e 	bx	lr

102e39b0 <__aeabi_d2f>:
102e39b0:	e1a02081 	lsl	r2, r1, #1
102e39b4:	e2523207 	subs	r3, r2, #1879048192	; 0x70000000
102e39b8:	2253c602 	subscs	ip, r3, #2097152	; 0x200000
102e39bc:	227cc57f 	rsbscs	ip, ip, #532676608	; 0x1fc00000
102e39c0:	9a000006 	bls	102e39e0 <__aeabi_d2f+0x30>
102e39c4:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
102e39c8:	e1a02180 	lsl	r2, r0, #3
102e39cc:	e18c0ea0 	orr	r0, ip, r0, lsr #29
102e39d0:	e3520102 	cmp	r2, #-2147483648	; 0x80000000
102e39d4:	e0a00103 	adc	r0, r0, r3, lsl #2
102e39d8:	03c00001 	biceq	r0, r0, #1
102e39dc:	e12fff1e 	bx	lr
102e39e0:	e3110101 	tst	r1, #1073741824	; 0x40000000
102e39e4:	1a00000f 	bne	102e3a28 <__aeabi_d2f+0x78>
102e39e8:	e293262e 	adds	r2, r3, #48234496	; 0x2e00000
102e39ec:	b2010102 	andlt	r0, r1, #-2147483648	; 0x80000000
102e39f0:	b12fff1e 	bxlt	lr
102e39f4:	e3811601 	orr	r1, r1, #1048576	; 0x100000
102e39f8:	e1a02aa2 	lsr	r2, r2, #21
102e39fc:	e2622018 	rsb	r2, r2, #24
102e3a00:	e262c020 	rsb	ip, r2, #32
102e3a04:	e1b03c10 	lsls	r3, r0, ip
102e3a08:	e1a00230 	lsr	r0, r0, r2
102e3a0c:	13800001 	orrne	r0, r0, #1
102e3a10:	e1a03581 	lsl	r3, r1, #11
102e3a14:	e1a035a3 	lsr	r3, r3, #11
102e3a18:	e1800c13 	orr	r0, r0, r3, lsl ip
102e3a1c:	e1a03233 	lsr	r3, r3, r2
102e3a20:	e1a03083 	lsl	r3, r3, #1
102e3a24:	eaffffe6 	b	102e39c4 <__aeabi_d2f+0x14>
102e3a28:	e1f03ac2 	mvns	r3, r2, asr #21
102e3a2c:	1a000003 	bne	102e3a40 <__aeabi_d2f+0x90>
102e3a30:	e1903601 	orrs	r3, r0, r1, lsl #12
102e3a34:	13a0047f 	movne	r0, #2130706432	; 0x7f000000
102e3a38:	13800503 	orrne	r0, r0, #12582912	; 0xc00000
102e3a3c:	112fff1e 	bxne	lr
102e3a40:	e2010102 	and	r0, r1, #-2147483648	; 0x80000000
102e3a44:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
102e3a48:	e3800502 	orr	r0, r0, #8388608	; 0x800000
102e3a4c:	e12fff1e 	bx	lr

102e3a50 <__aeabi_fmul>:
102e3a50:	e3a0c0ff 	mov	ip, #255	; 0xff
102e3a54:	e01c2ba0 	ands	r2, ip, r0, lsr #23
102e3a58:	101c3ba1 	andsne	r3, ip, r1, lsr #23
102e3a5c:	1132000c 	teqne	r2, ip
102e3a60:	1133000c 	teqne	r3, ip
102e3a64:	0a00003e 	beq	102e3b64 <__aeabi_fmul+0x114>
102e3a68:	e0822003 	add	r2, r2, r3
102e3a6c:	e020c001 	eor	ip, r0, r1
102e3a70:	e1b00480 	lsls	r0, r0, #9
102e3a74:	11b01481 	lslsne	r1, r1, #9
102e3a78:	0a000010 	beq	102e3ac0 <__aeabi_fmul+0x70>
102e3a7c:	e3a03302 	mov	r3, #134217728	; 0x8000000
102e3a80:	e18302a0 	orr	r0, r3, r0, lsr #5
102e3a84:	e18312a1 	orr	r1, r3, r1, lsr #5
102e3a88:	e0813190 	umull	r3, r1, r0, r1
102e3a8c:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
102e3a90:	e3510502 	cmp	r1, #8388608	; 0x800000
102e3a94:	31a01081 	lslcc	r1, r1, #1
102e3a98:	31811fa3 	orrcc	r1, r1, r3, lsr #31
102e3a9c:	31a03083 	lslcc	r3, r3, #1
102e3aa0:	e1800001 	orr	r0, r0, r1
102e3aa4:	e2c2207f 	sbc	r2, r2, #127	; 0x7f
102e3aa8:	e35200fd 	cmp	r2, #253	; 0xfd
102e3aac:	8a00000f 	bhi	102e3af0 <__aeabi_fmul+0xa0>
102e3ab0:	e3530102 	cmp	r3, #-2147483648	; 0x80000000
102e3ab4:	e0a00b82 	adc	r0, r0, r2, lsl #23
102e3ab8:	03c00001 	biceq	r0, r0, #1
102e3abc:	e12fff1e 	bx	lr
102e3ac0:	e3300000 	teq	r0, #0
102e3ac4:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
102e3ac8:	01a01481 	lsleq	r1, r1, #9
102e3acc:	e18c04a0 	orr	r0, ip, r0, lsr #9
102e3ad0:	e18004a1 	orr	r0, r0, r1, lsr #9
102e3ad4:	e252207f 	subs	r2, r2, #127	; 0x7f
102e3ad8:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
102e3adc:	c1800b82 	orrgt	r0, r0, r2, lsl #23
102e3ae0:	c12fff1e 	bxgt	lr
102e3ae4:	e3800502 	orr	r0, r0, #8388608	; 0x800000
102e3ae8:	e3a03000 	mov	r3, #0
102e3aec:	e2522001 	subs	r2, r2, #1
102e3af0:	ca000035 	bgt	102e3bcc <__aeabi_fmul+0x17c>
102e3af4:	e3720019 	cmn	r2, #25
102e3af8:	d2000102 	andle	r0, r0, #-2147483648	; 0x80000000
102e3afc:	d12fff1e 	bxle	lr
102e3b00:	e2622000 	rsb	r2, r2, #0
102e3b04:	e1b01080 	lsls	r1, r0, #1
102e3b08:	e1a01231 	lsr	r1, r1, r2
102e3b0c:	e2622020 	rsb	r2, r2, #32
102e3b10:	e1a0c210 	lsl	ip, r0, r2
102e3b14:	e1b00061 	rrxs	r0, r1
102e3b18:	e2a00000 	adc	r0, r0, #0
102e3b1c:	e193308c 	orrs	r3, r3, ip, lsl #1
102e3b20:	01c00fac 	biceq	r0, r0, ip, lsr #31
102e3b24:	e12fff1e 	bx	lr
102e3b28:	e3320000 	teq	r2, #0
102e3b2c:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
102e3b30:	01a00080 	lsleq	r0, r0, #1
102e3b34:	03100502 	tsteq	r0, #8388608	; 0x800000
102e3b38:	02422001 	subeq	r2, r2, #1
102e3b3c:	0afffffb 	beq	102e3b30 <__aeabi_fmul+0xe0>
102e3b40:	e180000c 	orr	r0, r0, ip
102e3b44:	e3330000 	teq	r3, #0
102e3b48:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
102e3b4c:	01a01081 	lsleq	r1, r1, #1
102e3b50:	03110502 	tsteq	r1, #8388608	; 0x800000
102e3b54:	02433001 	subeq	r3, r3, #1
102e3b58:	0afffffb 	beq	102e3b4c <__aeabi_fmul+0xfc>
102e3b5c:	e181100c 	orr	r1, r1, ip
102e3b60:	eaffffc0 	b	102e3a68 <__aeabi_fmul+0x18>
102e3b64:	e00c3ba1 	and	r3, ip, r1, lsr #23
102e3b68:	e132000c 	teq	r2, ip
102e3b6c:	1133000c 	teqne	r3, ip
102e3b70:	0a000005 	beq	102e3b8c <__aeabi_fmul+0x13c>
102e3b74:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
102e3b78:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
102e3b7c:	1affffe9 	bne	102e3b28 <__aeabi_fmul+0xd8>
102e3b80:	e0200001 	eor	r0, r0, r1
102e3b84:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
102e3b88:	e12fff1e 	bx	lr
102e3b8c:	e3300000 	teq	r0, #0
102e3b90:	13300102 	teqne	r0, #-2147483648	; 0x80000000
102e3b94:	01a00001 	moveq	r0, r1
102e3b98:	13310000 	teqne	r1, #0
102e3b9c:	13310102 	teqne	r1, #-2147483648	; 0x80000000
102e3ba0:	0a00000d 	beq	102e3bdc <__aeabi_fmul+0x18c>
102e3ba4:	e132000c 	teq	r2, ip
102e3ba8:	1a000001 	bne	102e3bb4 <__aeabi_fmul+0x164>
102e3bac:	e1b02480 	lsls	r2, r0, #9
102e3bb0:	1a000009 	bne	102e3bdc <__aeabi_fmul+0x18c>
102e3bb4:	e133000c 	teq	r3, ip
102e3bb8:	1a000002 	bne	102e3bc8 <__aeabi_fmul+0x178>
102e3bbc:	e1b03481 	lsls	r3, r1, #9
102e3bc0:	11a00001 	movne	r0, r1
102e3bc4:	1a000004 	bne	102e3bdc <__aeabi_fmul+0x18c>
102e3bc8:	e0200001 	eor	r0, r0, r1
102e3bcc:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
102e3bd0:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
102e3bd4:	e3800502 	orr	r0, r0, #8388608	; 0x800000
102e3bd8:	e12fff1e 	bx	lr
102e3bdc:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
102e3be0:	e3800503 	orr	r0, r0, #12582912	; 0xc00000
102e3be4:	e12fff1e 	bx	lr

102e3be8 <__aeabi_fdiv>:
102e3be8:	e3a0c0ff 	mov	ip, #255	; 0xff
102e3bec:	e01c2ba0 	ands	r2, ip, r0, lsr #23
102e3bf0:	101c3ba1 	andsne	r3, ip, r1, lsr #23
102e3bf4:	1132000c 	teqne	r2, ip
102e3bf8:	1133000c 	teqne	r3, ip
102e3bfc:	0a00003a 	beq	102e3cec <__aeabi_fdiv+0x104>
102e3c00:	e0422003 	sub	r2, r2, r3
102e3c04:	e020c001 	eor	ip, r0, r1
102e3c08:	e1b01481 	lsls	r1, r1, #9
102e3c0c:	e1a00480 	lsl	r0, r0, #9
102e3c10:	0a00001c 	beq	102e3c88 <__aeabi_fdiv+0xa0>
102e3c14:	e3a03201 	mov	r3, #268435456	; 0x10000000
102e3c18:	e1831221 	orr	r1, r3, r1, lsr #4
102e3c1c:	e1833220 	orr	r3, r3, r0, lsr #4
102e3c20:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
102e3c24:	e1530001 	cmp	r3, r1
102e3c28:	31a03083 	lslcc	r3, r3, #1
102e3c2c:	e2a2207d 	adc	r2, r2, #125	; 0x7d
102e3c30:	e3a0c502 	mov	ip, #8388608	; 0x800000
102e3c34:	e1530001 	cmp	r3, r1
102e3c38:	20433001 	subcs	r3, r3, r1
102e3c3c:	2180000c 	orrcs	r0, r0, ip
102e3c40:	e15300a1 	cmp	r3, r1, lsr #1
102e3c44:	204330a1 	subcs	r3, r3, r1, lsr #1
102e3c48:	218000ac 	orrcs	r0, r0, ip, lsr #1
102e3c4c:	e1530121 	cmp	r3, r1, lsr #2
102e3c50:	20433121 	subcs	r3, r3, r1, lsr #2
102e3c54:	2180012c 	orrcs	r0, r0, ip, lsr #2
102e3c58:	e15301a1 	cmp	r3, r1, lsr #3
102e3c5c:	204331a1 	subcs	r3, r3, r1, lsr #3
102e3c60:	218001ac 	orrcs	r0, r0, ip, lsr #3
102e3c64:	e1b03203 	lsls	r3, r3, #4
102e3c68:	11b0c22c 	lsrsne	ip, ip, #4
102e3c6c:	1afffff0 	bne	102e3c34 <__aeabi_fdiv+0x4c>
102e3c70:	e35200fd 	cmp	r2, #253	; 0xfd
102e3c74:	8affff9d 	bhi	102e3af0 <__aeabi_fmul+0xa0>
102e3c78:	e1530001 	cmp	r3, r1
102e3c7c:	e0a00b82 	adc	r0, r0, r2, lsl #23
102e3c80:	03c00001 	biceq	r0, r0, #1
102e3c84:	e12fff1e 	bx	lr
102e3c88:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
102e3c8c:	e18c04a0 	orr	r0, ip, r0, lsr #9
102e3c90:	e292207f 	adds	r2, r2, #127	; 0x7f
102e3c94:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
102e3c98:	c1800b82 	orrgt	r0, r0, r2, lsl #23
102e3c9c:	c12fff1e 	bxgt	lr
102e3ca0:	e3800502 	orr	r0, r0, #8388608	; 0x800000
102e3ca4:	e3a03000 	mov	r3, #0
102e3ca8:	e2522001 	subs	r2, r2, #1
102e3cac:	eaffff8f 	b	102e3af0 <__aeabi_fmul+0xa0>
102e3cb0:	e3320000 	teq	r2, #0
102e3cb4:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
102e3cb8:	01a00080 	lsleq	r0, r0, #1
102e3cbc:	03100502 	tsteq	r0, #8388608	; 0x800000
102e3cc0:	02422001 	subeq	r2, r2, #1
102e3cc4:	0afffffb 	beq	102e3cb8 <__aeabi_fdiv+0xd0>
102e3cc8:	e180000c 	orr	r0, r0, ip
102e3ccc:	e3330000 	teq	r3, #0
102e3cd0:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
102e3cd4:	01a01081 	lsleq	r1, r1, #1
102e3cd8:	03110502 	tsteq	r1, #8388608	; 0x800000
102e3cdc:	02433001 	subeq	r3, r3, #1
102e3ce0:	0afffffb 	beq	102e3cd4 <__aeabi_fdiv+0xec>
102e3ce4:	e181100c 	orr	r1, r1, ip
102e3ce8:	eaffffc4 	b	102e3c00 <__aeabi_fdiv+0x18>
102e3cec:	e00c3ba1 	and	r3, ip, r1, lsr #23
102e3cf0:	e132000c 	teq	r2, ip
102e3cf4:	1a000005 	bne	102e3d10 <__aeabi_fdiv+0x128>
102e3cf8:	e1b02480 	lsls	r2, r0, #9
102e3cfc:	1affffb6 	bne	102e3bdc <__aeabi_fmul+0x18c>
102e3d00:	e133000c 	teq	r3, ip
102e3d04:	1affffaf 	bne	102e3bc8 <__aeabi_fmul+0x178>
102e3d08:	e1a00001 	mov	r0, r1
102e3d0c:	eaffffb2 	b	102e3bdc <__aeabi_fmul+0x18c>
102e3d10:	e133000c 	teq	r3, ip
102e3d14:	1a000003 	bne	102e3d28 <__aeabi_fdiv+0x140>
102e3d18:	e1b03481 	lsls	r3, r1, #9
102e3d1c:	0affff97 	beq	102e3b80 <__aeabi_fmul+0x130>
102e3d20:	e1a00001 	mov	r0, r1
102e3d24:	eaffffac 	b	102e3bdc <__aeabi_fmul+0x18c>
102e3d28:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
102e3d2c:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
102e3d30:	1affffde 	bne	102e3cb0 <__aeabi_fdiv+0xc8>
102e3d34:	e3d02102 	bics	r2, r0, #-2147483648	; 0x80000000
102e3d38:	1affffa2 	bne	102e3bc8 <__aeabi_fmul+0x178>
102e3d3c:	e3d13102 	bics	r3, r1, #-2147483648	; 0x80000000
102e3d40:	1affff8e 	bne	102e3b80 <__aeabi_fmul+0x130>
102e3d44:	eaffffa4 	b	102e3bdc <__aeabi_fmul+0x18c>

102e3d48 <__gesf2>:
102e3d48:	e3e0c000 	mvn	ip, #0
102e3d4c:	ea000002 	b	102e3d5c <__cmpsf2+0x4>

102e3d50 <__lesf2>:
102e3d50:	e3a0c001 	mov	ip, #1
102e3d54:	ea000000 	b	102e3d5c <__cmpsf2+0x4>

102e3d58 <__cmpsf2>:
102e3d58:	e3a0c001 	mov	ip, #1
102e3d5c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
102e3d60:	e1a02080 	lsl	r2, r0, #1
102e3d64:	e1a03081 	lsl	r3, r1, #1
102e3d68:	e1f0cc42 	mvns	ip, r2, asr #24
102e3d6c:	11f0cc43 	mvnsne	ip, r3, asr #24
102e3d70:	0a000007 	beq	102e3d94 <__cmpsf2+0x3c>
102e3d74:	e28dd004 	add	sp, sp, #4
102e3d78:	e192c0a3 	orrs	ip, r2, r3, lsr #1
102e3d7c:	11300001 	teqne	r0, r1
102e3d80:	50520003 	subspl	r0, r2, r3
102e3d84:	81a00fc1 	asrhi	r0, r1, #31
102e3d88:	31e00fc1 	mvncc	r0, r1, asr #31
102e3d8c:	13800001 	orrne	r0, r0, #1
102e3d90:	e12fff1e 	bx	lr
102e3d94:	e1f0cc42 	mvns	ip, r2, asr #24
102e3d98:	1a000001 	bne	102e3da4 <__cmpsf2+0x4c>
102e3d9c:	e1b0c480 	lsls	ip, r0, #9
102e3da0:	1a000003 	bne	102e3db4 <__cmpsf2+0x5c>
102e3da4:	e1f0cc43 	mvns	ip, r3, asr #24
102e3da8:	1afffff1 	bne	102e3d74 <__cmpsf2+0x1c>
102e3dac:	e1b0c481 	lsls	ip, r1, #9
102e3db0:	0affffef 	beq	102e3d74 <__cmpsf2+0x1c>
102e3db4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
102e3db8:	e12fff1e 	bx	lr

102e3dbc <__aeabi_cfrcmple>:
102e3dbc:	e1a0c000 	mov	ip, r0
102e3dc0:	e1a00001 	mov	r0, r1
102e3dc4:	e1a0100c 	mov	r1, ip
102e3dc8:	eaffffff 	b	102e3dcc <__aeabi_cfcmpeq>

102e3dcc <__aeabi_cfcmpeq>:
102e3dcc:	e92d400f 	push	{r0, r1, r2, r3, lr}
102e3dd0:	ebffffe0 	bl	102e3d58 <__cmpsf2>
102e3dd4:	e3500000 	cmp	r0, #0
102e3dd8:	43700000 	cmnmi	r0, #0
102e3ddc:	e8bd400f 	pop	{r0, r1, r2, r3, lr}
102e3de0:	e12fff1e 	bx	lr

102e3de4 <__aeabi_fcmpeq>:
102e3de4:	e52de008 	str	lr, [sp, #-8]!
102e3de8:	ebfffff7 	bl	102e3dcc <__aeabi_cfcmpeq>
102e3dec:	03a00001 	moveq	r0, #1
102e3df0:	13a00000 	movne	r0, #0
102e3df4:	e49de008 	ldr	lr, [sp], #8
102e3df8:	e12fff1e 	bx	lr

102e3dfc <__aeabi_fcmplt>:
102e3dfc:	e52de008 	str	lr, [sp, #-8]!
102e3e00:	ebfffff1 	bl	102e3dcc <__aeabi_cfcmpeq>
102e3e04:	33a00001 	movcc	r0, #1
102e3e08:	23a00000 	movcs	r0, #0
102e3e0c:	e49de008 	ldr	lr, [sp], #8
102e3e10:	e12fff1e 	bx	lr

102e3e14 <__aeabi_fcmple>:
102e3e14:	e52de008 	str	lr, [sp, #-8]!
102e3e18:	ebffffeb 	bl	102e3dcc <__aeabi_cfcmpeq>
102e3e1c:	93a00001 	movls	r0, #1
102e3e20:	83a00000 	movhi	r0, #0
102e3e24:	e49de008 	ldr	lr, [sp], #8
102e3e28:	e12fff1e 	bx	lr

102e3e2c <__aeabi_fcmpge>:
102e3e2c:	e52de008 	str	lr, [sp, #-8]!
102e3e30:	ebffffe1 	bl	102e3dbc <__aeabi_cfrcmple>
102e3e34:	93a00001 	movls	r0, #1
102e3e38:	83a00000 	movhi	r0, #0
102e3e3c:	e49de008 	ldr	lr, [sp], #8
102e3e40:	e12fff1e 	bx	lr

102e3e44 <__aeabi_fcmpgt>:
102e3e44:	e52de008 	str	lr, [sp, #-8]!
102e3e48:	ebffffdb 	bl	102e3dbc <__aeabi_cfrcmple>
102e3e4c:	33a00001 	movcc	r0, #1
102e3e50:	23a00000 	movcs	r0, #0
102e3e54:	e49de008 	ldr	lr, [sp], #8
102e3e58:	e12fff1e 	bx	lr

102e3e5c <__aeabi_f2uiz>:
102e3e5c:	e1b02080 	lsls	r2, r0, #1
102e3e60:	2a000008 	bcs	102e3e88 <__aeabi_f2uiz+0x2c>
102e3e64:	e352047f 	cmp	r2, #2130706432	; 0x7f000000
102e3e68:	3a000006 	bcc	102e3e88 <__aeabi_f2uiz+0x2c>
102e3e6c:	e3a0309e 	mov	r3, #158	; 0x9e
102e3e70:	e0532c22 	subs	r2, r3, r2, lsr #24
102e3e74:	4a000005 	bmi	102e3e90 <__aeabi_f2uiz+0x34>
102e3e78:	e1a03400 	lsl	r3, r0, #8
102e3e7c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
102e3e80:	e1a00233 	lsr	r0, r3, r2
102e3e84:	e12fff1e 	bx	lr
102e3e88:	e3a00000 	mov	r0, #0
102e3e8c:	e12fff1e 	bx	lr
102e3e90:	e3720061 	cmn	r2, #97	; 0x61
102e3e94:	1a000001 	bne	102e3ea0 <__aeabi_f2uiz+0x44>
102e3e98:	e1b02480 	lsls	r2, r0, #9
102e3e9c:	1a000001 	bne	102e3ea8 <__aeabi_f2uiz+0x4c>
102e3ea0:	e3e00000 	mvn	r0, #0
102e3ea4:	e12fff1e 	bx	lr
102e3ea8:	e3a00000 	mov	r0, #0
102e3eac:	e12fff1e 	bx	lr

102e3eb0 <____aeabi_idiv_from_thumb>:
102e3eb0:	4778      	bx	pc
102e3eb2:	46c0      	nop			; (mov r8, r8)
102e3eb4:	eafffbbd 	b	102e2db0 <__aeabi_idiv>

102e3eb8 <____aeabi_idiv0_from_arm>:
102e3eb8:	e59fc000 	ldr	ip, [pc]	; 102e3ec0 <____aeabi_idiv0_from_arm+0x8>
102e3ebc:	e12fff1c 	bx	ip
102e3ec0:	102e2f01 	.word	0x102e2f01

102e3ec4 <____aeabi_fcmpgt_from_thumb>:
102e3ec4:	4778      	bx	pc
102e3ec6:	46c0      	nop			; (mov r8, r8)
102e3ec8:	eaffffdd 	b	102e3e44 <__aeabi_fcmpgt>

102e3ecc <____aeabi_dcmpgt_from_thumb>:
102e3ecc:	4778      	bx	pc
102e3ece:	46c0      	nop			; (mov r8, r8)
102e3ed0:	eafffe84 	b	102e38e8 <__aeabi_dcmpgt>

102e3ed4 <____aeabi_fcmpeq_from_thumb>:
102e3ed4:	4778      	bx	pc
102e3ed6:	46c0      	nop			; (mov r8, r8)
102e3ed8:	eaffffc1 	b	102e3de4 <__aeabi_fcmpeq>

102e3edc <____aeabi_dsub_from_thumb>:
102e3edc:	4778      	bx	pc
102e3ede:	46c0      	nop			; (mov r8, r8)
102e3ee0:	eafffc09 	b	102e2f0c <__aeabi_dsub>

102e3ee4 <____aeabi_dcmple_from_thumb>:
102e3ee4:	4778      	bx	pc
102e3ee6:	46c0      	nop			; (mov r8, r8)
102e3ee8:	eafffe72 	b	102e38b8 <__aeabi_dcmple>

102e3eec <____aeabi_ddiv_from_thumb>:
102e3eec:	4778      	bx	pc
102e3eee:	46c0      	nop			; (mov r8, r8)
102e3ef0:	eafffdae 	b	102e35b0 <__aeabi_ddiv>

102e3ef4 <____aeabi_dcmplt_from_thumb>:
102e3ef4:	4778      	bx	pc
102e3ef6:	46c0      	nop			; (mov r8, r8)
102e3ef8:	eafffe68 	b	102e38a0 <__aeabi_dcmplt>

102e3efc <____aeabi_uidivmod_from_thumb>:
102e3efc:	4778      	bx	pc
102e3efe:	46c0      	nop			; (mov r8, r8)
102e3f00:	eafffba2 	b	102e2d90 <__aeabi_uidivmod>

102e3f04 <____aeabi_d2f_from_thumb>:
102e3f04:	4778      	bx	pc
102e3f06:	46c0      	nop			; (mov r8, r8)
102e3f08:	eafffea8 	b	102e39b0 <__aeabi_d2f>

102e3f0c <____aeabi_fcmplt_from_thumb>:
102e3f0c:	4778      	bx	pc
102e3f0e:	46c0      	nop			; (mov r8, r8)
102e3f10:	eaffffb9 	b	102e3dfc <__aeabi_fcmplt>

102e3f14 <____aeabi_uidiv_from_thumb>:
102e3f14:	4778      	bx	pc
102e3f16:	46c0      	nop			; (mov r8, r8)
102e3f18:	eafffb5d 	b	102e2c94 <__aeabi_uidiv>

102e3f1c <____aeabi_d2uiz_from_thumb>:
102e3f1c:	4778      	bx	pc
102e3f1e:	46c0      	nop			; (mov r8, r8)
102e3f20:	eafffe8d 	b	102e395c <__aeabi_d2uiz>

102e3f24 <___sbrk_from_thumb>:
102e3f24:	4778      	bx	pc
102e3f26:	46c0      	nop			; (mov r8, r8)
102e3f28:	eaffc751 	b	102d5c74 <_sbrk>

102e3f2c <____aeabi_i2d_from_thumb>:
102e3f2c:	4778      	bx	pc
102e3f2e:	46c0      	nop			; (mov r8, r8)
102e3f30:	eafffcc3 	b	102e3244 <__aeabi_i2d>

102e3f34 <____aeabi_dadd_from_thumb>:
102e3f34:	4778      	bx	pc
102e3f36:	46c0      	nop			; (mov r8, r8)
102e3f38:	eafffbf4 	b	102e2f10 <__adddf3>

102e3f3c <____aeabi_ui2d_from_thumb>:
102e3f3c:	4778      	bx	pc
102e3f3e:	46c0      	nop			; (mov r8, r8)
102e3f40:	eafffcb6 	b	102e3220 <__aeabi_ui2d>

102e3f44 <____aeabi_dmul_from_thumb>:
102e3f44:	4778      	bx	pc
102e3f46:	46c0      	nop			; (mov r8, r8)
102e3f48:	eafffcf4 	b	102e3320 <__aeabi_dmul>

102e3f4c <____aeabi_dcmpeq_from_thumb>:
102e3f4c:	4778      	bx	pc
102e3f4e:	46c0      	nop			; (mov r8, r8)
102e3f50:	eafffe4c 	b	102e3888 <__aeabi_dcmpeq>

102e3f54 <____aeabi_d2iz_from_thumb>:
102e3f54:	4778      	bx	pc
102e3f56:	46c0      	nop			; (mov r8, r8)
102e3f58:	eafffe68 	b	102e3900 <__aeabi_d2iz>
102e3f5c:	00000000 	andeq	r0, r0, r0

Disassembly of section .text.Ql_EINT_Register:

102e3f60 <Ql_EINT_Register>:
102e3f60:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e3f64:	e59f4054 	ldr	r4, [pc, #84]	; 102e3fc0 <Ql_EINT_Register+0x60>
102e3f68:	e1a05000 	mov	r5, r0
102e3f6c:	e5943000 	ldr	r3, [r4]
102e3f70:	e1a07001 	mov	r7, r1
102e3f74:	e3530000 	cmp	r3, #0
102e3f78:	e1a06002 	mov	r6, r2
102e3f7c:	1a000006 	bne	102e3f9c <Ql_EINT_Register+0x3c>
102e3f80:	e59f303c 	ldr	r3, [pc, #60]	; 102e3fc4 <Ql_EINT_Register+0x64>
102e3f84:	e59f003c 	ldr	r0, [pc, #60]	; 102e3fc8 <Ql_EINT_Register+0x68>
102e3f88:	e5933000 	ldr	r3, [r3]
102e3f8c:	e12fff33 	blx	r3
102e3f90:	e3500000 	cmp	r0, #0
102e3f94:	0a000007 	beq	102e3fb8 <Ql_EINT_Register+0x58>
102e3f98:	e5840000 	str	r0, [r4]
102e3f9c:	e59f301c 	ldr	r3, [pc, #28]	; 102e3fc0 <Ql_EINT_Register+0x60>
102e3fa0:	e1a00005 	mov	r0, r5
102e3fa4:	e5933000 	ldr	r3, [r3]
102e3fa8:	e1a01007 	mov	r1, r7
102e3fac:	e1a02006 	mov	r2, r6
102e3fb0:	e12fff33 	blx	r3
102e3fb4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e3fb8:	e59f000c 	ldr	r0, [pc, #12]	; 102e3fcc <Ql_EINT_Register+0x6c>
102e3fbc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e3fc0:	f03da94c 	.word	0xf03da94c
102e3fc4:	f03daa08 	.word	0xf03daa08
102e3fc8:	102f0378 	.word	0x102f0378
102e3fcc:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_EINT_Init:

102e3fd0 <Ql_EINT_Init>:
102e3fd0:	e92d41f3 	push	{r0, r1, r4, r5, r6, r7, r8, lr}
102e3fd4:	e59f4064 	ldr	r4, [pc, #100]	; 102e4040 <Ql_EINT_Init+0x70>
102e3fd8:	e1a06003 	mov	r6, r3
102e3fdc:	e5943008 	ldr	r3, [r4, #8]
102e3fe0:	e1a05000 	mov	r5, r0
102e3fe4:	e3530000 	cmp	r3, #0
102e3fe8:	e1a08001 	mov	r8, r1
102e3fec:	e1a07002 	mov	r7, r2
102e3ff0:	1a000006 	bne	102e4010 <Ql_EINT_Init+0x40>
102e3ff4:	e59f3048 	ldr	r3, [pc, #72]	; 102e4044 <Ql_EINT_Init+0x74>
102e3ff8:	e59f0048 	ldr	r0, [pc, #72]	; 102e4048 <Ql_EINT_Init+0x78>
102e3ffc:	e5933000 	ldr	r3, [r3]
102e4000:	e12fff33 	blx	r3
102e4004:	e3500000 	cmp	r0, #0
102e4008:	0a00000a 	beq	102e4038 <Ql_EINT_Init+0x68>
102e400c:	e5840008 	str	r0, [r4, #8]
102e4010:	e5dd3020 	ldrb	r3, [sp, #32]
102e4014:	e58d3000 	str	r3, [sp]
102e4018:	e59f3020 	ldr	r3, [pc, #32]	; 102e4040 <Ql_EINT_Init+0x70>
102e401c:	e1a00005 	mov	r0, r5
102e4020:	e593c008 	ldr	ip, [r3, #8]
102e4024:	e1a01008 	mov	r1, r8
102e4028:	e1a02007 	mov	r2, r7
102e402c:	e1a03006 	mov	r3, r6
102e4030:	e12fff3c 	blx	ip
102e4034:	ea000000 	b	102e403c <Ql_EINT_Init+0x6c>
102e4038:	e59f000c 	ldr	r0, [pc, #12]	; 102e404c <Ql_EINT_Init+0x7c>
102e403c:	e8bd81fc 	pop	{r2, r3, r4, r5, r6, r7, r8, pc}
102e4040:	f03da94c 	.word	0xf03da94c
102e4044:	f03daa08 	.word	0xf03daa08
102e4048:	102f039e 	.word	0x102f039e
102e404c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_Open:

102e4050 <Ql_FS_Open>:
102e4050:	e92d4070 	push	{r4, r5, r6, lr}
102e4054:	e59f404c 	ldr	r4, [pc, #76]	; 102e40a8 <Ql_FS_Open+0x58>
102e4058:	e1a05000 	mov	r5, r0
102e405c:	e5943000 	ldr	r3, [r4]
102e4060:	e1a06001 	mov	r6, r1
102e4064:	e3530000 	cmp	r3, #0
102e4068:	1a000006 	bne	102e4088 <Ql_FS_Open+0x38>
102e406c:	e59f3038 	ldr	r3, [pc, #56]	; 102e40ac <Ql_FS_Open+0x5c>
102e4070:	e59f0038 	ldr	r0, [pc, #56]	; 102e40b0 <Ql_FS_Open+0x60>
102e4074:	e5933000 	ldr	r3, [r3]
102e4078:	e12fff33 	blx	r3
102e407c:	e3500000 	cmp	r0, #0
102e4080:	0a000006 	beq	102e40a0 <Ql_FS_Open+0x50>
102e4084:	e5840000 	str	r0, [r4]
102e4088:	e59f3018 	ldr	r3, [pc, #24]	; 102e40a8 <Ql_FS_Open+0x58>
102e408c:	e1a00005 	mov	r0, r5
102e4090:	e5933000 	ldr	r3, [r3]
102e4094:	e1a01006 	mov	r1, r6
102e4098:	e12fff33 	blx	r3
102e409c:	e8bd8070 	pop	{r4, r5, r6, pc}
102e40a0:	e59f000c 	ldr	r0, [pc, #12]	; 102e40b4 <Ql_FS_Open+0x64>
102e40a4:	e8bd8070 	pop	{r4, r5, r6, pc}
102e40a8:	f03da968 	.word	0xf03da968
102e40ac:	f03daa08 	.word	0xf03daa08
102e40b0:	102f03e7 	.word	0x102f03e7
102e40b4:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_Read:

102e40b8 <Ql_FS_Read>:
102e40b8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102e40bc:	e59f405c 	ldr	r4, [pc, #92]	; 102e4120 <Ql_FS_Read+0x68>
102e40c0:	e1a06003 	mov	r6, r3
102e40c4:	e5943008 	ldr	r3, [r4, #8]
102e40c8:	e1a05000 	mov	r5, r0
102e40cc:	e3530000 	cmp	r3, #0
102e40d0:	e1a08001 	mov	r8, r1
102e40d4:	e1a07002 	mov	r7, r2
102e40d8:	1a000006 	bne	102e40f8 <Ql_FS_Read+0x40>
102e40dc:	e59f3040 	ldr	r3, [pc, #64]	; 102e4124 <Ql_FS_Read+0x6c>
102e40e0:	e59f0040 	ldr	r0, [pc, #64]	; 102e4128 <Ql_FS_Read+0x70>
102e40e4:	e5933000 	ldr	r3, [r3]
102e40e8:	e12fff33 	blx	r3
102e40ec:	e3500000 	cmp	r0, #0
102e40f0:	0a000008 	beq	102e4118 <Ql_FS_Read+0x60>
102e40f4:	e5840008 	str	r0, [r4, #8]
102e40f8:	e59f3020 	ldr	r3, [pc, #32]	; 102e4120 <Ql_FS_Read+0x68>
102e40fc:	e1a00005 	mov	r0, r5
102e4100:	e593c008 	ldr	ip, [r3, #8]
102e4104:	e1a01008 	mov	r1, r8
102e4108:	e1a02007 	mov	r2, r7
102e410c:	e1a03006 	mov	r3, r6
102e4110:	e12fff3c 	blx	ip
102e4114:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e4118:	e59f000c 	ldr	r0, [pc, #12]	; 102e412c <Ql_FS_Read+0x74>
102e411c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e4120:	f03da968 	.word	0xf03da968
102e4124:	f03daa08 	.word	0xf03daa08
102e4128:	102f0404 	.word	0x102f0404
102e412c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_Write:

102e4130 <Ql_FS_Write>:
102e4130:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102e4134:	e59f405c 	ldr	r4, [pc, #92]	; 102e4198 <Ql_FS_Write+0x68>
102e4138:	e1a06003 	mov	r6, r3
102e413c:	e594300c 	ldr	r3, [r4, #12]
102e4140:	e1a05000 	mov	r5, r0
102e4144:	e3530000 	cmp	r3, #0
102e4148:	e1a08001 	mov	r8, r1
102e414c:	e1a07002 	mov	r7, r2
102e4150:	1a000006 	bne	102e4170 <Ql_FS_Write+0x40>
102e4154:	e59f3040 	ldr	r3, [pc, #64]	; 102e419c <Ql_FS_Write+0x6c>
102e4158:	e59f0040 	ldr	r0, [pc, #64]	; 102e41a0 <Ql_FS_Write+0x70>
102e415c:	e5933000 	ldr	r3, [r3]
102e4160:	e12fff33 	blx	r3
102e4164:	e3500000 	cmp	r0, #0
102e4168:	0a000008 	beq	102e4190 <Ql_FS_Write+0x60>
102e416c:	e584000c 	str	r0, [r4, #12]
102e4170:	e59f3020 	ldr	r3, [pc, #32]	; 102e4198 <Ql_FS_Write+0x68>
102e4174:	e1a00005 	mov	r0, r5
102e4178:	e593c00c 	ldr	ip, [r3, #12]
102e417c:	e1a01008 	mov	r1, r8
102e4180:	e1a02007 	mov	r2, r7
102e4184:	e1a03006 	mov	r3, r6
102e4188:	e12fff3c 	blx	ip
102e418c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e4190:	e59f000c 	ldr	r0, [pc, #12]	; 102e41a4 <Ql_FS_Write+0x74>
102e4194:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e4198:	f03da968 	.word	0xf03da968
102e419c:	f03daa08 	.word	0xf03daa08
102e41a0:	102f040f 	.word	0x102f040f
102e41a4:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_Seek:

102e41a8 <Ql_FS_Seek>:
102e41a8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e41ac:	e59f4054 	ldr	r4, [pc, #84]	; 102e4208 <Ql_FS_Seek+0x60>
102e41b0:	e1a05000 	mov	r5, r0
102e41b4:	e5943010 	ldr	r3, [r4, #16]
102e41b8:	e1a07001 	mov	r7, r1
102e41bc:	e3530000 	cmp	r3, #0
102e41c0:	e1a06002 	mov	r6, r2
102e41c4:	1a000006 	bne	102e41e4 <Ql_FS_Seek+0x3c>
102e41c8:	e59f303c 	ldr	r3, [pc, #60]	; 102e420c <Ql_FS_Seek+0x64>
102e41cc:	e59f003c 	ldr	r0, [pc, #60]	; 102e4210 <Ql_FS_Seek+0x68>
102e41d0:	e5933000 	ldr	r3, [r3]
102e41d4:	e12fff33 	blx	r3
102e41d8:	e3500000 	cmp	r0, #0
102e41dc:	0a000007 	beq	102e4200 <Ql_FS_Seek+0x58>
102e41e0:	e5840010 	str	r0, [r4, #16]
102e41e4:	e59f301c 	ldr	r3, [pc, #28]	; 102e4208 <Ql_FS_Seek+0x60>
102e41e8:	e1a00005 	mov	r0, r5
102e41ec:	e5933010 	ldr	r3, [r3, #16]
102e41f0:	e1a01007 	mov	r1, r7
102e41f4:	e1a02006 	mov	r2, r6
102e41f8:	e12fff33 	blx	r3
102e41fc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e4200:	e59f000c 	ldr	r0, [pc, #12]	; 102e4214 <Ql_FS_Seek+0x6c>
102e4204:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e4208:	f03da968 	.word	0xf03da968
102e420c:	f03daa08 	.word	0xf03daa08
102e4210:	102f041b 	.word	0x102f041b
102e4214:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_Flush:

102e4218 <Ql_FS_Flush>:
102e4218:	e92d4038 	push	{r3, r4, r5, lr}
102e421c:	e59f403c 	ldr	r4, [pc, #60]	; 102e4260 <Ql_FS_Flush+0x48>
102e4220:	e1a05000 	mov	r5, r0
102e4224:	e594301c 	ldr	r3, [r4, #28]
102e4228:	e3530000 	cmp	r3, #0
102e422c:	1a000006 	bne	102e424c <Ql_FS_Flush+0x34>
102e4230:	e59f302c 	ldr	r3, [pc, #44]	; 102e4264 <Ql_FS_Flush+0x4c>
102e4234:	e59f002c 	ldr	r0, [pc, #44]	; 102e4268 <Ql_FS_Flush+0x50>
102e4238:	e5933000 	ldr	r3, [r3]
102e423c:	e12fff33 	blx	r3
102e4240:	e3500000 	cmp	r0, #0
102e4244:	08bd8038 	popeq	{r3, r4, r5, pc}
102e4248:	e584001c 	str	r0, [r4, #28]
102e424c:	e59f300c 	ldr	r3, [pc, #12]	; 102e4260 <Ql_FS_Flush+0x48>
102e4250:	e1a00005 	mov	r0, r5
102e4254:	e593301c 	ldr	r3, [r3, #28]
102e4258:	e12fff33 	blx	r3
102e425c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4260:	f03da968 	.word	0xf03da968
102e4264:	f03daa08 	.word	0xf03daa08
102e4268:	102f044b 	.word	0x102f044b

Disassembly of section .text.Ql_FS_Close:

102e426c <Ql_FS_Close>:
102e426c:	e92d4038 	push	{r3, r4, r5, lr}
102e4270:	e59f403c 	ldr	r4, [pc, #60]	; 102e42b4 <Ql_FS_Close+0x48>
102e4274:	e1a05000 	mov	r5, r0
102e4278:	e5943020 	ldr	r3, [r4, #32]
102e427c:	e3530000 	cmp	r3, #0
102e4280:	1a000006 	bne	102e42a0 <Ql_FS_Close+0x34>
102e4284:	e59f302c 	ldr	r3, [pc, #44]	; 102e42b8 <Ql_FS_Close+0x4c>
102e4288:	e59f002c 	ldr	r0, [pc, #44]	; 102e42bc <Ql_FS_Close+0x50>
102e428c:	e5933000 	ldr	r3, [r3]
102e4290:	e12fff33 	blx	r3
102e4294:	e3500000 	cmp	r0, #0
102e4298:	08bd8038 	popeq	{r3, r4, r5, pc}
102e429c:	e5840020 	str	r0, [r4, #32]
102e42a0:	e59f300c 	ldr	r3, [pc, #12]	; 102e42b4 <Ql_FS_Close+0x48>
102e42a4:	e1a00005 	mov	r0, r5
102e42a8:	e5933020 	ldr	r3, [r3, #32]
102e42ac:	e12fff33 	blx	r3
102e42b0:	e8bd8038 	pop	{r3, r4, r5, pc}
102e42b4:	f03da968 	.word	0xf03da968
102e42b8:	f03daa08 	.word	0xf03daa08
102e42bc:	102f0457 	.word	0x102f0457

Disassembly of section .text.Ql_FS_GetSize:

102e42c0 <Ql_FS_GetSize>:
102e42c0:	e92d4038 	push	{r3, r4, r5, lr}
102e42c4:	e59f4044 	ldr	r4, [pc, #68]	; 102e4310 <Ql_FS_GetSize+0x50>
102e42c8:	e1a05000 	mov	r5, r0
102e42cc:	e5943024 	ldr	r3, [r4, #36]	; 0x24
102e42d0:	e3530000 	cmp	r3, #0
102e42d4:	1a000006 	bne	102e42f4 <Ql_FS_GetSize+0x34>
102e42d8:	e59f3034 	ldr	r3, [pc, #52]	; 102e4314 <Ql_FS_GetSize+0x54>
102e42dc:	e59f0034 	ldr	r0, [pc, #52]	; 102e4318 <Ql_FS_GetSize+0x58>
102e42e0:	e5933000 	ldr	r3, [r3]
102e42e4:	e12fff33 	blx	r3
102e42e8:	e3500000 	cmp	r0, #0
102e42ec:	0a000005 	beq	102e4308 <Ql_FS_GetSize+0x48>
102e42f0:	e5840024 	str	r0, [r4, #36]	; 0x24
102e42f4:	e59f3014 	ldr	r3, [pc, #20]	; 102e4310 <Ql_FS_GetSize+0x50>
102e42f8:	e1a00005 	mov	r0, r5
102e42fc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
102e4300:	e12fff33 	blx	r3
102e4304:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4308:	e59f000c 	ldr	r0, [pc, #12]	; 102e431c <Ql_FS_GetSize+0x5c>
102e430c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4310:	f03da968 	.word	0xf03da968
102e4314:	f03daa08 	.word	0xf03daa08
102e4318:	102f0463 	.word	0x102f0463
102e431c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_Delete:

102e4320 <Ql_FS_Delete>:
102e4320:	e92d4038 	push	{r3, r4, r5, lr}
102e4324:	e59f4044 	ldr	r4, [pc, #68]	; 102e4370 <Ql_FS_Delete+0x50>
102e4328:	e1a05000 	mov	r5, r0
102e432c:	e5943028 	ldr	r3, [r4, #40]	; 0x28
102e4330:	e3530000 	cmp	r3, #0
102e4334:	1a000006 	bne	102e4354 <Ql_FS_Delete+0x34>
102e4338:	e59f3034 	ldr	r3, [pc, #52]	; 102e4374 <Ql_FS_Delete+0x54>
102e433c:	e59f0034 	ldr	r0, [pc, #52]	; 102e4378 <Ql_FS_Delete+0x58>
102e4340:	e5933000 	ldr	r3, [r3]
102e4344:	e12fff33 	blx	r3
102e4348:	e3500000 	cmp	r0, #0
102e434c:	0a000005 	beq	102e4368 <Ql_FS_Delete+0x48>
102e4350:	e5840028 	str	r0, [r4, #40]	; 0x28
102e4354:	e59f3014 	ldr	r3, [pc, #20]	; 102e4370 <Ql_FS_Delete+0x50>
102e4358:	e1a00005 	mov	r0, r5
102e435c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
102e4360:	e12fff33 	blx	r3
102e4364:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4368:	e59f000c 	ldr	r0, [pc, #12]	; 102e437c <Ql_FS_Delete+0x5c>
102e436c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4370:	f03da968 	.word	0xf03da968
102e4374:	f03daa08 	.word	0xf03daa08
102e4378:	102f0471 	.word	0x102f0471
102e437c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_Check:

102e4380 <Ql_FS_Check>:
102e4380:	e92d4038 	push	{r3, r4, r5, lr}
102e4384:	e59f4044 	ldr	r4, [pc, #68]	; 102e43d0 <Ql_FS_Check+0x50>
102e4388:	e1a05000 	mov	r5, r0
102e438c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
102e4390:	e3530000 	cmp	r3, #0
102e4394:	1a000006 	bne	102e43b4 <Ql_FS_Check+0x34>
102e4398:	e59f3034 	ldr	r3, [pc, #52]	; 102e43d4 <Ql_FS_Check+0x54>
102e439c:	e59f0034 	ldr	r0, [pc, #52]	; 102e43d8 <Ql_FS_Check+0x58>
102e43a0:	e5933000 	ldr	r3, [r3]
102e43a4:	e12fff33 	blx	r3
102e43a8:	e3500000 	cmp	r0, #0
102e43ac:	0a000005 	beq	102e43c8 <Ql_FS_Check+0x48>
102e43b0:	e584002c 	str	r0, [r4, #44]	; 0x2c
102e43b4:	e59f3014 	ldr	r3, [pc, #20]	; 102e43d0 <Ql_FS_Check+0x50>
102e43b8:	e1a00005 	mov	r0, r5
102e43bc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
102e43c0:	e12fff33 	blx	r3
102e43c4:	e8bd8038 	pop	{r3, r4, r5, pc}
102e43c8:	e59f000c 	ldr	r0, [pc, #12]	; 102e43dc <Ql_FS_Check+0x5c>
102e43cc:	e8bd8038 	pop	{r3, r4, r5, pc}
102e43d0:	f03da968 	.word	0xf03da968
102e43d4:	f03daa08 	.word	0xf03daa08
102e43d8:	102f047e 	.word	0x102f047e
102e43dc:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_CreateDir:

102e43e0 <Ql_FS_CreateDir>:
102e43e0:	e92d4038 	push	{r3, r4, r5, lr}
102e43e4:	e59f4044 	ldr	r4, [pc, #68]	; 102e4430 <Ql_FS_CreateDir+0x50>
102e43e8:	e1a05000 	mov	r5, r0
102e43ec:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102e43f0:	e3530000 	cmp	r3, #0
102e43f4:	1a000006 	bne	102e4414 <Ql_FS_CreateDir+0x34>
102e43f8:	e59f3034 	ldr	r3, [pc, #52]	; 102e4434 <Ql_FS_CreateDir+0x54>
102e43fc:	e59f0034 	ldr	r0, [pc, #52]	; 102e4438 <Ql_FS_CreateDir+0x58>
102e4400:	e5933000 	ldr	r3, [r3]
102e4404:	e12fff33 	blx	r3
102e4408:	e3500000 	cmp	r0, #0
102e440c:	0a000005 	beq	102e4428 <Ql_FS_CreateDir+0x48>
102e4410:	e5840034 	str	r0, [r4, #52]	; 0x34
102e4414:	e59f3014 	ldr	r3, [pc, #20]	; 102e4430 <Ql_FS_CreateDir+0x50>
102e4418:	e1a00005 	mov	r0, r5
102e441c:	e5933034 	ldr	r3, [r3, #52]	; 0x34
102e4420:	e12fff33 	blx	r3
102e4424:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4428:	e59f000c 	ldr	r0, [pc, #12]	; 102e443c <Ql_FS_CreateDir+0x5c>
102e442c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4430:	f03da968 	.word	0xf03da968
102e4434:	f03daa08 	.word	0xf03daa08
102e4438:	102f0497 	.word	0x102f0497
102e443c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_CheckDir:

102e4440 <Ql_FS_CheckDir>:
102e4440:	e92d4038 	push	{r3, r4, r5, lr}
102e4444:	e59f4044 	ldr	r4, [pc, #68]	; 102e4490 <Ql_FS_CheckDir+0x50>
102e4448:	e1a05000 	mov	r5, r0
102e444c:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
102e4450:	e3530000 	cmp	r3, #0
102e4454:	1a000006 	bne	102e4474 <Ql_FS_CheckDir+0x34>
102e4458:	e59f3034 	ldr	r3, [pc, #52]	; 102e4494 <Ql_FS_CheckDir+0x54>
102e445c:	e59f0034 	ldr	r0, [pc, #52]	; 102e4498 <Ql_FS_CheckDir+0x58>
102e4460:	e5933000 	ldr	r3, [r3]
102e4464:	e12fff33 	blx	r3
102e4468:	e3500000 	cmp	r0, #0
102e446c:	0a000005 	beq	102e4488 <Ql_FS_CheckDir+0x48>
102e4470:	e584003c 	str	r0, [r4, #60]	; 0x3c
102e4474:	e59f3014 	ldr	r3, [pc, #20]	; 102e4490 <Ql_FS_CheckDir+0x50>
102e4478:	e1a00005 	mov	r0, r5
102e447c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
102e4480:	e12fff33 	blx	r3
102e4484:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4488:	e59f000c 	ldr	r0, [pc, #12]	; 102e449c <Ql_FS_CheckDir+0x5c>
102e448c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4490:	f03da968 	.word	0xf03da968
102e4494:	f03daa08 	.word	0xf03daa08
102e4498:	102f04b7 	.word	0x102f04b7
102e449c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_GetFreeSpace:

102e44a0 <Ql_FS_GetFreeSpace>:
102e44a0:	e92d4038 	push	{r3, r4, r5, lr}
102e44a4:	e59f4058 	ldr	r4, [pc, #88]	; 102e4504 <Ql_FS_GetFreeSpace+0x64>
102e44a8:	e1a05000 	mov	r5, r0
102e44ac:	e5943054 	ldr	r3, [r4, #84]	; 0x54
102e44b0:	e3530000 	cmp	r3, #0
102e44b4:	1a000006 	bne	102e44d4 <Ql_FS_GetFreeSpace+0x34>
102e44b8:	e59f3048 	ldr	r3, [pc, #72]	; 102e4508 <Ql_FS_GetFreeSpace+0x68>
102e44bc:	e59f0048 	ldr	r0, [pc, #72]	; 102e450c <Ql_FS_GetFreeSpace+0x6c>
102e44c0:	e5933000 	ldr	r3, [r3]
102e44c4:	e12fff33 	blx	r3
102e44c8:	e3500000 	cmp	r0, #0
102e44cc:	0a000007 	beq	102e44f0 <Ql_FS_GetFreeSpace+0x50>
102e44d0:	e5840054 	str	r0, [r4, #84]	; 0x54
102e44d4:	e59f3028 	ldr	r3, [pc, #40]	; 102e4504 <Ql_FS_GetFreeSpace+0x64>
102e44d8:	e1a00005 	mov	r0, r5
102e44dc:	e5933054 	ldr	r3, [r3, #84]	; 0x54
102e44e0:	e12fff33 	blx	r3
102e44e4:	e1a02000 	mov	r2, r0
102e44e8:	e1a03001 	mov	r3, r1
102e44ec:	ea000001 	b	102e44f8 <Ql_FS_GetFreeSpace+0x58>
102e44f0:	e59f2018 	ldr	r2, [pc, #24]	; 102e4510 <Ql_FS_GetFreeSpace+0x70>
102e44f4:	e3e03000 	mvn	r3, #0
102e44f8:	e1a00002 	mov	r0, r2
102e44fc:	e1a01003 	mov	r1, r3
102e4500:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4504:	f03da968 	.word	0xf03da968
102e4508:	f03daa08 	.word	0xf03daa08
102e450c:	102f050f 	.word	0x102f050f
102e4510:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_GetTotalSpace:

102e4514 <Ql_FS_GetTotalSpace>:
102e4514:	e92d4038 	push	{r3, r4, r5, lr}
102e4518:	e59f4058 	ldr	r4, [pc, #88]	; 102e4578 <Ql_FS_GetTotalSpace+0x64>
102e451c:	e1a05000 	mov	r5, r0
102e4520:	e5943058 	ldr	r3, [r4, #88]	; 0x58
102e4524:	e3530000 	cmp	r3, #0
102e4528:	1a000006 	bne	102e4548 <Ql_FS_GetTotalSpace+0x34>
102e452c:	e59f3048 	ldr	r3, [pc, #72]	; 102e457c <Ql_FS_GetTotalSpace+0x68>
102e4530:	e59f0048 	ldr	r0, [pc, #72]	; 102e4580 <Ql_FS_GetTotalSpace+0x6c>
102e4534:	e5933000 	ldr	r3, [r3]
102e4538:	e12fff33 	blx	r3
102e453c:	e3500000 	cmp	r0, #0
102e4540:	0a000007 	beq	102e4564 <Ql_FS_GetTotalSpace+0x50>
102e4544:	e5840058 	str	r0, [r4, #88]	; 0x58
102e4548:	e59f3028 	ldr	r3, [pc, #40]	; 102e4578 <Ql_FS_GetTotalSpace+0x64>
102e454c:	e1a00005 	mov	r0, r5
102e4550:	e5933058 	ldr	r3, [r3, #88]	; 0x58
102e4554:	e12fff33 	blx	r3
102e4558:	e1a02000 	mov	r2, r0
102e455c:	e1a03001 	mov	r3, r1
102e4560:	ea000001 	b	102e456c <Ql_FS_GetTotalSpace+0x58>
102e4564:	e59f2018 	ldr	r2, [pc, #24]	; 102e4584 <Ql_FS_GetTotalSpace+0x70>
102e4568:	e3e03000 	mvn	r3, #0
102e456c:	e1a00002 	mov	r0, r2
102e4570:	e1a01003 	mov	r1, r3
102e4574:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4578:	f03da968 	.word	0xf03da968
102e457c:	f03daa08 	.word	0xf03daa08
102e4580:	102f0522 	.word	0x102f0522
102e4584:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FS_Format:

102e4588 <Ql_FS_Format>:
102e4588:	e92d4038 	push	{r3, r4, r5, lr}
102e458c:	e59f4044 	ldr	r4, [pc, #68]	; 102e45d8 <Ql_FS_Format+0x50>
102e4590:	e1a05000 	mov	r5, r0
102e4594:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
102e4598:	e3530000 	cmp	r3, #0
102e459c:	1a000006 	bne	102e45bc <Ql_FS_Format+0x34>
102e45a0:	e59f3034 	ldr	r3, [pc, #52]	; 102e45dc <Ql_FS_Format+0x54>
102e45a4:	e59f0034 	ldr	r0, [pc, #52]	; 102e45e0 <Ql_FS_Format+0x58>
102e45a8:	e5933000 	ldr	r3, [r3]
102e45ac:	e12fff33 	blx	r3
102e45b0:	e3500000 	cmp	r0, #0
102e45b4:	0a000005 	beq	102e45d0 <Ql_FS_Format+0x48>
102e45b8:	e584005c 	str	r0, [r4, #92]	; 0x5c
102e45bc:	e59f3014 	ldr	r3, [pc, #20]	; 102e45d8 <Ql_FS_Format+0x50>
102e45c0:	e1a00005 	mov	r0, r5
102e45c4:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
102e45c8:	e12fff33 	blx	r3
102e45cc:	e8bd8038 	pop	{r3, r4, r5, pc}
102e45d0:	e59f000c 	ldr	r0, [pc, #12]	; 102e45e4 <Ql_FS_Format+0x5c>
102e45d4:	e8bd8038 	pop	{r3, r4, r5, pc}
102e45d8:	f03da968 	.word	0xf03da968
102e45dc:	f03daa08 	.word	0xf03daa08
102e45e0:	102f0536 	.word	0x102f0536
102e45e4:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FOTA_Init:

102e45e8 <Ql_FOTA_Init>:
102e45e8:	e92d4038 	push	{r3, r4, r5, lr}
102e45ec:	e59f4044 	ldr	r4, [pc, #68]	; 102e4638 <Ql_FOTA_Init+0x50>
102e45f0:	e1a05000 	mov	r5, r0
102e45f4:	e5943000 	ldr	r3, [r4]
102e45f8:	e3530000 	cmp	r3, #0
102e45fc:	1a000006 	bne	102e461c <Ql_FOTA_Init+0x34>
102e4600:	e59f3034 	ldr	r3, [pc, #52]	; 102e463c <Ql_FOTA_Init+0x54>
102e4604:	e59f0034 	ldr	r0, [pc, #52]	; 102e4640 <Ql_FOTA_Init+0x58>
102e4608:	e5933000 	ldr	r3, [r3]
102e460c:	e12fff33 	blx	r3
102e4610:	e3500000 	cmp	r0, #0
102e4614:	0a000005 	beq	102e4630 <Ql_FOTA_Init+0x48>
102e4618:	e5840000 	str	r0, [r4]
102e461c:	e59f3014 	ldr	r3, [pc, #20]	; 102e4638 <Ql_FOTA_Init+0x50>
102e4620:	e1a00005 	mov	r0, r5
102e4624:	e5933000 	ldr	r3, [r3]
102e4628:	e12fff33 	blx	r3
102e462c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4630:	e59f000c 	ldr	r0, [pc, #12]	; 102e4644 <Ql_FOTA_Init+0x5c>
102e4634:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4638:	f03da9c8 	.word	0xf03da9c8
102e463c:	f03daa08 	.word	0xf03daa08
102e4640:	102f0543 	.word	0x102f0543
102e4644:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FOTA_WriteData:

102e4648 <Ql_FOTA_WriteData>:
102e4648:	e92d4070 	push	{r4, r5, r6, lr}
102e464c:	e59f404c 	ldr	r4, [pc, #76]	; 102e46a0 <Ql_FOTA_WriteData+0x58>
102e4650:	e1a05000 	mov	r5, r0
102e4654:	e5943004 	ldr	r3, [r4, #4]
102e4658:	e1a06001 	mov	r6, r1
102e465c:	e3530000 	cmp	r3, #0
102e4660:	1a000006 	bne	102e4680 <Ql_FOTA_WriteData+0x38>
102e4664:	e59f3038 	ldr	r3, [pc, #56]	; 102e46a4 <Ql_FOTA_WriteData+0x5c>
102e4668:	e59f0038 	ldr	r0, [pc, #56]	; 102e46a8 <Ql_FOTA_WriteData+0x60>
102e466c:	e5933000 	ldr	r3, [r3]
102e4670:	e12fff33 	blx	r3
102e4674:	e3500000 	cmp	r0, #0
102e4678:	0a000006 	beq	102e4698 <Ql_FOTA_WriteData+0x50>
102e467c:	e5840004 	str	r0, [r4, #4]
102e4680:	e59f3018 	ldr	r3, [pc, #24]	; 102e46a0 <Ql_FOTA_WriteData+0x58>
102e4684:	e1a00005 	mov	r0, r5
102e4688:	e5933004 	ldr	r3, [r3, #4]
102e468c:	e1a01006 	mov	r1, r6
102e4690:	e12fff33 	blx	r3
102e4694:	e8bd8070 	pop	{r4, r5, r6, pc}
102e4698:	e59f000c 	ldr	r0, [pc, #12]	; 102e46ac <Ql_FOTA_WriteData+0x64>
102e469c:	e8bd8070 	pop	{r4, r5, r6, pc}
102e46a0:	f03da9c8 	.word	0xf03da9c8
102e46a4:	f03daa08 	.word	0xf03daa08
102e46a8:	102f0550 	.word	0x102f0550
102e46ac:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FOTA_Finish:

102e46b0 <Ql_FOTA_Finish>:
102e46b0:	e92d4010 	push	{r4, lr}
102e46b4:	e59f403c 	ldr	r4, [pc, #60]	; 102e46f8 <Ql_FOTA_Finish+0x48>
102e46b8:	e5943008 	ldr	r3, [r4, #8]
102e46bc:	e3530000 	cmp	r3, #0
102e46c0:	1a000006 	bne	102e46e0 <Ql_FOTA_Finish+0x30>
102e46c4:	e59f3030 	ldr	r3, [pc, #48]	; 102e46fc <Ql_FOTA_Finish+0x4c>
102e46c8:	e59f0030 	ldr	r0, [pc, #48]	; 102e4700 <Ql_FOTA_Finish+0x50>
102e46cc:	e5933000 	ldr	r3, [r3]
102e46d0:	e12fff33 	blx	r3
102e46d4:	e3500000 	cmp	r0, #0
102e46d8:	0a000004 	beq	102e46f0 <Ql_FOTA_Finish+0x40>
102e46dc:	e5840008 	str	r0, [r4, #8]
102e46e0:	e59f3010 	ldr	r3, [pc, #16]	; 102e46f8 <Ql_FOTA_Finish+0x48>
102e46e4:	e5933008 	ldr	r3, [r3, #8]
102e46e8:	e12fff33 	blx	r3
102e46ec:	e8bd8010 	pop	{r4, pc}
102e46f0:	e59f000c 	ldr	r0, [pc, #12]	; 102e4704 <Ql_FOTA_Finish+0x54>
102e46f4:	e8bd8010 	pop	{r4, pc}
102e46f8:	f03da9c8 	.word	0xf03da9c8
102e46fc:	f03daa08 	.word	0xf03daa08
102e4700:	102f0562 	.word	0x102f0562
102e4704:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_FOTA_Update:

102e4708 <Ql_FOTA_Update>:
102e4708:	e92d4010 	push	{r4, lr}
102e470c:	e59f403c 	ldr	r4, [pc, #60]	; 102e4750 <Ql_FOTA_Update+0x48>
102e4710:	e5943010 	ldr	r3, [r4, #16]
102e4714:	e3530000 	cmp	r3, #0
102e4718:	1a000006 	bne	102e4738 <Ql_FOTA_Update+0x30>
102e471c:	e59f3030 	ldr	r3, [pc, #48]	; 102e4754 <Ql_FOTA_Update+0x4c>
102e4720:	e59f0030 	ldr	r0, [pc, #48]	; 102e4758 <Ql_FOTA_Update+0x50>
102e4724:	e5933000 	ldr	r3, [r3]
102e4728:	e12fff33 	blx	r3
102e472c:	e3500000 	cmp	r0, #0
102e4730:	0a000004 	beq	102e4748 <Ql_FOTA_Update+0x40>
102e4734:	e5840010 	str	r0, [r4, #16]
102e4738:	e59f3010 	ldr	r3, [pc, #16]	; 102e4750 <Ql_FOTA_Update+0x48>
102e473c:	e5933010 	ldr	r3, [r3, #16]
102e4740:	e12fff33 	blx	r3
102e4744:	e8bd8010 	pop	{r4, pc}
102e4748:	e59f000c 	ldr	r0, [pc, #12]	; 102e475c <Ql_FOTA_Update+0x54>
102e474c:	e8bd8010 	pop	{r4, pc}
102e4750:	f03da9c8 	.word	0xf03da9c8
102e4754:	f03daa08 	.word	0xf03daa08
102e4758:	102f0582 	.word	0x102f0582
102e475c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_GPIO_Init:

102e4760 <Ql_GPIO_Init>:
102e4760:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102e4764:	e59f405c 	ldr	r4, [pc, #92]	; 102e47c8 <Ql_GPIO_Init+0x68>
102e4768:	e1a06003 	mov	r6, r3
102e476c:	e5943000 	ldr	r3, [r4]
102e4770:	e1a05000 	mov	r5, r0
102e4774:	e3530000 	cmp	r3, #0
102e4778:	e1a08001 	mov	r8, r1
102e477c:	e1a07002 	mov	r7, r2
102e4780:	1a000006 	bne	102e47a0 <Ql_GPIO_Init+0x40>
102e4784:	e59f3040 	ldr	r3, [pc, #64]	; 102e47cc <Ql_GPIO_Init+0x6c>
102e4788:	e59f0040 	ldr	r0, [pc, #64]	; 102e47d0 <Ql_GPIO_Init+0x70>
102e478c:	e5933000 	ldr	r3, [r3]
102e4790:	e12fff33 	blx	r3
102e4794:	e3500000 	cmp	r0, #0
102e4798:	0a000008 	beq	102e47c0 <Ql_GPIO_Init+0x60>
102e479c:	e5840000 	str	r0, [r4]
102e47a0:	e59f3020 	ldr	r3, [pc, #32]	; 102e47c8 <Ql_GPIO_Init+0x68>
102e47a4:	e1a00005 	mov	r0, r5
102e47a8:	e593c000 	ldr	ip, [r3]
102e47ac:	e1a01008 	mov	r1, r8
102e47b0:	e1a02007 	mov	r2, r7
102e47b4:	e1a03006 	mov	r3, r6
102e47b8:	e12fff3c 	blx	ip
102e47bc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e47c0:	e59f000c 	ldr	r0, [pc, #12]	; 102e47d4 <Ql_GPIO_Init+0x74>
102e47c4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e47c8:	f03da9dc 	.word	0xf03da9dc
102e47cc:	f03daa08 	.word	0xf03daa08
102e47d0:	102f0591 	.word	0x102f0591
102e47d4:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_GPIO_SetLevel:

102e47d8 <Ql_GPIO_SetLevel>:
102e47d8:	e92d4070 	push	{r4, r5, r6, lr}
102e47dc:	e59f404c 	ldr	r4, [pc, #76]	; 102e4830 <Ql_GPIO_SetLevel+0x58>
102e47e0:	e1a05000 	mov	r5, r0
102e47e4:	e5943004 	ldr	r3, [r4, #4]
102e47e8:	e1a06001 	mov	r6, r1
102e47ec:	e3530000 	cmp	r3, #0
102e47f0:	1a000006 	bne	102e4810 <Ql_GPIO_SetLevel+0x38>
102e47f4:	e59f3038 	ldr	r3, [pc, #56]	; 102e4834 <Ql_GPIO_SetLevel+0x5c>
102e47f8:	e59f0038 	ldr	r0, [pc, #56]	; 102e4838 <Ql_GPIO_SetLevel+0x60>
102e47fc:	e5933000 	ldr	r3, [r3]
102e4800:	e12fff33 	blx	r3
102e4804:	e3500000 	cmp	r0, #0
102e4808:	0a000006 	beq	102e4828 <Ql_GPIO_SetLevel+0x50>
102e480c:	e5840004 	str	r0, [r4, #4]
102e4810:	e59f3018 	ldr	r3, [pc, #24]	; 102e4830 <Ql_GPIO_SetLevel+0x58>
102e4814:	e1a00005 	mov	r0, r5
102e4818:	e5933004 	ldr	r3, [r3, #4]
102e481c:	e1a01006 	mov	r1, r6
102e4820:	e12fff33 	blx	r3
102e4824:	e8bd8070 	pop	{r4, r5, r6, pc}
102e4828:	e59f000c 	ldr	r0, [pc, #12]	; 102e483c <Ql_GPIO_SetLevel+0x64>
102e482c:	e8bd8070 	pop	{r4, r5, r6, pc}
102e4830:	f03da9dc 	.word	0xf03da9dc
102e4834:	f03daa08 	.word	0xf03daa08
102e4838:	102f059e 	.word	0x102f059e
102e483c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_MEM_Alloc:

102e4840 <Ql_MEM_Alloc>:
102e4840:	e92d4070 	push	{r4, r5, r6, lr}
102e4844:	e59f5058 	ldr	r5, [pc, #88]	; 102e48a4 <Ql_MEM_Alloc+0x64>
102e4848:	e1a06000 	mov	r6, r0
102e484c:	e5953000 	ldr	r3, [r5]
102e4850:	e3530000 	cmp	r3, #0
102e4854:	1a00000d 	bne	102e4890 <Ql_MEM_Alloc+0x50>
102e4858:	e59f3048 	ldr	r3, [pc, #72]	; 102e48a8 <Ql_MEM_Alloc+0x68>
102e485c:	e59f0048 	ldr	r0, [pc, #72]	; 102e48ac <Ql_MEM_Alloc+0x6c>
102e4860:	e5933000 	ldr	r3, [r3]
102e4864:	e12fff33 	blx	r3
102e4868:	e2504000 	subs	r4, r0, #0
102e486c:	15854000 	strne	r4, [r5]
102e4870:	1a000006 	bne	102e4890 <Ql_MEM_Alloc+0x50>
102e4874:	e59f3034 	ldr	r3, [pc, #52]	; 102e48b0 <Ql_MEM_Alloc+0x70>
102e4878:	e59f102c 	ldr	r1, [pc, #44]	; 102e48ac <Ql_MEM_Alloc+0x6c>
102e487c:	e5933000 	ldr	r3, [r3]
102e4880:	e59f002c 	ldr	r0, [pc, #44]	; 102e48b4 <Ql_MEM_Alloc+0x74>
102e4884:	e12fff33 	blx	r3
102e4888:	e1a00004 	mov	r0, r4
102e488c:	e8bd8070 	pop	{r4, r5, r6, pc}
102e4890:	e59f300c 	ldr	r3, [pc, #12]	; 102e48a4 <Ql_MEM_Alloc+0x64>
102e4894:	e1a00006 	mov	r0, r6
102e4898:	e5933000 	ldr	r3, [r3]
102e489c:	e12fff33 	blx	r3
102e48a0:	e8bd8070 	pop	{r4, r5, r6, pc}
102e48a4:	f03da9fc 	.word	0xf03da9fc
102e48a8:	f03daa08 	.word	0xf03daa08
102e48ac:	102f062b 	.word	0x102f062b
102e48b0:	f03de544 	.word	0xf03de544
102e48b4:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_MEM_Free:

102e48b8 <Ql_MEM_Free>:
102e48b8:	e92d4038 	push	{r3, r4, r5, lr}
102e48bc:	e59f4054 	ldr	r4, [pc, #84]	; 102e4918 <Ql_MEM_Free+0x60>
102e48c0:	e1a05000 	mov	r5, r0
102e48c4:	e5943004 	ldr	r3, [r4, #4]
102e48c8:	e3530000 	cmp	r3, #0
102e48cc:	1a00000c 	bne	102e4904 <Ql_MEM_Free+0x4c>
102e48d0:	e59f3044 	ldr	r3, [pc, #68]	; 102e491c <Ql_MEM_Free+0x64>
102e48d4:	e59f0044 	ldr	r0, [pc, #68]	; 102e4920 <Ql_MEM_Free+0x68>
102e48d8:	e5933000 	ldr	r3, [r3]
102e48dc:	e12fff33 	blx	r3
102e48e0:	e3500000 	cmp	r0, #0
102e48e4:	15840004 	strne	r0, [r4, #4]
102e48e8:	1a000005 	bne	102e4904 <Ql_MEM_Free+0x4c>
102e48ec:	e59f3030 	ldr	r3, [pc, #48]	; 102e4924 <Ql_MEM_Free+0x6c>
102e48f0:	e59f1028 	ldr	r1, [pc, #40]	; 102e4920 <Ql_MEM_Free+0x68>
102e48f4:	e5933000 	ldr	r3, [r3]
102e48f8:	e59f0028 	ldr	r0, [pc, #40]	; 102e4928 <Ql_MEM_Free+0x70>
102e48fc:	e12fff33 	blx	r3
102e4900:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4904:	e59f300c 	ldr	r3, [pc, #12]	; 102e4918 <Ql_MEM_Free+0x60>
102e4908:	e1a00005 	mov	r0, r5
102e490c:	e5933004 	ldr	r3, [r3, #4]
102e4910:	e12fff33 	blx	r3
102e4914:	e8bd8038 	pop	{r3, r4, r5, pc}
102e4918:	f03da9fc 	.word	0xf03da9fc
102e491c:	f03daa08 	.word	0xf03daa08
102e4920:	102f0638 	.word	0x102f0638
102e4924:	f03de544 	.word	0xf03de544
102e4928:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.ql_InitVFunc:

102e492c <ql_InitVFunc>:
102e492c:	e5903000 	ldr	r3, [r0]
102e4930:	e59f20b0 	ldr	r2, [pc, #176]	; 102e49e8 <ql_InitVFunc+0xbc>
102e4934:	e5933000 	ldr	r3, [r3]
102e4938:	e5901014 	ldr	r1, [r0, #20]
102e493c:	e3530007 	cmp	r3, #7
102e4940:	23a03007 	movcs	r3, #7
102e4944:	e5823000 	str	r3, [r2]
102e4948:	e59f209c 	ldr	r2, [pc, #156]	; 102e49ec <ql_InitVFunc+0xc0>
102e494c:	e3530001 	cmp	r3, #1
102e4950:	e5821000 	str	r1, [r2]
102e4954:	e59f2094 	ldr	r2, [pc, #148]	; 102e49f0 <ql_InitVFunc+0xc4>
102e4958:	e5901018 	ldr	r1, [r0, #24]
102e495c:	e5821000 	str	r1, [r2]
102e4960:	e59f108c 	ldr	r1, [pc, #140]	; 102e49f4 <ql_InitVFunc+0xc8>
102e4964:	e59f208c 	ldr	r2, [pc, #140]	; 102e49f8 <ql_InitVFunc+0xcc>
102e4968:	9a000004 	bls	102e4980 <ql_InitVFunc+0x54>
102e496c:	e590c004 	ldr	ip, [r0, #4]
102e4970:	e3530002 	cmp	r3, #2
102e4974:	e581c000 	str	ip, [r1]
102e4978:	1a000003 	bne	102e498c <ql_InitVFunc+0x60>
102e497c:	ea000007 	b	102e49a0 <ql_InitVFunc+0x74>
102e4980:	e3a03000 	mov	r3, #0
102e4984:	e5813000 	str	r3, [r1]
102e4988:	ea000004 	b	102e49a0 <ql_InitVFunc+0x74>
102e498c:	e5901008 	ldr	r1, [r0, #8]
102e4990:	e3530003 	cmp	r3, #3
102e4994:	e5821000 	str	r1, [r2]
102e4998:	1a000003 	bne	102e49ac <ql_InitVFunc+0x80>
102e499c:	ea000009 	b	102e49c8 <ql_InitVFunc+0x9c>
102e49a0:	e3a03000 	mov	r3, #0
102e49a4:	e5823000 	str	r3, [r2]
102e49a8:	ea000006 	b	102e49c8 <ql_InitVFunc+0x9c>
102e49ac:	e59f2048 	ldr	r2, [pc, #72]	; 102e49fc <ql_InitVFunc+0xd0>
102e49b0:	e590100c 	ldr	r1, [r0, #12]
102e49b4:	e3530004 	cmp	r3, #4
102e49b8:	e5821000 	str	r1, [r2]
102e49bc:	15902010 	ldrne	r2, [r0, #16]
102e49c0:	1a000005 	bne	102e49dc <ql_InitVFunc+0xb0>
102e49c4:	ea000003 	b	102e49d8 <ql_InitVFunc+0xac>
102e49c8:	e59f302c 	ldr	r3, [pc, #44]	; 102e49fc <ql_InitVFunc+0xd0>
102e49cc:	e3a02000 	mov	r2, #0
102e49d0:	e5832000 	str	r2, [r3]
102e49d4:	eaffffff 	b	102e49d8 <ql_InitVFunc+0xac>
102e49d8:	e3a02000 	mov	r2, #0
102e49dc:	e59f301c 	ldr	r3, [pc, #28]	; 102e4a00 <ql_InitVFunc+0xd4>
102e49e0:	e5832000 	str	r2, [r3]
102e49e4:	e12fff1e 	bx	lr
102e49e8:	f03daa28 	.word	0xf03daa28
102e49ec:	f03daa24 	.word	0xf03daa24
102e49f0:	f03daa08 	.word	0xf03daa08
102e49f4:	f03de544 	.word	0xf03de544
102e49f8:	f03de540 	.word	0xf03de540
102e49fc:	f03de53c 	.word	0xf03de53c
102e4a00:	f03de548 	.word	0xf03de548

Disassembly of section .text.ocpu_main:

102e4a04 <ocpu_main>:
102e4a04:	e92d4010 	push	{r4, lr}
102e4a08:	e24dd020 	sub	sp, sp, #32
102e4a0c:	e1a04000 	mov	r4, r0
102e4a10:	e3a01000 	mov	r1, #0
102e4a14:	e3a0201e 	mov	r2, #30
102e4a18:	e59f30ac 	ldr	r3, [pc, #172]	; 102e4acc <ocpu_main+0xc8>
102e4a1c:	e1a0000d 	mov	r0, sp
102e4a20:	e12fff33 	blx	r3
102e4a24:	e5d42000 	ldrb	r2, [r4]
102e4a28:	e59f10a0 	ldr	r1, [pc, #160]	; 102e4ad0 <ocpu_main+0xcc>
102e4a2c:	e5943004 	ldr	r3, [r4, #4]
102e4a30:	e3520000 	cmp	r2, #0
102e4a34:	e5c12004 	strb	r2, [r1, #4]
102e4a38:	e5813008 	str	r3, [r1, #8]
102e4a3c:	1a000004 	bne	102e4a54 <ocpu_main+0x50>
102e4a40:	e59f208c 	ldr	r2, [pc, #140]	; 102e4ad4 <ocpu_main+0xd0>
102e4a44:	e59f008c 	ldr	r0, [pc, #140]	; 102e4ad8 <ocpu_main+0xd4>
102e4a48:	e1a01003 	mov	r1, r3
102e4a4c:	e5922000 	ldr	r2, [r2]
102e4a50:	e12fff33 	blx	r3
102e4a54:	e5940008 	ldr	r0, [r4, #8]
102e4a58:	e3500000 	cmp	r0, #0
102e4a5c:	0a000002 	beq	102e4a6c <ocpu_main+0x68>
102e4a60:	e59f3074 	ldr	r3, [pc, #116]	; 102e4adc <ocpu_main+0xd8>
102e4a64:	e12fff33 	blx	r3
102e4a68:	ea000003 	b	102e4a7c <ocpu_main+0x78>
102e4a6c:	e59f305c 	ldr	r3, [pc, #92]	; 102e4ad0 <ocpu_main+0xcc>
102e4a70:	e59f0068 	ldr	r0, [pc, #104]	; 102e4ae0 <ocpu_main+0xdc>
102e4a74:	e5933008 	ldr	r3, [r3, #8]
102e4a78:	e12fff33 	blx	r3
102e4a7c:	e3a0201e 	mov	r2, #30
102e4a80:	e1a0000d 	mov	r0, sp
102e4a84:	e3a01000 	mov	r1, #0
102e4a88:	e59f3054 	ldr	r3, [pc, #84]	; 102e4ae4 <ocpu_main+0xe0>
102e4a8c:	e12fff33 	blx	r3
102e4a90:	e1a0000d 	mov	r0, sp
102e4a94:	e3a0101e 	mov	r1, #30
102e4a98:	e59f3048 	ldr	r3, [pc, #72]	; 102e4ae8 <ocpu_main+0xe4>
102e4a9c:	e12fff33 	blx	r3
102e4aa0:	e59f3028 	ldr	r3, [pc, #40]	; 102e4ad0 <ocpu_main+0xcc>
102e4aa4:	e1a0100d 	mov	r1, sp
102e4aa8:	e5933008 	ldr	r3, [r3, #8]
102e4aac:	e59f0038 	ldr	r0, [pc, #56]	; 102e4aec <ocpu_main+0xe8>
102e4ab0:	e12fff33 	blx	r3
102e4ab4:	e59f3034 	ldr	r3, [pc, #52]	; 102e4af0 <ocpu_main+0xec>
102e4ab8:	e5932000 	ldr	r2, [r3]
102e4abc:	e5930004 	ldr	r0, [r3, #4]
102e4ac0:	e12fff32 	blx	r2
102e4ac4:	e28dd020 	add	sp, sp, #32
102e4ac8:	e8bd8010 	pop	{r4, pc}
102e4acc:	102df9d5 	.word	0x102df9d5
102e4ad0:	f03daa28 	.word	0xf03daa28
102e4ad4:	f03de544 	.word	0xf03de544
102e4ad8:	102f0644 	.word	0x102f0644
102e4adc:	102e492c 	.word	0x102e492c
102e4ae0:	102f067b 	.word	0x102f067b
102e4ae4:	102e58f4 	.word	0x102e58f4
102e4ae8:	102e5bf0 	.word	0x102e5bf0
102e4aec:	102f0695 	.word	0x102f0695
102e4af0:	102e717c 	.word	0x102e717c

Disassembly of section .text.proc_reserved2:

102e4af4 <proc_reserved2>:
102e4af4:	e59f3054 	ldr	r3, [pc, #84]	; 102e4b50 <proc_reserved2+0x5c>
102e4af8:	e92d4030 	push	{r4, r5, lr}
102e4afc:	e5830000 	str	r0, [r3]
102e4b00:	e59f404c 	ldr	r4, [pc, #76]	; 102e4b54 <proc_reserved2+0x60>
102e4b04:	e59f304c 	ldr	r3, [pc, #76]	; 102e4b58 <proc_reserved2+0x64>
102e4b08:	e59f504c 	ldr	r5, [pc, #76]	; 102e4b5c <proc_reserved2+0x68>
102e4b0c:	e3a02001 	mov	r2, #1
102e4b10:	e24dd014 	sub	sp, sp, #20
102e4b14:	e5c32000 	strb	r2, [r3]
102e4b18:	e1a0000d 	mov	r0, sp
102e4b1c:	e12fff34 	blx	r4
102e4b20:	e59d3000 	ldr	r3, [sp]
102e4b24:	e3530002 	cmp	r3, #2
102e4b28:	1afffffa 	bne	102e4b18 <proc_reserved2+0x24>
102e4b2c:	e59d0008 	ldr	r0, [sp, #8]
102e4b30:	e3a01000 	mov	r1, #0
102e4b34:	e12fff35 	blx	r5
102e4b38:	e59d0008 	ldr	r0, [sp, #8]
102e4b3c:	e3500000 	cmp	r0, #0
102e4b40:	0afffff4 	beq	102e4b18 <proc_reserved2+0x24>
102e4b44:	e59f3014 	ldr	r3, [pc, #20]	; 102e4b60 <proc_reserved2+0x6c>
102e4b48:	e12fff33 	blx	r3
102e4b4c:	eafffff1 	b	102e4b18 <proc_reserved2+0x24>
102e4b50:	f03d4750 	.word	0xf03d4750
102e4b54:	102e5c54 	.word	0x102e5c54
102e4b58:	f03daa38 	.word	0xf03daa38
102e4b5c:	102ccc08 	.word	0x102ccc08
102e4b60:	102e48b8 	.word	0x102e48b8

Disassembly of section .text.ril_StopATTimer:

102e4b64 <ril_StopATTimer>:
102e4b64:	e92d4008 	push	{r3, lr}
102e4b68:	e59f3020 	ldr	r3, [pc, #32]	; 102e4b90 <ril_StopATTimer+0x2c>
102e4b6c:	e5d30009 	ldrb	r0, [r3, #9]
102e4b70:	e3500000 	cmp	r0, #0
102e4b74:	08bd8008 	popeq	{r3, pc}
102e4b78:	e3a02000 	mov	r2, #0
102e4b7c:	e5c32009 	strb	r2, [r3, #9]
102e4b80:	e5930000 	ldr	r0, [r3]
102e4b84:	e59f3008 	ldr	r3, [pc, #8]	; 102e4b94 <ril_StopATTimer+0x30>
102e4b88:	e12fff33 	blx	r3
102e4b8c:	e8bd8008 	pop	{r3, pc}
102e4b90:	f03d4754 	.word	0xf03d4754
102e4b94:	102e60f0 	.word	0x102e60f0

Disassembly of section .text.Callback_OnATTimer:

102e4b98 <Callback_OnATTimer>:
102e4b98:	e92d4008 	push	{r3, lr}
102e4b9c:	e59f3030 	ldr	r3, [pc, #48]	; 102e4bd4 <Callback_OnATTimer+0x3c>
102e4ba0:	e5d33009 	ldrb	r3, [r3, #9]
102e4ba4:	e3530000 	cmp	r3, #0
102e4ba8:	08bd8008 	popeq	{r3, pc}
102e4bac:	e59f3024 	ldr	r3, [pc, #36]	; 102e4bd8 <Callback_OnATTimer+0x40>
102e4bb0:	e12fff33 	blx	r3
102e4bb4:	e59f3020 	ldr	r3, [pc, #32]	; 102e4bdc <Callback_OnATTimer+0x44>
102e4bb8:	e3e02001 	mvn	r2, #1
102e4bbc:	e5832000 	str	r2, [r3]
102e4bc0:	e5930004 	ldr	r0, [r3, #4]
102e4bc4:	e3a01001 	mov	r1, #1
102e4bc8:	e59f3010 	ldr	r3, [pc, #16]	; 102e4be0 <Callback_OnATTimer+0x48>
102e4bcc:	e12fff33 	blx	r3
102e4bd0:	e8bd8008 	pop	{r3, pc}
102e4bd4:	f03d4754 	.word	0xf03d4754
102e4bd8:	102e4b64 	.word	0x102e4b64
102e4bdc:	f03daa3c 	.word	0xf03daa3c
102e4be0:	102e5ee4 	.word	0x102e5ee4

Disassembly of section .text.CallBack_SerialPort_Hdlr:

102e4be4 <CallBack_SerialPort_Hdlr>:
102e4be4:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
102e4be8:	e2515000 	subs	r5, r1, #0
102e4bec:	18bd8ff8 	popne	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102e4bf0:	e3500002 	cmp	r0, #2
102e4bf4:	18bd8ff8 	popne	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102e4bf8:	e59f030c 	ldr	r0, [pc, #780]	; 102e4f0c <CallBack_SerialPort_Hdlr+0x328>
102e4bfc:	e3a02b02 	mov	r2, #2048	; 0x800
102e4c00:	e59f3308 	ldr	r3, [pc, #776]	; 102e4f10 <CallBack_SerialPort_Hdlr+0x32c>
102e4c04:	e12fff33 	blx	r3
102e4c08:	e59f72fc 	ldr	r7, [pc, #764]	; 102e4f0c <CallBack_SerialPort_Hdlr+0x328>
102e4c0c:	e59f8300 	ldr	r8, [pc, #768]	; 102e4f14 <CallBack_SerialPort_Hdlr+0x330>
102e4c10:	e3a00002 	mov	r0, #2
102e4c14:	e0871005 	add	r1, r7, r5
102e4c18:	e2652b02 	rsb	r2, r5, #2048	; 0x800
102e4c1c:	e12fff38 	blx	r8
102e4c20:	e59f42f0 	ldr	r4, [pc, #752]	; 102e4f18 <CallBack_SerialPort_Hdlr+0x334>
102e4c24:	e2846008 	add	r6, r4, #8
102e4c28:	e3500000 	cmp	r0, #0
102e4c2c:	c0855000 	addgt	r5, r5, r0
102e4c30:	cafffff6 	bgt	102e4c10 <CallBack_SerialPort_Hdlr+0x2c>
102e4c34:	18bd8ff8 	popne	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102e4c38:	e3550000 	cmp	r5, #0
102e4c3c:	08bd8ff8 	popeq	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102e4c40:	e5845808 	str	r5, [r4, #2056]	; 0x808
102e4c44:	e0845005 	add	r5, r4, r5
102e4c48:	e5c50008 	strb	r0, [r5, #8]
102e4c4c:	e3a01001 	mov	r1, #1
102e4c50:	e3a00002 	mov	r0, #2
102e4c54:	e59f32c0 	ldr	r3, [pc, #704]	; 102e4f1c <CallBack_SerialPort_Hdlr+0x338>
102e4c58:	e584680c 	str	r6, [r4, #2060]	; 0x80c
102e4c5c:	e12fff33 	blx	r3
102e4c60:	e2502000 	subs	r2, r0, #0
102e4c64:	159f82a4 	ldrne	r8, [pc, #676]	; 102e4f10 <CallBack_SerialPort_Hdlr+0x32c>
102e4c68:	1a000004 	bne	102e4c80 <CallBack_SerialPort_Hdlr+0x9c>
102e4c6c:	e594080c 	ldr	r0, [r4, #2060]	; 0x80c
102e4c70:	e5941808 	ldr	r1, [r4, #2056]	; 0x808
102e4c74:	e59f32a4 	ldr	r3, [pc, #676]	; 102e4f20 <CallBack_SerialPort_Hdlr+0x33c>
102e4c78:	e12fff33 	blx	r3
102e4c7c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102e4c80:	e594680c 	ldr	r6, [r4, #2060]	; 0x80c
102e4c84:	e59f2298 	ldr	r2, [pc, #664]	; 102e4f24 <CallBack_SerialPort_Hdlr+0x340>
102e4c88:	e3a01000 	mov	r1, #0
102e4c8c:	e5940810 	ldr	r0, [r4, #2064]	; 0x810
102e4c90:	e5949808 	ldr	r9, [r4, #2056]	; 0x808
102e4c94:	e12fff38 	blx	r8
102e4c98:	e59f3288 	ldr	r3, [pc, #648]	; 102e4f28 <CallBack_SerialPort_Hdlr+0x344>
102e4c9c:	e59f1288 	ldr	r1, [pc, #648]	; 102e4f2c <CallBack_SerialPort_Hdlr+0x348>
102e4ca0:	e1a00006 	mov	r0, r6
102e4ca4:	e12fff33 	blx	r3
102e4ca8:	e59fa280 	ldr	sl, [pc, #640]	; 102e4f30 <CallBack_SerialPort_Hdlr+0x34c>
102e4cac:	e59f1278 	ldr	r1, [pc, #632]	; 102e4f2c <CallBack_SerialPort_Hdlr+0x348>
102e4cb0:	e3500000 	cmp	r0, #0
102e4cb4:	1286b002 	addne	fp, r6, #2
102e4cb8:	01a0b006 	moveq	fp, r6
102e4cbc:	e1a0000b 	mov	r0, fp
102e4cc0:	e12fff3a 	blx	sl
102e4cc4:	e59f1268 	ldr	r1, [pc, #616]	; 102e4f34 <CallBack_SerialPort_Hdlr+0x350>
102e4cc8:	e1a07000 	mov	r7, r0
102e4ccc:	e1a0000b 	mov	r0, fp
102e4cd0:	e12fff3a 	blx	sl
102e4cd4:	e59f125c 	ldr	r1, [pc, #604]	; 102e4f38 <CallBack_SerialPort_Hdlr+0x354>
102e4cd8:	e1a05000 	mov	r5, r0
102e4cdc:	e1a0000b 	mov	r0, fp
102e4ce0:	e12fff3a 	blx	sl
102e4ce4:	e2971000 	adds	r1, r7, #0
102e4ce8:	13a01001 	movne	r1, #1
102e4cec:	e2952000 	adds	r2, r5, #0
102e4cf0:	13a02001 	movne	r2, #1
102e4cf4:	e1923001 	orrs	r3, r2, r1
102e4cf8:	1a000002 	bne	102e4d08 <CallBack_SerialPort_Hdlr+0x124>
102e4cfc:	e3500000 	cmp	r0, #0
102e4d00:	1a000018 	bne	102e4d68 <CallBack_SerialPort_Hdlr+0x184>
102e4d04:	ea000027 	b	102e4da8 <CallBack_SerialPort_Hdlr+0x1c4>
102e4d08:	e3510000 	cmp	r1, #0
102e4d0c:	0a00000c 	beq	102e4d44 <CallBack_SerialPort_Hdlr+0x160>
102e4d10:	e1550007 	cmp	r5, r7
102e4d14:	83a02000 	movhi	r2, #0
102e4d18:	92022001 	andls	r2, r2, #1
102e4d1c:	e3520000 	cmp	r2, #0
102e4d20:	01a05007 	moveq	r5, r7
102e4d24:	e1500005 	cmp	r0, r5
102e4d28:	83a02000 	movhi	r2, #0
102e4d2c:	93a02001 	movls	r2, #1
102e4d30:	e3500000 	cmp	r0, #0
102e4d34:	03a02000 	moveq	r2, #0
102e4d38:	e3520000 	cmp	r2, #0
102e4d3c:	01a00005 	moveq	r0, r5
102e4d40:	ea000008 	b	102e4d68 <CallBack_SerialPort_Hdlr+0x184>
102e4d44:	e3520000 	cmp	r2, #0
102e4d48:	0a000006 	beq	102e4d68 <CallBack_SerialPort_Hdlr+0x184>
102e4d4c:	e1500005 	cmp	r0, r5
102e4d50:	83a02000 	movhi	r2, #0
102e4d54:	93a02001 	movls	r2, #1
102e4d58:	e3500000 	cmp	r0, #0
102e4d5c:	03a02000 	moveq	r2, #0
102e4d60:	e3520000 	cmp	r2, #0
102e4d64:	0a000004 	beq	102e4d7c <CallBack_SerialPort_Hdlr+0x198>
102e4d68:	e1500007 	cmp	r0, r7
102e4d6c:	00663000 	rsbeq	r3, r6, r0
102e4d70:	02835002 	addeq	r5, r3, #2
102e4d74:	0a000002 	beq	102e4d84 <CallBack_SerialPort_Hdlr+0x1a0>
102e4d78:	e1a05000 	mov	r5, r0
102e4d7c:	e0665005 	rsb	r5, r6, r5
102e4d80:	e2855001 	add	r5, r5, #1
102e4d84:	e59f31b0 	ldr	r3, [pc, #432]	; 102e4f3c <CallBack_SerialPort_Hdlr+0x358>
102e4d88:	e5940810 	ldr	r0, [r4, #2064]	; 0x810
102e4d8c:	e1a01006 	mov	r1, r6
102e4d90:	e1a02005 	mov	r2, r5
102e4d94:	e12fff33 	blx	r3
102e4d98:	e5943810 	ldr	r3, [r4, #2064]	; 0x810
102e4d9c:	e5843814 	str	r3, [r4, #2068]	; 0x814
102e4da0:	e5845818 	str	r5, [r4, #2072]	; 0x818
102e4da4:	ea000007 	b	102e4dc8 <CallBack_SerialPort_Hdlr+0x1e4>
102e4da8:	e59f318c 	ldr	r3, [pc, #396]	; 102e4f3c <CallBack_SerialPort_Hdlr+0x358>
102e4dac:	e5940810 	ldr	r0, [r4, #2064]	; 0x810
102e4db0:	e1a01006 	mov	r1, r6
102e4db4:	e1a02009 	mov	r2, r9
102e4db8:	e12fff33 	blx	r3
102e4dbc:	e5943810 	ldr	r3, [r4, #2064]	; 0x810
102e4dc0:	e5843814 	str	r3, [r4, #2068]	; 0x814
102e4dc4:	e5849818 	str	r9, [r4, #2072]	; 0x818
102e4dc8:	e5d4381c 	ldrb	r3, [r4, #2076]	; 0x81c
102e4dcc:	e3530001 	cmp	r3, #1
102e4dd0:	1a000029 	bne	102e4e7c <CallBack_SerialPort_Hdlr+0x298>
102e4dd4:	e59f0164 	ldr	r0, [pc, #356]	; 102e4f40 <CallBack_SerialPort_Hdlr+0x35c>
102e4dd8:	e5941814 	ldr	r1, [r4, #2068]	; 0x814
102e4ddc:	e5942818 	ldr	r2, [r4, #2072]	; 0x818
102e4de0:	e59f315c 	ldr	r3, [pc, #348]	; 102e4f44 <CallBack_SerialPort_Hdlr+0x360>
102e4de4:	e12fff33 	blx	r3
102e4de8:	e3500000 	cmp	r0, #0
102e4dec:	0a00003c 	beq	102e4ee4 <CallBack_SerialPort_Hdlr+0x300>
102e4df0:	e5943c20 	ldr	r3, [r4, #3104]	; 0xc20
102e4df4:	e5940814 	ldr	r0, [r4, #2068]	; 0x814
102e4df8:	e3530000 	cmp	r3, #0
102e4dfc:	059f3144 	ldreq	r3, [pc, #324]	; 102e4f48 <CallBack_SerialPort_Hdlr+0x364>
102e4e00:	e5941818 	ldr	r1, [r4, #2072]	; 0x818
102e4e04:	e5942c24 	ldr	r2, [r4, #3108]	; 0xc24
102e4e08:	e12fff33 	blx	r3
102e4e0c:	e5840c28 	str	r0, [r4, #3112]	; 0xc28
102e4e10:	e5943c28 	ldr	r3, [r4, #3112]	; 0xc28
102e4e14:	e3530001 	cmp	r3, #1
102e4e18:	0a000012 	beq	102e4e68 <CallBack_SerialPort_Hdlr+0x284>
102e4e1c:	e5942c20 	ldr	r2, [r4, #3104]	; 0xc20
102e4e20:	e3520000 	cmp	r2, #0
102e4e24:	13a02000 	movne	r2, #0
102e4e28:	15842c20 	strne	r2, [r4, #3104]	; 0xc20
102e4e2c:	e3530000 	cmp	r3, #0
102e4e30:	0a000001 	beq	102e4e3c <CallBack_SerialPort_Hdlr+0x258>
102e4e34:	e3730001 	cmn	r3, #1
102e4e38:	1a000001 	bne	102e4e44 <CallBack_SerialPort_Hdlr+0x260>
102e4e3c:	e59f20d4 	ldr	r2, [pc, #212]	; 102e4f18 <CallBack_SerialPort_Hdlr+0x334>
102e4e40:	e5823000 	str	r3, [r2]
102e4e44:	e59f3100 	ldr	r3, [pc, #256]	; 102e4f4c <CallBack_SerialPort_Hdlr+0x368>
102e4e48:	e12fff33 	blx	r3
102e4e4c:	e59f30fc 	ldr	r3, [pc, #252]	; 102e4f50 <CallBack_SerialPort_Hdlr+0x36c>
102e4e50:	e5940004 	ldr	r0, [r4, #4]
102e4e54:	e3a01001 	mov	r1, #1
102e4e58:	e12fff33 	blx	r3
102e4e5c:	e3a03000 	mov	r3, #0
102e4e60:	e5c4381c 	strb	r3, [r4, #2076]	; 0x81c
102e4e64:	ea00001e 	b	102e4ee4 <CallBack_SerialPort_Hdlr+0x300>
102e4e68:	e5940814 	ldr	r0, [r4, #2068]	; 0x814
102e4e6c:	e59f30e0 	ldr	r3, [pc, #224]	; 102e4f54 <CallBack_SerialPort_Hdlr+0x370>
102e4e70:	e12fff33 	blx	r3
102e4e74:	e3500000 	cmp	r0, #0
102e4e78:	0a000019 	beq	102e4ee4 <CallBack_SerialPort_Hdlr+0x300>
102e4e7c:	e59f30d4 	ldr	r3, [pc, #212]	; 102e4f58 <CallBack_SerialPort_Hdlr+0x374>
102e4e80:	e5d33000 	ldrb	r3, [r3]
102e4e84:	e3530000 	cmp	r3, #0
102e4e88:	0a000015 	beq	102e4ee4 <CallBack_SerialPort_Hdlr+0x300>
102e4e8c:	e5945818 	ldr	r5, [r4, #2072]	; 0x818
102e4e90:	e59f30c4 	ldr	r3, [pc, #196]	; 102e4f5c <CallBack_SerialPort_Hdlr+0x378>
102e4e94:	e2857001 	add	r7, r5, #1
102e4e98:	e1a00007 	mov	r0, r7
102e4e9c:	e12fff33 	blx	r3
102e4ea0:	e2506000 	subs	r6, r0, #0
102e4ea4:	0a00000e 	beq	102e4ee4 <CallBack_SerialPort_Hdlr+0x300>
102e4ea8:	e3a01000 	mov	r1, #0
102e4eac:	e1a02007 	mov	r2, r7
102e4eb0:	e12fff38 	blx	r8
102e4eb4:	e5941814 	ldr	r1, [r4, #2068]	; 0x814
102e4eb8:	e1a02005 	mov	r2, r5
102e4ebc:	e59f3078 	ldr	r3, [pc, #120]	; 102e4f3c <CallBack_SerialPort_Hdlr+0x358>
102e4ec0:	e1a00006 	mov	r0, r6
102e4ec4:	e12fff33 	blx	r3
102e4ec8:	e59f3090 	ldr	r3, [pc, #144]	; 102e4f60 <CallBack_SerialPort_Hdlr+0x37c>
102e4ecc:	e3a01002 	mov	r1, #2
102e4ed0:	e5930000 	ldr	r0, [r3]
102e4ed4:	e1a02005 	mov	r2, r5
102e4ed8:	e1a03006 	mov	r3, r6
102e4edc:	e59fc080 	ldr	ip, [pc, #128]	; 102e4f64 <CallBack_SerialPort_Hdlr+0x380>
102e4ee0:	e12fff3c 	blx	ip
102e4ee4:	e5943818 	ldr	r3, [r4, #2072]	; 0x818
102e4ee8:	e594280c 	ldr	r2, [r4, #2060]	; 0x80c
102e4eec:	e0822003 	add	r2, r2, r3
102e4ef0:	e584280c 	str	r2, [r4, #2060]	; 0x80c
102e4ef4:	e5942808 	ldr	r2, [r4, #2056]	; 0x808
102e4ef8:	e0633002 	rsb	r3, r3, r2
102e4efc:	e3530000 	cmp	r3, #0
102e4f00:	e5843808 	str	r3, [r4, #2056]	; 0x808
102e4f04:	1affff5d 	bne	102e4c80 <CallBack_SerialPort_Hdlr+0x9c>
102e4f08:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102e4f0c:	f03daa44 	.word	0xf03daa44
102e4f10:	102e58f4 	.word	0x102e58f4
102e4f14:	102e62a0 	.word	0x102e62a0
102e4f18:	f03daa3c 	.word	0xf03daa3c
102e4f1c:	102e6364 	.word	0x102e6364
102e4f20:	102c9fcc 	.word	0x102c9fcc
102e4f24:	00000801 	.word	0x00000801
102e4f28:	102ccd58 	.word	0x102ccd58
102e4f2c:	102f0692 	.word	0x102f0692
102e4f30:	102e5a04 	.word	0x102e5a04
102e4f34:	102f06b4 	.word	0x102f06b4
102e4f38:	102f0693 	.word	0x102f0693
102e4f3c:	102e597c 	.word	0x102e597c
102e4f40:	f03db259 	.word	0xf03db259
102e4f44:	102e5884 	.word	0x102e5884
102e4f48:	102c7094 	.word	0x102c7094
102e4f4c:	102e4b64 	.word	0x102e4b64
102e4f50:	102e5ee4 	.word	0x102e5ee4
102e4f54:	102cccd8 	.word	0x102cccd8
102e4f58:	f03daa38 	.word	0xf03daa38
102e4f5c:	102e4840 	.word	0x102e4840
102e4f60:	f03d4750 	.word	0xf03d4750
102e4f64:	102e5cb4 	.word	0x102e5cb4

Disassembly of section .text.proc_reserved1:

102e4f68 <proc_reserved1>:
102e4f68:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102e4f6c:	e59f118c 	ldr	r1, [pc, #396]	; 102e5100 <proc_reserved1+0x198>
102e4f70:	e24dd014 	sub	sp, sp, #20
102e4f74:	e1a04000 	mov	r4, r0
102e4f78:	e3a02000 	mov	r2, #0
102e4f7c:	e59f3180 	ldr	r3, [pc, #384]	; 102e5104 <proc_reserved1+0x19c>
102e4f80:	e3a00002 	mov	r0, #2
102e4f84:	e12fff33 	blx	r3
102e4f88:	e59f5178 	ldr	r5, [pc, #376]	; 102e5108 <proc_reserved1+0x1a0>
102e4f8c:	e3a01000 	mov	r1, #0
102e4f90:	e3a02001 	mov	r2, #1
102e4f94:	e59f3170 	ldr	r3, [pc, #368]	; 102e510c <proc_reserved1+0x1a4>
102e4f98:	e3a00002 	mov	r0, #2
102e4f9c:	e12fff33 	blx	r3
102e4fa0:	e59f3168 	ldr	r3, [pc, #360]	; 102e5110 <proc_reserved1+0x1a8>
102e4fa4:	e59f0168 	ldr	r0, [pc, #360]	; 102e5114 <proc_reserved1+0x1ac>
102e4fa8:	e585400c 	str	r4, [r5, #12]
102e4fac:	e12fff33 	blx	r3
102e4fb0:	e59f4160 	ldr	r4, [pc, #352]	; 102e5118 <proc_reserved1+0x1b0>
102e4fb4:	e59f3160 	ldr	r3, [pc, #352]	; 102e511c <proc_reserved1+0x1b4>
102e4fb8:	e1a06004 	mov	r6, r4
102e4fbc:	e5840c30 	str	r0, [r4, #3120]	; 0xc30
102e4fc0:	e59f0158 	ldr	r0, [pc, #344]	; 102e5120 <proc_reserved1+0x1b8>
102e4fc4:	e12fff33 	blx	r3
102e4fc8:	e59f1154 	ldr	r1, [pc, #340]	; 102e5124 <proc_reserved1+0x1bc>
102e4fcc:	e3a02000 	mov	r2, #0
102e4fd0:	e59f3150 	ldr	r3, [pc, #336]	; 102e5128 <proc_reserved1+0x1c0>
102e4fd4:	e5840004 	str	r0, [r4, #4]
102e4fd8:	e5950000 	ldr	r0, [r5]
102e4fdc:	e12fff33 	blx	r3
102e4fe0:	e3a00000 	mov	r0, #0
102e4fe4:	e59f1140 	ldr	r1, [pc, #320]	; 102e512c <proc_reserved1+0x1c4>
102e4fe8:	e1a02000 	mov	r2, r0
102e4fec:	e1a03000 	mov	r3, r0
102e4ff0:	e59fc138 	ldr	ip, [pc, #312]	; 102e5130 <proc_reserved1+0x1c8>
102e4ff4:	e12fff3c 	blx	ip
102e4ff8:	e59f0134 	ldr	r0, [pc, #308]	; 102e5134 <proc_reserved1+0x1cc>
102e4ffc:	e59f3134 	ldr	r3, [pc, #308]	; 102e5138 <proc_reserved1+0x1d0>
102e5000:	e12fff33 	blx	r3
102e5004:	e5840810 	str	r0, [r4, #2064]	; 0x810
102e5008:	e1a0000d 	mov	r0, sp
102e500c:	e59f3128 	ldr	r3, [pc, #296]	; 102e513c <proc_reserved1+0x1d4>
102e5010:	e12fff33 	blx	r3
102e5014:	e59d5000 	ldr	r5, [sp]
102e5018:	e3550001 	cmp	r5, #1
102e501c:	1afffff9 	bne	102e5008 <proc_reserved1+0xa0>
102e5020:	e59f0118 	ldr	r0, [pc, #280]	; 102e5140 <proc_reserved1+0x1d8>
102e5024:	e59f1118 	ldr	r1, [pc, #280]	; 102e5144 <proc_reserved1+0x1dc>
102e5028:	e3a02004 	mov	r2, #4
102e502c:	e59f3114 	ldr	r3, [pc, #276]	; 102e5148 <proc_reserved1+0x1e0>
102e5030:	e12fff33 	blx	r3
102e5034:	e2507000 	subs	r7, r0, #0
102e5038:	1a00000e 	bne	102e5078 <proc_reserved1+0x110>
102e503c:	e3a00002 	mov	r0, #2
102e5040:	e59f3104 	ldr	r3, [pc, #260]	; 102e514c <proc_reserved1+0x1e4>
102e5044:	e12fff33 	blx	r3
102e5048:	e5847000 	str	r7, [r4]
102e504c:	e3500000 	cmp	r0, #0
102e5050:	aa000003 	bge	102e5064 <proc_reserved1+0xfc>
102e5054:	e59f30f4 	ldr	r3, [pc, #244]	; 102e5150 <proc_reserved1+0x1e8>
102e5058:	e12fff33 	blx	r3
102e505c:	e3e03000 	mvn	r3, #0
102e5060:	e5843000 	str	r3, [r4]
102e5064:	e5960004 	ldr	r0, [r6, #4]
102e5068:	e3a01001 	mov	r1, #1
102e506c:	e59f30e0 	ldr	r3, [pc, #224]	; 102e5154 <proc_reserved1+0x1ec>
102e5070:	e12fff33 	blx	r3
102e5074:	eaffffe3 	b	102e5008 <proc_reserved1+0xa0>
102e5078:	e59f30d8 	ldr	r3, [pc, #216]	; 102e5158 <proc_reserved1+0x1f0>
102e507c:	e59f00bc 	ldr	r0, [pc, #188]	; 102e5140 <proc_reserved1+0x1d8>
102e5080:	e12fff33 	blx	r3
102e5084:	e59f10b4 	ldr	r1, [pc, #180]	; 102e5140 <proc_reserved1+0x1d8>
102e5088:	e59f30cc 	ldr	r3, [pc, #204]	; 102e515c <proc_reserved1+0x1f4>
102e508c:	e1a02000 	mov	r2, r0
102e5090:	e3a00002 	mov	r0, #2
102e5094:	e12fff33 	blx	r3
102e5098:	e3500000 	cmp	r0, #0
102e509c:	aa000007 	bge	102e50c0 <proc_reserved1+0x158>
102e50a0:	e59f30a8 	ldr	r3, [pc, #168]	; 102e5150 <proc_reserved1+0x1e8>
102e50a4:	e12fff33 	blx	r3
102e50a8:	e3e03000 	mvn	r3, #0
102e50ac:	e5843000 	str	r3, [r4]
102e50b0:	e5940004 	ldr	r0, [r4, #4]
102e50b4:	e1a01005 	mov	r1, r5
102e50b8:	e59f3094 	ldr	r3, [pc, #148]	; 102e5154 <proc_reserved1+0x1ec>
102e50bc:	e12fff33 	blx	r3
102e50c0:	e59f2040 	ldr	r2, [pc, #64]	; 102e5108 <proc_reserved1+0x1a0>
102e50c4:	e5923004 	ldr	r3, [r2, #4]
102e50c8:	e3530000 	cmp	r3, #0
102e50cc:	059f308c 	ldreq	r3, [pc, #140]	; 102e5160 <proc_reserved1+0x1f8>
102e50d0:	05823004 	streq	r3, [r2, #4]
102e50d4:	e5d22009 	ldrb	r2, [r2, #9]
102e50d8:	e59f3028 	ldr	r3, [pc, #40]	; 102e5108 <proc_reserved1+0x1a0>
102e50dc:	e3520001 	cmp	r2, #1
102e50e0:	0affffc8 	beq	102e5008 <proc_reserved1+0xa0>
102e50e4:	e3a02001 	mov	r2, #1
102e50e8:	e5c32009 	strb	r2, [r3, #9]
102e50ec:	e8930003 	ldm	r3, {r0, r1}
102e50f0:	e5d32008 	ldrb	r2, [r3, #8]
102e50f4:	e59f3068 	ldr	r3, [pc, #104]	; 102e5164 <proc_reserved1+0x1fc>
102e50f8:	e12fff33 	blx	r3
102e50fc:	eaffffc1 	b	102e5008 <proc_reserved1+0xa0>
102e5100:	102e4be4 	.word	0x102e4be4
102e5104:	102e6150 	.word	0x102e6150
102e5108:	f03d4754 	.word	0xf03d4754
102e510c:	102e61c0 	.word	0x102e61c0
102e5110:	102e5d2c 	.word	0x102e5d2c
102e5114:	102f069a 	.word	0x102f069a
102e5118:	f03daa3c 	.word	0xf03daa3c
102e511c:	102e5e28 	.word	0x102e5e28
102e5120:	102f06a4 	.word	0x102f06a4
102e5124:	102e4b98 	.word	0x102e4b98
102e5128:	102e6010 	.word	0x102e6010
102e512c:	00001001 	.word	0x00001001
102e5130:	102e5cb4 	.word	0x102e5cb4
102e5134:	00000801 	.word	0x00000801
102e5138:	102e4840 	.word	0x102e4840
102e513c:	102e5c54 	.word	0x102e5c54
102e5140:	f03db259 	.word	0xf03db259
102e5144:	102f06b1 	.word	0x102f06b1
102e5148:	102e5884 	.word	0x102e5884
102e514c:	102e63cc 	.word	0x102e63cc
102e5150:	102e4b64 	.word	0x102e4b64
102e5154:	102e5ee4 	.word	0x102e5ee4
102e5158:	102e57a4 	.word	0x102e57a4
102e515c:	102e6230 	.word	0x102e6230
102e5160:	0002bf20 	.word	0x0002bf20
102e5164:	102e6080 	.word	0x102e6080

Disassembly of section .text.Ql_RIL_SendATCmd:

102e5168 <Ql_RIL_SendATCmd>:
102e5168:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
102e516c:	e1a04000 	mov	r4, r0
102e5170:	e1a08003 	mov	r8, r3
102e5174:	e3e00000 	mvn	r0, #0
102e5178:	e59f31f4 	ldr	r3, [pc, #500]	; 102e5374 <Ql_RIL_SendATCmd+0x20c>
102e517c:	e1a07002 	mov	r7, r2
102e5180:	e12fff33 	blx	r3
102e5184:	e59f31ec 	ldr	r3, [pc, #492]	; 102e5378 <Ql_RIL_SendATCmd+0x210>
102e5188:	e5d33c2c 	ldrb	r3, [r3, #3116]	; 0xc2c
102e518c:	e3530000 	cmp	r3, #0
102e5190:	0a000059 	beq	102e52fc <Ql_RIL_SendATCmd+0x194>
102e5194:	e3540000 	cmp	r4, #0
102e5198:	13a03000 	movne	r3, #0
102e519c:	159f21d8 	ldrne	r2, [pc, #472]	; 102e537c <Ql_RIL_SendATCmd+0x214>
102e51a0:	1a000001 	bne	102e51ac <Ql_RIL_SendATCmd+0x44>
102e51a4:	e3e06003 	mvn	r6, #3
102e51a8:	ea00006f 	b	102e536c <Ql_RIL_SendATCmd+0x204>
102e51ac:	e5d40000 	ldrb	r0, [r4]
102e51b0:	e7d31002 	ldrb	r1, [r3, r2]
102e51b4:	e1500001 	cmp	r0, r1
102e51b8:	0afffff9 	beq	102e51a4 <Ql_RIL_SendATCmd+0x3c>
102e51bc:	e2833001 	add	r3, r3, #1
102e51c0:	e3530004 	cmp	r3, #4
102e51c4:	1afffff8 	bne	102e51ac <Ql_RIL_SendATCmd+0x44>
102e51c8:	ea00004f 	b	102e530c <Ql_RIL_SendATCmd+0x1a4>
102e51cc:	e1a00004 	mov	r0, r4
102e51d0:	e59f11a8 	ldr	r1, [pc, #424]	; 102e5380 <Ql_RIL_SendATCmd+0x218>
102e51d4:	e12fff35 	blx	r5
102e51d8:	e59f61a4 	ldr	r6, [pc, #420]	; 102e5384 <Ql_RIL_SendATCmd+0x21c>
102e51dc:	e3a05000 	mov	r5, #0
102e51e0:	e59fa1a0 	ldr	sl, [pc, #416]	; 102e5388 <Ql_RIL_SendATCmd+0x220>
102e51e4:	e59f91a0 	ldr	r9, [pc, #416]	; 102e538c <Ql_RIL_SendATCmd+0x224>
102e51e8:	e3500000 	cmp	r0, #0
102e51ec:	13a03000 	movne	r3, #0
102e51f0:	15c03000 	strbne	r3, [r0]
102e51f4:	ea000005 	b	102e5210 <Ql_RIL_SendATCmd+0xa8>
102e51f8:	e1a00004 	mov	r0, r4
102e51fc:	e79a1105 	ldr	r1, [sl, r5, lsl #2]
102e5200:	e12fff39 	blx	r9
102e5204:	e3500000 	cmp	r0, #0
102e5208:	1a00003d 	bne	102e5304 <Ql_RIL_SendATCmd+0x19c>
102e520c:	e2855001 	add	r5, r5, #1
102e5210:	e12fff36 	blx	r6
102e5214:	e1550000 	cmp	r5, r0
102e5218:	3afffff6 	bcc	102e51f8 <Ql_RIL_SendATCmd+0x90>
102e521c:	ea000042 	b	102e532c <Ql_RIL_SendATCmd+0x1c4>
102e5220:	e1a00004 	mov	r0, r4
102e5224:	e59f1164 	ldr	r1, [pc, #356]	; 102e5390 <Ql_RIL_SendATCmd+0x228>
102e5228:	e59f3164 	ldr	r3, [pc, #356]	; 102e5394 <Ql_RIL_SendATCmd+0x22c>
102e522c:	e12fff33 	blx	r3
102e5230:	e59f9160 	ldr	r9, [pc, #352]	; 102e5398 <Ql_RIL_SendATCmd+0x230>
102e5234:	e59fb160 	ldr	fp, [pc, #352]	; 102e539c <Ql_RIL_SendATCmd+0x234>
102e5238:	e3500000 	cmp	r0, #0
102e523c:	0a00000b 	beq	102e5270 <Ql_RIL_SendATCmd+0x108>
102e5240:	e0646000 	rsb	r6, r4, r0
102e5244:	e1a01004 	mov	r1, r4
102e5248:	e1a02006 	mov	r2, r6
102e524c:	e1a00005 	mov	r0, r5
102e5250:	e12fff39 	blx	r9
102e5254:	e1a00005 	mov	r0, r5
102e5258:	e12fff3b 	blx	fp
102e525c:	e0850006 	add	r0, r5, r6
102e5260:	e0841006 	add	r1, r4, r6
102e5264:	e066200a 	rsb	r2, r6, sl
102e5268:	e12fff39 	blx	r9
102e526c:	ea000005 	b	102e5288 <Ql_RIL_SendATCmd+0x120>
102e5270:	e1a00005 	mov	r0, r5
102e5274:	e1a01004 	mov	r1, r4
102e5278:	e1a0200a 	mov	r2, sl
102e527c:	e12fff39 	blx	r9
102e5280:	e1a00005 	mov	r0, r5
102e5284:	e12fff3b 	blx	fp
102e5288:	e59f40e8 	ldr	r4, [pc, #232]	; 102e5378 <Ql_RIL_SendATCmd+0x210>
102e528c:	e3a0300d 	mov	r3, #13
102e5290:	e084a00a 	add	sl, r4, sl
102e5294:	e5ca381d 	strb	r3, [sl, #2077]	; 0x81d
102e5298:	e59f3100 	ldr	r3, [pc, #256]	; 102e53a0 <Ql_RIL_SendATCmd+0x238>
102e529c:	e3a05000 	mov	r5, #0
102e52a0:	e3a06001 	mov	r6, #1
102e52a4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
102e52a8:	e5832004 	str	r2, [r3, #4]
102e52ac:	e1a01006 	mov	r1, r6
102e52b0:	e1a02005 	mov	r2, r5
102e52b4:	e59fc0e8 	ldr	ip, [pc, #232]	; 102e53a4 <Ql_RIL_SendATCmd+0x23c>
102e52b8:	e593000c 	ldr	r0, [r3, #12]
102e52bc:	e1a03005 	mov	r3, r5
102e52c0:	e5c4681c 	strb	r6, [r4, #2076]	; 0x81c
102e52c4:	e5ca581e 	strb	r5, [sl, #2078]	; 0x81e
102e52c8:	e5848c24 	str	r8, [r4, #3108]	; 0xc24
102e52cc:	e5847c20 	str	r7, [r4, #3104]	; 0xc20
102e52d0:	e12fff3c 	blx	ip
102e52d4:	e1a01006 	mov	r1, r6
102e52d8:	e59f30c8 	ldr	r3, [pc, #200]	; 102e53a8 <Ql_RIL_SendATCmd+0x240>
102e52dc:	e5940004 	ldr	r0, [r4, #4]
102e52e0:	e12fff33 	blx	r3
102e52e4:	e5940c30 	ldr	r0, [r4, #3120]	; 0xc30
102e52e8:	e59f30bc 	ldr	r3, [pc, #188]	; 102e53ac <Ql_RIL_SendATCmd+0x244>
102e52ec:	e5946000 	ldr	r6, [r4]
102e52f0:	e12fff33 	blx	r3
102e52f4:	e5c4581c 	strb	r5, [r4, #2076]	; 0x81c
102e52f8:	ea00001b 	b	102e536c <Ql_RIL_SendATCmd+0x204>
102e52fc:	e3e06004 	mvn	r6, #4
102e5300:	ea000019 	b	102e536c <Ql_RIL_SendATCmd+0x204>
102e5304:	e59f60a4 	ldr	r6, [pc, #164]	; 102e53b0 <Ql_RIL_SendATCmd+0x248>
102e5308:	ea000017 	b	102e536c <Ql_RIL_SendATCmd+0x204>
102e530c:	e1a00004 	mov	r0, r4
102e5310:	e59f109c 	ldr	r1, [pc, #156]	; 102e53b4 <Ql_RIL_SendATCmd+0x24c>
102e5314:	e59f5078 	ldr	r5, [pc, #120]	; 102e5394 <Ql_RIL_SendATCmd+0x22c>
102e5318:	e12fff35 	blx	r5
102e531c:	e3500000 	cmp	r0, #0
102e5320:	13a03000 	movne	r3, #0
102e5324:	15c03000 	strbne	r3, [r0]
102e5328:	eaffffa7 	b	102e51cc <Ql_RIL_SendATCmd+0x64>
102e532c:	e59f3044 	ldr	r3, [pc, #68]	; 102e5378 <Ql_RIL_SendATCmd+0x210>
102e5330:	e59f5080 	ldr	r5, [pc, #128]	; 102e53b8 <Ql_RIL_SendATCmd+0x250>
102e5334:	e5930c30 	ldr	r0, [r3, #3120]	; 0xc30
102e5338:	e59f307c 	ldr	r3, [pc, #124]	; 102e53bc <Ql_RIL_SendATCmd+0x254>
102e533c:	e12fff33 	blx	r3
102e5340:	e3a01000 	mov	r1, #0
102e5344:	e3a02b01 	mov	r2, #1024	; 0x400
102e5348:	e59f3070 	ldr	r3, [pc, #112]	; 102e53c0 <Ql_RIL_SendATCmd+0x258>
102e534c:	e1a00005 	mov	r0, r5
102e5350:	e12fff33 	blx	r3
102e5354:	e1a00004 	mov	r0, r4
102e5358:	e59f3064 	ldr	r3, [pc, #100]	; 102e53c4 <Ql_RIL_SendATCmd+0x25c>
102e535c:	e12fff33 	blx	r3
102e5360:	e250a000 	subs	sl, r0, #0
102e5364:	1affffad 	bne	102e5220 <Ql_RIL_SendATCmd+0xb8>
102e5368:	eaffff8d 	b	102e51a4 <Ql_RIL_SendATCmd+0x3c>
102e536c:	e1a00006 	mov	r0, r6
102e5370:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
102e5374:	102c7080 	.word	0x102c7080
102e5378:	f03daa3c 	.word	0xf03daa3c
102e537c:	102edabe 	.word	0x102edabe
102e5380:	102f0693 	.word	0x102f0693
102e5384:	102caa40 	.word	0x102caa40
102e5388:	f03d2004 	.word	0xf03d2004
102e538c:	102ccd58 	.word	0x102ccd58
102e5390:	102f06b6 	.word	0x102f06b6
102e5394:	102e5a04 	.word	0x102e5a04
102e5398:	102e597c 	.word	0x102e597c
102e539c:	102ccda8 	.word	0x102ccda8
102e53a0:	f03d4754 	.word	0xf03d4754
102e53a4:	102e5cb4 	.word	0x102e5cb4
102e53a8:	102e5e7c 	.word	0x102e5e7c
102e53ac:	102e5dd4 	.word	0x102e5dd4
102e53b0:	ffffd8f0 	.word	0xffffd8f0
102e53b4:	102f06b4 	.word	0x102f06b4
102e53b8:	f03db259 	.word	0xf03db259
102e53bc:	102e5d80 	.word	0x102e5d80
102e53c0:	102e58f4 	.word	0x102e58f4
102e53c4:	102e57a4 	.word	0x102e57a4

Disassembly of section .text.Ql_RIL_WriteDataToCore:

102e53c8 <Ql_RIL_WriteDataToCore>:
102e53c8:	e92d4008 	push	{r3, lr}
102e53cc:	e1a03000 	mov	r3, r0
102e53d0:	e1a02001 	mov	r2, r1
102e53d4:	e3a00002 	mov	r0, #2
102e53d8:	e1a01003 	mov	r1, r3
102e53dc:	e59f3004 	ldr	r3, [pc, #4]	; 102e53e8 <Ql_RIL_WriteDataToCore+0x20>
102e53e0:	e12fff33 	blx	r3
102e53e4:	e8bd8008 	pop	{r3, pc}
102e53e8:	102e6230 	.word	0x102e6230

Disassembly of section .text.Ql_SPI_Init:

102e53ec <Ql_SPI_Init>:
102e53ec:	e92d41f3 	push	{r0, r1, r4, r5, r6, r7, r8, lr}
102e53f0:	e59f406c 	ldr	r4, [pc, #108]	; 102e5464 <Ql_SPI_Init+0x78>
102e53f4:	e1a06003 	mov	r6, r3
102e53f8:	e5943000 	ldr	r3, [r4]
102e53fc:	e1a05000 	mov	r5, r0
102e5400:	e3530000 	cmp	r3, #0
102e5404:	e1a08001 	mov	r8, r1
102e5408:	e1a07002 	mov	r7, r2
102e540c:	1a000006 	bne	102e542c <Ql_SPI_Init+0x40>
102e5410:	e59f3050 	ldr	r3, [pc, #80]	; 102e5468 <Ql_SPI_Init+0x7c>
102e5414:	e59f0050 	ldr	r0, [pc, #80]	; 102e546c <Ql_SPI_Init+0x80>
102e5418:	e5933000 	ldr	r3, [r3]
102e541c:	e12fff33 	blx	r3
102e5420:	e3500000 	cmp	r0, #0
102e5424:	0a00000c 	beq	102e545c <Ql_SPI_Init+0x70>
102e5428:	e5840000 	str	r0, [r4]
102e542c:	e5dd3020 	ldrb	r3, [sp, #32]
102e5430:	e58d3000 	str	r3, [sp]
102e5434:	e5dd3024 	ldrb	r3, [sp, #36]	; 0x24
102e5438:	e58d3004 	str	r3, [sp, #4]
102e543c:	e59f3020 	ldr	r3, [pc, #32]	; 102e5464 <Ql_SPI_Init+0x78>
102e5440:	e1a00005 	mov	r0, r5
102e5444:	e593c000 	ldr	ip, [r3]
102e5448:	e1a01008 	mov	r1, r8
102e544c:	e1a02007 	mov	r2, r7
102e5450:	e1a03006 	mov	r3, r6
102e5454:	e12fff3c 	blx	ip
102e5458:	ea000000 	b	102e5460 <Ql_SPI_Init+0x74>
102e545c:	e59f000c 	ldr	r0, [pc, #12]	; 102e5470 <Ql_SPI_Init+0x84>
102e5460:	e8bd81fc 	pop	{r2, r3, r4, r5, r6, r7, r8, pc}
102e5464:	f03db670 	.word	0xf03db670
102e5468:	f03daa08 	.word	0xf03daa08
102e546c:	102f06b8 	.word	0x102f06b8
102e5470:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_SPI_Config:

102e5474 <Ql_SPI_Config>:
102e5474:	e92d41f3 	push	{r0, r1, r4, r5, r6, r7, r8, lr}
102e5478:	e59f4064 	ldr	r4, [pc, #100]	; 102e54e4 <Ql_SPI_Config+0x70>
102e547c:	e1a06003 	mov	r6, r3
102e5480:	e5943004 	ldr	r3, [r4, #4]
102e5484:	e1a05000 	mov	r5, r0
102e5488:	e3530000 	cmp	r3, #0
102e548c:	e1a08001 	mov	r8, r1
102e5490:	e1a07002 	mov	r7, r2
102e5494:	1a000006 	bne	102e54b4 <Ql_SPI_Config+0x40>
102e5498:	e59f3048 	ldr	r3, [pc, #72]	; 102e54e8 <Ql_SPI_Config+0x74>
102e549c:	e59f0048 	ldr	r0, [pc, #72]	; 102e54ec <Ql_SPI_Config+0x78>
102e54a0:	e5933000 	ldr	r3, [r3]
102e54a4:	e12fff33 	blx	r3
102e54a8:	e3500000 	cmp	r0, #0
102e54ac:	0a00000a 	beq	102e54dc <Ql_SPI_Config+0x68>
102e54b0:	e5840004 	str	r0, [r4, #4]
102e54b4:	e59d3020 	ldr	r3, [sp, #32]
102e54b8:	e58d3000 	str	r3, [sp]
102e54bc:	e59f3020 	ldr	r3, [pc, #32]	; 102e54e4 <Ql_SPI_Config+0x70>
102e54c0:	e1a00005 	mov	r0, r5
102e54c4:	e593c004 	ldr	ip, [r3, #4]
102e54c8:	e1a01008 	mov	r1, r8
102e54cc:	e1a02007 	mov	r2, r7
102e54d0:	e1a03006 	mov	r3, r6
102e54d4:	e12fff3c 	blx	ip
102e54d8:	ea000000 	b	102e54e0 <Ql_SPI_Config+0x6c>
102e54dc:	e59f000c 	ldr	r0, [pc, #12]	; 102e54f0 <Ql_SPI_Config+0x7c>
102e54e0:	e8bd81fc 	pop	{r2, r3, r4, r5, r6, r7, r8, pc}
102e54e4:	f03db670 	.word	0xf03db670
102e54e8:	f03daa08 	.word	0xf03daa08
102e54ec:	102f06c4 	.word	0x102f06c4
102e54f0:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_SPI_Write:

102e54f4 <Ql_SPI_Write>:
102e54f4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e54f8:	e59f4054 	ldr	r4, [pc, #84]	; 102e5554 <Ql_SPI_Write+0x60>
102e54fc:	e1a05000 	mov	r5, r0
102e5500:	e5943008 	ldr	r3, [r4, #8]
102e5504:	e1a07001 	mov	r7, r1
102e5508:	e3530000 	cmp	r3, #0
102e550c:	e1a06002 	mov	r6, r2
102e5510:	1a000006 	bne	102e5530 <Ql_SPI_Write+0x3c>
102e5514:	e59f303c 	ldr	r3, [pc, #60]	; 102e5558 <Ql_SPI_Write+0x64>
102e5518:	e59f003c 	ldr	r0, [pc, #60]	; 102e555c <Ql_SPI_Write+0x68>
102e551c:	e5933000 	ldr	r3, [r3]
102e5520:	e12fff33 	blx	r3
102e5524:	e3500000 	cmp	r0, #0
102e5528:	0a000007 	beq	102e554c <Ql_SPI_Write+0x58>
102e552c:	e5840008 	str	r0, [r4, #8]
102e5530:	e59f301c 	ldr	r3, [pc, #28]	; 102e5554 <Ql_SPI_Write+0x60>
102e5534:	e1a00005 	mov	r0, r5
102e5538:	e5933008 	ldr	r3, [r3, #8]
102e553c:	e1a01007 	mov	r1, r7
102e5540:	e1a02006 	mov	r2, r6
102e5544:	e12fff33 	blx	r3
102e5548:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e554c:	e59f000c 	ldr	r0, [pc, #12]	; 102e5560 <Ql_SPI_Write+0x6c>
102e5550:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e5554:	f03db670 	.word	0xf03db670
102e5558:	f03daa08 	.word	0xf03daa08
102e555c:	102f06d2 	.word	0x102f06d2
102e5560:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_atof:

102e5564 <Ql_atof>:
102e5564:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
102e5568:	e59f4074 	ldr	r4, [pc, #116]	; 102e55e4 <Ql_atof+0x80>
102e556c:	e1a05000 	mov	r5, r0
102e5570:	e5943008 	ldr	r3, [r4, #8]
102e5574:	e3530000 	cmp	r3, #0
102e5578:	1a000013 	bne	102e55cc <Ql_atof+0x68>
102e557c:	e59f1064 	ldr	r1, [pc, #100]	; 102e55e8 <Ql_atof+0x84>
102e5580:	e3a02008 	mov	r2, #8
102e5584:	e59f3060 	ldr	r3, [pc, #96]	; 102e55ec <Ql_atof+0x88>
102e5588:	e1a0000d 	mov	r0, sp
102e558c:	e12fff33 	blx	r3
102e5590:	e59f3058 	ldr	r3, [pc, #88]	; 102e55f0 <Ql_atof+0x8c>
102e5594:	e1a0000d 	mov	r0, sp
102e5598:	e5933000 	ldr	r3, [r3]
102e559c:	e12fff33 	blx	r3
102e55a0:	e3500000 	cmp	r0, #0
102e55a4:	15840008 	strne	r0, [r4, #8]
102e55a8:	1a000007 	bne	102e55cc <Ql_atof+0x68>
102e55ac:	e59f3040 	ldr	r3, [pc, #64]	; 102e55f4 <Ql_atof+0x90>
102e55b0:	e1a0100d 	mov	r1, sp
102e55b4:	e5933000 	ldr	r3, [r3]
102e55b8:	e59f0038 	ldr	r0, [pc, #56]	; 102e55f8 <Ql_atof+0x94>
102e55bc:	e12fff33 	blx	r3
102e55c0:	e3a00000 	mov	r0, #0
102e55c4:	e3a01000 	mov	r1, #0
102e55c8:	ea000003 	b	102e55dc <Ql_atof+0x78>
102e55cc:	e59f3010 	ldr	r3, [pc, #16]	; 102e55e4 <Ql_atof+0x80>
102e55d0:	e1a00005 	mov	r0, r5
102e55d4:	e5933008 	ldr	r3, [r3, #8]
102e55d8:	e12fff33 	blx	r3
102e55dc:	e28dd00c 	add	sp, sp, #12
102e55e0:	e8bd8030 	pop	{r4, r5, pc}
102e55e4:	f03db688 	.word	0xf03db688
102e55e8:	102f071d 	.word	0x102f071d
102e55ec:	102df8c9 	.word	0x102df8c9
102e55f0:	f03daa08 	.word	0xf03daa08
102e55f4:	f03de544 	.word	0xf03de544
102e55f8:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_strcpy:

102e55fc <Ql_strcpy>:
102e55fc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
102e5600:	e59f407c 	ldr	r4, [pc, #124]	; 102e5684 <Ql_strcpy+0x88>
102e5604:	e24dd014 	sub	sp, sp, #20
102e5608:	e594300c 	ldr	r3, [r4, #12]
102e560c:	e1a07000 	mov	r7, r0
102e5610:	e3530000 	cmp	r3, #0
102e5614:	e1a06001 	mov	r6, r1
102e5618:	1a000012 	bne	102e5668 <Ql_strcpy+0x6c>
102e561c:	e59f1064 	ldr	r1, [pc, #100]	; 102e5688 <Ql_strcpy+0x8c>
102e5620:	e3a0200a 	mov	r2, #10
102e5624:	e59f3060 	ldr	r3, [pc, #96]	; 102e568c <Ql_strcpy+0x90>
102e5628:	e28d0004 	add	r0, sp, #4
102e562c:	e12fff33 	blx	r3
102e5630:	e59f3058 	ldr	r3, [pc, #88]	; 102e5690 <Ql_strcpy+0x94>
102e5634:	e28d0004 	add	r0, sp, #4
102e5638:	e5933000 	ldr	r3, [r3]
102e563c:	e12fff33 	blx	r3
102e5640:	e2505000 	subs	r5, r0, #0
102e5644:	1584500c 	strne	r5, [r4, #12]
102e5648:	1a000006 	bne	102e5668 <Ql_strcpy+0x6c>
102e564c:	e59f3040 	ldr	r3, [pc, #64]	; 102e5694 <Ql_strcpy+0x98>
102e5650:	e59f0040 	ldr	r0, [pc, #64]	; 102e5698 <Ql_strcpy+0x9c>
102e5654:	e5933000 	ldr	r3, [r3]
102e5658:	e28d1004 	add	r1, sp, #4
102e565c:	e12fff33 	blx	r3
102e5660:	e1a00005 	mov	r0, r5
102e5664:	ea000004 	b	102e567c <Ql_strcpy+0x80>
102e5668:	e59f3014 	ldr	r3, [pc, #20]	; 102e5684 <Ql_strcpy+0x88>
102e566c:	e1a00007 	mov	r0, r7
102e5670:	e593300c 	ldr	r3, [r3, #12]
102e5674:	e1a01006 	mov	r1, r6
102e5678:	e12fff33 	blx	r3
102e567c:	e28dd014 	add	sp, sp, #20
102e5680:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
102e5684:	f03db688 	.word	0xf03db688
102e5688:	102f0725 	.word	0x102f0725
102e568c:	102df8c9 	.word	0x102df8c9
102e5690:	f03daa08 	.word	0xf03daa08
102e5694:	f03de544 	.word	0xf03de544
102e5698:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_strncpy:

102e569c <Ql_strncpy>:
102e569c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102e56a0:	e59f5068 	ldr	r5, [pc, #104]	; 102e5710 <Ql_strncpy+0x74>
102e56a4:	e1a06000 	mov	r6, r0
102e56a8:	e5953010 	ldr	r3, [r5, #16]
102e56ac:	e1a08001 	mov	r8, r1
102e56b0:	e3530000 	cmp	r3, #0
102e56b4:	e1a07002 	mov	r7, r2
102e56b8:	1a00000d 	bne	102e56f4 <Ql_strncpy+0x58>
102e56bc:	e59f3050 	ldr	r3, [pc, #80]	; 102e5714 <Ql_strncpy+0x78>
102e56c0:	e59f0050 	ldr	r0, [pc, #80]	; 102e5718 <Ql_strncpy+0x7c>
102e56c4:	e5933000 	ldr	r3, [r3]
102e56c8:	e12fff33 	blx	r3
102e56cc:	e2504000 	subs	r4, r0, #0
102e56d0:	15854010 	strne	r4, [r5, #16]
102e56d4:	1a000006 	bne	102e56f4 <Ql_strncpy+0x58>
102e56d8:	e59f303c 	ldr	r3, [pc, #60]	; 102e571c <Ql_strncpy+0x80>
102e56dc:	e59f1034 	ldr	r1, [pc, #52]	; 102e5718 <Ql_strncpy+0x7c>
102e56e0:	e5933000 	ldr	r3, [r3]
102e56e4:	e59f0034 	ldr	r0, [pc, #52]	; 102e5720 <Ql_strncpy+0x84>
102e56e8:	e12fff33 	blx	r3
102e56ec:	e1a00004 	mov	r0, r4
102e56f0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e56f4:	e59f3014 	ldr	r3, [pc, #20]	; 102e5710 <Ql_strncpy+0x74>
102e56f8:	e1a00006 	mov	r0, r6
102e56fc:	e5933010 	ldr	r3, [r3, #16]
102e5700:	e1a01008 	mov	r1, r8
102e5704:	e1a02007 	mov	r2, r7
102e5708:	e12fff33 	blx	r3
102e570c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e5710:	f03db688 	.word	0xf03db688
102e5714:	f03daa08 	.word	0xf03daa08
102e5718:	102f072f 	.word	0x102f072f
102e571c:	f03de544 	.word	0xf03de544
102e5720:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_strcat:

102e5724 <Ql_strcat>:
102e5724:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e5728:	e59f5060 	ldr	r5, [pc, #96]	; 102e5790 <Ql_strcat+0x6c>
102e572c:	e1a06000 	mov	r6, r0
102e5730:	e5953014 	ldr	r3, [r5, #20]
102e5734:	e1a07001 	mov	r7, r1
102e5738:	e3530000 	cmp	r3, #0
102e573c:	1a00000d 	bne	102e5778 <Ql_strcat+0x54>
102e5740:	e59f304c 	ldr	r3, [pc, #76]	; 102e5794 <Ql_strcat+0x70>
102e5744:	e59f004c 	ldr	r0, [pc, #76]	; 102e5798 <Ql_strcat+0x74>
102e5748:	e5933000 	ldr	r3, [r3]
102e574c:	e12fff33 	blx	r3
102e5750:	e2504000 	subs	r4, r0, #0
102e5754:	15854014 	strne	r4, [r5, #20]
102e5758:	1a000006 	bne	102e5778 <Ql_strcat+0x54>
102e575c:	e59f3038 	ldr	r3, [pc, #56]	; 102e579c <Ql_strcat+0x78>
102e5760:	e59f1030 	ldr	r1, [pc, #48]	; 102e5798 <Ql_strcat+0x74>
102e5764:	e5933000 	ldr	r3, [r3]
102e5768:	e59f0030 	ldr	r0, [pc, #48]	; 102e57a0 <Ql_strcat+0x7c>
102e576c:	e12fff33 	blx	r3
102e5770:	e1a00004 	mov	r0, r4
102e5774:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e5778:	e59f3010 	ldr	r3, [pc, #16]	; 102e5790 <Ql_strcat+0x6c>
102e577c:	e1a00006 	mov	r0, r6
102e5780:	e5933014 	ldr	r3, [r3, #20]
102e5784:	e1a01007 	mov	r1, r7
102e5788:	e12fff33 	blx	r3
102e578c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e5790:	f03db688 	.word	0xf03db688
102e5794:	f03daa08 	.word	0xf03daa08
102e5798:	102f073a 	.word	0x102f073a
102e579c:	f03de544 	.word	0xf03de544
102e57a0:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_strlen:

102e57a4 <Ql_strlen>:
102e57a4:	e92d4070 	push	{r4, r5, r6, lr}
102e57a8:	e59f5058 	ldr	r5, [pc, #88]	; 102e5808 <Ql_strlen+0x64>
102e57ac:	e1a06000 	mov	r6, r0
102e57b0:	e595301c 	ldr	r3, [r5, #28]
102e57b4:	e3530000 	cmp	r3, #0
102e57b8:	1a00000d 	bne	102e57f4 <Ql_strlen+0x50>
102e57bc:	e59f3048 	ldr	r3, [pc, #72]	; 102e580c <Ql_strlen+0x68>
102e57c0:	e59f0048 	ldr	r0, [pc, #72]	; 102e5810 <Ql_strlen+0x6c>
102e57c4:	e5933000 	ldr	r3, [r3]
102e57c8:	e12fff33 	blx	r3
102e57cc:	e2504000 	subs	r4, r0, #0
102e57d0:	1585401c 	strne	r4, [r5, #28]
102e57d4:	1a000006 	bne	102e57f4 <Ql_strlen+0x50>
102e57d8:	e59f3034 	ldr	r3, [pc, #52]	; 102e5814 <Ql_strlen+0x70>
102e57dc:	e59f102c 	ldr	r1, [pc, #44]	; 102e5810 <Ql_strlen+0x6c>
102e57e0:	e5933000 	ldr	r3, [r3]
102e57e4:	e59f002c 	ldr	r0, [pc, #44]	; 102e5818 <Ql_strlen+0x74>
102e57e8:	e12fff33 	blx	r3
102e57ec:	e1a00004 	mov	r0, r4
102e57f0:	e8bd8070 	pop	{r4, r5, r6, pc}
102e57f4:	e59f300c 	ldr	r3, [pc, #12]	; 102e5808 <Ql_strlen+0x64>
102e57f8:	e1a00006 	mov	r0, r6
102e57fc:	e593301c 	ldr	r3, [r3, #28]
102e5800:	e12fff33 	blx	r3
102e5804:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5808:	f03db688 	.word	0xf03db688
102e580c:	f03daa08 	.word	0xf03daa08
102e5810:	102f074f 	.word	0x102f074f
102e5814:	f03de544 	.word	0xf03de544
102e5818:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_strcmp:

102e581c <Ql_strcmp>:
102e581c:	e92d4070 	push	{r4, r5, r6, lr}
102e5820:	e59f404c 	ldr	r4, [pc, #76]	; 102e5874 <Ql_strcmp+0x58>
102e5824:	e1a05000 	mov	r5, r0
102e5828:	e5943020 	ldr	r3, [r4, #32]
102e582c:	e1a06001 	mov	r6, r1
102e5830:	e3530000 	cmp	r3, #0
102e5834:	1a000006 	bne	102e5854 <Ql_strcmp+0x38>
102e5838:	e59f3038 	ldr	r3, [pc, #56]	; 102e5878 <Ql_strcmp+0x5c>
102e583c:	e59f0038 	ldr	r0, [pc, #56]	; 102e587c <Ql_strcmp+0x60>
102e5840:	e5933000 	ldr	r3, [r3]
102e5844:	e12fff33 	blx	r3
102e5848:	e3500000 	cmp	r0, #0
102e584c:	0a000006 	beq	102e586c <Ql_strcmp+0x50>
102e5850:	e5840020 	str	r0, [r4, #32]
102e5854:	e59f3018 	ldr	r3, [pc, #24]	; 102e5874 <Ql_strcmp+0x58>
102e5858:	e1a00005 	mov	r0, r5
102e585c:	e5933020 	ldr	r3, [r3, #32]
102e5860:	e1a01006 	mov	r1, r6
102e5864:	e12fff33 	blx	r3
102e5868:	e8bd8070 	pop	{r4, r5, r6, pc}
102e586c:	e59f000c 	ldr	r0, [pc, #12]	; 102e5880 <Ql_strcmp+0x64>
102e5870:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5874:	f03db688 	.word	0xf03db688
102e5878:	f03daa08 	.word	0xf03daa08
102e587c:	102f0759 	.word	0x102f0759
102e5880:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_strncmp:

102e5884 <Ql_strncmp>:
102e5884:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e5888:	e59f4054 	ldr	r4, [pc, #84]	; 102e58e4 <Ql_strncmp+0x60>
102e588c:	e1a05000 	mov	r5, r0
102e5890:	e5943024 	ldr	r3, [r4, #36]	; 0x24
102e5894:	e1a07001 	mov	r7, r1
102e5898:	e3530000 	cmp	r3, #0
102e589c:	e1a06002 	mov	r6, r2
102e58a0:	1a000006 	bne	102e58c0 <Ql_strncmp+0x3c>
102e58a4:	e59f303c 	ldr	r3, [pc, #60]	; 102e58e8 <Ql_strncmp+0x64>
102e58a8:	e59f003c 	ldr	r0, [pc, #60]	; 102e58ec <Ql_strncmp+0x68>
102e58ac:	e5933000 	ldr	r3, [r3]
102e58b0:	e12fff33 	blx	r3
102e58b4:	e3500000 	cmp	r0, #0
102e58b8:	0a000007 	beq	102e58dc <Ql_strncmp+0x58>
102e58bc:	e5840024 	str	r0, [r4, #36]	; 0x24
102e58c0:	e59f301c 	ldr	r3, [pc, #28]	; 102e58e4 <Ql_strncmp+0x60>
102e58c4:	e1a00005 	mov	r0, r5
102e58c8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
102e58cc:	e1a01007 	mov	r1, r7
102e58d0:	e1a02006 	mov	r2, r6
102e58d4:	e12fff33 	blx	r3
102e58d8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e58dc:	e59f000c 	ldr	r0, [pc, #12]	; 102e58f0 <Ql_strncmp+0x6c>
102e58e0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e58e4:	f03db688 	.word	0xf03db688
102e58e8:	f03daa08 	.word	0xf03daa08
102e58ec:	102f0763 	.word	0x102f0763
102e58f0:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_memset:

102e58f4 <Ql_memset>:
102e58f4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102e58f8:	e59f5068 	ldr	r5, [pc, #104]	; 102e5968 <Ql_memset+0x74>
102e58fc:	e1a06000 	mov	r6, r0
102e5900:	e5953028 	ldr	r3, [r5, #40]	; 0x28
102e5904:	e1a08001 	mov	r8, r1
102e5908:	e3530000 	cmp	r3, #0
102e590c:	e1a07002 	mov	r7, r2
102e5910:	1a00000d 	bne	102e594c <Ql_memset+0x58>
102e5914:	e59f3050 	ldr	r3, [pc, #80]	; 102e596c <Ql_memset+0x78>
102e5918:	e59f0050 	ldr	r0, [pc, #80]	; 102e5970 <Ql_memset+0x7c>
102e591c:	e5933000 	ldr	r3, [r3]
102e5920:	e12fff33 	blx	r3
102e5924:	e2504000 	subs	r4, r0, #0
102e5928:	15854028 	strne	r4, [r5, #40]	; 0x28
102e592c:	1a000006 	bne	102e594c <Ql_memset+0x58>
102e5930:	e59f303c 	ldr	r3, [pc, #60]	; 102e5974 <Ql_memset+0x80>
102e5934:	e59f1034 	ldr	r1, [pc, #52]	; 102e5970 <Ql_memset+0x7c>
102e5938:	e5933000 	ldr	r3, [r3]
102e593c:	e59f0034 	ldr	r0, [pc, #52]	; 102e5978 <Ql_memset+0x84>
102e5940:	e12fff33 	blx	r3
102e5944:	e1a00004 	mov	r0, r4
102e5948:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e594c:	e59f3014 	ldr	r3, [pc, #20]	; 102e5968 <Ql_memset+0x74>
102e5950:	e1a00006 	mov	r0, r6
102e5954:	e5933028 	ldr	r3, [r3, #40]	; 0x28
102e5958:	e1a01008 	mov	r1, r8
102e595c:	e1a02007 	mov	r2, r7
102e5960:	e12fff33 	blx	r3
102e5964:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e5968:	f03db688 	.word	0xf03db688
102e596c:	f03daa08 	.word	0xf03daa08
102e5970:	102f076e 	.word	0x102f076e
102e5974:	f03de544 	.word	0xf03de544
102e5978:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_memcpy:

102e597c <Ql_memcpy>:
102e597c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102e5980:	e59f5068 	ldr	r5, [pc, #104]	; 102e59f0 <Ql_memcpy+0x74>
102e5984:	e1a06000 	mov	r6, r0
102e5988:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
102e598c:	e1a08001 	mov	r8, r1
102e5990:	e3530000 	cmp	r3, #0
102e5994:	e1a07002 	mov	r7, r2
102e5998:	1a00000d 	bne	102e59d4 <Ql_memcpy+0x58>
102e599c:	e59f3050 	ldr	r3, [pc, #80]	; 102e59f4 <Ql_memcpy+0x78>
102e59a0:	e59f0050 	ldr	r0, [pc, #80]	; 102e59f8 <Ql_memcpy+0x7c>
102e59a4:	e5933000 	ldr	r3, [r3]
102e59a8:	e12fff33 	blx	r3
102e59ac:	e2504000 	subs	r4, r0, #0
102e59b0:	1585402c 	strne	r4, [r5, #44]	; 0x2c
102e59b4:	1a000006 	bne	102e59d4 <Ql_memcpy+0x58>
102e59b8:	e59f303c 	ldr	r3, [pc, #60]	; 102e59fc <Ql_memcpy+0x80>
102e59bc:	e59f1034 	ldr	r1, [pc, #52]	; 102e59f8 <Ql_memcpy+0x7c>
102e59c0:	e5933000 	ldr	r3, [r3]
102e59c4:	e59f0034 	ldr	r0, [pc, #52]	; 102e5a00 <Ql_memcpy+0x84>
102e59c8:	e12fff33 	blx	r3
102e59cc:	e1a00004 	mov	r0, r4
102e59d0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e59d4:	e59f3014 	ldr	r3, [pc, #20]	; 102e59f0 <Ql_memcpy+0x74>
102e59d8:	e1a00006 	mov	r0, r6
102e59dc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
102e59e0:	e1a01008 	mov	r1, r8
102e59e4:	e1a02007 	mov	r2, r7
102e59e8:	e12fff33 	blx	r3
102e59ec:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e59f0:	f03db688 	.word	0xf03db688
102e59f4:	f03daa08 	.word	0xf03daa08
102e59f8:	102f0778 	.word	0x102f0778
102e59fc:	f03de544 	.word	0xf03de544
102e5a00:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_strstr:

102e5a04 <Ql_strstr>:
102e5a04:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e5a08:	e59f5060 	ldr	r5, [pc, #96]	; 102e5a70 <Ql_strstr+0x6c>
102e5a0c:	e1a06000 	mov	r6, r0
102e5a10:	e5953038 	ldr	r3, [r5, #56]	; 0x38
102e5a14:	e1a07001 	mov	r7, r1
102e5a18:	e3530000 	cmp	r3, #0
102e5a1c:	1a00000d 	bne	102e5a58 <Ql_strstr+0x54>
102e5a20:	e59f304c 	ldr	r3, [pc, #76]	; 102e5a74 <Ql_strstr+0x70>
102e5a24:	e59f004c 	ldr	r0, [pc, #76]	; 102e5a78 <Ql_strstr+0x74>
102e5a28:	e5933000 	ldr	r3, [r3]
102e5a2c:	e12fff33 	blx	r3
102e5a30:	e2504000 	subs	r4, r0, #0
102e5a34:	15854038 	strne	r4, [r5, #56]	; 0x38
102e5a38:	1a000006 	bne	102e5a58 <Ql_strstr+0x54>
102e5a3c:	e59f3038 	ldr	r3, [pc, #56]	; 102e5a7c <Ql_strstr+0x78>
102e5a40:	e59f1030 	ldr	r1, [pc, #48]	; 102e5a78 <Ql_strstr+0x74>
102e5a44:	e5933000 	ldr	r3, [r3]
102e5a48:	e59f0030 	ldr	r0, [pc, #48]	; 102e5a80 <Ql_strstr+0x7c>
102e5a4c:	e12fff33 	blx	r3
102e5a50:	e1a00004 	mov	r0, r4
102e5a54:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e5a58:	e59f3010 	ldr	r3, [pc, #16]	; 102e5a70 <Ql_strstr+0x6c>
102e5a5c:	e1a00006 	mov	r0, r6
102e5a60:	e5933038 	ldr	r3, [r3, #56]	; 0x38
102e5a64:	e1a01007 	mov	r1, r7
102e5a68:	e12fff33 	blx	r3
102e5a6c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e5a70:	f03db688 	.word	0xf03db688
102e5a74:	f03daa08 	.word	0xf03daa08
102e5a78:	102f0797 	.word	0x102f0797
102e5a7c:	f03de544 	.word	0xf03de544
102e5a80:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_toupper:

102e5a84 <Ql_toupper>:
102e5a84:	e2400020 	sub	r0, r0, #32
102e5a88:	e12fff1e 	bx	lr

Disassembly of section .text.Ql_atoi:

102e5a8c <Ql_atoi>:
102e5a8c:	e92d4010 	push	{r4, lr}
102e5a90:	e1a02000 	mov	r2, r0
102e5a94:	e5d23000 	ldrb	r3, [r2]
102e5a98:	e2800001 	add	r0, r0, #1
102e5a9c:	e3530020 	cmp	r3, #32
102e5aa0:	13530009 	cmpne	r3, #9
102e5aa4:	0afffff9 	beq	102e5a90 <Ql_atoi+0x4>
102e5aa8:	e353000a 	cmp	r3, #10
102e5aac:	1353000c 	cmpne	r3, #12
102e5ab0:	0afffff6 	beq	102e5a90 <Ql_atoi+0x4>
102e5ab4:	e3530008 	cmp	r3, #8
102e5ab8:	1353000d 	cmpne	r3, #13
102e5abc:	0afffff3 	beq	102e5a90 <Ql_atoi+0x4>
102e5ac0:	e253102d 	subs	r1, r3, #45	; 0x2d
102e5ac4:	e271c000 	rsbs	ip, r1, #0
102e5ac8:	e0bcc001 	adcs	ip, ip, r1
102e5acc:	e353002d 	cmp	r3, #45	; 0x2d
102e5ad0:	1353002b 	cmpne	r3, #43	; 0x2b
102e5ad4:	11a02000 	movne	r2, r0
102e5ad8:	05d23001 	ldrbeq	r3, [r2, #1]
102e5adc:	e3a00000 	mov	r0, #0
102e5ae0:	02822002 	addeq	r2, r2, #2
102e5ae4:	e3a0100a 	mov	r1, #10
102e5ae8:	e2433030 	sub	r3, r3, #48	; 0x30
102e5aec:	e20340ff 	and	r4, r3, #255	; 0xff
102e5af0:	e3540009 	cmp	r4, #9
102e5af4:	9a000002 	bls	102e5b04 <Ql_atoi+0x78>
102e5af8:	e35c0000 	cmp	ip, #0
102e5afc:	12600000 	rsbne	r0, r0, #0
102e5b00:	e8bd8010 	pop	{r4, pc}
102e5b04:	e0203091 	mla	r0, r1, r0, r3
102e5b08:	e4d23001 	ldrb	r3, [r2], #1
102e5b0c:	eafffff5 	b	102e5ae8 <Ql_atoi+0x5c>

Disassembly of section .text.Ql_Sleep:

102e5b10 <Ql_Sleep>:
102e5b10:	e92d4038 	push	{r3, r4, r5, lr}
102e5b14:	e59f4054 	ldr	r4, [pc, #84]	; 102e5b70 <Ql_Sleep+0x60>
102e5b18:	e1a05000 	mov	r5, r0
102e5b1c:	e5943000 	ldr	r3, [r4]
102e5b20:	e3530000 	cmp	r3, #0
102e5b24:	1a00000c 	bne	102e5b5c <Ql_Sleep+0x4c>
102e5b28:	e59f3044 	ldr	r3, [pc, #68]	; 102e5b74 <Ql_Sleep+0x64>
102e5b2c:	e59f0044 	ldr	r0, [pc, #68]	; 102e5b78 <Ql_Sleep+0x68>
102e5b30:	e5933000 	ldr	r3, [r3]
102e5b34:	e12fff33 	blx	r3
102e5b38:	e3500000 	cmp	r0, #0
102e5b3c:	15840000 	strne	r0, [r4]
102e5b40:	1a000005 	bne	102e5b5c <Ql_Sleep+0x4c>
102e5b44:	e59f3030 	ldr	r3, [pc, #48]	; 102e5b7c <Ql_Sleep+0x6c>
102e5b48:	e59f1028 	ldr	r1, [pc, #40]	; 102e5b78 <Ql_Sleep+0x68>
102e5b4c:	e5933000 	ldr	r3, [r3]
102e5b50:	e59f0028 	ldr	r0, [pc, #40]	; 102e5b80 <Ql_Sleep+0x70>
102e5b54:	e12fff33 	blx	r3
102e5b58:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5b5c:	e59f300c 	ldr	r3, [pc, #12]	; 102e5b70 <Ql_Sleep+0x60>
102e5b60:	e1a00005 	mov	r0, r5
102e5b64:	e5933000 	ldr	r3, [r3]
102e5b68:	e12fff33 	blx	r3
102e5b6c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5b70:	f03db6c8 	.word	0xf03db6c8
102e5b74:	f03daa08 	.word	0xf03daa08
102e5b78:	102f07ab 	.word	0x102f07ab
102e5b7c:	f03de544 	.word	0xf03de544
102e5b80:	f03d4738 	.word	0xf03d4738

Disassembly of section .text.Ql_GetCoreVer:

102e5b84 <Ql_GetCoreVer>:
102e5b84:	e92d4070 	push	{r4, r5, r6, lr}
102e5b88:	e59f4050 	ldr	r4, [pc, #80]	; 102e5be0 <Ql_GetCoreVer+0x5c>
102e5b8c:	e1a05000 	mov	r5, r0
102e5b90:	e5943010 	ldr	r3, [r4, #16]
102e5b94:	e1a06001 	mov	r6, r1
102e5b98:	e3530000 	cmp	r3, #0
102e5b9c:	1a000006 	bne	102e5bbc <Ql_GetCoreVer+0x38>
102e5ba0:	e59f303c 	ldr	r3, [pc, #60]	; 102e5be4 <Ql_GetCoreVer+0x60>
102e5ba4:	e59f003c 	ldr	r0, [pc, #60]	; 102e5be8 <Ql_GetCoreVer+0x64>
102e5ba8:	e5933000 	ldr	r3, [r3]
102e5bac:	e12fff33 	blx	r3
102e5bb0:	e3500000 	cmp	r0, #0
102e5bb4:	0a000007 	beq	102e5bd8 <Ql_GetCoreVer+0x54>
102e5bb8:	e5840010 	str	r0, [r4, #16]
102e5bbc:	e59f301c 	ldr	r3, [pc, #28]	; 102e5be0 <Ql_GetCoreVer+0x5c>
102e5bc0:	e1a01806 	lsl	r1, r6, #16
102e5bc4:	e5933010 	ldr	r3, [r3, #16]
102e5bc8:	e1a00005 	mov	r0, r5
102e5bcc:	e1a01821 	lsr	r1, r1, #16
102e5bd0:	e12fff33 	blx	r3
102e5bd4:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5bd8:	e59f000c 	ldr	r0, [pc, #12]	; 102e5bec <Ql_GetCoreVer+0x68>
102e5bdc:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5be0:	f03db6c8 	.word	0xf03db6c8
102e5be4:	f03daa08 	.word	0xf03daa08
102e5be8:	102f07da 	.word	0x102f07da
102e5bec:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_GetSDKVer:

102e5bf0 <Ql_GetSDKVer>:
102e5bf0:	e3500000 	cmp	r0, #0
102e5bf4:	13510000 	cmpne	r1, #0
102e5bf8:	e92d4070 	push	{r4, r5, r6, lr}
102e5bfc:	e1a06001 	mov	r6, r1
102e5c00:	e1a05000 	mov	r5, r0
102e5c04:	0a00000d 	beq	102e5c40 <Ql_GetSDKVer+0x50>
102e5c08:	e59f3038 	ldr	r3, [pc, #56]	; 102e5c48 <Ql_GetSDKVer+0x58>
102e5c0c:	e59f0038 	ldr	r0, [pc, #56]	; 102e5c4c <Ql_GetSDKVer+0x5c>
102e5c10:	e12fff33 	blx	r3
102e5c14:	e59f1030 	ldr	r1, [pc, #48]	; 102e5c4c <Ql_GetSDKVer+0x5c>
102e5c18:	e59f3030 	ldr	r3, [pc, #48]	; 102e5c50 <Ql_GetSDKVer+0x60>
102e5c1c:	e1a00800 	lsl	r0, r0, #16
102e5c20:	e1a04820 	lsr	r4, r0, #16
102e5c24:	e1540006 	cmp	r4, r6
102e5c28:	21a04006 	movcs	r4, r6
102e5c2c:	e1a00005 	mov	r0, r5
102e5c30:	e1a02004 	mov	r2, r4
102e5c34:	e12fff33 	blx	r3
102e5c38:	e1a00004 	mov	r0, r4
102e5c3c:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5c40:	e3e00032 	mvn	r0, #50	; 0x32
102e5c44:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5c48:	102e57a4 	.word	0x102e57a4
102e5c4c:	102edac2 	.word	0x102edac2
102e5c50:	102e569c 	.word	0x102e569c

Disassembly of section .text.Ql_OS_GetMessage:

102e5c54 <Ql_OS_GetMessage>:
102e5c54:	e92d4038 	push	{r3, r4, r5, lr}
102e5c58:	e59f4044 	ldr	r4, [pc, #68]	; 102e5ca4 <Ql_OS_GetMessage+0x50>
102e5c5c:	e1a05000 	mov	r5, r0
102e5c60:	e5943000 	ldr	r3, [r4]
102e5c64:	e3530000 	cmp	r3, #0
102e5c68:	1a000006 	bne	102e5c88 <Ql_OS_GetMessage+0x34>
102e5c6c:	e59f3034 	ldr	r3, [pc, #52]	; 102e5ca8 <Ql_OS_GetMessage+0x54>
102e5c70:	e59f0034 	ldr	r0, [pc, #52]	; 102e5cac <Ql_OS_GetMessage+0x58>
102e5c74:	e5933000 	ldr	r3, [r3]
102e5c78:	e12fff33 	blx	r3
102e5c7c:	e3500000 	cmp	r0, #0
102e5c80:	0a000005 	beq	102e5c9c <Ql_OS_GetMessage+0x48>
102e5c84:	e5840000 	str	r0, [r4]
102e5c88:	e59f3014 	ldr	r3, [pc, #20]	; 102e5ca4 <Ql_OS_GetMessage+0x50>
102e5c8c:	e1a00005 	mov	r0, r5
102e5c90:	e5933000 	ldr	r3, [r3]
102e5c94:	e12fff33 	blx	r3
102e5c98:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5c9c:	e59f000c 	ldr	r0, [pc, #12]	; 102e5cb0 <Ql_OS_GetMessage+0x5c>
102e5ca0:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5ca4:	f03db6dc 	.word	0xf03db6dc
102e5ca8:	f03daa08 	.word	0xf03daa08
102e5cac:	102f07e8 	.word	0x102f07e8
102e5cb0:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_OS_SendMessage:

102e5cb4 <Ql_OS_SendMessage>:
102e5cb4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
102e5cb8:	e59f405c 	ldr	r4, [pc, #92]	; 102e5d1c <Ql_OS_SendMessage+0x68>
102e5cbc:	e1a06003 	mov	r6, r3
102e5cc0:	e5943004 	ldr	r3, [r4, #4]
102e5cc4:	e1a05000 	mov	r5, r0
102e5cc8:	e3530000 	cmp	r3, #0
102e5ccc:	e1a08001 	mov	r8, r1
102e5cd0:	e1a07002 	mov	r7, r2
102e5cd4:	1a000006 	bne	102e5cf4 <Ql_OS_SendMessage+0x40>
102e5cd8:	e59f3040 	ldr	r3, [pc, #64]	; 102e5d20 <Ql_OS_SendMessage+0x6c>
102e5cdc:	e59f0040 	ldr	r0, [pc, #64]	; 102e5d24 <Ql_OS_SendMessage+0x70>
102e5ce0:	e5933000 	ldr	r3, [r3]
102e5ce4:	e12fff33 	blx	r3
102e5ce8:	e3500000 	cmp	r0, #0
102e5cec:	0a000008 	beq	102e5d14 <Ql_OS_SendMessage+0x60>
102e5cf0:	e5840004 	str	r0, [r4, #4]
102e5cf4:	e59f3020 	ldr	r3, [pc, #32]	; 102e5d1c <Ql_OS_SendMessage+0x68>
102e5cf8:	e1a00005 	mov	r0, r5
102e5cfc:	e593c004 	ldr	ip, [r3, #4]
102e5d00:	e1a01008 	mov	r1, r8
102e5d04:	e1a02007 	mov	r2, r7
102e5d08:	e1a03006 	mov	r3, r6
102e5d0c:	e12fff3c 	blx	ip
102e5d10:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e5d14:	e59f000c 	ldr	r0, [pc, #12]	; 102e5d28 <Ql_OS_SendMessage+0x74>
102e5d18:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
102e5d1c:	f03db6dc 	.word	0xf03db6dc
102e5d20:	f03daa08 	.word	0xf03daa08
102e5d24:	102f07f9 	.word	0x102f07f9
102e5d28:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_OS_CreateMutex:

102e5d2c <Ql_OS_CreateMutex>:
102e5d2c:	e92d4038 	push	{r3, r4, r5, lr}
102e5d30:	e59f403c 	ldr	r4, [pc, #60]	; 102e5d74 <Ql_OS_CreateMutex+0x48>
102e5d34:	e1a05000 	mov	r5, r0
102e5d38:	e5943008 	ldr	r3, [r4, #8]
102e5d3c:	e3530000 	cmp	r3, #0
102e5d40:	1a000006 	bne	102e5d60 <Ql_OS_CreateMutex+0x34>
102e5d44:	e59f302c 	ldr	r3, [pc, #44]	; 102e5d78 <Ql_OS_CreateMutex+0x4c>
102e5d48:	e59f002c 	ldr	r0, [pc, #44]	; 102e5d7c <Ql_OS_CreateMutex+0x50>
102e5d4c:	e5933000 	ldr	r3, [r3]
102e5d50:	e12fff33 	blx	r3
102e5d54:	e3500000 	cmp	r0, #0
102e5d58:	08bd8038 	popeq	{r3, r4, r5, pc}
102e5d5c:	e5840008 	str	r0, [r4, #8]
102e5d60:	e59f300c 	ldr	r3, [pc, #12]	; 102e5d74 <Ql_OS_CreateMutex+0x48>
102e5d64:	e1a00005 	mov	r0, r5
102e5d68:	e5933008 	ldr	r3, [r3, #8]
102e5d6c:	e12fff33 	blx	r3
102e5d70:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5d74:	f03db6dc 	.word	0xf03db6dc
102e5d78:	f03daa08 	.word	0xf03daa08
102e5d7c:	102f080b 	.word	0x102f080b

Disassembly of section .text.Ql_OS_TakeMutex:

102e5d80 <Ql_OS_TakeMutex>:
102e5d80:	e92d4038 	push	{r3, r4, r5, lr}
102e5d84:	e59f403c 	ldr	r4, [pc, #60]	; 102e5dc8 <Ql_OS_TakeMutex+0x48>
102e5d88:	e1a05000 	mov	r5, r0
102e5d8c:	e594300c 	ldr	r3, [r4, #12]
102e5d90:	e3530000 	cmp	r3, #0
102e5d94:	1a000006 	bne	102e5db4 <Ql_OS_TakeMutex+0x34>
102e5d98:	e59f302c 	ldr	r3, [pc, #44]	; 102e5dcc <Ql_OS_TakeMutex+0x4c>
102e5d9c:	e59f002c 	ldr	r0, [pc, #44]	; 102e5dd0 <Ql_OS_TakeMutex+0x50>
102e5da0:	e5933000 	ldr	r3, [r3]
102e5da4:	e12fff33 	blx	r3
102e5da8:	e3500000 	cmp	r0, #0
102e5dac:	08bd8038 	popeq	{r3, r4, r5, pc}
102e5db0:	e584000c 	str	r0, [r4, #12]
102e5db4:	e59f300c 	ldr	r3, [pc, #12]	; 102e5dc8 <Ql_OS_TakeMutex+0x48>
102e5db8:	e1a00005 	mov	r0, r5
102e5dbc:	e593300c 	ldr	r3, [r3, #12]
102e5dc0:	e12fff33 	blx	r3
102e5dc4:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5dc8:	f03db6dc 	.word	0xf03db6dc
102e5dcc:	f03daa08 	.word	0xf03daa08
102e5dd0:	102f081d 	.word	0x102f081d

Disassembly of section .text.Ql_OS_GiveMutex:

102e5dd4 <Ql_OS_GiveMutex>:
102e5dd4:	e92d4038 	push	{r3, r4, r5, lr}
102e5dd8:	e59f403c 	ldr	r4, [pc, #60]	; 102e5e1c <Ql_OS_GiveMutex+0x48>
102e5ddc:	e1a05000 	mov	r5, r0
102e5de0:	e5943010 	ldr	r3, [r4, #16]
102e5de4:	e3530000 	cmp	r3, #0
102e5de8:	1a000006 	bne	102e5e08 <Ql_OS_GiveMutex+0x34>
102e5dec:	e59f302c 	ldr	r3, [pc, #44]	; 102e5e20 <Ql_OS_GiveMutex+0x4c>
102e5df0:	e59f002c 	ldr	r0, [pc, #44]	; 102e5e24 <Ql_OS_GiveMutex+0x50>
102e5df4:	e5933000 	ldr	r3, [r3]
102e5df8:	e12fff33 	blx	r3
102e5dfc:	e3500000 	cmp	r0, #0
102e5e00:	08bd8038 	popeq	{r3, r4, r5, pc}
102e5e04:	e5840010 	str	r0, [r4, #16]
102e5e08:	e59f300c 	ldr	r3, [pc, #12]	; 102e5e1c <Ql_OS_GiveMutex+0x48>
102e5e0c:	e1a00005 	mov	r0, r5
102e5e10:	e5933010 	ldr	r3, [r3, #16]
102e5e14:	e12fff33 	blx	r3
102e5e18:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5e1c:	f03db6dc 	.word	0xf03db6dc
102e5e20:	f03daa08 	.word	0xf03daa08
102e5e24:	102f082d 	.word	0x102f082d

Disassembly of section .text.Ql_OS_CreateEvent:

102e5e28 <Ql_OS_CreateEvent>:
102e5e28:	e92d4038 	push	{r3, r4, r5, lr}
102e5e2c:	e59f403c 	ldr	r4, [pc, #60]	; 102e5e70 <Ql_OS_CreateEvent+0x48>
102e5e30:	e1a05000 	mov	r5, r0
102e5e34:	e5943020 	ldr	r3, [r4, #32]
102e5e38:	e3530000 	cmp	r3, #0
102e5e3c:	1a000006 	bne	102e5e5c <Ql_OS_CreateEvent+0x34>
102e5e40:	e59f302c 	ldr	r3, [pc, #44]	; 102e5e74 <Ql_OS_CreateEvent+0x4c>
102e5e44:	e59f002c 	ldr	r0, [pc, #44]	; 102e5e78 <Ql_OS_CreateEvent+0x50>
102e5e48:	e5933000 	ldr	r3, [r3]
102e5e4c:	e12fff33 	blx	r3
102e5e50:	e3500000 	cmp	r0, #0
102e5e54:	08bd8038 	popeq	{r3, r4, r5, pc}
102e5e58:	e5840020 	str	r0, [r4, #32]
102e5e5c:	e59f300c 	ldr	r3, [pc, #12]	; 102e5e70 <Ql_OS_CreateEvent+0x48>
102e5e60:	e1a00005 	mov	r0, r5
102e5e64:	e5933020 	ldr	r3, [r3, #32]
102e5e68:	e12fff33 	blx	r3
102e5e6c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5e70:	f03db6dc 	.word	0xf03db6dc
102e5e74:	f03daa08 	.word	0xf03daa08
102e5e78:	102f087b 	.word	0x102f087b

Disassembly of section .text.Ql_OS_WaitEvent:

102e5e7c <Ql_OS_WaitEvent>:
102e5e7c:	e92d4070 	push	{r4, r5, r6, lr}
102e5e80:	e59f404c 	ldr	r4, [pc, #76]	; 102e5ed4 <Ql_OS_WaitEvent+0x58>
102e5e84:	e1a05000 	mov	r5, r0
102e5e88:	e5943024 	ldr	r3, [r4, #36]	; 0x24
102e5e8c:	e1a06001 	mov	r6, r1
102e5e90:	e3530000 	cmp	r3, #0
102e5e94:	1a000006 	bne	102e5eb4 <Ql_OS_WaitEvent+0x38>
102e5e98:	e59f3038 	ldr	r3, [pc, #56]	; 102e5ed8 <Ql_OS_WaitEvent+0x5c>
102e5e9c:	e59f0038 	ldr	r0, [pc, #56]	; 102e5edc <Ql_OS_WaitEvent+0x60>
102e5ea0:	e5933000 	ldr	r3, [r3]
102e5ea4:	e12fff33 	blx	r3
102e5ea8:	e3500000 	cmp	r0, #0
102e5eac:	0a000006 	beq	102e5ecc <Ql_OS_WaitEvent+0x50>
102e5eb0:	e5840024 	str	r0, [r4, #36]	; 0x24
102e5eb4:	e59f3018 	ldr	r3, [pc, #24]	; 102e5ed4 <Ql_OS_WaitEvent+0x58>
102e5eb8:	e1a00005 	mov	r0, r5
102e5ebc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
102e5ec0:	e1a01006 	mov	r1, r6
102e5ec4:	e12fff33 	blx	r3
102e5ec8:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5ecc:	e59f000c 	ldr	r0, [pc, #12]	; 102e5ee0 <Ql_OS_WaitEvent+0x64>
102e5ed0:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5ed4:	f03db6dc 	.word	0xf03db6dc
102e5ed8:	f03daa08 	.word	0xf03daa08
102e5edc:	102f088d 	.word	0x102f088d
102e5ee0:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_OS_SetEvent:

102e5ee4 <Ql_OS_SetEvent>:
102e5ee4:	e92d4070 	push	{r4, r5, r6, lr}
102e5ee8:	e59f404c 	ldr	r4, [pc, #76]	; 102e5f3c <Ql_OS_SetEvent+0x58>
102e5eec:	e1a05000 	mov	r5, r0
102e5ef0:	e5943028 	ldr	r3, [r4, #40]	; 0x28
102e5ef4:	e1a06001 	mov	r6, r1
102e5ef8:	e3530000 	cmp	r3, #0
102e5efc:	1a000006 	bne	102e5f1c <Ql_OS_SetEvent+0x38>
102e5f00:	e59f3038 	ldr	r3, [pc, #56]	; 102e5f40 <Ql_OS_SetEvent+0x5c>
102e5f04:	e59f0038 	ldr	r0, [pc, #56]	; 102e5f44 <Ql_OS_SetEvent+0x60>
102e5f08:	e5933000 	ldr	r3, [r3]
102e5f0c:	e12fff33 	blx	r3
102e5f10:	e3500000 	cmp	r0, #0
102e5f14:	0a000006 	beq	102e5f34 <Ql_OS_SetEvent+0x50>
102e5f18:	e5840028 	str	r0, [r4, #40]	; 0x28
102e5f1c:	e59f3018 	ldr	r3, [pc, #24]	; 102e5f3c <Ql_OS_SetEvent+0x58>
102e5f20:	e1a00005 	mov	r0, r5
102e5f24:	e5933028 	ldr	r3, [r3, #40]	; 0x28
102e5f28:	e1a01006 	mov	r1, r6
102e5f2c:	e12fff33 	blx	r3
102e5f30:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5f34:	e59f000c 	ldr	r0, [pc, #12]	; 102e5f48 <Ql_OS_SetEvent+0x64>
102e5f38:	e8bd8070 	pop	{r4, r5, r6, pc}
102e5f3c:	f03db6dc 	.word	0xf03db6dc
102e5f40:	f03daa08 	.word	0xf03daa08
102e5f44:	102f089d 	.word	0x102f089d
102e5f48:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_GetLocalTime:

102e5f4c <Ql_GetLocalTime>:
102e5f4c:	e92d4038 	push	{r3, r4, r5, lr}
102e5f50:	e59f403c 	ldr	r4, [pc, #60]	; 102e5f94 <Ql_GetLocalTime+0x48>
102e5f54:	e1a05000 	mov	r5, r0
102e5f58:	e5943004 	ldr	r3, [r4, #4]
102e5f5c:	e3530000 	cmp	r3, #0
102e5f60:	1a000006 	bne	102e5f80 <Ql_GetLocalTime+0x34>
102e5f64:	e59f302c 	ldr	r3, [pc, #44]	; 102e5f98 <Ql_GetLocalTime+0x4c>
102e5f68:	e59f002c 	ldr	r0, [pc, #44]	; 102e5f9c <Ql_GetLocalTime+0x50>
102e5f6c:	e5933000 	ldr	r3, [r3]
102e5f70:	e12fff33 	blx	r3
102e5f74:	e3500000 	cmp	r0, #0
102e5f78:	08bd8038 	popeq	{r3, r4, r5, pc}
102e5f7c:	e5840004 	str	r0, [r4, #4]
102e5f80:	e59f300c 	ldr	r3, [pc, #12]	; 102e5f94 <Ql_GetLocalTime+0x48>
102e5f84:	e1a00005 	mov	r0, r5
102e5f88:	e5933004 	ldr	r3, [r3, #4]
102e5f8c:	e12fff33 	blx	r3
102e5f90:	e8bd8038 	pop	{r3, r4, r5, pc}
102e5f94:	f03db71c 	.word	0xf03db71c
102e5f98:	f03daa08 	.word	0xf03daa08
102e5f9c:	102f0938 	.word	0x102f0938

Disassembly of section .text.Ql_Mktime:

102e5fa0 <Ql_Mktime>:
102e5fa0:	e92d4038 	push	{r3, r4, r5, lr}
102e5fa4:	e59f4058 	ldr	r4, [pc, #88]	; 102e6004 <Ql_Mktime+0x64>
102e5fa8:	e1a05000 	mov	r5, r0
102e5fac:	e5943008 	ldr	r3, [r4, #8]
102e5fb0:	e3530000 	cmp	r3, #0
102e5fb4:	1a000008 	bne	102e5fdc <Ql_Mktime+0x3c>
102e5fb8:	e59f3048 	ldr	r3, [pc, #72]	; 102e6008 <Ql_Mktime+0x68>
102e5fbc:	e59f0048 	ldr	r0, [pc, #72]	; 102e600c <Ql_Mktime+0x6c>
102e5fc0:	e5933000 	ldr	r3, [r3]
102e5fc4:	e12fff33 	blx	r3
102e5fc8:	e3500000 	cmp	r0, #0
102e5fcc:	03a02000 	moveq	r2, #0
102e5fd0:	03a03000 	moveq	r3, #0
102e5fd4:	0a000007 	beq	102e5ff8 <Ql_Mktime+0x58>
102e5fd8:	e5840008 	str	r0, [r4, #8]
102e5fdc:	e59f3020 	ldr	r3, [pc, #32]	; 102e6004 <Ql_Mktime+0x64>
102e5fe0:	e1a00005 	mov	r0, r5
102e5fe4:	e5933008 	ldr	r3, [r3, #8]
102e5fe8:	e12fff33 	blx	r3
102e5fec:	e1a02000 	mov	r2, r0
102e5ff0:	e1a03001 	mov	r3, r1
102e5ff4:	eaffffff 	b	102e5ff8 <Ql_Mktime+0x58>
102e5ff8:	e1a00002 	mov	r0, r2
102e5ffc:	e1a01003 	mov	r1, r3
102e6000:	e8bd8038 	pop	{r3, r4, r5, pc}
102e6004:	f03db71c 	.word	0xf03db71c
102e6008:	f03daa08 	.word	0xf03daa08
102e600c:	102f0948 	.word	0x102f0948

Disassembly of section .text.Ql_Timer_Register:

102e6010 <Ql_Timer_Register>:
102e6010:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e6014:	e59f4054 	ldr	r4, [pc, #84]	; 102e6070 <Ql_Timer_Register+0x60>
102e6018:	e1a05000 	mov	r5, r0
102e601c:	e5943000 	ldr	r3, [r4]
102e6020:	e1a07001 	mov	r7, r1
102e6024:	e3530000 	cmp	r3, #0
102e6028:	e1a06002 	mov	r6, r2
102e602c:	1a000006 	bne	102e604c <Ql_Timer_Register+0x3c>
102e6030:	e59f303c 	ldr	r3, [pc, #60]	; 102e6074 <Ql_Timer_Register+0x64>
102e6034:	e59f003c 	ldr	r0, [pc, #60]	; 102e6078 <Ql_Timer_Register+0x68>
102e6038:	e5933000 	ldr	r3, [r3]
102e603c:	e12fff33 	blx	r3
102e6040:	e3500000 	cmp	r0, #0
102e6044:	0a000007 	beq	102e6068 <Ql_Timer_Register+0x58>
102e6048:	e5840000 	str	r0, [r4]
102e604c:	e59f301c 	ldr	r3, [pc, #28]	; 102e6070 <Ql_Timer_Register+0x60>
102e6050:	e1a00005 	mov	r0, r5
102e6054:	e5933000 	ldr	r3, [r3]
102e6058:	e1a01007 	mov	r1, r7
102e605c:	e1a02006 	mov	r2, r6
102e6060:	e12fff33 	blx	r3
102e6064:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e6068:	e59f000c 	ldr	r0, [pc, #12]	; 102e607c <Ql_Timer_Register+0x6c>
102e606c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e6070:	f03db72c 	.word	0xf03db72c
102e6074:	f03daa08 	.word	0xf03daa08
102e6078:	102f0969 	.word	0x102f0969
102e607c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_Timer_Start:

102e6080 <Ql_Timer_Start>:
102e6080:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e6084:	e59f4054 	ldr	r4, [pc, #84]	; 102e60e0 <Ql_Timer_Start+0x60>
102e6088:	e1a05000 	mov	r5, r0
102e608c:	e5943008 	ldr	r3, [r4, #8]
102e6090:	e1a07001 	mov	r7, r1
102e6094:	e3530000 	cmp	r3, #0
102e6098:	e1a06002 	mov	r6, r2
102e609c:	1a000006 	bne	102e60bc <Ql_Timer_Start+0x3c>
102e60a0:	e59f303c 	ldr	r3, [pc, #60]	; 102e60e4 <Ql_Timer_Start+0x64>
102e60a4:	e59f003c 	ldr	r0, [pc, #60]	; 102e60e8 <Ql_Timer_Start+0x68>
102e60a8:	e5933000 	ldr	r3, [r3]
102e60ac:	e12fff33 	blx	r3
102e60b0:	e3500000 	cmp	r0, #0
102e60b4:	0a000007 	beq	102e60d8 <Ql_Timer_Start+0x58>
102e60b8:	e5840008 	str	r0, [r4, #8]
102e60bc:	e59f301c 	ldr	r3, [pc, #28]	; 102e60e0 <Ql_Timer_Start+0x60>
102e60c0:	e1a00005 	mov	r0, r5
102e60c4:	e5933008 	ldr	r3, [r3, #8]
102e60c8:	e1a01007 	mov	r1, r7
102e60cc:	e1a02006 	mov	r2, r6
102e60d0:	e12fff33 	blx	r3
102e60d4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e60d8:	e59f000c 	ldr	r0, [pc, #12]	; 102e60ec <Ql_Timer_Start+0x6c>
102e60dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e60e0:	f03db72c 	.word	0xf03db72c
102e60e4:	f03daa08 	.word	0xf03daa08
102e60e8:	102f0991 	.word	0x102f0991
102e60ec:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_Timer_Stop:

102e60f0 <Ql_Timer_Stop>:
102e60f0:	e92d4038 	push	{r3, r4, r5, lr}
102e60f4:	e59f4044 	ldr	r4, [pc, #68]	; 102e6140 <Ql_Timer_Stop+0x50>
102e60f8:	e1a05000 	mov	r5, r0
102e60fc:	e594300c 	ldr	r3, [r4, #12]
102e6100:	e3530000 	cmp	r3, #0
102e6104:	1a000006 	bne	102e6124 <Ql_Timer_Stop+0x34>
102e6108:	e59f3034 	ldr	r3, [pc, #52]	; 102e6144 <Ql_Timer_Stop+0x54>
102e610c:	e59f0034 	ldr	r0, [pc, #52]	; 102e6148 <Ql_Timer_Stop+0x58>
102e6110:	e5933000 	ldr	r3, [r3]
102e6114:	e12fff33 	blx	r3
102e6118:	e3500000 	cmp	r0, #0
102e611c:	0a000005 	beq	102e6138 <Ql_Timer_Stop+0x48>
102e6120:	e584000c 	str	r0, [r4, #12]
102e6124:	e59f3014 	ldr	r3, [pc, #20]	; 102e6140 <Ql_Timer_Stop+0x50>
102e6128:	e1a00005 	mov	r0, r5
102e612c:	e593300c 	ldr	r3, [r3, #12]
102e6130:	e12fff33 	blx	r3
102e6134:	e8bd8038 	pop	{r3, r4, r5, pc}
102e6138:	e59f000c 	ldr	r0, [pc, #12]	; 102e614c <Ql_Timer_Stop+0x5c>
102e613c:	e8bd8038 	pop	{r3, r4, r5, pc}
102e6140:	f03db72c 	.word	0xf03db72c
102e6144:	f03daa08 	.word	0xf03daa08
102e6148:	102f09a0 	.word	0x102f09a0
102e614c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_UART_Register:

102e6150 <Ql_UART_Register>:
102e6150:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e6154:	e59f4054 	ldr	r4, [pc, #84]	; 102e61b0 <Ql_UART_Register+0x60>
102e6158:	e1a05000 	mov	r5, r0
102e615c:	e5943000 	ldr	r3, [r4]
102e6160:	e1a07001 	mov	r7, r1
102e6164:	e3530000 	cmp	r3, #0
102e6168:	e1a06002 	mov	r6, r2
102e616c:	1a000006 	bne	102e618c <Ql_UART_Register+0x3c>
102e6170:	e59f303c 	ldr	r3, [pc, #60]	; 102e61b4 <Ql_UART_Register+0x64>
102e6174:	e59f003c 	ldr	r0, [pc, #60]	; 102e61b8 <Ql_UART_Register+0x68>
102e6178:	e5933000 	ldr	r3, [r3]
102e617c:	e12fff33 	blx	r3
102e6180:	e3500000 	cmp	r0, #0
102e6184:	0a000007 	beq	102e61a8 <Ql_UART_Register+0x58>
102e6188:	e5840000 	str	r0, [r4]
102e618c:	e59f301c 	ldr	r3, [pc, #28]	; 102e61b0 <Ql_UART_Register+0x60>
102e6190:	e1a00005 	mov	r0, r5
102e6194:	e5933000 	ldr	r3, [r3]
102e6198:	e1a01007 	mov	r1, r7
102e619c:	e1a02006 	mov	r2, r6
102e61a0:	e12fff33 	blx	r3
102e61a4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e61a8:	e59f000c 	ldr	r0, [pc, #12]	; 102e61bc <Ql_UART_Register+0x6c>
102e61ac:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e61b0:	f03db73c 	.word	0xf03db73c
102e61b4:	f03daa08 	.word	0xf03daa08
102e61b8:	102f09ae 	.word	0x102f09ae
102e61bc:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_UART_Open:

102e61c0 <Ql_UART_Open>:
102e61c0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e61c4:	e59f4054 	ldr	r4, [pc, #84]	; 102e6220 <Ql_UART_Open+0x60>
102e61c8:	e1a05000 	mov	r5, r0
102e61cc:	e5943004 	ldr	r3, [r4, #4]
102e61d0:	e1a07001 	mov	r7, r1
102e61d4:	e3530000 	cmp	r3, #0
102e61d8:	e1a06002 	mov	r6, r2
102e61dc:	1a000006 	bne	102e61fc <Ql_UART_Open+0x3c>
102e61e0:	e59f303c 	ldr	r3, [pc, #60]	; 102e6224 <Ql_UART_Open+0x64>
102e61e4:	e59f003c 	ldr	r0, [pc, #60]	; 102e6228 <Ql_UART_Open+0x68>
102e61e8:	e5933000 	ldr	r3, [r3]
102e61ec:	e12fff33 	blx	r3
102e61f0:	e3500000 	cmp	r0, #0
102e61f4:	0a000007 	beq	102e6218 <Ql_UART_Open+0x58>
102e61f8:	e5840004 	str	r0, [r4, #4]
102e61fc:	e59f301c 	ldr	r3, [pc, #28]	; 102e6220 <Ql_UART_Open+0x60>
102e6200:	e1a00005 	mov	r0, r5
102e6204:	e5933004 	ldr	r3, [r3, #4]
102e6208:	e1a01007 	mov	r1, r7
102e620c:	e1a02006 	mov	r2, r6
102e6210:	e12fff33 	blx	r3
102e6214:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e6218:	e59f000c 	ldr	r0, [pc, #12]	; 102e622c <Ql_UART_Open+0x6c>
102e621c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e6220:	f03db73c 	.word	0xf03db73c
102e6224:	f03daa08 	.word	0xf03daa08
102e6228:	102f09bf 	.word	0x102f09bf
102e622c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_UART_Write:

102e6230 <Ql_UART_Write>:
102e6230:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e6234:	e59f4054 	ldr	r4, [pc, #84]	; 102e6290 <Ql_UART_Write+0x60>
102e6238:	e1a05000 	mov	r5, r0
102e623c:	e594300c 	ldr	r3, [r4, #12]
102e6240:	e1a07001 	mov	r7, r1
102e6244:	e3530000 	cmp	r3, #0
102e6248:	e1a06002 	mov	r6, r2
102e624c:	1a000006 	bne	102e626c <Ql_UART_Write+0x3c>
102e6250:	e59f303c 	ldr	r3, [pc, #60]	; 102e6294 <Ql_UART_Write+0x64>
102e6254:	e59f003c 	ldr	r0, [pc, #60]	; 102e6298 <Ql_UART_Write+0x68>
102e6258:	e5933000 	ldr	r3, [r3]
102e625c:	e12fff33 	blx	r3
102e6260:	e3500000 	cmp	r0, #0
102e6264:	0a000007 	beq	102e6288 <Ql_UART_Write+0x58>
102e6268:	e584000c 	str	r0, [r4, #12]
102e626c:	e59f301c 	ldr	r3, [pc, #28]	; 102e6290 <Ql_UART_Write+0x60>
102e6270:	e1a00005 	mov	r0, r5
102e6274:	e593300c 	ldr	r3, [r3, #12]
102e6278:	e1a01007 	mov	r1, r7
102e627c:	e1a02006 	mov	r2, r6
102e6280:	e12fff33 	blx	r3
102e6284:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e6288:	e59f000c 	ldr	r0, [pc, #12]	; 102e629c <Ql_UART_Write+0x6c>
102e628c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e6290:	f03db73c 	.word	0xf03db73c
102e6294:	f03daa08 	.word	0xf03daa08
102e6298:	102f09db 	.word	0x102f09db
102e629c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_UART_Read:

102e62a0 <Ql_UART_Read>:
102e62a0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
102e62a4:	e59f4054 	ldr	r4, [pc, #84]	; 102e6300 <Ql_UART_Read+0x60>
102e62a8:	e1a05000 	mov	r5, r0
102e62ac:	e5943010 	ldr	r3, [r4, #16]
102e62b0:	e1a07001 	mov	r7, r1
102e62b4:	e3530000 	cmp	r3, #0
102e62b8:	e1a06002 	mov	r6, r2
102e62bc:	1a000006 	bne	102e62dc <Ql_UART_Read+0x3c>
102e62c0:	e59f303c 	ldr	r3, [pc, #60]	; 102e6304 <Ql_UART_Read+0x64>
102e62c4:	e59f003c 	ldr	r0, [pc, #60]	; 102e6308 <Ql_UART_Read+0x68>
102e62c8:	e5933000 	ldr	r3, [r3]
102e62cc:	e12fff33 	blx	r3
102e62d0:	e3500000 	cmp	r0, #0
102e62d4:	0a000007 	beq	102e62f8 <Ql_UART_Read+0x58>
102e62d8:	e5840010 	str	r0, [r4, #16]
102e62dc:	e59f301c 	ldr	r3, [pc, #28]	; 102e6300 <Ql_UART_Read+0x60>
102e62e0:	e1a00005 	mov	r0, r5
102e62e4:	e5933010 	ldr	r3, [r3, #16]
102e62e8:	e1a01007 	mov	r1, r7
102e62ec:	e1a02006 	mov	r2, r6
102e62f0:	e12fff33 	blx	r3
102e62f4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e62f8:	e59f000c 	ldr	r0, [pc, #12]	; 102e630c <Ql_UART_Read+0x6c>
102e62fc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
102e6300:	f03db73c 	.word	0xf03db73c
102e6304:	f03daa08 	.word	0xf03daa08
102e6308:	102f09e9 	.word	0x102f09e9
102e630c:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_UART_ClrRxBuffer:

102e6310 <Ql_UART_ClrRxBuffer>:
102e6310:	e92d4038 	push	{r3, r4, r5, lr}
102e6314:	e59f403c 	ldr	r4, [pc, #60]	; 102e6358 <Ql_UART_ClrRxBuffer+0x48>
102e6318:	e1a05000 	mov	r5, r0
102e631c:	e594301c 	ldr	r3, [r4, #28]
102e6320:	e3530000 	cmp	r3, #0
102e6324:	1a000006 	bne	102e6344 <Ql_UART_ClrRxBuffer+0x34>
102e6328:	e59f302c 	ldr	r3, [pc, #44]	; 102e635c <Ql_UART_ClrRxBuffer+0x4c>
102e632c:	e59f002c 	ldr	r0, [pc, #44]	; 102e6360 <Ql_UART_ClrRxBuffer+0x50>
102e6330:	e5933000 	ldr	r3, [r3]
102e6334:	e12fff33 	blx	r3
102e6338:	e3500000 	cmp	r0, #0
102e633c:	08bd8038 	popeq	{r3, r4, r5, pc}
102e6340:	e584001c 	str	r0, [r4, #28]
102e6344:	e59f300c 	ldr	r3, [pc, #12]	; 102e6358 <Ql_UART_ClrRxBuffer+0x48>
102e6348:	e1a00005 	mov	r0, r5
102e634c:	e593301c 	ldr	r3, [r3, #28]
102e6350:	e12fff33 	blx	r3
102e6354:	e8bd8038 	pop	{r3, r4, r5, pc}
102e6358:	f03db73c 	.word	0xf03db73c
102e635c:	f03daa08 	.word	0xf03daa08
102e6360:	102f0a20 	.word	0x102f0a20

Disassembly of section .text.Ql_UART_GetPinStatus:

102e6364 <Ql_UART_GetPinStatus>:
102e6364:	e92d4070 	push	{r4, r5, r6, lr}
102e6368:	e59f404c 	ldr	r4, [pc, #76]	; 102e63bc <Ql_UART_GetPinStatus+0x58>
102e636c:	e1a05000 	mov	r5, r0
102e6370:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
102e6374:	e1a06001 	mov	r6, r1
102e6378:	e3530000 	cmp	r3, #0
102e637c:	1a000006 	bne	102e639c <Ql_UART_GetPinStatus+0x38>
102e6380:	e59f3038 	ldr	r3, [pc, #56]	; 102e63c0 <Ql_UART_GetPinStatus+0x5c>
102e6384:	e59f0038 	ldr	r0, [pc, #56]	; 102e63c4 <Ql_UART_GetPinStatus+0x60>
102e6388:	e5933000 	ldr	r3, [r3]
102e638c:	e12fff33 	blx	r3
102e6390:	e3500000 	cmp	r0, #0
102e6394:	0a000006 	beq	102e63b4 <Ql_UART_GetPinStatus+0x50>
102e6398:	e584002c 	str	r0, [r4, #44]	; 0x2c
102e639c:	e59f3018 	ldr	r3, [pc, #24]	; 102e63bc <Ql_UART_GetPinStatus+0x58>
102e63a0:	e1a00005 	mov	r0, r5
102e63a4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
102e63a8:	e1a01006 	mov	r1, r6
102e63ac:	e12fff33 	blx	r3
102e63b0:	e8bd8070 	pop	{r4, r5, r6, pc}
102e63b4:	e59f000c 	ldr	r0, [pc, #12]	; 102e63c8 <Ql_UART_GetPinStatus+0x64>
102e63b8:	e8bd8070 	pop	{r4, r5, r6, pc}
102e63bc:	f03db73c 	.word	0xf03db73c
102e63c0:	f03daa08 	.word	0xf03daa08
102e63c4:	102f0a6c 	.word	0x102f0a6c
102e63c8:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_UART_SendEscap:

102e63cc <Ql_UART_SendEscap>:
102e63cc:	e92d4038 	push	{r3, r4, r5, lr}
102e63d0:	e59f4044 	ldr	r4, [pc, #68]	; 102e641c <Ql_UART_SendEscap+0x50>
102e63d4:	e1a05000 	mov	r5, r0
102e63d8:	e5943034 	ldr	r3, [r4, #52]	; 0x34
102e63dc:	e3530000 	cmp	r3, #0
102e63e0:	1a000006 	bne	102e6400 <Ql_UART_SendEscap+0x34>
102e63e4:	e59f3034 	ldr	r3, [pc, #52]	; 102e6420 <Ql_UART_SendEscap+0x54>
102e63e8:	e59f0034 	ldr	r0, [pc, #52]	; 102e6424 <Ql_UART_SendEscap+0x58>
102e63ec:	e5933000 	ldr	r3, [r3]
102e63f0:	e12fff33 	blx	r3
102e63f4:	e3500000 	cmp	r0, #0
102e63f8:	0a000005 	beq	102e6414 <Ql_UART_SendEscap+0x48>
102e63fc:	e5840034 	str	r0, [r4, #52]	; 0x34
102e6400:	e59f3014 	ldr	r3, [pc, #20]	; 102e641c <Ql_UART_SendEscap+0x50>
102e6404:	e1a00005 	mov	r0, r5
102e6408:	e5933034 	ldr	r3, [r3, #52]	; 0x34
102e640c:	e12fff33 	blx	r3
102e6410:	e8bd8038 	pop	{r3, r4, r5, pc}
102e6414:	e59f000c 	ldr	r0, [pc, #12]	; 102e6428 <Ql_UART_SendEscap+0x5c>
102e6418:	e8bd8038 	pop	{r3, r4, r5, pc}
102e641c:	f03db73c 	.word	0xf03db73c
102e6420:	f03daa08 	.word	0xf03daa08
102e6424:	102f0a96 	.word	0x102f0a96
102e6428:	ffffd8f0 	.word	0xffffd8f0

Disassembly of section .text.Ql_WTD_Feed:

102e642c <Ql_WTD_Feed>:
102e642c:	e59f304c 	ldr	r3, [pc, #76]	; 102e6480 <Ql_WTD_Feed+0x54>
102e6430:	e92d4010 	push	{r4, lr}
102e6434:	e5d32000 	ldrb	r2, [r3]
102e6438:	e3520000 	cmp	r2, #0
102e643c:	08bd8010 	popeq	{r4, pc}
102e6440:	e5934004 	ldr	r4, [r3, #4]
102e6444:	e3540000 	cmp	r4, #0
102e6448:	08bd8010 	popeq	{r4, pc}
102e644c:	e5943000 	ldr	r3, [r4]
102e6450:	e1530000 	cmp	r3, r0
102e6454:	1a000005 	bne	102e6470 <Ql_WTD_Feed+0x44>
102e6458:	e5940004 	ldr	r0, [r4, #4]
102e645c:	e3a010c8 	mov	r1, #200	; 0xc8
102e6460:	e59f301c 	ldr	r3, [pc, #28]	; 102e6484 <Ql_WTD_Feed+0x58>
102e6464:	e12fff33 	blx	r3
102e6468:	e5840008 	str	r0, [r4, #8]
102e646c:	e8bd8010 	pop	{r4, pc}
102e6470:	e594400c 	ldr	r4, [r4, #12]
102e6474:	e3540000 	cmp	r4, #0
102e6478:	1afffff3 	bne	102e644c <Ql_WTD_Feed+0x20>
102e647c:	e8bd8010 	pop	{r4, pc}
102e6480:	f03db778 	.word	0xf03db778
102e6484:	102e2c94 	.word	0x102e2c94
